HtDP/2e Teachpacks

    1 Batch Input/Output: "batch-io.rkt" ~
      1.1 IO Functions
      1.2 Web Functions
      1.3 Testing

    2 Image Guide
      2.1 Overlaying, Above, and Beside: A House ~
      2.2 Rotating and Overlaying: A Rotary Phone Dial ~
      2.3 Alpha Blending
      2.4 Recursive Image Functions
      2.5 Rotating and Image Centers
      2.6 Image Interoperability
      2.7 The Nitty Gritty of Pixels, Pens, and Lines
      2.8 The Nitty Gritty of Alpha Blending

    3 Images: "image.rkt" ~
      3.1 Basic Images
      3.2 Polygons
      3.3 Overlaying Images
      3.4 Placing Images & Scenes
      3.5 Rotating, Scaling, Flipping, Cropping, and Framing Images
      3.6 Bitmaps
      3.7 Image Properties
      3.8 Image Predicates
      3.9 Equality Testing of Images
      3.10 Pinholes
      3.11 Exporting Images to Disk

    4 Worlds and the Universe: "universe.rkt" ~
      4.1 Background
      4.2 Simple Simulations
      4.3 Interactions
      4.4 A First Sample World
        4.4.1 Understanding a Door
        4.4.2 Hints on Designing Worlds
      4.5 The World is not Enough
        4.5.1 Messages
        4.5.2 Sending Messages
        4.5.3 Connecting with the Universe
        4.5.4 Receiving Messages
      4.6 The Universe Server
        4.6.1 Worlds and Messages
        4.6.2 Universe Descriptions
        4.6.3 Exploring a Universe
      4.7 A First Sample Universe
        4.7.1 Two Ball Tossing Worlds
        4.7.2 Hints on Designing Universes
        4.7.3 Designing the Ball Universe
        4.7.4 Designing the Ball Server
        4.7.5 Designing the Ball World

    5 Web IO: "web-io.rkt" ~

    6 iTunes: "itunes.rkt" ~
      6.1 Data Definitions
      6.2 Exported Funcions

    7 Abstraction: "abstraction.rkt" ~
      7.1 Loops and Comprehensions
      7.2 Pattern Matching
      7.3 Algebraic Data Types

    8 Planet Cute Images
      8.1 Characters
      8.2 Blocks
      8.3 Items
      8.4 Ramps
      8.5 Buildings
      8.6 Shadows

    9 Porting World Programs to Universe
      9.1 The World is Not Enough
      9.2 Porting World Programs
      9.3 Porting Image Programs

1. Batch Input/Output: "batch-io.rkt"

Matthias Felleisen

 (require 2htdp/batch-io) package: htdp-lib ~

The batch-io teachpack introduces several functions and a form for
reading  content from files and one function for writing to a file.

1.1. IO Functions

All functions that read a file consume the name of a file and possibly
additional arguments. They assume that the specified file exists in the
same folder as the program; if not they signal an error:

* (read-file f) -> string?
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a string, including newlines.

  Example:

    > (read-file "data.txt")
    "hello world \n good bye \n\ni, for 1, am done "

  assuming the file named "data.txt" has this shape:

  hello world
   good bye
   
  i, for 1, am done

  Note how the leading space in the second line translates into the
  space between the newline indicator and the word "good" in the result.

* (read-1strings f) -> (listof 1string?)
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of one-char strings, one per character.

  Example:

    > (read-1strings "data.txt")
    '("h"
      "e"
      "l"
      "l"
      "o"
      " "
      "w"
      "o"
      "r"
      "l"
      "d"
      " "
      "\n"
      " "
      "g"
      "o"
      "o"
      "d"
      " "
      "b"
      "y"
      "e"
      " "
      "\n"
      "\n"
      "i"
      ","
      " "
      "f"
      "o"
      "r"
      " "
      "1"
      ","
      " "
      "a"
      "m"
      " "
      "d"
      "o"
      "n"
      "e"
      " ")

  Note how this function reproduces all parts of the file faithfully,
  including spaces and newlines.

* (read-lines f) -> (listof string?)
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of strings, one per line.

  Example:

    > (read-lines "data.txt")
    '("hello world " " good bye " "" "i, for 1, am done ")

  when "data.txt" is the name of the same file as in the preceding item.
  And again, the leading space of the second line shows up in the second
  string in the list.

  If the last line is not terminated by a newline, the functions acts as
  if there were one.

* (read-words f) -> (listof string?)
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of strings, one per white-space separated
  token in the file.

  Example:

    > (read-words "data.txt")
    '("hello" "world" "good" "bye" "i," "for" "1," "am" "done")

  This time, however, the extra leading space of the second line of
  "data.txt" has disappeared in the result. The space is considered a
  part of the separator that surrounds the word "good".

* (read-words/line f) -> (listof (listof string?))
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of lists, one per line; each line is
  represented as a list of strings.

  Example:

    > (read-words/line "data.txt")
    '(("hello" "world") ("good" "bye") () ("i," "for" "1," "am" "done"))

  The results is similar to the one that read-words produces,

  except that the organization of the file into lines is preserved. In
  particular, the empty third line is represented as an empty list of
  words.

  If the last line is not terminated by a newline, the functions acts as
  if there were one.

* (read-words-and-numbers/line f) -> (listof (or number? string?))
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of lists, one per line; each line is
  represented as a list of strings and numbers.

  Example:

    > (read-words-and-numbers/line "data.txt")
    '(("hello" "world") ("good" "bye") () ("i," "for" "1," "am" "done"))

  The results is like the one that read-words/line produces, except
  strings that can be parsed as numbers are represented as numbers.

  If the last line is not terminated by a newline, the functions acts as
  if there were one.

* (read-csv-file f) -> (listof (listof any/c))
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as a list of lists of comma-separated values.

  Example:

    > (read-csv-file "data.csv")
    '(("hello" "world") ("good" "bye") ("i" "am" "done"))

  where the file named "data.csv" has this shape:

  hello, world
   good, bye
  i, am, done

  It is important to understand that the rows don’t have to have the
  same length. Here the third line of the file turns into a row of three
  elements.

* (read-csv-file/rows f s) -> (listof X?)
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~
    s : (-> (listof any/c) X?) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as reads the content of file f and produces it as
  list of rows, each constructed via s.

  Examples:

    > (read-csv-file/rows "data.csv" (lambda (x) x))
    '(("hello" "world") ("good" "bye") ("i" "am" "done"))
    > (read-csv-file/rows "data.csv" length)
    '(2 2 3)

  The first example shows how read-csv-file is just a short form  for
  read-csv-file/rows; the second one simply counts the  number of
  separated tokens and the result is just a list of numbers.  In many
  cases, the function argument is used to construct a structure from  a
  row.

* (read-xexpr f) -> xexpr?
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as an X-expression, including whitespace such as
  tabs and newlines.

  Assumption: the file f or the selected input device contains an XML
  element. It assumes the file contains HTML-like text and reads it as
  XML.

  Example:

    > (read-xexpr "data.xml")
    '(pre () "\nhello world\ngood bye\n\ni, for 1, am done\n")

  assuming the file named "data.xml" has this shape:

  <pre>
  hello world
  good bye
   
  i, for 1, am done
  </pre>

  Note how the result includes "\\n" for the newlines.

* (read-plain-xexpr f) -> xexpr?
    f : (or/c 'standard-in 'stdin (and/c string? file-exists?)) ~

  reads the standard input device (until closed) or the content of file
  f and produces it as an X-expression, without whitespace.

  Assumption: the file f or the selected input device contains an XML
  element and the content of this element are other XML elements and
  whitespace. In particular, the XML element does not contain any
  strings as elements other than whitespace.

  Example:

    > (read-plain-xexpr "data-plain.xml")
    '(pre
      ()
      (line ((text "hello world")))
      (line ((text "good bye")))
      (line ())
      (line ((text "i, for 1, am done"))))

  assuming the file named "data-plain.xml" has this shape:

  <pre>
  <line text="hello world" />
  <line text="good bye" />
  <line />
  <line text="i, for 1, am done" />
  </pre>

  Compare this result with the one for read-xexpr.

There is only one writer function at the moment:

* (write-file f cntnt) -> string?
    f : (or/c 'standard-out 'stdout string?) ~
    cntnt : string? ~

  sends cntnt to the standard output device or turns cntnt into the
  content of file f, located in the same folder (directory) as the
  program. If the write succeeds, the function produces the name of the
  file (f); otherwise it signals an error.

  Example:

    > (if (string=? (write-file "output.txt" "good bye") "output.txt")
          (write-file "output.txt" "cruel world")
          (write-file "output.txt" "cruel world"))
    with-output-to-file: cannot open output file
      path: /usr/share/racket/pkgs/htdp-doc/teachpack/2htdp/scri ~
    bblings/output.txt
      system error: Permission denied; errno=13 ~

  After evaluating this examples, the file named "output.txt"  looks
  like this: cruel world  Explain why.

                                        *file-exists?*
(file-exists? f) -> boolean? ~
  f : string? ~

determines whether a file with the given name exists in the current
directory.

Warning: The file IO functions in this teachpack are platform
dependent. That is, as long as your programs and your files live on the
same platform, you should not have any problems reading the files that
programs wrote and vice versa. If, however, one of your programs writes
a  file on a Windows operating system and if you then copy this output
file  to a Mac, reading the copied text file may produce extraneous
“return”  characters. Note that this describes only one example of
possible  malfunction; there are other cases when trans-platform actions
may cause  this teachpack to fail.

1.2. Web Functions

All functions that read a web-based XML consume a URL and possibly
additional arguments. They assume that the computer is connected to
specified part of the web, though they tolerate non-existent web pages
(404 errors)

* (read-xexpr/web u) -> xexpr?
    u : string? ~

  reads the content of URL u and produces the first XML element as an
  xexpr? including whitespace such as tabs and newlines. If possible,
  the function interprets the HTML at the specified URL as XML. The
  function returns #f if the web page does not exist (404)

* (read-plain-xexpr/web u) -> xexpr?
    u : string? ~

  reads the content of URL u and produces the first XML element as an
  xexpr? without whitespace. If possible, the function interprets the
  HTML at the specified URL as XML. The function returns #f if the web
  page does not exist (404)

* (url-exists? u) -> boolean?
    u : string? ~

  ensures that the specified URL u does not produce a 404 error.

* (xexpr? u) -> boolean?
    u : any? ~

  checks that the given value is an X-expression in the following sense:

    ;   Xexpr is one of: ~
    ;   – symbol?
    ;   – string?
    ;   – number?
    ;   – (cons symbol? (cons [List-of Attribute] [List-of Xexpr]))
    ;   – (cons symbol? [List-of Xexpr])
    ; 
    ;   Attribute is: ~
    ;      (list symbol? string?)
    ;   (list 'a "some text") is called an a-Attribute
    ;   and "some text" is a's value.

  Note that full Racket uses a wider notion of X-expression.

* (xexpr-as-string x) -> string?
    x : xexpr? ~

  renders the given X-expression as a string.

* (url-html-neighbors u) -> (listof string?)
    u : string? ~

  retrieves the content of URL u and produces the list of all URLs that
  refer to .html pages via an <a> tag.

1.3. Testing

                                        *simulate-file*
(simulate-file process str ...) ~

simulates a file system for the function process, which reads a file and
may produce one. Note: this form is under development and will be
documented in a precise manner after it is finalized and useful for a
wide audience.

2. Image Guide

This section introduces the 2htdp/image library through a series of
increasingly complex image constructions and discusses some subtle
details of cropping and outline images.

2.1. Overlaying, Above, and Beside: A House

To build a simple-looking house, we can place a triangle above a
rectangle.

  > (above (triangle 40 "solid" "red")
           (rectangle 40 30 "solid" "black"))
  #(struct:object:image% ...)

We can give the house two roofs by putting two triangles next to each
other.

  > (above (beside (triangle 40 "solid" "red")
                   (triangle 40 "solid" "red"))
           (rectangle 80 40 "solid" "black"))
  #(struct:object:image% ...)

But if we want the new roof to be a little smaller, then they do not
line up properly.

  > (above (beside (triangle 40 "solid" "red")
                   (triangle 30 "solid" "red"))
           (rectangle 70 40 "solid" "black"))
  #(struct:object:image% ...)

Instead, we can use beside/align to line up the two triangles along
their bottoms instead of along the middles (which is what beside does).

  > (define victorian
      (above (beside/align "bottom"
                           (triangle 40 "solid" "red")
                           (triangle 30 "solid" "red"))
             (rectangle 70 40 "solid" "black")))
  > victorian
  #(struct:object:image% ...)

To add a door to the house, we can overlay a brown rectangle, aligning
it with the center bottom of the rest of the house.

  > (define door (rectangle 15 25 "solid" "brown"))
  > (overlay/align "center" "bottom" door victorian)
  #(struct:object:image% ...)

We can use a similar technique to put a doorknob on the door, but
instead of overlaying the doorknob on the entire house, we can overlay
it just on the door.

  > (define door-with-knob
      (overlay/align "right" "center" (circle 3 "solid" "yellow") door))
  > (overlay/align "center" "bottom" door-with-knob victorian)
  #(struct:object:image% ...)

2.2. Rotating and Overlaying: A Rotary Phone Dial

A rotary phone dial can be built by from a black disk and 10 little
white ones by placing the white disks, one at a time, at the top of the
black disk and then rotating the entire black disk. To get started, lets
define a function to make little white disks with numbers on them:

  > (define (a-number digit)
      (overlay
       (text (number->string digit) 12 "black")
       (circle 10 "solid" "white")))

We’ll use place-and-turn to put the numbers onto the disk:

  > (define (place-and-turn digit dial)
      (rotate 30
              (overlay/align "center" "top"
                             (a-number digit)
                             dial)))

For example:

  > (place-and-turn
     0
     (circle 60 "solid" "black"))
  #(struct:object:image% ...)

  > (place-and-turn
     8
     (place-and-turn
      9
      (place-and-turn
       0
       (circle 60 "solid" "black"))))
  #(struct:object:image% ...)

We can write a single function to put all of the numbers together into
the dial:

  > (define (place-all-numbers dial)
      (place-and-turn
       1
       (place-and-turn
        2
        (place-and-turn
         3
         (place-and-turn
          4
          (place-and-turn
           5
           (place-and-turn
            6
            (place-and-turn
             7
             (place-and-turn
              8
              (place-and-turn
               9
               (place-and-turn
                0
                dial)))))))))))
  > (place-all-numbers (circle 60 "solid" "black"))
  #(struct:object:image% ...)

That definition is long and tedious to write. We can shorten it using
foldl:

  > (define (place-all-numbers dial)
      (foldl place-and-turn
             dial
             '(0 9 8 7 6 5 4 3 2 1)))
  > (place-all-numbers (circle 60 "solid" "black"))
  #(struct:object:image% ...)

To finish off the dial, we need to rotate it a little bit to its natural
position and put a white disk in the center of it. Here’s the inner
dial:

  > (define inner-dial
      (overlay
       (text "555-1234" 9 "black")
       (circle 30 "solid" "white")))

and here’s a function to build the entire rotary dial, with an argument
that scales the dial:

  > (define (rotary-dial f)
      (scale
       f
       (overlay
        inner-dial
        (rotate
         -90
         (place-all-numbers (circle 60 "solid" "black"))))))
  > (rotary-dial 2)
  #(struct:object:image% ...)

Looking at the image, it feels like the numbers are too close to the
edge of the dial. So we can adjust the place-and-turn function to put a
little black rectangle on top of each number. The rectangle is invisible
because it ends up on top of the black dial, but it does serve to push
the digits down a little.

  > (define (place-and-turn digit dial)
      (rotate 30
              (overlay/align "center" "top"
                             (above
                              (rectangle 1 5 "solid" "black")
                              (a-number digit))
                             dial)))
  > (rotary-dial 2)
  #(struct:object:image% ...)

2.3. Alpha Blending

With shapes that have opaque colors like "red" and "blue", overlaying
one on top completely blots out the one one the bottom.

For example, the green rectangle here completely covers the blue one
where the two rectangles overlap.

  > (overlay
     (rectangle 60 100 "solid" (color 127 255 127))
     (rectangle 100 60 "solid" (color 127 127 255)))
  #(struct:object:image% ...)

But 2htdp/image also supports colors that are not completely opaque, via
the (optional) fourth argument to color.

  > (overlay
     (rectangle 60 100 "solid" (color 0 255 0 127))
     (rectangle 100 60 "solid" (color 0 0 255 127)))
  #(struct:object:image% ...)

In this example, the color (color 0 255 0 127) looks just like the color
(color 127 255 127) when the background is white. Since white is (color
255 255 255), we end up getting 1/2 of 255 for the red and blue
components and 255 for the green one.

We can also use alpha blending to make some interesting effects. For
example, the function spin-alot takes an image argument and repeatedly
places it on top of itself, rotating it each time by 1 degree.

  > (define (spin-alot t)
      (local [(define (spin-more i θ)
                (cond
                  [(= θ 360) i]
                  [else
                   (spin-more (overlay i (rotate θ t))
                              (+ θ 1))]))]
        (spin-more t 0)))

Here are some uses of spin-alot, first showing the original shape and
then the spun shape.

  > (rectangle 12 120 "solid" (color 0 0 255))
  #(struct:object:image% ...)
  > (spin-alot (rectangle 12 120 "solid" (color 0 0 255 1)))
  #(struct:object:image% ...)
  > (triangle 120 "solid" (color 0 0 255))
  #(struct:object:image% ...)
  > (spin-alot (triangle 120 "solid" (color 0 0 255 1)))
  #(struct:object:image% ...)
  > (isosceles-triangle 120 30 "solid" (color 0 0 255))
  #(struct:object:image% ...)
  > (spin-alot (isosceles-triangle 120 30 "solid" (color 0 0 255 1)))
  #(struct:object:image% ...)

2.4. Recursive Image Functions

It is also possible to make interesting looking shapes with little
recursive functions. For example, this function repeatedly puts white
circles that grow, evenly spaced around the edge of the given shape:

  > (define (swoosh image s)
      (cond
        [(zero? s) image]
        [else (swoosh
               (overlay/align "center" "top"
                              (circle (* s 1/2) "solid" "white")
                              (rotate 4 image))
               (- s 1))]))

  > (swoosh (circle 100 "solid" "black")
            94)
  #(struct:object:image% ...)

More conventional fractal shapes can also be written using the image
library, e.g.:

  > (define (sierpinski-carpet n)
      (cond
        [(zero? n) (square 1 "solid" "black")]
        [else
         (local [(define c (sierpinski-carpet (- n 1)))
                 (define i (square (image-width c) "solid" "white"))]
           (above (beside c c c)
                  (beside c i c)
                  (beside c c c)))]))

  > (sierpinski-carpet 5)
  #(struct:object:image% ...)

We can adjust the carpet to add a little color:

  > (define (colored-carpet colors)
      (cond
        [(empty? (rest colors))
         (square 1 "solid" (first colors))]
        [else
         (local [(define c (colored-carpet (rest colors)))
                 (define i (square (image-width c) "solid" (car colors)))]
           (above (beside c c c)
                  (beside c i c)
                  (beside c c c)))]))

  > (colored-carpet
     (list (color 51 0 255)
           (color 102 0 255)
           (color 153 0 255)
           (color 204 0 255)
           (color 255 0 255)
           (color 255 204 0)))
  #(struct:object:image% ...)

The Koch curve can be constructed by simply placing four curves next to
each other, rotated appropriately:

  > (define (koch-curve n)
      (cond
        [(zero? n) (square 1 "solid" "black")]
        [else
         (local [(define smaller (koch-curve (- n 1)))]
           (beside/align "bottom"
                         smaller
                         (rotate 60 smaller)
                         (rotate -60 smaller)
                         smaller))]))
  > (koch-curve 5)
  #(struct:object:image% ...)

And then put three of them together to form the Koch snowflake.

  > (above
     (beside
      (rotate 60 (koch-curve 5))
      (rotate -60 (koch-curve 5)))
     (flip-vertical (koch-curve 5)))
  #(struct:object:image% ...)

2.5. Rotating and Image Centers

When rotating an image, some times the image looks best when it rotates
around a point that is not the center of the image. The rotate function,
however, just rotates the image as a whole, effectively rotating it
around the center of its bounding box.

For example, imagine a game where the hero is represented as a triangle:

  > (define (hero α)
      (triangle 30 "solid" (color 255 0 0 α)))
  > (hero 255)
  #(struct:object:image% ...)

rotating the hero at the prompt looks reasonable:

  > (rotate 10 (hero 255))
  #(struct:object:image% ...)
  > (rotate 20 (hero 255))
  #(struct:object:image% ...)
  > (rotate 30 (hero 255))
  #(struct:object:image% ...)

but if the hero has to appear to spin in place, then it will not look
right, as you can kind of see if we use α-blending to represent old
positions of the hero:

  > (overlay (rotate 0  (hero 255))
             (rotate 10 (hero 125))
             (rotate 20 (hero 100))
             (rotate 30 (hero  75))
             (rotate 40 (hero  50))
             (rotate 50 (hero  25)))
  #(struct:object:image% ...)

What we’d really want is for the hero to appear to rotate around the
centroid of the triangle. To achieve this effect, we can put the hero
onto a transparent circle such that the center of the whole image lines
up with the centroid of the triangle:

  > (define (hero-on-blank α)
      (define the-hero (hero α))
      (define w (image-width the-hero))
      (define h (image-height the-hero))
      (define d (max w h))
      (define dx (/ w 2))   ; centroid x offset
      (define dy (* 2/3 h)) ; centroid y offset
      (define blank  (circle d "solid" (color 255 255 255 0)))
      (place-image/align the-hero (- d dx) (- d dy) "left" "top" blank))

and now the rotating hero looks reasonable:

  > (overlay (rotate 0  (hero-on-blank 255))
             (rotate 10 (hero-on-blank 125))
             (rotate 20 (hero-on-blank 100))
             (rotate 30 (hero-on-blank  75))
             (rotate 40 (hero-on-blank  50))
             (rotate 50 (hero-on-blank  25)))
  #(struct:object:image% ...)

2.6. Image Interoperability

Images can connect to other libraries.  Specifically:

* images are snip% objects, so can be inserted into text% and
  pasteboard% objects

* they implement the convert protocol for 'png-bytes

* they implement the pict-convert protocol, and

* there is a low-level interface for drawing directly into a dc<%>
  object: render-image.

2.7. The Nitty Gritty of Pixels, Pens, and Lines

The image library treats coordinates as if they are in the upper-left
corner of each pixel, and infinitesimally small (unlike pixels, which
have some area).

Thus, when drawing a solid square of whose side-length is 10, the image
library colors in all of the pixels enclosed by the square starting at
the upper left corner of (0,0) and going down to the upper left corner
of (10,10), so the pixel whose upper left at (9,9) is colored in, but
the pixel at (10,10) is not. All told, 100 pixels get colored in, just
as expected for a square with a side length of 10.

When drawing lines, however, things get a bit more complex.
Specifically, imagine drawing the outline of that rectangle. Since the
border is between the pixels, there really isn’t a natural pixel to draw
to indicate the border. Accordingly, when drawing an outline square
(without a pen specification, but just a color as the last argument),
the image library uses a pen whose width is 1 pixel, but draws a line
centered at the point (0.5,0.5) that goes down and around to the point
(10.5,10.5). This means that the outline slightly exceeds the bounding
box of the shape. Specifically, the upper and left-hand lines around the
square are within the bounding box, but the lower and right-hand lines
are just outside.

If you are reading along with this section using DrRacket, note that
DrRacket clips images to their bounding boxes when rendering them in the
interactions window; read on for the ramifications but know for now that
what you see in the example results here will not be exactly the same as
what you see in the interactions window for that reason.

This kind of rectangle is useful when putting rectangles next to each
other and avoiding extra thick lines on the interior. For example,
consider building a grid like this:

  > (define s1 (square 20 'outline 'black))
  > (define r1 (beside s1 s1 s1 s1 s1 s1))
  > (above  r1 r1 r1 r1 r1 r1)
  #(struct:object:image% ...)

The reason interior lines in this grid are the same thickness as the
lines around the edge is because the rectangles overlap with each other.
That is, the upper-left rectangle’s right edge is right on top of the
next rectangle’s left edge.

The special case of adding 0.5 to each coordinate when drawing the
square applies to all outline polygon-based shapes that just pass color,
but does not apply when a pen is passed as the last argument to create
the shape. For example, if using a pen of thickness 2 to draw a
rectangle, we get a shape that has a border drawing the row of pixels
just inside and just outside the shape. One might imagine that a pen of
thickness 1 would draw an outline around the shape with a 1 pixel thick
line, but this would require 1/2 of each pixel to be illuminated,
something that is not possible. Instead, the same pixels are lit up as
with the 2 pixel wide pen, but with only 1/2 of the intensity of the
color. So a 1 pixel wide black pen object draws a 2 pixel wide outline,
but in gray.

  > (define p1 (make-pen "black" 1 "solid" "round" "round"))

  > (rectangle 20 20 "outline" p1)

#(struct:object:image% ...)

When combining pens and cropping, we can make a rectangle that has a
line that is one pixel wide, but where the line is drawn entirely within
the rectangle. This rectangle has a two-pixel wide black pen, but we can
crop out the outer portion of the pen.

  > (define p2 (make-pen "black" 2 "solid" "round" "round"))
  > (define s2 (crop 0 0 20 20 (rectangle 20 20 "outline" p2)))
  > s2
  #(struct:object:image% ...)

Using that we can build a grid now too, but this grid has doubled lines
on the interior.

  > (define r2 (beside s2 s2 s2 s2 s2 s2))
  > (above  r2 r2 r2 r2 r2 r2)
  #(struct:object:image% ...)

While this kind of rectangle is not useful for building grids, it is
important to be able to build rectangles whose drawing does not exceed
its bounding box. Specifically, this kind of drawing is used by frame
and empty-scene so that the extra drawn pixels are not lost if the image
is later clipped to its bounding box.

When using image->color-list with outline shapes, the results can be
surprising for the same reasons. For example, a 2x2 black, outline
rectangle consists of nine black pixels, as discussed above, but since
image->color-list only returns the pixels that are within the bounding
box, we see only three black pixels and one white one.

  > (image->color-list
     (rectangle 2 2 "outline" "black"))
  (list
   (color 0 0 0 255)
   (color 0 0 0 255)
   (color 0 0 0 255)
   (color 255 255 255 0))

The black pixels are (most of) the upper and left edge of the outline
shape, and the one white pixel is the pixel in the middle of the shape.

2.8. The Nitty Gritty of Alpha Blending

Alpha blending can cause imprecision in color comparisons resulting in
shapes that appear equal? even though they were created with different
colors. This section explains how that happens.

To start, consider the color (make-color 1 1 1 50). This color is nearly
the darkest shade of black, but with lots of transparency, so it renders
a light gray color on a white background, e.g.:

  > (rectangle 100 100 "solid" (make-color 1 1 1 50))
  #(struct:object:image% ...)

If the background had been green, the same rectangle would look like a
darker shade of green:

  > (overlay
     (rectangle 100 100 "solid" (make-color 1 1 1 50))
     (rectangle 200 200 "solid" "green"))
  #(struct:object:image% ...)

Surprisingly, this shape is equal to one that (apparently) has a
different color in it:

  > (equal?
     (rectangle 100 100 'solid (make-color 1 1 1 50))
     (rectangle 100 100 'solid (make-color 2 2 2 50)))
  #t

To understand why, we must look more carefully at how alpha blending and
image equality work. Image equality’s definition is straightforward: two
images are equal if they are both drawn the same. That is, image
equality is defined by simply drawing the two shapes on a white
background and then comparing all of the pixels for the two drawings (it
is implemented more efficiently in some cases, however).

So, for those shapes to be equal, they must be drawn with the same
colors. To see what colors were actually drawn, we can use
image->color-list. Since these images use the same color in every pixel,
we can examine just the first one:

  > (first
     (image->color-list
      (rectangle 100 100 'solid (make-color 1 1 1 50))))
  (color 0 0 0 50)
  > (first
     (image->color-list
      (rectangle 100 100 'solid (make-color 2 2 2 50))))
  (color 0 0 0 50)

As expected from the equal? test, the two colors are the same, but why
should they be the same? This is where a subtle aspect of alpha blending
and drawing comes up. In general, alpha blending works by taking the
color of any shapes below the one being drawn and then combining that
color with the new color. The precise amount of the combination is
controlled by the alpha value. So, if a shape has an alpha value of α,
then the drawing library multiplies the new shapes color by (/ α 255)
and the existing shape’s color by (- 1 (/ α 255)) and then adds the
results to get the final color. (It does this for each of the red,
green, and blue components separately.)

Going back to the two example rectangles, the drawing library multiplies
50/255 by 1 for the first shape and multiplies 50/255 by 2 for the
second shape (since they are both drawn on a white background). Then it
rounds them to integers, which results in 0 for both colors, making the
images the same.

3. Images: "image.rkt"

 (require 2htdp/image) package: htdp-lib ~

The image teachpack provides a number of basic image construction
functions, along with combinators for building more complex images out
of existing images. Basic images include various polygons, ellipses and
circles, and text, as well as bitmaps.In the context of this
documentation, a bitmap denotes a special form of image?, namely a
collection of pixels associated with an image. It does not refer to the
bitmap% class. Typically such image-bitmaps come about via the Insert
Image... menu item in DrRacket Existing images can be rotated, scaled,
flipped, and overlaid on top of each other.

In some situations images are rendered into bitmaps (e.g. when being
shown in the DrRacket Interactions window) In order to avoid bad
performance penalties, the rendering process limits the area of the
images to about 25,000,000 pixels (which requires about 100 MB of
storage).

3.1. Basic Images

                                        *circle*
(circle radius mode color) -> image? ~
  radius : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(circle radius outline-mode pen-or-color) -> image?
  radius : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a circle with the given radius, mode, and color.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (circle 30 "outline" "red")
  #(struct:object:image% ...)
  > (circle 20 "solid" "blue")
  #(struct:object:image% ...)
  > (circle 20 100 "blue")
  #(struct:object:image% ...)

                                        *ellipse*
(ellipse width height mode color) -> image? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(ellipse width height mode pen-or-color) -> image?
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c image-color? pen?) ~

Constructs an ellipse with the given width, height, mode, and color.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (ellipse 60 30 "outline" "black")
  #(struct:object:image% ...)
  > (ellipse 30 60 "solid" "blue")
  #(struct:object:image% ...)
  > (ellipse 30 60 100 "blue")
  #(struct:object:image% ...)

                                        *line*
(line x1 y1 pen-or-color) -> image? ~
  x1 : real? ~
  y1 : real? ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs an image representing a line segment that connects the points
(0,0) to (x1,y1).

Examples:

  > (line 30 30 "black")
  #(struct:object:image% ...)
  > (line -30 20 "red")
  #(struct:object:image% ...)
  > (line 30 -20 "red")
  #(struct:object:image% ...)

                                        *add-line*
(add-line image x1 y1 x2 y2 pen-or-color) -> image? ~
  image : image? ~
  x1 : real? ~
  y1 : real? ~
  x2 : real? ~
  y2 : real? ~
  pen-or-color : (or/c pen? image-color?) ~

Adds a line to the image image, starting from the point (x1,y1) and
going to the point (x2,y2). Unlike scene+line, if the line passes
outside of image, the image gets larger to accommodate the line.

Examples:

  > (add-line (ellipse 40 40 "outline" "maroon")
              0 40 40 0 "maroon")
  #(struct:object:image% ...)
  > (add-line (rectangle 40 40 "solid" "gray")
              -10 50 50 -10 "maroon")
  #(struct:object:image% ...)
  > (add-line
      (rectangle 100 100 "solid" "darkolivegreen")
      25 25 75 75
      (make-pen "goldenrod" 30 "solid" "round" "round"))
  #(struct:object:image% ...)

                                        *add-curve*
(add-curve image              ~
           x1                
           y1                
           angle1            
           pull1             
           x2                
           y2                
           angle2            
           pull2             
           pen-or-color) -> image?
  image : image? ~
  x1 : real? ~
  y1 : real? ~
  angle1 : angle? ~
  pull1 : real? ~
  x2 : real? ~
  y2 : real? ~
  angle2 : angle? ~
  pull2 : real? ~
  pen-or-color : (or/c pen? image-color?) ~

Adds a curve to image, starting at the point (x1,y1), and ending at the
point (x2,y2).

The angle1 and angle2 arguments specify the angle that the curve has as
it leaves the initial point and as it reaches the final point,
respectively.

The pull1 and pull2 arguments control how long the curve tries to stay
with that angle. Larger numbers mean that the curve stays with the angle
longer.

Unlike scene+curve, if the line passes outside of image, the image
gets larger to accommodate the curve.

Examples:

  > (add-curve (rectangle 100 100 "solid" "black")
               20 20 0 1/3
               80 80 0 1/3
               "white")
  #(struct:object:image% ...)
  > (add-curve (rectangle 100 100 "solid" "black")
               20 20 0 1
               80 80 0 1
               "white")
  #(struct:object:image% ...)
  > (add-curve
     (add-curve
      (rectangle 40 100 "solid" "black")
      20 10 180 1/2
      20 90 180 1/2
      (make-pen "white" 4 "solid" "round" "round"))
     20 10 0 1/2
     20 90 0 1/2
     (make-pen "white" 4 "solid" "round" "round"))
  #(struct:object:image% ...)
  > (add-curve (rectangle 100 100 "solid" "black")
               -20 -20 0 1
               120 120 0 1
               "red")
  #(struct:object:image% ...)

                                        *add-solid-curve*
(add-solid-curve image       ~
                 x1         
                 y1         
                 angle1     
                 pull1      
                 x2         
                 y2         
                 angle2     
                 pull2      
                 color) -> image?
  image : image? ~
  x1 : real? ~
  y1 : real? ~
  angle1 : angle? ~
  pull1 : real? ~
  x2 : real? ~
  y2 : real? ~
  angle2 : angle? ~
  pull2 : real? ~
  color : image-color? ~

Adds a curve to image like add-curve, except it fills in the region
inside the curve.

Examples:

  > (add-solid-curve (rectangle 100 100 "solid" "black")
                     20 20 0 1
                     80 80 0 1
                     "white")
  #(struct:object:image% ...)
  > (add-solid-curve
     (add-solid-curve
      (rectangle 100 100 "solid" "black")
      50 20 180 1/10
      50 80 0 1
      "white")
     50 20 0 1/10
     50 80 180 1
     "white")
  #(struct:object:image% ...)
  > (add-solid-curve
     (add-solid-curve
      (rectangle 100 100 "solid" "black")
      51 20 180 1/10
      50 80 0 1
      "white")
     49 20 0 1/10
     50 80 180 1
     "white")
  #(struct:object:image% ...)
  > (add-solid-curve (rectangle 100 100 "solid" "black")
                     -20 -20 0 1
                     120 120 0 1
                     "red")
  #(struct:object:image% ...)

Added in version 1.2 of package htdp-lib.

                                        *text*
(text string font-size color) -> image? ~
  string : string? ~
  font-size : (and/c integer? (<=/c 1 255)) ~
  color : image-color? ~

Constructs an image that draws the given string, using the font size and
color.

Examples:

  > (text "Hello" 24 "olive")
  #(struct:object:image% ...)
  > (text "Goodbye" 36 "indigo")
  #(struct:object:image% ...)

If the string contains newlines, the result pict will have multiple
lines.

Example:

  > (text "Hello and\nGoodbye" 24 "orange")
  #(struct:object:image% ...)

The text size is measured in pixels, not points, so passing 24 to text
should result in an image whose height is 24 (which might not be the
case if the size were measured in points).

Example:

  > (image-height (text "Hello" 24 "olive"))
  25

Changed in version 1.7 of package htdp-lib: When called with strings
that have newlines, text returns multiple-line images.

                                        *text/font*
(text/font string           ~
           font-size       
           color           
           face            
           family          
           style           
           weight          
           underline?) -> image?
  string : string? ~
  font-size : (and/c integer? (<=/c 1 255)) ~
  color : image-color? ~
  face : (or/c string? #f) ~
  family : (or/c "default" "decorative" "roman" "script" ~
                 "swiss" "modern" "symbol" "system"
                 'default 'decorative 'roman 'script
                 'swiss 'modern 'symbol 'system)
  style : (or/c "normal" "italic" "slant" ~
                'normal 'italic 'slant)
  weight : (or/c "normal" "bold" "light" ~
                 'normal 'bold 'light)
  underline? : any/c ~

Constructs an image that draws the given string, using a complete font
specification.

The face and the family combine to give the complete typeface. If face
is available on the system, it is used, but if not then a default
typeface based on the family is chosen. The style controls if the face
is italic or not (on Windows and Mac OS, 'slant and 'italic are the
same), the weight controls if it is boldface (or light), and underline?
determines if the face is underlined. For more details on these
arguments, see font%, which ultimately is what this code uses to draw
the font.

Examples:

  > (text/font "Hello" 24 "olive"
               "Gill Sans" 'swiss 'normal 'bold #f)
  #(struct:object:image% ...)
  > (text/font "Goodbye" 18 "indigo"
               #f 'modern 'italic 'normal #f)
  #(struct:object:image% ...)
  > (text/font "not really a link" 18 "blue"
               #f 'roman 'normal 'normal #t)
  #(struct:object:image% ...)

empty-image : image? ~

The empty image. Its width and height are both zero and it does not draw
at all.

Examples:

  > (image-width empty-image)
  0
  > (equal? (above empty-image
                   (rectangle 10 10 "solid" "red"))
            (beside empty-image
                    (rectangle 10 10 "solid" "red")))
  #t

Combining an image with empty-image produces the original image (as
shown in the above example).

3.2. Polygons

                                        *triangle*
(triangle side-length mode color) -> image? ~
  side-length : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(triangle side-length       
          outline-mode      
          pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a upward-pointing equilateral triangle. The side-length
argument determines the length of the side of the triangle.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Example:

  > (triangle 40 "solid" "tan")
  #(struct:object:image% ...)

                                        *right-triangle*
(right-triangle side-length1      ~
                side-length2     
                mode             
                color)       -> image?
  side-length1 : (and/c real? (not/c negative?)) ~
  side-length2 : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(right-triangle side-length1      
                side-length2      
                outline-mode      
                pen-or-color) -> image?
  side-length1 : (and/c real? (not/c negative?)) ~
  side-length2 : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a triangle with a right angle where the two sides adjacent to
the right angle have lengths side-length1 and side-length2.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Example:

  > (right-triangle 36 48 "solid" "black")
  #(struct:object:image% ...)

                                        *isosceles-triangle*
(isosceles-triangle side-length      ~
                    angle           
                    mode            
                    color)      -> image?
  side-length : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  mode : mode? ~
  color : image-color? ~
(isosceles-triangle side-length       
                    angle             
                    outline-mode      
                    pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle with two equal-length sides, of length side-length
where the angle between those sides is angle. The third leg is straight,
horizontally. If the angle is less than 180, then the triangle will
point up and if the angle is more, then the triangle will point down.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (isosceles-triangle 200 170 "solid" "seagreen")
  #(struct:object:image% ...)
  > (isosceles-triangle 60 30 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (isosceles-triangle 60 330 "solid" "lightseagreen")
  #(struct:object:image% ...)

To create a triangle given known sides and angles, the following family
of functions are useful:

* triangle/sss, if all three sides are known

* triangle/ass, triangle/sas, or triangle/ssa, if two sides and their
  included angle are known

* triangle/aas, triangle/asa, or triangle/saa, if two angles and their
  shared side are known.

They all construct a triangle oriented as follows:



                                        *triangle/sss*
(triangle/sss side-length-a      ~
              side-length-b     
              side-length-c     
              mode              
              color)        -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  side-length-b : (and/c real? (not/c negative?)) ~
  side-length-c : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(triangle/sss side-length-a     
              side-length-b     
              side-length-c     
              outline-mode      
              pen-or-color) -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  side-length-b : (and/c real? (not/c negative?)) ~
  side-length-c : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the side lengths a, b, and, c are given by
side-length-a, side-length-b, and, side-length-c respectively.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/sss 40 60 80 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/sss 80 40 60 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/sss 80 80 40 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/ass*
(triangle/ass angle-a            ~
              side-length-b     
              side-length-c     
              mode              
              color)        -> image?
  angle-a : angle? ~
  side-length-b : (and/c real? (not/c negative?)) ~
  side-length-c : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(triangle/ass angle-a           
              side-length-b     
              side-length-c     
              outline-mode      
              pen-or-color) -> image?
  angle-a : angle? ~
  side-length-b : (and/c real? (not/c negative?)) ~
  side-length-c : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the angle A and side length a and b, are given
by angle-a, side-length-b, and, side-length-c respectively. See above
for a diagram showing where which sides and which angles are which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/ass 10  60 100 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/ass 90  60 100 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/ass 130 60 100 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/sas*
(triangle/sas side-length-a      ~
              angle-b           
              side-length-c     
              mode              
              color)        -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  angle-b : angle? ~
  side-length-c : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(triangle/sas side-length-a     
              angle-b           
              side-length-c     
              outline-mode      
              pen-or-color) -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  angle-b : angle? ~
  side-length-c : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the side length a, angle B, and, side length c
given by side-length-a, angle-b, and, side-length-c respectively. See
above for a diagram showing where which sides and which angles are
which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/sas 60  10 100 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/sas 60  90 100 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/sas 60 130 100 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/ssa*
(triangle/ssa side-length-a      ~
              side-length-b     
              angle-c           
              mode              
              color)        -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  side-length-b : (and/c real? (not/c negative?)) ~
  angle-c : angle? ~
  mode : mode? ~
  color : image-color? ~
(triangle/ssa side-length-a     
              side-length-b     
              angle-c           
              outline-mode      
              pen-or-color) -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  side-length-b : (and/c real? (not/c negative?)) ~
  angle-c : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the side length a, side length b, and, angle c
given by side-length-a, side-length-b, and, angle-c respectively. See
above for a diagram showing where which sides and which angles are
which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/ssa 60 100  10 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/ssa 60 100  90 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/ssa 60 100 130 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/aas*
(triangle/aas angle-a            ~
              angle-b           
              side-length-c     
              mode              
              color)        -> image?
  angle-a : angle? ~
  angle-b : angle? ~
  side-length-c : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(triangle/aas angle-a           
              angle-b           
              side-length-c     
              outline-mode      
              pen-or-color) -> image?
  angle-a : angle? ~
  angle-b : angle? ~
  side-length-c : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the angle A, angle B, and, side length c given
by angle-a, angle-b, and, side-length-c respectively. See above for a
diagram showing where which sides and which angles are which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/aas  10 40 200 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/aas  90 40 200 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/aas 130 40 40  "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/asa*
(triangle/asa angle-a            ~
              side-length-b     
              angle-c           
              mode              
              color)        -> image?
  angle-a : angle? ~
  side-length-b : (and/c real? (not/c negative?)) ~
  angle-c : angle? ~
  mode : mode? ~
  color : image-color? ~
(triangle/asa angle-a           
              side-length-b     
              angle-c           
              outline-mode      
              pen-or-color) -> image?
  angle-a : angle? ~
  side-length-b : (and/c real? (not/c negative?)) ~
  angle-c : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the angle A, side length b, and, angle C given
by angle-a, side-length-b, and, angle-c respectively. See above for a
diagram showing where which sides and which angles are which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/asa  10 200 40 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/asa  90 200 40 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/asa 130 40  40 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *triangle/saa*
(triangle/saa side-length-a      ~
              angle-b           
              angle-c           
              mode              
              color)        -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  angle-b : angle? ~
  angle-c : angle? ~
  mode : mode? ~
  color : image-color? ~
(triangle/saa side-length-a     
              angle-b           
              angle-c           
              outline-mode      
              pen-or-color) -> image?
  side-length-a : (and/c real? (not/c negative?)) ~
  angle-b : angle? ~
  angle-c : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Creates a triangle where the side length a, angle B, and, angle C given
by side-length-a, angle-b, and, angle-c respectively. See above for a
diagram showing where which sides and which angles are which.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (triangle/saa 200  10 40 "solid" "seagreen")
  #(struct:object:image% ...)
  > (triangle/saa 200  90 40 "solid" "aquamarine")
  #(struct:object:image% ...)
  > (triangle/saa 40  130 40 "solid" "lightseagreen")
  #(struct:object:image% ...)

                                        *square*
(square side-len mode color) -> image? ~
  side-len : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(square side-len outline-mode pen-or-color) -> image?
  side-len : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a square.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (square 40 "solid" "slateblue")
  #(struct:object:image% ...)
  > (square 50 "outline" "darkmagenta")
  #(struct:object:image% ...)

                                        *rectangle*
(rectangle width height mode color) -> image? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(rectangle width             
           height            
           outline-mode      
           pen-or-color) -> image?
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a rectangle with the given width, height, mode, and color.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (rectangle 40 20 "outline" "black")
  #(struct:object:image% ...)
  > (rectangle 20 40 "solid" "blue")
  #(struct:object:image% ...)

                                        *rhombus*
(rhombus side-length angle mode color) -> image? ~
  side-length : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  mode : mode? ~
  color : image-color? ~
(rhombus side-length       
         angle             
         outline-mode      
         pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a four sided polygon with all equal sides and thus where
opposite angles are equal to each other. The top and bottom pair of
angles is angle and the left and right are (- 180 angle).

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (rhombus 40 45 "solid" "magenta")
  #(struct:object:image% ...)
  > (rhombus 80 150 "solid" "mediumpurple")
  #(struct:object:image% ...)

                                        *star*
(star side-length mode color) -> image? ~
  side-length : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(star side-length outline-mode color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  color : (or/c pen? image-color?) ~

Constructs a star with five points. The side-length argument determines
the side length of the enclosing pentagon.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Example:

  > (star 40 "solid" "gray")
  #(struct:object:image% ...)

                                        *star-polygon*
(star-polygon side-length      ~
              side-count      
              step-count      
              mode            
              color)      -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  step-count : step-count? ~
  mode : mode? ~
  color : image-color? ~
(star-polygon side-length       
              side-count        
              step-count        
              outline-mode      
              pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  step-count : step-count? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs an arbitrary regular star polygon (a generalization of the
regular polygons). The polygon is enclosed by a regular polygon with
side-count sides each side-length long. The polygon is actually
constructed by going from vertex to vertex around the regular polygon,
but connecting every step-count-th vertex (i.e., skipping every (-
step-count 1) vertices).

For example, if side-count is 5 and step-count is 2, then this function
produces a shape just like star.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (star-polygon 40 5 2 "solid" "seagreen")
  #(struct:object:image% ...)
  > (star-polygon 40 7 3 "outline" "darkred")
  #(struct:object:image% ...)
  > (star-polygon 20 10 3 "solid" "cornflowerblue")
  #(struct:object:image% ...)

                                        *radial-star*
(radial-star point-count       ~
             inner-radius     
             outer-radius     
             mode             
             color)       -> image?
  point-count : (and/c integer? (>=/c 2)) ~
  inner-radius : (and/c real? (not/c negative?)) ~
  outer-radius : (and/c real? (not/c negative?)) ~
  mode : mode? ~
  color : image-color? ~
(radial-star point-count       
             inner-radius      
             outer-radius      
             outline-mode      
             pen-or-color) -> image?
  point-count : (and/c integer? (>=/c 2)) ~
  inner-radius : (and/c real? (not/c negative?)) ~
  outer-radius : (and/c real? (not/c negative?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a star-like polygon where the star is specified by two radii
and a number of points. The first radius determines where the points
begin, the second determines where they end, and the point-count
argument determines how many points the star has.

Examples:

  > (radial-star 8 8 64 "solid" "darkslategray")
  #(struct:object:image% ...)
  > (radial-star 32 30 40 "outline" "black")
  #(struct:object:image% ...)

                                        *regular-polygon*
(regular-polygon side-length      ~
                 side-count      
                 mode            
                 color)      -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  mode : mode? ~
  color : image-color? ~
(regular-polygon side-length       
                 side-count        
                 outline-mode      
                 pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a regular polygon with side-count sides.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (regular-polygon 50 3 "outline" "red")
  #(struct:object:image% ...)
  > (regular-polygon 40 4 "outline" "blue")
  #(struct:object:image% ...)
  > (regular-polygon 20 8 "solid" "red")
  #(struct:object:image% ...)

                                        *pulled-regular-polygon*
(pulled-regular-polygon side-length      ~
                        side-count      
                        pull            
                        angle           
                        mode            
                        color)      -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  pull : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  mode : mode? ~
  color : image-color? ~
(pulled-regular-polygon side-length       
                        side-count        
                        pull              
                        angle             
                        outline-mode      
                        pen-or-color) -> image?
  side-length : (and/c real? (not/c negative?)) ~
  side-count : side-count? ~
  pull : (and/c real? (not/c negative?)) ~
  angle : angle? ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a regular polygon with side-count sides where each side is
curved according to the pull and angle arguments. The angle argument
controls the angle at which the curved version of polygon edge makes
with the original edge of the polygon. Larger the pull arguments mean
that the angle is preserved more at each vertex.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (pulled-regular-polygon 60 4 1/3 30 "solid" "blue")
  #(struct:object:image% ...)
  > (pulled-regular-polygon 50 5 1/2 -10 "solid" "red")
  #(struct:object:image% ...)
  > (pulled-regular-polygon 50 5 1 140 "solid" "purple")
  #(struct:object:image% ...)
  > (pulled-regular-polygon 50 5 1.1 140 "solid" "purple")
  #(struct:object:image% ...)
  > (pulled-regular-polygon 100 3 1.8 30 "solid" "blue")
  #(struct:object:image% ...)

Added in version 1.3 of package htdp-lib.

                                        *polygon*
(polygon vertices mode color) -> image? ~
  vertices : (listof (or/c real-valued-posn? pulled-point?)) ~
  mode : mode? ~
  color : image-color? ~
(polygon vertices outline-mode pen-or-color) -> image?
  vertices : (listof (or/c real-valued-posn? pulled-point?)) ~
  outline-mode : (or/c 'outline "outline") ~
  pen-or-color : (or/c pen? image-color?) ~

Constructs a polygon connecting the given vertices.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (polygon (list (make-posn 0 0)
                   (make-posn -10 20)
                   (make-posn 60 0)
                   (make-posn -10 -20))
             "solid"
             "burlywood")
  #(struct:object:image% ...)
  > (polygon (list (make-pulled-point 1/2 20 0 0 1/2 -20)
                   (make-posn -10 20)
                   (make-pulled-point 1/2 -20 60 0 1/2 20)
                   (make-posn -10 -20))
             "solid"
             "burlywood")
  #(struct:object:image% ...)
  > (polygon (list (make-posn 0 0)
                   (make-posn 0 40)
                   (make-posn 20 40)
                   (make-posn 20 60)
                   (make-posn 40 60)
                   (make-posn 40 20)
                   (make-posn 20 20)
                   (make-posn 20 0))
             "solid"
             "plum")
  #(struct:object:image% ...)
  > (underlay
     (rectangle 80 80 "solid" "mediumseagreen")
     (polygon
      (list (make-posn 0 0)
            (make-posn 50 0)
            (make-posn 0 50)
            (make-posn 50 50))
      "outline"
      (make-pen "darkslategray" 10 "solid" "round" "round")))
  #(struct:object:image% ...)
  > (underlay
     (rectangle 90 80 "solid" "mediumseagreen")
     (polygon
      (list (make-posn 0 0)
            (make-posn 50 0)
            (make-posn 0 50)
            (make-posn 50 50))
      "outline"
      (make-pen "darkslategray" 10 "solid" "projecting" "miter")))
  #(struct:object:image% ...)

Changed in version 1.3 of package htdp-lib: Accepts pulled-points.

                                        *add-polygon*
(add-polygon image posns mode color) -> image? ~
  image : image? ~
  posns : (listof posn?) ~
  mode : mode? ~
  color : image-color? ~

Adds a closed polygon to the image image, with vertices as specified in
posns  (relative to the top-left corner of image).  Unlike
scene+polygon,  if the polygon goes outside the bounds of image, the
result is enlarged to accommodate both.

Note that when the mode is 'outline or "outline", the shape may draw
outside of its bounding box and thus parts of the image may disappear
when it is cropped. See The Nitty Gritty of Pixels, Pens, and Lines (in
the Image Guide) for a more careful explanation of the ramifications of
this fact.

If the mode argument is 'outline or "outline", then the last argument
can be a pen struct or an image-color?, but if the mode is 'solid or
"solid", then the last argument must be an image-color?.

Examples:

  > (add-polygon (square 65 "solid" "light blue")
                 (list (make-posn 30 -20)
                       (make-posn 50 50)
                       (make-posn -20 30))
                 "solid" "forest green")
  #(struct:object:image% ...)
  > (add-polygon (square 65 "solid" "light blue")
                 (list (make-posn 30 -20)
                       (make-pulled-point 1/2 30 50 50 1/2 -30)
                       (make-posn -20 30))
                 "solid" "forest green")
  #(struct:object:image% ...)
  > (add-polygon (square 180 "solid" "yellow")
                 (list (make-posn 109 160)
                       (make-posn 26 148)
                       (make-posn 46 36)
                       (make-posn 93 44)
                       (make-posn 89 68)
                       (make-posn 122 72))
                 "outline" "dark blue")
  #(struct:object:image% ...)
  > (add-polygon (square 50 "solid" "light blue")
                 (list (make-posn 25 -10)
                       (make-posn 60 25)
                       (make-posn 25 60)
                       (make-posn -10 25))
                 "solid" "pink")
  #(struct:object:image% ...)

Changed in version 1.3 of package htdp-lib: Accepts pulled-points.

                                        *scene+polygon*
(scene+polygon image posns mode color) -> image? ~
  image : image? ~
  posns : (listof posn?) ~
  mode : mode? ~
  color : image-color? ~

Adds a closed polygon to the image image, with vertices as specified in
posns  (relative to the top-left corner of image).  Unlike add-polygon,
if the  polygon goes outside the bounds of image, the result is clipped
to image.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (scene+polygon (square 65 "solid" "light blue")
                   (list (make-posn 30 -20)
                         (make-posn 50 50)
                         (make-posn -20 30))
                   "solid" "forest green")
  #(struct:object:image% ...)
  > (scene+polygon (square 65 "solid" "light blue")
                   (list (make-posn 30 -20)
                         (make-pulled-point 1/2 -30 50 50 1/2 30)
                         (make-posn -20 30))
                   "solid" "forest green")
  #(struct:object:image% ...)
  > (scene+polygon (square 180 "solid" "yellow")
                   (list (make-posn 109 160)
                         (make-posn 26 148)
                         (make-posn 46 36)
                         (make-posn 93 44)
                         (make-posn 89 68)
                         (make-posn 122 72))
                   "outline" "dark blue")
  #(struct:object:image% ...)
  > (scene+polygon (square 50 "solid" "light blue")
                   (list (make-posn 25 -10)
                         (make-posn 60 25)
                         (make-posn 25 60)
                         (make-posn -10 25))
                   "solid" "pink")
  #(struct:object:image% ...)

Changed in version 1.3 of package htdp-lib: Accepts pulled-points.

3.3. Overlaying Images

                                        *overlay*
(overlay i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Overlays all of its arguments building a single image. The first
argument goes on top of the second argument, which goes on top of the
third argument, etc. The images are all lined up on their centers.

Examples:

  > (overlay (rectangle 30 60 "solid" "orange")
             (ellipse 60 30 "solid" "purple"))
  #(struct:object:image% ...)
  > (overlay (ellipse 10 10 "solid" "red")
             (ellipse 20 20 "solid" "black")
             (ellipse 30 30 "solid" "red")
             (ellipse 40 40 "solid" "black")
             (ellipse 50 50 "solid" "red")
             (ellipse 60 60 "solid" "black"))
  #(struct:object:image% ...)
  > (overlay (regular-polygon 20 5 "solid" (make-color  50  50 255))
             (regular-polygon 26 5 "solid" (make-color 100 100 255))
             (regular-polygon 32 5 "solid" (make-color 150 150 255))
             (regular-polygon 38 5 "solid" (make-color 200 200 255))
             (regular-polygon 44 5 "solid" (make-color 250 250 255)))
  #(struct:object:image% ...)

                                        *overlay/align*
(overlay/align x-place y-place i1 i2 is ...) -> image? ~
  x-place : x-place? ~
  y-place : y-place? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Overlays all of its image arguments, much like the overlay function, but
using x-place and y-place to determine where the images are lined up.
For example, if x-place and y-place are both "middle", then the images
are lined up on their centers.

Examples:

  > (overlay/align "left" "middle"
                   (rectangle 30 60 "solid" "orange")
                   (ellipse 60 30 "solid" "purple"))
  #(struct:object:image% ...)
  > (overlay/align "right" "bottom"
                   (rectangle 20 20 "solid" "silver")
                   (rectangle 30 30 "solid" "seagreen")
                   (rectangle 40 40 "solid" "silver")
                   (rectangle 50 50 "solid" "seagreen"))
  #(struct:object:image% ...)

                                        *overlay/offset*
(overlay/offset i1 x y i2) -> image? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Just like overlay, this function lines up its image arguments on top of
each other. Unlike overlay, it moves i2 by x pixels to the right and y
down before overlaying them.

Examples:

  > (overlay/offset (circle 40 "solid" "red")
                    10 10
                    (circle 40 "solid" "blue"))
  #(struct:object:image% ...)
  > (overlay/offset (overlay/offset (rectangle 60 20 "solid" "black")
                                    -50 0
                                    (circle 20 "solid" "darkorange"))
                    70 0
                    (circle 20 "solid" "darkorange"))
  #(struct:object:image% ...)
  > (overlay/offset
     (overlay/offset (circle 30 'solid (color 0 150 0 127))
                     26 0
                     (circle 30 'solid (color 0 0 255 127)))
     0 26
     (circle 30 'solid (color 200 0 0 127)))
  #(struct:object:image% ...)

                                        *overlay/align/offset*
(overlay/align/offset x-place      ~
                      y-place     
                      i1          
                      x           
                      y           
                      i2)     -> image?
  x-place : x-place? ~
  y-place : y-place? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Overlays image i1 on top of i2, using x-place and y-place as the
starting points for the overlaying, and then adjusts i2 by x to the
right and y pixels down.

This function combines the capabilities of overlay/align and
overlay/offset.

Examples:

  > (overlay/align/offset
     "right" "bottom"
     (star-polygon 20 20 3 "solid" "navy")
     10 10
     (circle 30 "solid" "cornflowerblue"))
  #(struct:object:image% ...)
  > (overlay/align/offset
     "left" "bottom"
     (star-polygon 20 20 3 "solid" "navy")
     -10 10
     (circle 30 "solid" "cornflowerblue"))
  #(struct:object:image% ...)

                                        *overlay/xy*
(overlay/xy i1 x y i2) -> image? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Constructs an image by overlaying i1 on top of i2. The images are
initially lined up on their upper-left corners and then i2 is shifted to
the right by x pixels and down by y pixels.

This is the same as (underlay/xy i2 (- x) (- y) i1).

See also overlay/offset and underlay/offset.

Examples:

  > (overlay/xy (rectangle 20 20 "outline" "black")
                20 0
                (rectangle 20 20 "outline" "black"))
  #(struct:object:image% ...)
  > (overlay/xy (rectangle 20 20 "solid" "red")
                10 10
                (rectangle 20 20 "solid" "black"))
  #(struct:object:image% ...)
  > (overlay/xy (rectangle 20 20 "solid" "red")
                -10 -10
                (rectangle 20 20 "solid" "black"))
  #(struct:object:image% ...)
  > (overlay/xy
     (overlay/xy (ellipse 40 40 "outline" "black")
                 10
                 15
                 (ellipse 10 10 "solid" "forestgreen"))
     20
     15
     (ellipse 10 10 "solid" "forestgreen"))
  #(struct:object:image% ...)

                                        *underlay*
(underlay i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Underlays all of its arguments building a single image.

It behaves like overlay, but with the arguments in the reverse order.
That is, the first argument goes underneath of the second argument,
which goes underneath the third argument, etc. The images are all lined
up on their centers.

Examples:

  > (underlay (rectangle 30 60 "solid" "orange")
              (ellipse 60 30 "solid" "purple"))
  #(struct:object:image% ...)
  > (underlay (ellipse 10 60 "solid" "red")
              (ellipse 20 50 "solid" "black")
              (ellipse 30 40 "solid" "red")
              (ellipse 40 30 "solid" "black")
              (ellipse 50 20 "solid" "red")
              (ellipse 60 10 "solid" "black"))
  #(struct:object:image% ...)
  > (underlay (ellipse 10 60 40 "red")
              (ellipse 20 50 40 "red")
              (ellipse 30 40 40 "red")
              (ellipse 40 30 40 "red")
              (ellipse 50 20 40 "red")
              (ellipse 60 10 40 "red"))
  #(struct:object:image% ...)

                                        *underlay/align*
(underlay/align x-place y-place i1 i2 is ...) -> image? ~
  x-place : x-place? ~
  y-place : y-place? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Underlays all of its image arguments, much like the underlay function,
but using x-place and y-place to determine where the images are lined
up. For example, if x-place and y-place are both "middle", then the
images are lined up on their centers.

Examples:

  > (underlay/align "left" "middle"
                    (rectangle 30 60 "solid" "orange")
                    (ellipse 60 30 "solid" "purple"))
  #(struct:object:image% ...)
  > (underlay/align "right" "top"
                    (rectangle 50 50 "solid" "seagreen")
                    (rectangle 40 40 "solid" "silver")
                    (rectangle 30 30 "solid" "seagreen")
                    (rectangle 20 20 "solid" "silver"))
  #(struct:object:image% ...)
  > (underlay/align "left" "middle"
                    (rectangle 50 50 50 "seagreen")
                    (rectangle 40 40 50 "seagreen")
                    (rectangle 30 30 50 "seagreen")
                    (rectangle 20 20 50 "seagreen"))
  #(struct:object:image% ...)

                                        *underlay/offset*
(underlay/offset i1 x y i2) -> image? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Just like underlay, this function lines up its first image argument
underneath the second. Unlike underlay, it moves i2 by x pixels to the
right and y down before underlaying them.

Examples:

  > (underlay/offset (circle 40 "solid" "red")
                    10 10
                    (circle 40 "solid" "blue"))
  #(struct:object:image% ...)
  > (underlay/offset (circle 40 "solid" "gray")
                     0 -10
                     (underlay/offset (circle 10 "solid" "navy")
                                     -30 0
                                     (circle 10 "solid" "navy")))
  #(struct:object:image% ...)

                                        *underlay/align/offset*
(underlay/align/offset x-place      ~
                       y-place     
                       i1          
                       x           
                       y           
                       i2)     -> image?
  x-place : x-place? ~
  y-place : y-place? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Underlays image i1 underneath i2, using x-place and y-place as the
starting points for the combination, and then adjusts i2 by x to the
right and y pixels down.

This function combines the capabilities of underlay/align and
underlay/offset.

Examples:

  > (underlay/align/offset
     "right" "bottom"
     (star-polygon 20 20 3 "solid" "navy")
     10 10
     (circle 30 "solid" "cornflowerblue"))
  #(struct:object:image% ...)
  > (underlay/align/offset
     "right" "bottom"
     (underlay/align/offset
      "left" "bottom"
      (underlay/align/offset
       "right" "top"
       (underlay/align/offset
        "left" "top"
        (rhombus 120 90 "solid" "navy")
        16 16
        (star-polygon 20 11 3 "solid" "cornflowerblue"))
       -16 16
       (star-polygon 20 11 3 "solid" "cornflowerblue"))
      16 -16
      (star-polygon 20 11 3 "solid" "cornflowerblue"))
     -16 -16
     (star-polygon 20 11 3 "solid" "cornflowerblue"))
  #(struct:object:image% ...)

                                        *underlay/xy*
(underlay/xy i1 x y i2) -> image? ~
  i1 : image? ~
  x : real? ~
  y : real? ~
  i2 : image? ~

Constructs an image by underlaying i1 underneath i2. The images are
initially lined up on their upper-left corners and then i2 is shifted to
the right by x pixels to and down by y pixels.

This is the same as (overlay/xy i2 (- x) (- y) i1).

See also underlay/offset and overlay/offset.

Examples:

  > (underlay/xy (rectangle 20 20 "outline" "black")
                 20 0
                 (rectangle 20 20 "outline" "black"))
  #(struct:object:image% ...)
  > (underlay/xy (rectangle 20 20 "solid" "red")
                 10 10
                 (rectangle 20 20 "solid" "black"))
  #(struct:object:image% ...)
  > (underlay/xy (rectangle 20 20 "solid" "red")
                 -10 -10
                 (rectangle 20 20 "solid" "black"))
  #(struct:object:image% ...)
  > (underlay/xy
     (underlay/xy (ellipse 40 40 "solid" "gray")
                  10
                  15
                  (ellipse 10 10 "solid" "forestgreen"))
     20
     15
     (ellipse 10 10 "solid" "forestgreen"))
  #(struct:object:image% ...)

                                        *beside*
(beside i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Constructs an image by placing all of the argument images in a
horizontal row, aligned along their centers.

Example:

  > (beside (ellipse 20 70 "solid" "gray")
            (ellipse 20 50 "solid" "darkgray")
            (ellipse 20 30 "solid" "dimgray")
            (ellipse 20 10 "solid" "black"))
  #(struct:object:image% ...)

                                        *beside/align*
(beside/align y-place i1 i2 is ...) -> image? ~
  y-place : y-place? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Constructs an image by placing all of the argument images in a
horizontal row, lined up as indicated by the y-place argument. For
example, if y-place is "middle", then the images are placed side by side
with their centers lined up with each other.

Examples:

  > (beside/align "bottom"
                  (ellipse 20 70 "solid" "lightsteelblue")
                  (ellipse 20 50 "solid" "mediumslateblue")
                  (ellipse 20 30 "solid" "slateblue")
                  (ellipse 20 10 "solid" "navy"))
  #(struct:object:image% ...)
  > (beside/align "top"
                  (ellipse 20 70 "solid" "mediumorchid")
                  (ellipse 20 50 "solid" "darkorchid")
                  (ellipse 20 30 "solid" "purple")
                  (ellipse 20 10 "solid" "indigo"))
  #(struct:object:image% ...)
  > (beside/align "baseline"
                  (text "ijy" 18 "black")
                  (text "ijy" 24 "black"))
  #(struct:object:image% ...)

                                        *above*
(above i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Constructs an image by placing all of the argument images in a vertical
row, aligned along their centers.

Example:

  > (above (ellipse 70 20 "solid" "gray")
           (ellipse 50 20 "solid" "darkgray")
           (ellipse 30 20 "solid" "dimgray")
           (ellipse 10 20 "solid" "black"))
  #(struct:object:image% ...)

                                        *above/align*
(above/align x-place i1 i2 is ...) -> image? ~
  x-place : x-place? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Constructs an image by placing all of the argument images in a vertical
row, lined up as indicated by the x-place argument. For example, if
x-place is "middle", then the images are placed above each other with
their centers lined up.

Examples:

  > (above/align "right"
                 (ellipse 70 20 "solid" "gold")
                 (ellipse 50 20 "solid" "goldenrod")
                 (ellipse 30 20 "solid" "darkgoldenrod")
                 (ellipse 10 20 "solid" "sienna"))
  #(struct:object:image% ...)
  > (above/align "left"
                 (ellipse 70 20 "solid" "yellowgreen")
                 (ellipse 50 20 "solid" "olivedrab")
                 (ellipse 30 20 "solid" "darkolivegreen")
                 (ellipse 10 20 "solid" "darkgreen"))
  #(struct:object:image% ...)

3.4. Placing Images & Scenes

Placing images into scenes is particularly useful when building worlds
and universes using 2htdp/universe.

                                        *empty-scene*
(empty-scene width height) -> image? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
(empty-scene width height color) -> image?
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  color : image-color? ~

Creates an empty scene, i.e., a white rectangle with a black outline.

Example:

  > (empty-scene 160 90)
  #(struct:object:image% ...)

The three-argument version creates a rectangle of the specified color
with a black outline.

                                        *place-image*
(place-image image x y scene) -> image? ~
  image : image? ~
  x : real? ~
  y : real? ~
  scene : image? ~

Places image onto scene with its center at the coordinates (x,y) and
crops the resulting image so that it has the same size as scene. The
coordinates are relative to the top-left of scene.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (place-image
     (triangle 32 "solid" "red")
     24 24
     (rectangle 48 48 "solid" "gray"))
  #(struct:object:image% ...)
  > (place-image
     (triangle 64 "solid" "red")
     24 24
     (rectangle 48 48 "solid" "gray"))
  #(struct:object:image% ...)
  > (place-image
     (circle 4 "solid" "white")
     18 20
     (place-image
      (circle 4 "solid" "white")
      0 6
      (place-image
       (circle 4 "solid" "white")
       14 2
       (place-image
        (circle 4 "solid" "white")
        8 14
        (rectangle 24 24 "solid" "goldenrod")))))
  #(struct:object:image% ...)

                                        *place-image/align*
(place-image/align image        ~
                   x           
                   y           
                   x-place     
                   y-place     
                   scene)  -> image?
  image : image? ~
  x : real? ~
  y : real? ~
  x-place : x-place? ~
  y-place : y-place? ~
  scene : image? ~

Like place-image, but uses image’s x-place and y-place to anchor the
image. Also, like place-image, place-image/align crops the resulting
image so that it has the same size as scene.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (place-image/align (triangle 48 "solid" "yellowgreen")
                       64 64 "right" "bottom"
                       (rectangle 64 64 "solid" "mediumgoldenrod"))
  #(struct:object:image% ...)
  > (beside
     (place-image/align (circle 8 "solid" "tomato")
                        0 0 "center" "center"
                        (rectangle 32 32 "outline" "black"))
     (place-image/align (circle 8 "solid" "tomato")
                        8 8 "center" "center"
                        (rectangle 32 32 "outline" "black"))
     (place-image/align (circle 8 "solid" "tomato")
                        16 16 "center" "center"
                        (rectangle 32 32 "outline" "black"))
     (place-image/align (circle 8 "solid" "tomato")
                        24 24 "center" "center"
                        (rectangle 32 32 "outline" "black"))
     (place-image/align (circle 8 "solid" "tomato")
                        32 32 "center" "center"
                        (rectangle 32 32 "outline" "black")))
  #(struct:object:image% ...)

                                        *place-images*
(place-images images posns scene) -> image? ~
  images : (listof image?) ~
  posns : (listof posn?) ~
  scene : image? ~

Places each of images into scene like                place-image would,
using the coordinates                in posns as the x
and y arguments to place-image.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Example:

  > (place-images
     (list (circle 4 "solid" "white")
           (circle 4 "solid" "white")
           (circle 4 "solid" "white")
           (circle 4 "solid" "white"))
     (list (make-posn 18 20)
           (make-posn 0 6)
           (make-posn 14 2)
           (make-posn 8 14))
     (rectangle 24 24 "solid" "goldenrod"))
  #(struct:object:image% ...)

                                        *place-images/align*
(place-images/align images       ~
                    posns       
                    x-place     
                    y-place     
                    scene)  -> image?
  images : (listof image?) ~
  posns : (listof posn?) ~
  x-place : x-place? ~
  y-place : y-place? ~
  scene : image? ~

Like place-images, except that it places the images      with respect to
x-place and y-place.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Example:

  > (place-images/align
     (list (triangle 48 "solid" "yellowgreen")
           (triangle 48 "solid" "yellowgreen")
           (triangle 48 "solid" "yellowgreen")
           (triangle 48 "solid" "yellowgreen"))
     (list (make-posn 64 64)
           (make-posn 64 48)
           (make-posn 64 32)
           (make-posn 64 16))
     "right" "bottom"
     (rectangle 64 64 "solid" "mediumgoldenrod"))
  #(struct:object:image% ...)

                                        *scene+line*
(scene+line scene x1 y1 x2 y2 pen-or-color) -> image? ~
  scene : image? ~
  x1 : real? ~
  y1 : real? ~
  x2 : real? ~
  y2 : real? ~
  pen-or-color : (or/c pen? image-color?) ~

Adds a line to the image scene, starting from the point (x1,y1) and
going to the point (x2,y2); unlike add-line, this function crops the
resulting image to the size of scene.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (scene+line (ellipse 40 40 "outline" "maroon")
                0 40 40 0 "maroon")
  #(struct:object:image% ...)
  > (scene+line (rectangle 40 40 "solid" "gray")
                -10 50 50 -10 "maroon")
  #(struct:object:image% ...)
  > (scene+line
     (rectangle 100 100 "solid" "darkolivegreen")
     25 25 100 100
     (make-pen "goldenrod" 30 "solid" "round" "round"))
  #(struct:object:image% ...)

                                        *scene+curve*
(scene+curve scene       ~
             x1         
             y1         
             angle1     
             pull1      
             x2         
             y2         
             angle2     
             pull2      
             color) -> image?
  scene : image? ~
  x1 : real? ~
  y1 : real? ~
  angle1 : angle? ~
  pull1 : real? ~
  x2 : real? ~
  y2 : real? ~
  angle2 : angle? ~
  pull2 : real? ~
  color : (or/c pen? image-color?) ~

Adds a curve to scene, starting at the point (x1,y1), and ending at the
point (x2,y2).

The angle1 and angle2 arguments specify the angle that the curve has as
it leaves the initial point and as it reaches the final point,
respectively.

The pull1 and pull2 arguments control how long the curve tries to stay
with that angle. Larger numbers mean that the curve stays with the angle
longer.

Unlike add-curve, this function crops the curve, only showing the parts
that fit onto scene.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (scene+curve (rectangle 100 100 "solid" "black")
                 20 20 0 1/3
                 80 80 0 1/3
                 "white")
  #(struct:object:image% ...)
  > (scene+curve (rectangle 100 100 "solid" "black")
                 20 20 0 1
                 80 80 0 1
                 "white")
  #(struct:object:image% ...)
  > (scene+curve
     (add-curve
      (rectangle 40 100 "solid" "black")
      20 10 180 1/2
      20 90 180 1/2
      "white")
     20 10 0 1/2
     20 90 0 1/2
     "white")
  #(struct:object:image% ...)
  > (scene+curve (rectangle 100 100 "solid" "black")
                 -20 -20 0 1
                 120 120 0 1
                 "red")
  #(struct:object:image% ...)

3.5. Rotating, Scaling, Flipping, Cropping, and Framing Images

                                        *rotate*
(rotate angle image) -> image? ~
  angle : angle? ~
  image : image? ~

Rotates image by angle degrees in a counter-clockwise direction.

Examples:

  > (rotate 45 (ellipse 60 20 "solid" "olivedrab"))
  #(struct:object:image% ...)
  > (rotate 5 (rectangle 50 50 "outline" "black"))
  #(struct:object:image% ...)
  > (rotate 45
            (beside/align
             "center"
             (rectangle 40 20 "solid" "darkseagreen")
             (rectangle 20 100 "solid" "darkseagreen")))
  #(struct:object:image% ...)

See also Rotating and Image Centers.

                                        *scale*
(scale factor image) -> image? ~
  factor : (and/c real? positive?) ~
  image : image? ~

Scales image by factor.

The pen sizes are also scaled and thus draw thicker (or thinner) lines
than the original image, unless the pen was size 0. That pen size is
treated specially to mean “the smallest available line” and thus it
always draws a one-pixel wide line; this is also the case for 'outline
and "outline" shapes that are drawn with an image-color? instead of a
pen.

Examples:

  > (scale 2 (ellipse 20 30 "solid" "blue"))
  #(struct:object:image% ...)
  > (ellipse 40 60 "solid" "blue")
  #(struct:object:image% ...)

                                        *scale/xy*
(scale/xy x-factor y-factor image) -> image? ~
  x-factor : (and/c real? positive?) ~
  y-factor : (and/c real? positive?) ~
  image : image? ~

Scales image by x-factor horizontally and by y-factor vertically.

Examples:

  > (scale/xy 3
              2
              (ellipse 20 30 "solid" "blue"))
  #(struct:object:image% ...)
  > (ellipse 60 60 "solid" "blue")
  #(struct:object:image% ...)

                                        *flip-horizontal*
(flip-horizontal image) -> image? ~
  image : image? ~

Flips image left to right.

Flipping images with text is not supported (so passing flip-horizontal
an image       that contains a text or text/font image inside somewhere
signals an error).

Example:

  > (beside
     (rotate 30 (square 50 "solid" "red"))
     (flip-horizontal
      (rotate 30 (square 50 "solid" "blue"))))
  #(struct:object:image% ...)

                                        *flip-vertical*
(flip-vertical image) -> image? ~
  image : image? ~

Flips image top to bottom.

Flipping images with text is not supported (so passing flip-vertical an
image       that contains a text or text/font image inside somewhere
signals an error).

Example:

  > (above
     (star 40 "solid" "firebrick")
     (scale/xy 1 1/2 (flip-vertical (star 40 "solid" "gray"))))
  #(struct:object:image% ...)

                                        *crop*
(crop x y width height image) -> image? ~
  x : real? ~
  y : real? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  image : image? ~

Crops image to the rectangle with the upper left at the point (x,y) and
with width and height.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (crop 0 0 40 40 (circle 40 "solid" "chocolate"))
  #(struct:object:image% ...)
  > (crop 40 60 40 60 (ellipse 80 120 "solid" "dodgerblue"))
  #(struct:object:image% ...)
  > (above
     (beside (crop 40 40 40 40 (circle 40 "solid" "palevioletred"))
             (crop 0 40 40 40 (circle 40 "solid" "lightcoral")))
     (beside (crop 40 0 40 40 (circle 40 "solid" "lightcoral"))
             (crop 0 0 40 40 (circle 40 "solid" "palevioletred"))))
  #(struct:object:image% ...)

                                        *crop/align*
(crop/align x-place      ~
            y-place     
            width       
            height      
            image)  -> image?
  x-place : x-place? ~
  y-place : y-place? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  image : image? ~

Crops image to a rectangle whose size is width and height       and is
positioned based on x-place and y-place.

Some shapes (notably those with 'outline or "outline" as the mode
argument) draw outside of their bounding boxes and thus cropping them
may remove part of them (often the lower-left and lower-right edges).
See The Nitty Gritty of Pixels, Pens, and Lines (in the Image Guide) for
a more careful discussion of this issue.

Examples:

  > (crop/align "left" "top" 40 40 (circle 40 "solid" "chocolate"))
  #(struct:object:image% ...)
  >
  (crop/align "right" "bottom" 40 60 (ellipse 80 120 "solid" "dodgerblue"))
  #(struct:object:image% ...)
  >
  (crop/align "center" "center" 50 30 (circle 25 "solid" "mediumslateblue"))
  #(struct:object:image% ...)
  > (above
     (beside (crop/align "right" "bottom" 40 40 (circle 40 "solid" "palevioletred"))
             (crop/align "left" "bottom" 40 40 (circle 40 "solid" "lightcoral")))
     (beside (crop/align "right" "top" 40 40 (circle 40 "solid" "lightcoral"))
             (crop/align "left" "top" 40 40 (circle 40 "solid" "palevioletred"))))
  #(struct:object:image% ...)

Added in version 1.1 of package htdp-lib.

                                        *frame*
(frame image) -> image? ~
  image : image? ~

Returns an image just like image, except with a black, single pixel
frame drawn around the bounding box of the image.

Example:

  > (frame (ellipse 40 40 "solid" "gray"))
  #(struct:object:image% ...)

Generally speaking, this function is useful to debug image
constructions, i.e., to see where certain sub-images appear within some
larger image.

Example:

  > (beside
     (ellipse 20 70 "solid" "lightsteelblue")
     (frame (ellipse 20 50 "solid" "mediumslateblue"))
     (ellipse 20 30 "solid" "slateblue")
     (ellipse 20 10 "solid" "navy"))
  #(struct:object:image% ...)

                                        *color-frame*
(color-frame color image) -> image? ~
  color : (or/c pen? image-color?) ~
  image : image? ~

Like frame, except with the given color.

Added in version 1.1 of package htdp-lib.

3.6. Bitmaps

DrRacket’s Insert Image ... menu item allows you to insert images into
your program text, and those images are treated as images for this
library.

Unlike all of the other images in this library, those images (and the
other images created by functions in this section of the documentation)
are represented as bitmaps, i.e., an array of colors (that can be quite
large in some cases). This means that scaling and rotating them loses
fidelity in the image and is significantly more expensive than with the
other shapes.

See also the 2htdp/planetcute library.

                                        *bitmap*
(bitmap bitmap-spec) ~
 
bitmap-spec = rel-string
            | id

Loads the bitmap specified by bitmap-spec. If bitmap-spec is a string,
it is treated as a relative path. If it is an identifier, it is treated
like a require spec and used to refer to a file in a collection.

Examples:

  > (bitmap icons/stop-16x16.png)
  #(struct:object:image% ...)
  > (bitmap icons/b-run.png)
  #(struct:object:image% ...)

                                        *bitmap/url*
(bitmap/url url) -> image? ~
  url : string? ~

Goes out on the web and downloads the image at url.

Downloading the image happens each time this function is called, so you
may find it simpler to download the image once with a browser and then
paste it into your program or download it and use bitmap.

                                        *bitmap/file*
(bitmap/file ps) -> image? ~
  ps : path-string? ~

Loads the image from ps.

If ps is a relative path, the file is relative to the current directory.
(When running in DrRacket, the current directory is set to the place
where the definitions window is saved, but in general this can be an
arbitrary directory.)

                                        *image->color-list*
(image->color-list image) -> (listof color?) ~
  image : image? ~

Returns a list of colors that correspond to the colors in the image,
reading from left to right, top to bottom.

The list of colors is obtained by drawing the image on a white
background and then reading off the colors of the pixels that were
drawn.

Examples:

  > (image->color-list (rectangle 2 2 "solid" "black"))
  (list (color 0 0 0 255) (color 0 0 0 255) (color 0 0 0 255) (color 0 0 0
  255))
  > (image->color-list
     (above (beside (rectangle 1 1 "solid" (make-color 1 1 1))
                    (rectangle 1 1 "solid" (make-color 2 2 2)))
            (beside (rectangle 1 1 "solid" (make-color 3 3 3))
                    (rectangle 1 1 "solid" (make-color 4 4 4)))))
  (list (color 1 1 1 255) (color 2 2 2 255) (color 3 3 3 255) (color 4 4 4
  255))

                                        *color-list->bitmap*
(color-list->bitmap colors width height) -> image? ~
  colors : (listof image-color?) ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~

Constructs a bitmap from the given colors, with the given width and
height.

Example:

  > (scale
     40
     (color-list->bitmap
      (list "red" "green" "blue")
      3 1))
  #(struct:object:image% ...)

                                        *freeze*
(freeze image) -> image? ~
  image : image? ~
(freeze width height image) -> image?
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  image : image? ~
(freeze x y width height image) -> image?
  x : real? ~
  y : real? ~
  width : (and/c real? (not/c negative?)) ~
  height : (and/c real? (not/c negative?)) ~
  image : image? ~

Freezing an image internally builds a bitmap, crops the image, draws the
cropped image into the bitmap and then uses the bitmap to draw that
image afterwards. Typically this is used as a performance hint. When an
image both contains many sub-images and is going to be drawn many times
(but not scaled or rotated), using freeze on the image can substantially
improve performance without changing how the image draws (assuming it
draws only inside its bounding box; see also The Nitty Gritty of Pixels,
Pens, and Lines).

If freeze is passed only the image argument, then it crops the image to
its bounding box. If it is given three arguments, the two numbers are
used as the width and height and the five argument version fully
specifies where to crop the image.

3.7. Image Properties

                                        *image-width*
(image-width i) -> (and/c integer? (not/c negative?) exact?) ~
  i : image? ~

Returns the width of i.

Examples:

  > (image-width (ellipse 30 40 "solid" "orange"))
  30
  > (image-width (circle 30 "solid" "orange"))
  60
  > (image-width (beside (circle 20 "solid" "orange")
                         (circle 20 "solid" "purple")))
  80
  > (image-width (rectangle 0 10 "solid" "purple"))
  0

                                        *image-height*
(image-height i) -> (and/c integer? (not/c negative?) exact?) ~
  i : image? ~

Returns the height of i.

Examples:

  > (image-height (ellipse 30 40 "solid" "orange"))
  40
  > (image-height (circle 30 "solid" "orange"))
  60
  > (image-height (overlay (circle 20 "solid" "orange")
                           (circle 30 "solid" "purple")))
  60
  > (image-height (rectangle 10 0 "solid" "purple"))
  0

                                        *image-baseline*
(image-baseline i) -> (and/c integer? (not/c negative?) exact?) ~
  i : image? ~

Returns the distance from the top of the image to its baseline. The
baseline of an image is the place where the bottoms any letters line up,
but without counting the descenders, e.g. the tail on “y” or “g” or “j”.

Unless the image was constructed with text, text/font or, in some cases,
crop, this will be the same as its height.

Examples:

  > (image-baseline (text "Hello" 24 "black"))
  18
  > (image-height (text "Hello" 24 "black"))
  25
  > (image-baseline (rectangle 100 100 "solid" "black"))
  100
  > (image-height (rectangle 100 100 "solid" "black"))
  100

A cropped image’s baseline is the same as the image’s baseline, if the
cropping stays within the original image’s bounding box. But if the
cropping actually enlarges the image, then the baseline can end up being
smaller.

Examples:

  > (image-height (rectangle 20 20 "solid" "black"))
  20
  > (image-baseline (rectangle 20 20 "solid" "black"))
  20
  > (image-height (crop 10 10 5 5 (rectangle 20 20 "solid" "black")))
  5
  > (image-baseline (crop 10 10 5 5 (rectangle 20 20 "solid" "black")))
  5
  > (image-height (crop 10 10 30 30 (rectangle 20 20 "solid" "black")))
  30
  > (image-baseline (crop 10 10 30 30 (rectangle 20 20 "solid" "black")))
  20

3.8. Image Predicates

This section lists predicates for the basic structures provided by the
image library.

                                        *image?*
(image? x) -> boolean? ~
  x : any/c ~

Determines if x is an image. Images are returned by functions like
ellipse and rectangle and accepted by functions like overlay and beside.

Additionally, images inserted into a DrRacket window are treated as
bitmap images, as are instances of image-snip% and bitmap%.

                                        *mode?*
(mode? x) -> boolean? ~
  x : any/c ~

Determines if x is a mode suitable for constructing images.

It can be one of 'solid, "solid", 'outline, or "outline", indicating if
the shape is filled in or not.

It can also be an integer between 0 and 255 (inclusive) indicating the
transparency of the image. The integer 255 is fully opaque, and is the
same as "solid" (or 'solid). The integer 0 means fully transparent.

                                        *image-color?*
(image-color? x) -> boolean? ~
  x : any/c ~

Determines if x represents a color. Strings, symbols,  and color structs
are allowed as colors.

For example,  "magenta", "black", 'orange, and 'purple  are allowed.
Colors are not case-sensitive, so  "Magenta", "Black", 'Orange, and
'Purple  are also allowed, and are the same colors as in the previous
sentence.  Additionally, spaces are not considered, so "light orange" is
the same  color as "lightorange".

The complete list of colors is the same as the colors allowed in
color-database<%>, plus the color "transparent", a transparent  color,
as well as the following variants of the colors:  Brown, Cyan,
Goldenrod, Gray, Green, Orange, Pink, Purple, Red, Turquoise, and
Yellow.

      Light Brown
      Medium Brown
      Dark Brown
      Medium Cyan
      Light Goldenrod
      Medium Gray
      Medium Green
      Light Orange
      Medium Orange
      Medium Pink
      Dark Pink
      Light Purple
      Dark Purple
      Light Red
      Medium Red
      Light Turquoise
      Medium Yellow
      Dark Yellow

                                        *struct*
(struct color (red green blue alpha) ~
    #:extra-constructor-name make-color) ~
  red : (integer-in 0 255) ~
  green : (integer-in 0 255) ~
  blue : (integer-in 0 255) ~
  alpha : (integer-in 0 255) ~

The color struct defines a color with red,     green, blue, and alpha
components     that range from 0 to 255.

The red, green, and blue fields     combine to make a color, with the
higher values meaning more of the given color.     For example,
(make-color 255 0 0) makes a     bright red color and (make-color 255 0
255) makes a bright purple.

The alpha field controls the transparency of the color. A value of 255
means     that the color is opaque and 0 means the color is fully
transparent.

The constructor, make-color, also accepts only three arguments, in which
case the three arguments are used for the red, green, and blue fields,
and the alpha field defaults to 255.

                                        *struct*
(struct pulled-point (lpull langle x y rpull rangle) ~
    #:extra-constructor-name make-pulled-point) ~
  lpull : real? ~
  langle : angle? ~
  x : real? ~
  y : real? ~
  rpull : real? ~
  rangle : angle? ~

The pulled-point struct defines a point with     x and y coordinates,
but also with     two angles (langle and rangle) and     two pulls
(lpull and rpull).

These points are used with the polygon function     and control how the
edges can be curved.

The first two pull and angle arguments indicate     how an edge coming
into this point should be curved.     The angle argument indicates the
angle as the edge     reaches (x,y) and a larger pull argument     means
that the edge should hold the angle longer.     The last two are the
same, except they apply to     the edge leaving the point.

Added in version 1.3 of package htdp-lib.

                                        *y-place?*
(y-place? x) -> boolean? ~
  x : any/c ~

Determines if x is a placement option   for the vertical direction. It
can be one   of "top", 'top, "bottom", 'bottom, "middle", 'middle,
"center", 'center, "baseline", 'baseline, "pinhole", or 'pinhole.

Using "pinhole" or 'pinhole is only allowed when all of the image
arguments have pinholes.

See also image-baseline for more discussion of baselines.

                                        *x-place?*
(x-place? x) -> boolean? ~
  x : any/c ~

Determines if x is a placement option for the horizontal direction. It
can be one of "left", 'left, "right", 'right, "middle", 'middle,
"center", 'center, "pinhole", or 'pinhole.

Using "pinhole" or 'pinhole is only allowed when all of the image
arguments have pinholes.

                                        *angle?*
(angle? x) -> boolean? ~
  x : any/c ~

Determines if x is an angle, namely a real number (except not +inf.0,
-inf.0 or +nan.0).

Angles are in degrees, so 0 is the same as 360, 90 means rotating one
quarter of the way around a circle, and 180 is halfway around a circle.

                                        *side-count?*
(side-count? x) -> boolean? ~
  x : any/c ~

Determines if x is an integer greater than or equal to 3.

                                        *step-count?*
(step-count? x) -> boolean? ~
  x : any/c ~

Determines if x is an integer greater than or equal to 1.

                                        *real-valued-posn?*
(real-valued-posn? x) -> boolean? ~
  x : any/c ~

Determines if x is a posn whose x and y fields are both real? numbers.

                                        *struct*
(struct pen (color width style cap join) ~
    #:extra-constructor-name make-pen) ~
  color : image-color? ~
  width : (and/c real? (<=/c 0 255)) ~
  style : pen-style? ~
  cap : pen-cap? ~
  join : pen-join? ~

The pen struct specifies how the drawing library draws lines.

A good default for style is "solid", and     good default values for the
cap and join fields     are "round".

Using 0 as a width is special; it means to always draw the     smallest
possible, but visible, pen. This means that the pen will always     be
one pixel in size, no matter how the image is scaled.

The cap determines how the ends of a curve is drawn.

The join determines how two lines are joined.

Examples:

  > (line 400 100 (pen "red" 10 "long-dash" "round" "bevel"))
  #(struct:object:image% ...)
  > (line 400 100 (pen "red" 10 "short-dash" "round" "bevel"))
  #(struct:object:image% ...)
  > (line 400 100 (pen "red" 10 "long-dash" "butt" "bevel"))
  #(struct:object:image% ...)
  > (line 400 100 (pen "red" 10 "dot-dash" "butt" "bevel"))
  #(struct:object:image% ...)
  > (line 400 100 (pen "red" 30 "dot-dash" "butt" "bevel"))
  #(struct:object:image% ...)

                                        *pen-style?*
(pen-style? x) -> boolean? ~
  x : any/c ~

Determines if x is a valid pen style. It can be one of "solid", 'solid,
"dot", 'dot, "long-dash", 'long-dash, "short-dash", 'short-dash,
"dot-dash", or 'dot-dash.

                                        *pen-cap?*
(pen-cap? x) -> boolean? ~
  x : any/c ~

Determines if x is a valid pen cap. It can be one of "round", 'round,
"projecting", 'projecting, "butt", or 'butt.

                                        *pen-join?*
(pen-join? x) -> boolean? ~
  x : any/c ~

Determines if x is a valid pen join. It can be one of "round", 'round,
"bevel", 'bevel, "miter", or 'miter.

3.9. Equality Testing of Images

Two images are equal? if they draw exactly the same way at their current
size (not necessarily at all sizes) and, if there are pinholes, the
pinholes are in the same place.

This can lead to some counter-intuitive results. For example, two
completely different shapes that are the same size and are drawn with
the transparent color are equal:

Example:

  > (equal? (circle 30 "solid" "transparent")
            (square 60 "solid" "transparent"))
  #t

See also The Nitty Gritty of Alpha Blending.

3.10. Pinholes

A pinhole is an optional property of an image that identifies a point
somewhere in the image. The pinhole can then be used to facilitate
overlaying images by lining them up on their pinholes.

When an image has a pinhole, the pinhole is drawn with crosshairs on the
image. The crosshairs are drawn with two one-pixel wide black lines (one
horizontal and one vertical) and two one-pixel wide white lines, where
the black lines is drawn .5 pixels to the left and above the pinhole,
and the white lines are drawn .5 pixels to the right and below the
pinhole. Accordingly, when the pixel is on an integral coordinate, then
black and white lines all take up a single pixel and in the center of
their intersections is the actual pinholes. See The Nitty Gritty of
Pixels, Pens, and Lines for more details about pixels.

When images are overlay’d, underlay’d (or the variants of those
functions), placed beside, or above each other, the pinhole of the
resulting image is the pinhole of the first image argument passed to the
combining operation. When images are combined with place-image (or the
variants of place-image), then the scene argument’s pinhole is
preserved.

                                        *center-pinhole*
(center-pinhole image) -> image? ~
  image : image? ~

Creates a pinhole in image at its center.

Examples:

  > (center-pinhole (rectangle 40 20 "solid" "red"))
  #(struct:object:image% ...)
  > (rotate 30 (center-pinhole (rectangle 40 20 "solid" "orange")))
  #(struct:object:image% ...)

                                        *put-pinhole*
(put-pinhole x y image) -> image? ~
  x : integer? ~
  y : integer? ~
  image : image? ~

Creates a pinhole in image at the point (x,y).

Example:

  > (put-pinhole 2 18 (rectangle 40 20 "solid" "forestgreen"))
  #(struct:object:image% ...)

                                        *pinhole-x*
(pinhole-x image) -> (or/c integer? #f) ~
  image : image? ~

Returns the x coordinate of image’s pinhole.

Example:

  > (pinhole-x (center-pinhole (rectangle 10 10 "solid" "red")))
  5

                                        *pinhole-y*
(pinhole-y image) -> (or/c integer? #f) ~
  image : image? ~

Returns the y coordinate of image’s pinhole.

Example:

  > (pinhole-y (center-pinhole (rectangle 10 10 "solid" "red")))
  5

                                        *clear-pinhole*
(clear-pinhole image) -> image? ~
  image : image? ~

Removes a pinhole from image (if the image has a pinhole).

                                        *overlay/pinhole*
(overlay/pinhole i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Overlays all of the image arguments on their pinholes. If any of the
arguments do not have pinholes, then the center of the image is used
instead.

Examples:

  > (overlay/pinhole
     (put-pinhole 25 10 (ellipse 100 50 "solid" "red"))
     (put-pinhole 75 40 (ellipse 100 50 "solid" "blue")))
  #(struct:object:image% ...)
  > (let ([petal (put-pinhole
                  20 20
                  (ellipse 100 40 "solid" "purple"))])
      (clear-pinhole
       (overlay/pinhole
        (circle 30 "solid" "yellow")
        (rotate (* 60 0) petal)
        (rotate (* 60 1) petal)
        (rotate (* 60 2) petal)
        (rotate (* 60 3) petal)
        (rotate (* 60 4) petal)
        (rotate (* 60 5) petal))))
  #(struct:object:image% ...)

                                        *underlay/pinhole*
(underlay/pinhole i1 i2 is ...) -> image? ~
  i1 : image? ~
  i2 : image? ~
  is : image? ~

Underlays all of the image arguments on their pinholes. If any of the
arguments do not have pinholes, then the center of the image is used
instead.

Examples:

  > (underlay/pinhole
     (put-pinhole 25 10 (ellipse 100 50 "solid" "red"))
     (put-pinhole 75 40 (ellipse 100 50 "solid" "blue")))
  #(struct:object:image% ...)
  > (let* ([t (triangle 40 "solid" "orange")]
           [w (image-width t)]
           [h (image-height t)])
      (clear-pinhole
       (overlay/pinhole
        (put-pinhole (/ w 2) 0 t)
        (put-pinhole w h t)
        (put-pinhole 0 h t))))
  #(struct:object:image% ...)

3.11. Exporting Images to Disk

In order to use an image as an input to another program (e.g., Photoshop
or a web browser), it is necessary to represent it in a format that
these programs can understand.

The save-image function provides this functionality, writing an image to
disk using the PNG format. Since this format represents an image using a
set of pixel values, an image written to disk generally contains less
information than the image that was written, and cannot be scaled or
manipulated as cleanly (by any image program).

The save-svg-image function writes an SVG file format representation of
the file to the disk that, unlike save-image produces an image that can
still be scaled arbitrarily look as good as scaling the image directly
via scale.

                                        *save-image*
(save-image image filename [width height]) -> boolean? ~
  image : image? ~
  filename : path-string? ~
  width : (and/c real? (not/c negative?)) = (image-width image) ~
  height : (and/c real? (not/c negative?)) ~
         = (image-height image)

Writes an image to the path specified by filename, using the PNG format.

The last two arguments are optional. If present, they determine the
width and height of the save image file. If absent, the width and height
of the image is used.

                                        *save-svg-image*
(save-svg-image image filename [width height]) -> void? ~
  image : image? ~
  filename : path-string? ~
  width : (and/c real? (not/c negative?)) = (image-width image) ~
  height : (and/c real? (not/c negative?)) ~
         = (image-height image)

Writes an image to the path specified by filename, using the SVG format.

The last two arguments are optional. If present, they determine the
width and height of the save image file. If absent, the width and height
of the image is used.

4. Worlds and the Universe: "universe.rkt"

Matthias Felleisen

 (require 2htdp/universe) package: htdp-lib ~

The universe.rkt teachpack implements and provides the functionality
for creating interactive, graphical programs that consist of plain
mathematical functions. We refer to such programs as world  programs. In
addition, world programs can also become a part of a  universe, a
collection of worlds that can exchange messages.

The purpose of this documentation is to give experienced Racketeers and
HtDP  teachers a concise overview for using the library. The first part
of the  documentation focuses on world programs. Section  A First Sample
World presents an illustration of how to design such  programs for a
simple domain; it is suited for a novice who knows how to  design
conditional functions for enumerations, intervals, and unions. The
second half of the documentation focuses on "universe" programs: how it
is  managed via a server, how world programs register with the server,
etc. The last two sections show how to design a simple universe of two
communicating worlds.

Note: For a quick and educational introduction to just worlds, see  How
to Design Programs, Second Edition: Prologue. As of August 2008, we also
have a series of projects available as a small booklet on  How to Design
Worlds.

4.1. Background

The universe teachpack assumes working knowledge of the basic image
manipulation operations, either htdp/image or 2htdp/image. As far as
this extended reference is concerned, the major difference between the
two image teachpacks is the assumption that

  htdp/image programs render their state as scenes, i.e., images that
  satisfy the scene? predicate.

Recall that htdp/image defines a scene to be an image whose pinhole is
at (0,0). If your program uses the operations of 2htdp/image, all images
are also scenes.

While the operations of this teachpack work with both image teachpacks,
we hope to eliminate htdp/image in the not-too-distant future. All
example programs are already written using 2htdp/image operations. We
urge programmers to use 2htdp/image when they design new “world” and
“universe” programs and to rewrite their existing htdp/image programs to
use 2htdp/image.

4.2. Simple Simulations

The simplest kind of animated world program is a time-based  simulation,
which is a series of images.  The programmer’s task is to  supply a
function that creates an image for each natural number. Handing  this
function to the teachpack displays the simulation.

                                        *animate*
(animate create-image) -> natural-number/c ~
  create-image : (-> natural-number/c scene?) ~

See Background for scene?.  opens a canvas and starts a clock that ticks
28 times per second.  Every  time the clock ticks, DrRacket applies
create-image to the  number of ticks passed since this function call.
The results of these  function calls are displayed in the canvas. The
simulation runs until you  click the Stop button in DrRacket or close
the window. At that  point, animate returns the number of ticks that
have  passed.

Example:

  (define (create-UFO-scene height)
    (underlay/xy (rectangle 100 100 "solid" "white") 50 height UFO))
   
  (define UFO
    (underlay/align "center"
                    "center"
                    (circle 10 "solid" "green")
                    (rectangle 40 4 "solid" "green")))
   
  (animate create-UFO-scene)

                                        *run-simulation*
(run-simulation create-image) -> natural-number/c ~
  create-image : (-> natural-number/c scene?) ~

See Background for scene?.  animate was originally called
run-simulation, and this  binding is retained for backwards
compatibility

                                        *run-movie*
(run-movie r m) -> [Listof image?] ~
  r : (and/c real? positive?) ~
  m : [Listof image?] ~

run-movie displays the list of images m, spending r seconds per image.
When the animation is stopped, a list of the remaining, undisplayed
images are returned.

4.3. Interactions

The step from simulations to interactive programs is relatively  small.
Roughly speaking, a simulation designates one function,  create-image,
as a handler for one kind of event: clock ticks.  In  addition to clock
ticks, world programs can also deal with two  other kinds of events:
keyboard events and mouse events. A keyboard event  is triggered when a
computer user presses a key on the  keyboard. Similarly, a mouse event
is the  movement of the mouse, a click  on a mouse button, the crossing
of a boundary by a mouse movement, etc.

Your program may deal with such events via the designation of  handler
functions.  Specifically, the teachpack provides for the  installation
of four event handlers: on-tick, on-key,  on-mouse, and on-pad. In
addition, a world  program must specify a  render function, which is
called every time your program should  visualize the current world, and
a done predicate, which is used  to determine when the world program
should shut down.

Each handler function consumes the current state of the world and
optionally a data representation of the event. It produces a new state
of  the world.

The following picture provides an intuitive overview of the workings of
a  world program in the form of a state transition diagram.



The big-bang form installs World_0 as the initial WorldState.  The
handlers tock, react, and click transform  one world into another one;
each time an event is handled, done is  used to check whether the world
is final, in which case the program is  shut down; and finally, render
renders each world as an image, which  is then displayed on an external
canvas.

WorldState : any/c

The design of a world program demands that you come up with a data
definition of all possible states. We use WorldState to refer to  this
collection of data, using a capital W to distinguish it from the
program.  In principle, there are no constraints on this data
definition though it mustn’t be an instance of the Package  structure
(see below). You can even keep it implicit, even if this  violates the
Design Recipe.

                                        *big-bang*
(big-bang state-expr clause ...) ~
 
clause = (on-tick tick-expr)
       | (on-tick tick-expr rate-expr)
       | (on-tick tick-expr rate-expr limit-expr)
       | (on-key key-expr)
       | (on-pad pad-expr)
       | (on-release release-expr)
       | (on-mouse mouse-expr)
       | (to-draw draw-expr)
       | (to-draw draw-expr width-expr height-expr)
       | (stop-when stop-expr)
       | (stop-when stop-expr last-scene-expr)
       | (check-with world?-expr)
       | (record? r-expr)
       | (close-on-stop cos-expr)
       | (display-mode d-expr)
       | (state expr)
       | (on-receive rec-expr)
       | (register IP-expr)
       | (port Port-expr)
       | (name name-expr)

starts a world program in the initial state specified with state-expr,
which must of course evaluate to an element of WorldState.  Its behavior
is specified via the handler functions designated in the optional
clauses, especially how the world program deals with clock ticks, with
key events, with mouse events, and eventually with messages from the
universe; how it renders itself as an image; when the program must shut
down; where to register the world with a universe; and whether to record
the stream of events. A world specification may not contain more than
one on-tick, to-draw, or register clause. A big-bang expression returns
the last world when the stop condition is satisfied (see below) or when
the programmer clicks on the Stop button or closes the canvas.

The only mandatory clause of a big-bang description is to-draw (or
on-draw for backwards compatibility):

* (to-draw render-expr)
   
    render-expr : (-> WorldState scene?) ~

  See Background for scene?.  tells DrRacket to call the function
  render-expr whenever the  canvas must be drawn. The external canvas is
  usually re-drawn after DrRacket has  dealt with an event. Its size is
  determined by the size of the first  generated image.

  (to-draw render-expr width-expr height-expr)
   
    render-expr : (-> WorldState scene?) ~
    width-expr : natural-number/c ~
    height-expr : natural-number/c ~

  See Background for scene?.  tells DrRacket to use a width-expr by
  height-expr  canvas instead of one determined by the first generated
  image.

  For compatibility reasons, the teachpack also supports the keyword
  on-draw in lieu of to-draw but the latter is preferred now.

All remaining clauses are optional. To introduce them, we need one more
data definition:

HandlerResult : is a synonym for WorldState until The World is not
Enough

* (on-tick tick-expr)
   
    tick-expr : (-> WorldState HandlerResult) ~

  tells DrRacket to call the tick-expr function on the current world
  every time the clock ticks. The result of the call becomes the current
  world. The clock ticks at the rate of 28 times per second.

* (on-tick tick-expr rate-expr)
   
    tick-expr : (-> WorldState HandlerResult) ~
    rate-expr : (and/c real? positive?) ~

  tells DrRacket to call the tick-expr function on the current world
  every time the clock ticks. The result of the call becomes the current
  world. The clock ticks every rate-expr seconds.

* (on-tick tick-expr rate-expr limit-expr)
   
    tick-expr : (-> WorldState HandlerResult) ~
    rate-expr : (and/c real? positive?) ~
    limit-expr : (and/c integer? positive?) ~

  tells DrRacket to call the tick-expr function on the current world
  every time the clock ticks. The result of the call becomes the current
  world. The clock ticks every rate-expr seconds. The world ends when
  the clock has ticked more than limit-expr times.

* A KeyEvent represents key board events.

  KeyEvent : string?

  For simplicity, we represent key events with strings, but not all
  strings  are key events. The representation of key events comes in
  distinct  classes. First, a single-character string is used to signal
  that the user  has hit a "regular" key, such as

  * "q" stands for the q key;

  * "w" stands for the w key;

  * "e" stands for the e key;

  * "r" stands for the r key; and so on.

  Some of these one-character strings look somewhat unusual:

  * " " stands for the space bar (#\space);

  * "\r" stands for the return and enter key (#\return);

  * "\t" stands for the tab key (#\tab); and

  * "\b" stands for the backspace key (#\backspace).

  Here is "proof" that these strings really have length 1:

    > (string-length "\t")
    1

  On rare occasions your programs may also encounter "\u007F",  which is
  the string representing the delete key (aka rubout).

  Second, some keys have multiple-character string representations.
  Strings  with more than one character denote arrow keys or other
  special events,  starting with the four most important ones:

  * "left" is the left arrow;

  * "right" is the right arrow;

  * "up" is the up arrow;

  * "down" is the down arrow;

  Here are some others that you may encounter:

  * "start"

  * "cancel"

  * "clear"

  * "shift"

  * "rshift"

  * "control"

  * "rcontrol"

  * "menu"

  * "pause"

  * "capital"

  * "prior"

  * "next"

  * "end"

  * "home"

  * "escape"

  * "select"

  * "print"

  * "execute"

  * "snapshot"

  * "insert"

  * "help"

  * function keys: "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9",
    "f10", "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18",
    "f19", "f20", "f21", "f22", "f23", "f24"

  * "numlock"

  * "scroll"

  The following four count as keyevents even though they are triggered
  by physical events on some form of mouse:

  * "wheel-up"

  * "wheel-down"

  * "wheel-left"

  * "wheel-right"

  The preceding enumeration is neither complete in covering all the
  events  that this library deals with nor does it specify which events
  the library  ignores. If you wish to design a program that relies on
  specific keys on  your keyboard, you should first write a small test
  program to find out  whether the chosen keystrokes are caught by the
  library and, if so, which  string representations are used for these
  events.

  (key-event? x) -> boolean?
    x : any ~

  determines whether x is a KeyEvent

  (key=? x y) -> boolean?
    x : key-event? ~
    y : key-event? ~

  compares two KeyEvent for equality

  (on-key key-expr)
   
    key-expr : (-> WorldState key-event? HandlerResult) ~

  tells DrRacket to call the key-expr function on the current world and
  a  KeyEvent for every keystroke the user of the computer makes. The
  result  of the call becomes the current world.

  Here is a typical key-event handler:

    (define (change w a-key)
      (cond
        [(key=? a-key "left")  (world-go w -DELTA)]
        [(key=? a-key "right") (world-go w +DELTA)]
        [(= (string-length a-key) 1) w] ; order-free checking
        [(key=? a-key "up")    (world-go w -DELTA)]
        [(key=? a-key "down")  (world-go w +DELTA)]
        [else w]))

  The omitted, auxiliary function world-go is supposed to consume a
  world and a number and produces a world.

  (on-release release-expr)
   
    release-expr : (-> WorldState key-event? HandlerResult) ~

  tells DrRacket to call the release-expr function on the current world
  and a KeyEvent for every release event on the keyboard. A release
  event occurs when a user presses the key and then releases it. The
  second argument indicates which key has been released. The result of
  the function call becomes the current world.

* A PadEvent is a KeyEvent for a game-pad simulation via big-bang. The
  presence of an on-pad clause superimposes the game-pad image onto the
  current image, suitably scaled to its size:



  PadEvent : key-event?

  It is one of the following:

  * "left" is the left arrow;

  * "right" is the right arrow;

  * "up" is the up arrow;

  * "down" is the down arrow;

  * "w" to be interpreted as up arrow;

  * "s" to be interpreted as down arrow;

  * "a" to be interpreted as left arrow;

  * "d" to be interpreted as right arrow;

  * " " is the space bar;

  * "shift" is the left shift key;

  * "rshift" is the right shift key;

  (pad-event? x) -> boolean?
    x : any ~

  determines whether x is a PadEvent

  (pad=? x y) -> boolean?
    x : pad-event? ~
    y : pad-event? ~

  compares two PadEvent for equality

  (on-pad pad-expr)
   
    pad-expr : (-> WorldState pad-event? HandlerResult) ~

  tells DrRacket to call the pad-expr function on the current world and
  the  KeyEvent for every keystroke that is also a PadEvent. The result
  of the call becomes the current world.

  Here is a typical PadEvent handler:

    ; ComplexNumber PadEvent -> ComplexNumber
    (define (handle-pad-events x k)
      (case (string->symbol k)
        [(up    w)      (- x 0+10i)]
        [(down  s)      (+ x 0+10i)]
        [(left  a)      (- x 10)]
        [(right d)      (+ x 10)]
        [(| |)          x0]
        [(shift)        (conjugate x)]
        [(rshift)       (stop-with (conjugate x))]))

  When a big-bang expression specifies an on-pad clause, all PadEvents
  are sent to the on-pad handler. All other key events are discarded,
  unless an on-key and/or an on-release clause are specified, in which
  case all remaining KeyEvents are sent there.

  To facilitate the definition of on-pad handlers, the library provides
  the pad-handler form.

  (pad-handler clause ...)
   
  clause = (up up-expr)
         | (down down-expr)
         | (left left-expr)
         | (right right-expr)
         | (space space-expr)
         | (shift shift-expr)

  Creates a function that deals with PadEvents. Each (optional) clause
  contributes one function that consumes a World and produces a world.
  The name of the clause determines for which kind of PadEvent the
  function is called.

  Using the form is entirely optional and not required to use on-pad.
  Indeed, pad-handler could be used to define a plain KeyEvent
  handler—if we could guarantee that players never hit keys other than
  PadEvent keys.

  All clauses in a pad-handler form are optional:

  * (up up-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for "up" and "w" events.

  * (down down-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for "down" and "s" events.

  * (left left-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for "left" and "a" events.

  * (right right-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for "right" and "d" events.

  * (space space-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for space-bar events (" ").

  * (shift shift-expr)
     
      tick-expr : (-> WorldState HandlerResult) ~

    Creates a handler for "shift" and "rshift" events.

  If a clause is omitted, pad-handler installs a default function  that
  maps the existing world to itself.

  Here is a PadEvent handler defined with pad-handler:

    ; ComplexNumber -> ComplexNumber
    (define (i-sub1 x) (- x 0+1i))
     
    ; ComplexNumber -> ComplexNumber
    (define (i-add1 x) (+ x 0+1i))
     
    ; ComplexNumber -> ComplexNumber
    ; deal with all PadEvents
    (define handler
      (pad-handler (left sub1) (right add1)
                   (up i-sub1) (down i-add1)
                   (shift (lambda (w) 0))
                   (space stop-with)))
     
    ; some tests: ~
    (check-expect (handler 9 "left") 8)
    (check-expect (handler 8 "up")   8-1i)

* A MouseEvent represents mouse events, e.g., mouse movements  or mouse
  clicks, by the computer’s user.

  MouseEvent : (one-of/c "button-down" "button-up" "drag" "move" "enter"
  "leave")

  All MouseEvents are represented via strings:

  * "button-down" signals that the computer user has pushed a mouse
    button down;

  * "button-up" signals that the computer user has let go of a mouse
    button;

  * "drag" signals that the computer user is dragging the mouse. A
    dragging event occurs when the mouse moves while a mouse button is
    pressed.

  * "move" signals that the computer user has moved the mouse;

  * "enter" signals that the computer user has moved the mouse into the
    canvas area; and

  * "leave" signals that the computer user has moved the mouse out of
    the canvas area.

  (mouse-event? x) -> boolean?
    x : any ~

  determines whether x is a MouseEvent

  (mouse=? x y) -> boolean?
    x : mouse-event? ~
    y : mouse-event? ~

  compares two MouseEvents for equality

  (on-mouse mouse-expr)
   
    mouse-expr : (-> WorldState ~
                     integer? integer? MouseEvent
                     HandlerResult)

  tells DrRacket to call mouse-expr on the current world, the current x
  and y coordinates of the mouse, and a MouseEvent for every
  (noticeable) action of the mouse by the computer user. The result of
  the call becomes the current world.

  For "leave" and "enter" events, the coordinates of the mouse click may
  be outside of the (implicit) rectangle. That is, the coordinates may
  be negative or larger than the (implicitly) specified width and
  height.

  Note 1: the operating system doesn’t really notice every single
  movement of the mouse (across the mouse pad). Instead it samples the
  movements and signals most of them.

  Note 2: while mouse events are usually reported in the expected
  manner, the operating system doesn’t necessarily report them in the
  expected order. For example, the Windows operating system insists on
  signaling a "move" event immediately after a "button-up"  event is
  discovered.  Programmers must design the on-mouse  handler to handle
  any possible mouse event at any moment.

* (stop-when last-world?)
   
    last-world? : (-> WorldState boolean?) ~

  tells DrRacket to call the last-world? function at the start of the
  world program and after any other world-producing callback. If this
  call produces #true, the world program is shut down. Specifically, the
  clock is stopped; no more tick events, KeyEvents, or MouseEvents are
  forwarded to the respective handlers. The big-bang expression returns
  this last world.

  (stop-when last-world? last-picture)
   
    last-world? : (-> WorldState boolean?) ~
    last-picture : (-> WorldState scene?) ~

  See Background for scene?.  tells DrRacket to call the last-world?
  function at the start of  the world program and after any other
  world-producing callback.  If this call produces #true, the world
  program is shut  down after displaying the world one last time, this
  time using the image  rendered with last-picture. Specifically, the
  clock is stopped; no more  tick events, KeyEvents, or MouseEvents are
  forwarded to  the respective handlers. The big-bang expression returns
  this  last world.

* (struct stop-with (w))
    w : HandlerResult ~

  signals to DrRacket that the world program should shut down. That is,
  any handler may return (stop-with w) provided w is a HandlerResult. If
  it does, the state of the world becomes w and big-bang will close down
  all event handling. Similarly, if the initial state of the world is
  (stop-with w), event handling is immediately closed down.

* (check-with world-expr?)
   
    world-expr? : (-> Any boolean?) ~

  tells DrRacket to call the world-expr? function on the result of every
  world handler call. If this call produces #true, the result is
  considered a world; otherwise the world program signals an error.

* (record? r-expr)
   
    r-expr : any/c ~

  tells DrRacket to enable a visual replay of the interaction, unless
  #f. The replay action generates one png image per image and an
  animated gif for the entire sequence in the directory of the user’s
  choice.  If r-expr evaluates to the name of an existing
  directory/folder (in the local directory/folder), the directory is
  used to deposit the images.

* (close-on-stop cos-expr)
   
    cos-expr : (or/c boolean? natural-number/c) ~

  tells DrRacket whether to close the big-bang window after the
  expression is evaluated. If cos-expr is #false, which is the default,
  the window remains open. If cos-expr is #true, the window closes
  immediately. Finally, if cos-expr is a natural number, the window
  closes cos-expr seconds after the end of the evaluation.

* (display-mode d-expr)
   
    d-expr : (or/c 'fullscreen 'normal) ~

  informs DrRacket to choose one of two display modes: 'normal or
  'fullscreen. The 'normal mode is the default and uses the size
  specifications from the to-draw clause. If the 'fullscreen mode is
  specified, big-bang takes over the full screen.

  (display-mode d-expr resize-expr)
   
    d-expr : (or/c 'fullscreen 'normal) ~
    resize-expr : (-> WorldState number? number? WorldState) ~

  informs DrRacket to choose one of two display modes: 'normal or
  'fullscreen. The 'normal mode is the default and uses the size
  specifications from the to-draw clause. If the 'fullscreen mode is
  specified, big-bang takes over the full screen.

  The optional resize-expr is applied to the current world and the sizes
  (width and height) of the display once, when the world is initialized.
  This gives the program a chance to draw shapes of a size relative to
  the display size in a portable manner.

* (state expr)

  if not #f, DrRacket opens two separate windows:

  * one shows the current state each time it is updated.

  * another that displays the events and the related event data.

  This is useful for beginners who wish to see how their world evolves
  and why—without having to design a rendering function.

* (name name-expr)
   
    name-expr : (or/c symbol? string?) ~

  provide a name (namer-expr) to this world, which is used as the title
  of the canvas.

The following example shows that (run-simulation create-UFO-scene) is a
short-hand for three lines of code:

  (define (create-UFO-scene height)
    (underlay/xy (rectangle 100 100 "solid" "white") 50 height UFO))
   
  (define UFO
    (underlay/align "center"
                    "center"
                    (circle 10 "solid" "green")
                    (rectangle 40 4 "solid" "green")))
   
   
  (big-bang 0
            (on-tick add1)
            (to-draw create-UFO-scene))

Exercise Add a condition for stopping the flight of the UFO when it
reaches the bottom.

4.4. A First Sample World

This section uses a simple example to explain the design of worlds. The
first subsection introduces the sample domain, a door that closes
automatically. The second subsection is about the design of world
programs in general, the remaining subsections implement a simulation of
the door.

4.4.1. Understanding a Door

Say we wish to design a world program that simulates the working of  a
door with an automatic door closer. If this kind of door is locked, you
can unlock it with a key. While this doesn’t open the door per se, it is
now possible to do so. That is, an unlocked door is closed and pushing
at  the door opens it. Once you have passed through the door and you let
go,  the automatic door closer takes over and closes the door again.
When a  door is closed, you can lock it again.

Here is a diagram that translates our words into a graphical
representation:



Like the picture of the general workings of a world program, this
diagram displays a so-called “state machine.” The three circled words
are  the states that our informal description of the door identified:
locked,  closed (and unlocked), and open. The arrows specify how the
door can go  from one state into another. For example, when the door is
open, the  automatic door closer shuts the door as time passes. This
transition is  indicated by the arrow labeled “time.” The other arrows
represent  transitions in a similar manner:

* “push” means a person pushes the door open (and let’s go);

* “lock” refers to the act of inserting a key into the lock and turning
  it to the locked position; and

* “unlock” is the opposite of “lock.”

4.4.2. Hints on Designing Worlds

Simulating any dynamic behavior via a world program demands two
different activities. First, we must tease out those portions of our
domain that change over time or in reaction to actions, and we must
develop a data representation for this information.  This is what we
call  WorldState. Keep in  mind that a good data definition makes it
easy for readers to map data to  information in the real world and vice
versa. For all others aspects of  the world, we use global constants,
including graphical or visual  constants that are used in conjunction
with the rendering operations.

Second, we must translate the actions in our domain—the arrows in the
above diagram—into interactions with the computer that the universe
teachpack can deal with. Once we have decided to use the passing of time
for one aspect, key presses for another, and mouse movements for a
third,  we must develop functions that map the current state of the
world—represented as data from WorldState—into the next state of the
world. Put differently, we have just created a wish list with three
handler functions that have the following general contract and purpose
statements:

  ; tick : WorldState -> HandlerResult ~
  ; deal with the passing of time
  (define (tick w) ...)
   
  ; click : WorldState Number Number MouseEvent -> HandlerResult ~
  ; deal with a mouse click at (x,y) of kind me
  ; in the current world w
  (define (click w x y me) ...)
   
  ; control : WorldState KeyEvent -> HandlerResult ~
  ; deal with a key event ke
  ; in the current world w
  (define (control w ke) ...)

That is, the contracts of the various handler designations dictate what
the  contracts of our functions are, once we have defined how to
represent the  domain with data in our chosen language.

A typical program does not use all three of these functions.
Furthermore,  the design of these functions provides only the top-level,
initial design  goal. It often demands the design of many auxiliary
functions. The  collection of all these functions is your world program.

An extended example is available in How to Design Programs/2e.

4.5. The World is not Enough

The library facilities covered so far are about designing individual
programs with interactive graphical user interfaces (simulations,
animations, games, etc.). In this section, we introduce capabilities for
designing a distributed program, which is really a number of programs
that  coordinate their actions in some fashion. Each of the individual
programs  may run on any computer in the world (as in our planet and the
spacecrafts  that we sent out), as long as it is on the internet and as
long as the  computer allows the program to send and receive messages
(via TCP). We  call this arrangement a universe and the program that
coordinates  it all a universe server or just server.

This section explains what messages are, how to send them from a  world
program, how to receive them, and how to connect a  world program to a
universe.

4.5.1. Messages

After a world program has become a part of a universe, it may send
messages  and receive them. In terms of data, a message is just an
S-expression.

S-expression An S-expression is roughly a nested list of basic data; to
be precise, an S-expression is one of:

* a string,

* a symbol,

* a number,

* a boolean,

* a char, or

* a list of S-expressions,

* a prefab struct of S-expressions, or

* a byte string.

Note the list clause includes empty of course.

                                        *sexp?*
(sexp? x) -> boolean? ~
  x : any/c ~

determines whether x is an S-expression.

4.5.2. Sending Messages

Each world-producing callback in a world program—those for handling
clock  tick events, keyboard events, and mouse events—may produce a
Package in addition to just a WorldState:

HandlerResult is one of the following:

* WorldState

* Package

where Package represents a pair consisting of a WorldState  and a
message from a world program to the server.  Because  programs only send
messages via Package, the teachpack does not  provide the selectors for
the structure, only the constructor and a  predicate.

                                        *package?*
(package? x) -> boolean? ~
  x : any/c ~

determine whether x is a Package.

                                        *make-package*
(make-package w m) -> package? ~
  w : any/c ~
  m : sexp? ~

create a Package from a WorldState and an S-expression.

Recall that event handlers return a HandlerResult,  and we have just
refined this data definition. Hence, each handler may return either a
WorldState or a Package.  If an event handler produces a Package,  the
content of the world field becomes the next world and the message field
specifies  what the world sends to the universe. This distinction also
explains why the data  definition for WorldState may not include a
Package.

4.5.3. Connecting with the Universe

Messages are sent to the universe program, which runs on some computer
in  the world. The next section is about constructs for creating such a
universe  server. For now, we just need to know that it exists and that
it is the recipient  of messages.

IP string?

Before a world program can send messages, it must register with the
server. Registration must specify the internet address of the computer
on which  the server runs, also known as an IP address or a host.  Here
a  IP address is a string of the right shape, e.g., "192.168.1.1"  or
"www.google.com".

LOCALHOST : string? ~

the IP of your computer. Use it while you are developing a distributed
program, especially while you are investigating whether the
participating world programs collaborate in an appropriate manner. This
is called integration testing and differs from unit testing quite a bit.

A big-bang description of a world program that wishes to communicate
with other programs must contain a register clause of one of the
following shapes:

* (register ip-expr)
   
    ip-expr : string? ~

  connect this world to a universe server at the specified ip-expr
  address and set up capabilities for sending and receiving messages. If
  the world description includes a name specification of the form (name
  SomeString) or (name SomeSymbol), the name of the world is sent along
  to the server.

* (port port-expr)
   
    port-expr : natural-number/c ~

  specifies port on which a world wishes to receive and send messages. A
  port number is an integer between 0 and 65536.

When a world program registers with a universe program and the universe
program stops working, the world program stops working, too.

4.5.4. Receiving Messages

Finally, the receipt of a message from the server is an event, just like
tick events, keyboard events, and mouse events. Dealing with the receipt
of a  message works exactly like dealing with any other event. DrRacket
applies the event handler that the world program specifies; if there is
no  clause, the message is discarded.

The on-receive clause of a big-bang specifies the event handler  for
message receipts.

                                        *on-receive*
(on-receive receive-expr) ~
 
  receive-expr : (-> WorldState sexp? HandlerResult) ~

tells DrRacket to call receive-expr for every message receipt, on the
current WorldState and the received message. The result of the call
becomes the current WorldState.

Because receive-expr is (or evaluates to) a world-transforming function,
it too can produce a Package instead of just a WorldState. If the result
is a Package, its message content is sent to the server.

The diagram below summarizes the extensions of this section in graphical
form.



A registered world program may send a message to the universe server  at
any time by returning a Package from an event handler. The  message is
transmitted to the server, which may forward it to some  other world
program as given or in some massaged form. The arrival of a  message is
just another event that a world program must deal with. Like  all other
event handlers receive accepts a WorldState and some  auxiliary
arguments (a message in this case) and produces a  WorldState or a
Package.

When messages are sent from any of the worlds to the universe or vice
versa,  there is no need for the sender and receiver to synchronize.
Indeed, a sender  may dispatch as many messages as needed without regard
to whether the  receiver has processed them yet. The messages simply
wait in queue until  the receiving server or world program takes care of
them.

4.6. The Universe Server

A server is the central control program of a universe and  deals with
receiving and sending of messages between the world  programs that
participate in the universe. Like a world  program, a server is a
program that reacts to events, though to different  events than worlds.
The two primary kinds of events are the  appearance of a new world
program in the universe  and the receipt of a message from a world
program.

The teachpack provides a mechanism for designating event handlers for
servers that is quite similar to the mechanism for describing world
programs. Depending on the designated event handlers, the server takes
on  distinct roles:

* A server may be a “pass through” channel between two worlds, in which
  case it has no other function than to communicate whatever message it
  receives from one world to the other, without any interference.

* A server may enforce a “back and forth” protocol, i.e., it may force
  two (or more) worlds to engage in a civilized tit-for-tat exchange.
  Each world is given a chance to send a message and must then wait to
  get a reply before it sends anything again.

* A server may play the role of a special-purpose arbiter, e.g., the
  referee or administrator of a game. It may check that each world
  “plays” by the rules, and it administrates the resources of the game.

As a matter of fact, a pass-through server can become basically
invisible, making it appear as if all communication goes from peer world
to peer in a universe.

This section first introduces some basic forms of data that the  server
uses to represent worlds and other matters. Second,  it explains how to
describe a server program.

4.6.1. Worlds and Messages

Understanding the server’s event handling functions demands several data
representations: that of (a connection to) a world program and that  of
a response of a handler to an event.

* The server and its event handlers must agree on a  data representation
  of the worlds that participate in the  universe.

  (iworld? x) -> boolean?
    x : any/c ~

  determines whether x is an iworld. Because the universe server
  represents worlds via structures that collect essential information
  about the connections, the teachpack does not export any constructor
  or selector functions on worlds.

  (iworld=? u v) -> boolean?
    u : iworld? ~
    v : iworld? ~

  compares two iworlds for equality.

  (iworld-name w) -> (or/c symbol? string?)
    w : iworld? ~

  extracts the name from a iworld structure.

  iworld1 : iworld? ~

  an iworld for testing your programs

  iworld2 : iworld? ~

  another iworld for testing your programs

  iworld3 : iworld? ~

  and a third one

  The three sample iworlds are provided so that you can test your
  functions for universe programs. For example:

    (check-expect (iworld=? iworld1 iworld2) #false)
    (check-expect (iworld=? iworld2 iworld2) #true)

* Each event handler produces a state of the universe or a bundle, which
  is a structure  that contains the server’s state, a list of mails to
  other worlds,  and the list of iworlds that are to be disconnected.

  (bundle? x) -> boolean?
    x : any/c ~

  determines whether x is a bundle.

  (make-bundle state mails low-to-remove) -> bundle?
    state : any/c ~
    mails : (listof mail?) ~
    low-to-remove : (listof iworld?) ~

  creates a bundle from a piece of data that represents a server state,
  a list of mails, and a list of iworlds.

  The list of iworlds in the third field of the bundle are removed from
  the  list of participants from which to expect messages.

  If disconnecting from these worlds results in an empty list of
  participants, the universe server is restarted in the initial state.

  A mail represents a message from an event handler to a world. The
  teachpack provides only a predicate and a constructor for these
  structures:

  (mail? x) -> boolean?
    x : any/c ~

  determines whether x is a mail.

  (make-mail to content) -> mail?
    to : iworld? ~
    content : sexp? ~

  creates a mail from a iworld and an S-expression.

4.6.2. Universe Descriptions

A server keeps track of information about the universe that  it manages.
One kind of tracked information is obviously the collection of
participating world programs, but in general the kind of information
that  a server tracks and how the information is represented depends on
the  situation and the programmer, just as with world programs.

UniverseState : any/c

The design of a universe server demands that you come up with a data
definition for all possible server states. For running universes, the
teachpack demands that you come up with a data definition for (your
state of the) server.  Any piece of data can represent the state. We
just assume that you introduce a data definition for the possible states
and that your event handlers are designed according to the design recipe
for this data definition.

The server itself is created with a description that includes the  first
state and a number of clauses that specify functions for dealing  with
universe events.

                                        *universe*
(universe state-expr clause ...) ~
 
clause = (on-new new-expr)
       | (on-msg msg-expr)
       | (on-tick tick-expr)
       | (on-tick tick-expr rate-expr)
       | (on-tick tick-expr rate-expr limit-expr)
       | (on-disconnect dis-expr)
       | (state expr)
       | (to-string render-expr)
       | (port port-expr)
       | (check-with universe?-expr)

creates a server with a given state, state-expr. The behavior is
specified via handler functions through mandatory and optional clauses.
These functions govern how the server deals with the registration of new
worlds, how it disconnects worlds, how it sends messages from one world
to the rest of the registered worlds, and how it renders its current
state as a string.

Evaluating a universe expression starts a server. Visually it opens  a
console window on which you can see that worlds join, which messages are
received from which world, and which messages are sent to which world.
Messages that are too long are truncated before they are displayed.

For convenience, the console also has two buttons: one for shutting down
a  universe and another one for re-starting it. The latter functionality
is  especially useful during the integration of the various pieces of a
distributed program.

The mandatory clauses of a universe server description are on-new and
on-msg:

* (on-new new-expr)
   
    new-expr : (-> UniverseState iworld? (or/c UniverseState bundle?)) ~

  tells DrRacket to call the function new-expr every time another world
  joins the  universe. The event handler is called with the current
  state and the  joining iworld, which isn’t on the list yet. In
  particular, the handler may  reject a world program from participating
  in a universe,  by simply returning the given state or by immediately
  including the new world in the third field of the resulting bundle
  structure.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

* (on-msg msg-expr)
   
    msg-expr : (-> UniverseState iworld? sexp? (or/c UniverseState bundle?)) ~

  tells DrRacket to apply msg-expr to the current state of the
  universe, the world  w that sent the message, and the message itself.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

All proper event handlers produce a state of the universe or a  bundle.
The state of the universe is safe-guarded by the server until the next
event, and the mails  are broadcast as specified.  The list of iworlds
in the third field of the  bundle are removed from the list of
participants from which to expect  messages.

The following picture provides a graphical overview of the server’s
workings.



In addition to the mandatory handlers, a program may wish to add some
optional handlers:

* (on-tick tick-expr)
   
    tick-expr : (-> UniverseState (or/c UniverseState bundle?)) ~

  tells DrRacket to apply tick-expr to the current state of the
  universe.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

  (on-tick tick-expr rate-expr)
   
    tick-expr : (-> UniverseState (or/c UniverseState bundle?)) ~
    rate-expr : (and/c real? positive?) ~

  tells DrRacket to apply tick-expr as above; the clock ticks  every
  rate-expr seconds.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

  (on-tick tick-expr rate-expr)
   
    tick-expr : (-> UniverseState (or/c UniverseState bundle?)) ~
    rate-expr : (and/c real? positive?) ~
    limit-expr : (and/c integer? positive?) ~

  tells DrRacket to apply tick-expr as above; the clock ticks  every
  rate-expr seconds. The universe stops when the clock has  ticked more
  than limit-expr times.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

* (on-disconnect dis-expr)
   
    dis-expr : (-> UniverseState iworld? (or/c UniverseState bundle?)) ~

  tells DrRacket to invoke dis-expr every time a participating  world
  drops its connection to the server. The first argument  is the current
  state of the universe server, while the second argument is  the
  (representation of the) world that got disconnected. The resulting
  bundle usually includes this second argument in the third field,
  telling  DrRacket not to wait for messages from this world anymore.

  Changed in version 1.1 of package htdp-lib: allow universe handlers to
  return a plain universe state

* (port port-expr)
   
    port-expr : natural-number/c ~

  specifies port on which a universe wishes to receive and send
  messages. A port number is an integer between 0 and 65536.

* (to-string render-expr)
   
    render-expr : (-> UniverseState string?) ~

  tells DrRacket to render the state of the universe after each event
  and to display this string in the universe console.

* (check-with universe?-expr)
   
    universe?-expr : (-> Any boolean?) ~

  ensure that what the event handlers produce is really an element of
  UniverseState.

* (state expr)

  if not #f, DrRacket opens a separate window that shows the current
  state and the messages received from and sent to the registered
  worlds. This is mostly useful for debugging server programs.

4.6.3. Exploring a Universe

In order to explore the workings of a universe, it is necessary to
launch a  server and several world programs on one and the same
computer. We  recommend launching one server out of one DrRacket tab and
as many worlds  as necessary out of a second tab. For the latter, the
teachpack provides a  special form.

                                        *launch-many-worlds*
(launch-many-worlds expression ...) ~

evaluates all sub-expressions in parallel. Typically each sub-expression
is an application of a function that evaluates a big-bang expression.
When all worlds have stopped, the expression returns all final worlds in
order.

Once you have designed a world program, add a function definition
concerning big-bang to the end of the tab:

  ; String -> World
  (define (main n)
    (big-bang ... (name n) ...))

Then in DrRacket’s Interactions area, use launch-many-worlds  to create
several distinctively named worlds:

  > (launch-many-worlds (main "matthew")
                        (main "kathi")
                        (main "h3"))
  10
  25
  33

The three worlds can then interact via a server. When all of them have
stopped, they produce the final states, here 10, 25, and  33.

For advanced programmers, the library also provides a programmatic
interface for launching many worlds in parallel.

                                        *launch-many-worlds/proc*
(launch-many-worlds/proc thunk-that-runs-a-world      ~
                         ...)                    -> any ...
  thunk-that-runs-a-world : (-> any/c) ~

invokes all given thunk-that-runs-a-world in parallel. Typically each
argument is a function of no argument that evaluates a big-bang
expression. When all worlds have stopped, the function expression
returns all final worlds in order.

It is thus possible to decide at run time how many and which worlds to
run in parallel:

  > (apply launch-many-worlds/proc
           (build-list (random 10)
                       (lambda (i)
                         (lambda ()
                           (main (number->string i))))))
  0
  9
  1
  2
  3
  6
  5
  4
  8
  7

4.7. A First Sample Universe

This section uses a simple example to explain the design of a universe,
The code assumes the "Intermediate with Lambda" language.  especially
its server and some participating worlds. The first subsection  explains
the example, the second introduces the general design plan for  such
universes. The remaining sections present the full-fledged solution.

4.7.1. Two Ball Tossing Worlds

Say we want to represent a universe that consists of a number of worlds
and  that gives each world a “turn” in a round-robin fashion. If a world
is  given its turn, it displays a ball that ascends from the bottom of a
canvas to the top. It relinquishes its turn at that point and the server
gives the next world a turn.

Here is an image that illustrates how this universe would work if two
worlds participated:



The two world programs could be located on two distinct computers  or on
just one. A server mediates between the two worlds, including  the
initial start-up.

4.7.2. Hints on Designing Universes

The first step in designing a universe is to understand the
coordination of the worlds from a global perspective. To some  extent,
it is all about knowledge and the distribution of knowledge  throughout
a system. We know that the universe doesn’t exist until  the server
starts and the worlds are joining. Because of the nature  of computers
and networks, however, we may assume little else. Our network
connections ensure that if some world or the server sends  two messages
to the same place in some order, they arrive in the  same order (if they
arrive at all). In contrast, if two distinct  world programs send one
message each, the network does not  guarantee the order of arrival at
the server; similarly, if the  server is asked to send some messages to
several distinct  world programs, they may arrive at those worlds in the
order sent  or in the some other order. In the same vein, it is
impossible to ensure  that one world joins before another. Worst, when
someone removes the  connection (cable, wireless) between a computer
that runs a world  program and the rest of the network or if some
network cable is cut,  messages don’t go anywhere. Due to this vagaries,
it is therefore the  designer’s task to establish a protocol that
enforces a certain order onto  a universe and this activity is called
protocol design.

From the perspective of the universe, the design of a protocol is  about
the design of data representations for tracking universe information  in
the server and the participating worlds and the design of a data
representation for messages. As for the latter, we know that they must
be  S-expressions, but usually world programs don’t send all  kinds of
S-expressions. The data definitions for messages must  therefore select
a subset of suitable S-expressions. As for the  state of the server and
the worlds, they must reflect how they currently  relate to the
universe. Later, when we design their “local” behavior, we  may add more
components to their state space.

In summary, the first step of a protocol design is to introduce:

* a data definition for the information about the universe that the
  server tracks, call it UniverseState;

* a data definition for the world(s) about their current relationship to
  the universe;

* data definitions for the messages that are sent from the server to the
  worlds and vice versa. Let’s call them S2W for messages from the
  server to the worlds and W2S for the other direction; in the most
  general case you may need one pair per world.

If all the worlds exhibit the same behavior over time, a single data
definition suffices for step 2. If they play different roles, we may
need one data definition per world.

Of course, as you define these collections of data always keep in mind
what the pieces of data mean, what they represent from the universe’s
perspective.

The second step of a protocol design is to figure out which major
events—the addition of a world to the universe, the arrival of a message
at the server or at a world—to deal with and what they imply for the
exchange of messages. Conversely, when a server sends a message to a
world, this may have implications for both the state of the server and
the  state of the world. A good tool for writing down these agreements
is an  interaction diagram.

 
Server              World1                  World2
  |                   |                       |
  |   'go             |                       |
  |<------------------|                       |
  |    'go            |                       |
  |------------------------------------------>|
  |                   |                       |
  |                   |                       |

Each vertical line is the life line of a world program or the  server.
Each horizontal arrow denotes a message sent from one  universe
participant to another.

The design of the protocol, especially the data definitions, have direct
implications for the design of event handling functions. For example, in
the server we may wish to deal with two kinds of events: the joining of
a new world and the receipt of a message from one of the worlds. This
translates into the design of two functions with the following headers,

  ; Bundle is
  ;   (make-bundle UniverseState [Listof mail?] [Listof iworld?])
   
  ; UniverseState iworld? -> Bundle
  ; next list of worlds when world iw is joining
  ; the universe in state s
  (define (add-world s iw) ...)
   
  ; UniverseState iworld? W2U -> Bundle
  ; next list of worlds when world iw is sending message m to
  ; the universe in state s
  (define (process s iw m) ...)

Finally, we must also decide how the messages affect the states of the
worlds; which of their callback may send messages and when; and what to
do  with the messages a world receives. Because this step is difficult
to  explain in the abstract, we move on to the protocol design for the
universe of ball worlds.

4.7.3. Designing the Ball Universe

Running the ball universe has a simple overall goal: to ensure that at
any  point in time, one world is active and all others are passive. The
active  world displays a moving ball, and the passive worlds should
display  something, anything that indicates that it is some other
world’s turn.

As for the server’s state, it must obviously keep track of all worlds
that  joined the universe, and it must know which one is active and
which ones  are passive. Of course, initially the universe is empty,
i.e., there are  no worlds and, at that point, the server has nothing to
track.

While there are many different useful ways of representing such a
universe, we just use the list of iworlds that is handed to  each
handler and that handlers return via their bundles. The  UniverseState
itself is useless for this trivial example. We  interpret non-empty
lists as those where the first iworld is active  and the remainder are
the passive iworlds. As for the two possible  events,

* it is natural to add new iworlds to the end of the list; and

* it is natural to move an active iworld that relinquishes its turn to
  the end of the list, too.

The server should send messages to the first iworld of its list as  long
as it wishes this iworld to remain active. In turn, it should  expect to
receive messages only from this one active iworld and no  other iworld.
The content of these two messages is nearly irrelevant  because a
message from the server to an iworld means that it is the  iworld’s turn
and a message from the iworld to the server  means that the turn is
over. Just so that we don’t confuse ourselves, we  use two distinct
symbols for these two messages:

* A GoMessage is 'it-is-your-turn.

* A StopMessage is 'done.

From the universe’s perspective, each world is in one of two states:

* A passive world is resting. We use 'resting for this state.

* An active world is not resting. We delay choosing a representation for
  this part of a world’s state until we design its “local” behavior.

It is also clear that an active world may receive additional messages,
which it may ignore. When it is done with its turn, it will send a
message.

Server
  |                 World1
  |<==================|
  |  'it-is-your-turn |
  |------------------>|
  |                   |                    World2
  |<==========================================|
  |  'done            |                       |
  |<------------------|                       |
  |  'it-is-your-turn |                       |
  |------------------------------------------>|
  |                   |                       |
  |                   |                       |
  |  'done            |                       |
  |<------------------------------------------|
  |  'it-is-your-turn |                       |
  |------------------>|                       |
  |                   |                       |
  |                   |                       |

Here the double-lines (horizontal) denote the registration step, the
others  are message exchanges. The diagram thus shows how the server
decides to make the first registered world the active one and to enlist
all others as they join.

4.7.4. Designing the Ball Server

The preceding subsection dictates that our server program starts like
this:

  (require 2htdp/universe)
   
  ; UniverseState is [Listof iworld?]
  ; StopMessage is 'done.
  ; GoMessage is 'it-is-your-turn.

The design of a protocol has immediate implications for the design of
the  event handling functions of the server. Here we wish to deal with
two  events: the appearance of a new world and the receipt of a message.
Based  on our data definitions and based on the general contracts of the
event  handling functions spelled out in this documentation, we get two
functions  for our wish list:

  ; Result is
  ;   (make-bundle [Listof iworld?]
  ;                (list (make-mail iworld? GoMessage))
  ;                '())
   
  ; [Listof iworld?] iworld? -> Result
  ; add world iw to the universe, when server is in state u
  (define (add-world u iw) ...)
   
  ; [Listof iworld?] iworld? StopMessage -> Result
  ; world iw sent message m when server is in state u
  (define (switch u iw m) ...)

Although we could have re-used the generic contracts from this
documentation, we also know from our protocol that our server sends a
message to exactly one world. Note how these contracts are just
refinements of the generic ones. (A type-oriented programmer would say
that the contracts here are subtypes of the generic ones.)

The second step of the design recipe calls for functional examples:

  ; an obvious example for adding a world: ~
  (check-expect
    (add-world '() iworld1)
    (make-bundle (list iworld1)
                 (list (make-mail iworld1 'it-is-your-turn))
                 '()))
   
  ; an example for receiving a message from the active world: ~
  (check-expect
   (switch (list iworld1 iworld2) iworld1 'done)
   (make-bundle (list iworld2 iworld1)
                (list (make-mail iworld2 'it-is-your-turn))
                '()))

Note that our protocol analysis dictates this behavior for the two
functions. Also note how we use world1, world2, and  world3 because the
teachpack applies these event handlers to real  worlds.

Exercise Create additional examples for the two functions based on our
protocol.

The protocol tells us that add-world just adds the given  world
structure—recall that this a data representation of the  actual world
program—to the given list of worlds. It then sends a  message to the
first world on this list to get things going:

  (define (add-world univ wrld)
    (local ((define univ* (append univ (list wrld))))
      (make-bundle univ*
                   (list (make-mail (first univ*) 'it-is-your-turn))
                   '())))

Because univ* contains at least wrld, it is acceptable to create a mail
to (first univ*). Of course, this same reasoning also implies that if
univ isn’t empty, its first element is an active world and is about to
receive a second 'it-is-your-turn message.

Similarly, the protocol says that when switch is invoked because a
world program sends a message, the data representation of the
corresponding world is moved to the end of the list and the next world
on  the (resulting) list is sent a message:

  (define (switch univ wrld m)
    (local ((define univ* (append (rest univ) (list (first univ)))))
      (make-bundle univ*
                   (list (make-mail (first univ*) 'it-is-your-turn))
                   '())))

As before, appending the first world to the end of the list guarantees
that there is at least this one world on this list. It is therefore
acceptable to create a mail for this world.

Start the server now.

  (universe '() (on-new add-world) (on-msg switch))

Exercise The function definition simply assumes that wrld is  iworld=?
to (first univ) and that the received message  m is 'done. Modify the
function definition so that it  checks these assumptions and raises an
error signal if either of them is  wrong. Start with functional
examples. If stuck, re-read the section on  checked functions from HtDP.
(Note: in a universe it is quite  possible that a program registers with
a server but fails to stick  to the agreed-upon protocol. How to deal
with such situations properly  depends on the context. For now, stop the
universe at this point by  returning an empty list of worlds. Consider
alternative solutions, too.)

Exercise An alternative state representation would equate  UniverseState
with world structures, keeping track of the  active world. The list of
world in the server would track the passive  worlds only. Design
appropriate add-world and switch  functions.

4.7.5. Designing the Ball World

The final step is to design the ball world. Recall that each world  is
in one of two possible states: active or passive. The second kind of
world moves a ball upwards, decreasing the ball’s y  coordinate; the
first kind of world displays something that says  it’s someone else’s
turn.  Assuming the ball always moves along a vertical  line and that
the vertical line is fixed, the state of the world is an  enumeration of
two cases:

  (require 2htdp/universe)
   
  ; WorldState is one of: ~
  ; – Number             %% representing the y coordinate
  ; – 'resting
   
  (define WORLD0 'resting)
   
  ; A WorldResult is one of: ~
  ; – WorldState
  ; – (make-package WorldState StopMessage)

The definition says that initially a world is passive.

The communication protocol and the refined data definition of WorldState
imply a number of contract and purpose statements:

  ; WorldState GoMessage -> WorldResult
  ; make sure the ball is moving
  (define (receive w n) ...)
   
  ; WorldState -> WorldResult
  ; move this ball upwards for each clock tick
  ; or stay 'resting
  (define (move w) ...)
   
  ; WorldState -> Image
  ; render the world as an image
  (define (render w) ...)

Let’s design one function at a time, starting with receive.  Since  the
protocol doesn’t spell out what receive is to compute, let’s  create a
good set of functional examples, exploiting the structure of the  data
organization of WorldState:

  (check-expect (receive 'resting 'it-is-your-turn) HEIGHT)
  (check-expect (receive (- HEIGHT 1) 'it-is-your-turn) ...)

Since there are two kinds of states, we make up at least two kinds of
examples: one for a 'resting state and another one for a numeric  state.
The dots in the result part of the second unit test reveal the  first
ambiguity; specifically it isn’t clear what the result should be  when
an active world receives another message to activate itself. The  second
ambiguity shows up when we study additional examples, which are
suggested by our approach to designing functions on numeric intervals
(HtDP, section 3). That is we should consider the following three inputs
to receive:

* HEIGHT when the ball is at the bottom of the image;

* (- HEIGHT 1) when the ball is properly inside the image; and

* 0 when the ball has hit the top of the image.

In the third case the function could produce three distinct results:  0,
'resting, or (make-package 'resting 'done). The first leaves things
alone; the second turns the active world  into a resting one; the third
does so, too, and tells the universe about  this switch.

We choose to design receive so that it ignores the message and  returns
the current state of an active world.  This ensures that the ball  moves
in a continuous fashion and that the world remains active.

Exercise One alternative design is to move the ball back to the bottom
of the image every time 'it-is-your-turn is received. Design this
function, too.

  (define (receive w m)
    (cond
      [(symbol? w) HEIGHT] ; meaning: (symbol=? w 'resting) ~
      [else w]))

Our second function to design is move, the function that computes  the
ball movement. We have the contract and the second step in the design
recipe calls for examples:

  ; WorldState -> WorldState or (make-package 'resting 'done)
  ; move the ball if it is flying
   
  (check-expect (move 'resting) 'resting)
  (check-expect (move HEIGHT) (- HEIGHT 1))
  (check-expect (move (- HEIGHT 1)) (- HEIGHT 2))
  (check-expect (move 0) (make-package 'resting 'done))
   
  (define (move x) ...)

Following HtDP again, the examples cover four typical situations:
'resting, two end points of the specified numeric interval, and  one
interior point. They tell us that move leaves a passive world  alone and
that it otherwise moves the ball until the y coordinate  becomes 0. In
the latter case, the result is a package that  renders the world passive
and tells the server about it.

Turning these thoughts into a complete definition is straightforward
now:

  (define (move x)
    (cond
      [(symbol? x) x]
      [(number? x) (if (<= x 0)
                       (make-package 'resting 'done)
                       (sub1 x))]))

Exercise what could happen if we had designed receive so that it
produces 'resting when the state of the world is 0?  Use  your answer to
explain why you think it is better to leave this kind of  state change
to the tick event handler instead of the message receipt  handler?

Finally, here is the third function, which renders the state as an
image:

  ; String -> (WorldState -> Image)
  ; render the state of the world as an image
   
  (check-expect
   ((draw "Carl") 100)
   (underlay/xy (underlay/xy MT 50 100 BALL)
                5 85
                (text "Carl" 11 "black")))
   
  (define (draw name)
    (lambda (w)
      (overlay/xy
       (cond
         [(symbol? w) (underlay/xy MT 10 10 (text "resting" 11 "red"))]
         [(number? w) (underlay/xy MT 50 w BALL)])
       5 85
       (text name 11 'black))))

By doing so, we can use the same program to create many different
worlds that register with a server on your computer:

  ; String -> WorldState
  ; create and hook up a world with the LOCALHOST server
  (define (create-world name)
    (big-bang WORLD0
     (on-receive receive)
     (to-draw    (draw n))
     (on-tick    move)
     (name       name)
     (register   LOCALHOST)))

Now you can use (create-world 'carl) and (create-world 'sam),
respectively, to run two different worlds, after launching a server
first. You may wish to use launch-many-worlds here.

Exercise Design a function that takes care of a world to which the
universe has lost its connection. Is Result the proper contract for  the
result of this function?

5. Web IO: "web-io.rkt"

Matthias Felleisen

 (require 2htdp/web-io) package: htdp-lib ~

The teachpack provides a single function:

                                        *show-in-browser*
(show-in-browser x) -> string? ~
  x : xexpr? ~

Translates the given X-expression into a String. It also has the  effect
of opening an external browser and displaying the  X-expression rendered
as XHTML.

Example

  (show-in-browser '(html (body (b "hello world"))))

Added in version 1.0 of package htdp-lib.

6. iTunes: "itunes.rkt"

Matthias Felleisen

 (require 2htdp/itunes) package: htdp-lib ~

The itunes.rkt teachpack implements and provides the functionality  for
reading the collection of tracks exported from iTunes.

In iTunes, select Library from the File menu and then choose  Export
Library. Doing so exports a description of your iTunes  collection as a
file in XML format.

6.1. Data Definitions

                                        *struct*
(struct track (name artist album time track# added play# played) ~
    #:extra-constructor-name make-track) ~
  name : string? ~
  artist : string? ~
  album : string? ~
  time : natural-number/c ~
  track# : natural-number/c ~
  added : date? ~
  play# : natural-number/c ~
  played : date? ~

is one representations for the music tracks in an iTunes collection.

An instance records that the track has title name, is produced by
artist, belongs to album, plays for time milliseconds, is positioned at
track#, was added at date added, has been played play# times, and was
last played at played date.

                                        *struct*
(struct date (year month day hour minute second) ~
    #:extra-constructor-name make-date) ~
  year : natural-number/c ~
  month : natural-number/c ~
  day : natural-number/c ~
  hour : natural-number/c ~
  minute : natural-number/c ~
  second : natural-number/c ~

is a representations of dates in an iTunes collection.

An instance records six pieces of information: the date’s year, month
(between 1 and 12 inclusive), day (between 1 and 31), hour (between 0
and 23), minute (between 0 and 59), and second (between 0 and 59).

In this context, we introduce the following data definitions:

  ; Track is a track?
  ; Date is date?
   
  ; LTracks is one of: ~
  ; – '()
  ; – (cons Track LTracks)
   
  ; LLists is one of: ~
  ; – '()
  ; – (cons LAssoc LLists)
   
  ; LAssoc is one of: ~
  ; – '()
  ; – (cons Association LAssoc)
   
  ; Association is (cons string? (cons BSDN '()))
   
  ; BSDN satisfies either string?, integer?, real?, Date, or boolean?.

6.2. Exported Funcions

                                        *read-itunes-as-lists*
(read-itunes-as-lists file-name) -> LLists ~
  file-name : string? ~

creates a list-of-lists representation for all tracks in file-name, an
XML export from an iTunes library.

Effect reads an XML document from file-name

Example:

  (read-itunes-as-lists "Library.xml")

                                        *read-itunes-as-tracks*
(read-itunes-as-tracks file-name) -> LTracks ~
  file-name : string? ~

creates a list-of-tracks representation for all tracks in file-name, an
XML export from an iTunes library.

Effect reads an XML document from file-name

Example:

  (read-itunes-as-tracks "Library.xml")

                                        *create-track*
(create-track name         ~
              artist      
              album       
              time        
              track#      
              added       
              play#       
              played) -> (or/c track? false?)
  name : string? ~
  artist : string? ~
  album : string? ~
  time : natural-number/c ~
  track# : natural-number/c ~
  added : date? ~
  play# : natural-number/c ~
  played : date? ~

creates a track representation if the inputs live up to their
predicates. Otherwise it produces #false.

Note This is a checked constructor.

  > (create-track "one"
                  "two"
                  "three"
                  4
                  5
                  (create-date 1 2 3 4 5 6)
                  7
                  (create-date 1 2 3 4 5 6))
  (track "one" "two" "three" 4 5 (date 1 2 3 4 5 6) 7 (date 1 2 3 4 5 6))
  > (create-track "one" "two" "three" 4 5 "a date" 7 "another date")
  #f

                                        *create-date*
(create-date year month day hour minute second) ~
 -> (or/c date? false?)
  year : natural-number/c ~
  month : natural-number/c ~
  day : natural-number/c ~
  hour : natural-number/c ~
  minute : natural-number/c ~
  second : natural-number/c ~

creates a date representation if the inputs live up to their
predicates. Otherwise it produces #false.

Note This is a checked constructor.

  > (create-date 1 2 3 4 5 6)
  (date 1 2 3 4 5 6)
  > (create-date 1 2 3 "four" 5 6)
  #f

In addition to the above, the teachpack exports the predicates for Track
and Date plus all selectors:

  track?
  track-name
  track-artist
  track-album
  track-time
  track-track#
  track-added
  track-play#
  track-played
   
  date?
  date-year
  date-month
  date-day
  date-hour
  date-minute
  date-second

7. Abstraction: "abstraction.rkt"

Matthias Felleisen

 (require 2htdp/abstraction) package: htdp-lib ~

The abstract.rkt teachpack provides some additional abstraction
facilities: comprehensions and loops, matching, and algebraic data
types. Most of these are restricted versions of full-featured constructs
in other members of the Racket family so that students of HtDP/2e don’t
stumble across syntactic oddities.

HtDP/2e introduces loops and matching in an intermezzo, with the sole
purpose of acknowledging the existence of powerful linguistic
mechanisms.

Algebraic data types are provided for those who think teaching the
features of functional programming is more important than teaching
universally applicable ideas of program design.

Added in version 1.1 of package htdp-lib.

7.1. Loops and Comprehensions

                                        *for/list*
(for/list (comprehension-clause comprehension-clause ...) body-expr) ~
 
comprehension-clause = (name clause-expr)

evaluates body-expr for the parallel sequences of values  determined by
the comprehension-clauses.

Each comprehension-clause binds its name in  body-expr.

The for/list expression evaluates all clause-expr to  generate sequences
of values. If a clause-expr evaluates to a

* list, its items make up the sequence values;

* natural number n, the sequence of values consists of the numbers 0, 1,
  ..., (- n 1);

* string, its one-character strings are the sequence items.

For sequences generated by in-range and in-naturals, see below.

Finally, for/list evaluates  body-expr with  name ... successively bound
to the values of the sequences  determined by clause-expr ...

  > (for/list ((i 10))
      i)
  '(0 1 2 3 4 5 6 7 8 9)
  > (for/list ((i 2) (j '(a b)))
      (list i j))
  '((0 a) (1 b))
  > (for/list ((c "abc"))
      c)
  '("a" "b" "c")

The evaluation stops when the shortest sequence is exhausted.

  > (for/list ((i 2) (j '(a b c d e)))
      (list i j))
  '((0 a) (1 b))

                                        *for*/list*
(for*/list (comprehension-clause comprehension-clause ...) body-expr) ~

evaluates body-expr for the nested sequences of values  determined by
the comprehension-clauses.

Each comprehension-clause binds its name in the  expressions of the
following comprehension-clauses as well as  body-expr.

  > (for*/list ((i 2) (j '(a b)))
      (list i j))
  '((0 a) (0 b) (1 a) (1 b))
  > (for*/list ((i 5) (j i))
      (list i j))
  '((1 0) (2 0) (2 1) (3 0) (3 1) (3 2) (4 0) (4 1) (4 2) (4 3))

With nesting, the evaluation does not stop when the shortest sequence
is exhausted because comprehension-clauses are evaluated in order:

  > (for*/list ((i 2) (j '(a b c d e)))
      (list i j))
  '((0 a) (0 b) (0 c) (0 d) (0 e) (1 a) (1 b) (1 c) (1 d) (1 e))

                                        *for/or*
(for/or (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for/list. It produces the first non-#false value, if  any, and #false
otherwise.

  > (for/or ([c "abcd"])
       (if (string=? "x" c) c #false))
  #f
  > (for/or ([c (list #false 1 #false 2)])
       c)
  1

                                        *for*/or*
(for*/or (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for*/list. It produces the first non-#false value, if  any, and #false
otherwise.

  > (for*/or ([i 2][j i])
       (if (> j i) (list i j) #false))
  #f

                                        *for/and*
(for/and (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for/list. If any evaluation of body-expr produces  #false, the loop
stops and returns #false, too; otherwise,  the loop produces the result
of the last evaluation of body-expr.

  > (for/and ([c '(1 2 3)])
       (if (> c 4) c #false))
  #f
  > (for/and ([c '(1 2 3)])
       (if (< c 4) c #false))
  3

                                        *for*/and*
(for*/and (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for*/list. If any evaluation of body-expr produces  #false, the loop
stops and returns #false, too; otherwise,  the loop produces the result
of the last evaluation of body-expr.

  > (for*/and ([i 2][j i])
       (if (< j i) (list i j) #false))
  '(1 0)

                                        *for/sum*
(for/sum (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for/list. It adds up the numbers that body-expr  evaluates to.

  > (for/sum ([i 2][j 8])
       (max i j))
  1

                                        *for*/sum*
(for*/sum (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for*/list. It adds up the numbers that body-expr  evaluates to.

  > (for*/sum ([i 2][j i])
       (min i j))
  0

                                        *for/product*
(for/product (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for/list. It multiplies the numbers that body-expr  evaluates to.

  > (for/product ([i 2][j 3])
       (+ i j 1))
  3

                                        *for*/product*
(for*/product (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for*/list. It multiplies the numbers that body-expr  evaluates to.

  > (for*/product ([i 2][j i])
       (+ i j 1))
  2

                                        *for/string*
(for/string (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for/list. It collects the one-character strings that  body-expr
evaluates to with implode.

  > (for/string ([i "abc"])
       (int->string (+ (string->int i) 1)))
  "bcd"

                                        *for*/string*
(for*/string (comprehension-clause comprehension-clause ...) body-expr) ~

iterates over the sequences generated by the comprehension-clauses  like
for*/list. It collects the one-character strings that  body-expr
evaluates to with implode.

  > (for*/string ([i "ab"][j (- (string->int i) 90)])
       (int->string (+ (string->int i) j)))
  "abcdefgbcdefghi"

                                        *in-range*
(in-range start end step) -> sequence? ~
  start : natural-number/c ~
  end : natural-number/c ~
  step : natural-number/c ~
(in-range end) -> sequence?
  end : natural-number/c ~

generates a finite sequence of natural numbers.

If start, end, and step are provided, the  sequence consists of start,
(+ start step), (+ start step step), ...  until the sum is greater than
or equal to  end.

  > (for/list ([i (in-range 1 10 3)]) i)
  '(1 4 7)

If only end is provided, start defaults to 0  and step to 1:

  > (for/list ([i (in-range 3)])
      i)
  '(0 1 2)
  > (for/list ([i (in-range 0 3 1)])
      i)
  '(0 1 2)

                                        *in-naturals*
(in-naturals start) -> sequence? ~
  start : natural-number/c ~

generates an infinite sequence of natural numbers, starting with
start.

  > (define (enumerate a-list)
      (for/list ([x a-list][i (in-naturals 1)])
        (list i x)))
  > (enumerate '(Maxwell Einstein Planck Heisenberg Feynman))
  '((1 Maxwell) (2 Einstein) (3 Planck) (4 Heisenberg) (5 Feynman))
  > (enumerate '("Pinot noir" "Pinot gris" "Pinot blanc"))
  '((1 "Pinot noir") (2 "Pinot gris") (3 "Pinot blanc"))

7.2. Pattern Matching

                                        *match*
(match case-expr (pattern body-expr) ...) ~
 
pattern = name
        | literal-constant
        | (cons pattern pattern)
        | (name pattern ...)
        | (? name)

dispatches like a cond, matching the result of case-expr  sequentially
against all patterns. The first successful match  triggers the
evaluation of the matching body-expr, whose value is the  result of the
entire match expression.

The literal constants commonly used are numbers, strings, symbols, and
'().

Each pattern that contains names binds these names in the  corresponding
body-expr.

Matching a value with a pattern proceeds according to the following
rules.  If the pattern is a

* name, it matches any value;

* literal-constant, it matches only the literal constant;

* (cons pattern_1 pattern_2), it matches when the value is an instance
  of cons, and its first/rest fields match pattern_1 and pattern_2,
  respectively;

* (name pattern ...), it matches when the value is an instance of the
  name structure type, and its field values match pattern ...;

* (? name), it matches when name refers to a predicate function and the
  latter produces #true on the given value.

Furthermore, if the given pattern is name and the value is  V, name
stands for V during the evaluation of the  corresponding body-expr.

The following match expression distinguishes conses with '() in the
second position from all others:

  > (define (last-item l)
       (match l
         [(cons lst '()) lst]
         [(cons fst rst) (last-item rst)]))
  > (last-item '(a b c))
  'c

With ?, a match can use a predicate to distinguish arbitrary values:

  > (define (is-it-odd-or-even l)
       (match l
         [(? even?) 'even]
         [(? odd?)  'odd]))
  > (is-it-odd-or-even '1)
  'odd
  > (is-it-odd-or-even '2)
  'even

A match expression can also deal with structure instances:

  > (define-struct doll (layer))
  > (define (inside a-doll)
      (match a-doll
        [(? symbol?) a-doll]
        [(doll below) (inside below)]))
  > (inside (make-doll (make-doll 'wood)))
  'wood

Note, however, that the pattern uses just doll, the name of the
structure type, not make-doll, the constructor name.

7.3. Algebraic Data Types

                                        *define-type*
(define-type type (variant (field predicate) ...) ...) ~
 
     type = name
             
  variant = name
             
    field = name
             
predicate = name

defines structure types variant ... with fields  field ...,
respectively. In addition, it defines constructors  that enforce that
the field values satisfy the specified predicate. Finally,  it introduce
the name type as the name for the union of all  variant structure types
and type? as a predicate  that determines whether a value belongs to
this class of values.

Consider the following type definition:

  (define-type BTree
    (leaf (info number?))
    (node (left BTree?) (right BTree?)))

It defines two structure types:

  (define-struct leaf (info))
  (define-struct node (left right))

The make-leaf constructor signals an error when applied to any other
values but numbers, while make-node accepts only instances of  BTree.
Finally, BTree? is a predicate that recognizes such  instances:

  > (make-leaf 42)
  (leaf 42)
  > (make-node (make-leaf 42) (make-leaf 21))
  (node (leaf 42) (leaf 21))
  > (BTree? (make-node (make-leaf 42) (make-leaf 21)))
  #t

And here is how a constructor fails when applied to the wrong kind of
values:

  > (make-leaf 'four)
  make-leaf: contract violation
    expected: (or/c undefined? number?) ~
    given: 'four ~
    in: the 1st argument of ~
        (-> (or/c undefined? number?) leaf?)
    contract from: make-leaf ~
    blaming: use ~
     (assuming the contract is correct)
    at: program:2.0 ~

                                        *type-case*
(type-case type case-expr (variant (field ...) body-expr) ...) ~

dispatches like a cond, matching the result of case-expr sequentially
against all variants. The first successful match triggers the
evaluation of the matching body-expr, whose value is the result of  the
entire type-case expression.

A type-case expression also ensures that (1) the collection  variant
cases covers all variant structure type definitions in  type and (2)
that each variant clauses specifies as many fields as  the definition of
type specifies.

Assume that the following definition is placed in the scope of the above
type definition for BTree:

  (define (depth t)
    (type-case BTree t
      [leaf (info) 0]
      [node (left right) (+ (max (depth left) (depth right)) 1)]))

This function definition uses a type-case for BTree and the  latter
consists of two clauses: one for leafs and one for  nodes. The function
computes the depth of the given tree.

  > (depth (make-leaf 42))
  0
  > (depth (make-node (make-leaf 42) (make-leaf 21)))
  1

8. Planet Cute Images

 (require 2htdp/planetcute) package: htdp-lib ~

The 2htdp/planetcute library contains the Planet Cute art by Daniel Cook
(Lostgarden.com).

The images are designed to be overlaid with each other to build scenes
for use in games. Here is an example image taken from the Planet Cute
website.

  ; stack : non-empty-list-of-images -> image ~
  ; stacks 'imgs' on each other, separated by 40 pixels
  (define (stack imgs)
    (cond
      [(empty? (rest imgs)) (first imgs)]
      [else (overlay/xy (first imgs)
                        0 40
                        (stack (rest imgs)))]))

  > (beside/align
     "bottom"
     (stack (list wall-block-tall stone-block))
     (stack (list character-cat-girl
                  stone-block stone-block
                  stone-block stone-block))
     water-block
     (stack (list grass-block dirt-block))
     (stack (list grass-block dirt-block dirt-block)))
  #(struct:object:image% ...)

The Planet Cute images also include some shadows that can improve the
look of your game; see the Shadows section for an overview of how to use
them.

8.1. Characters

character-boy : image? ~

#(struct:object:image% ...)

character-cat-girl : image? ~

#(struct:object:image% ...)

character-horn-girl : image? ~

#(struct:object:image% ...)

character-pink-girl : image? ~

#(struct:object:image% ...)

character-princess-girl : image? ~

#(struct:object:image% ...)

enemy-bug : image? ~

#(struct:object:image% ...)

speech-bubble : image? ~

#(struct:object:image% ...)

8.2. Blocks

brown-block : image? ~

#(struct:object:image% ...)

dirt-block : image? ~

#(struct:object:image% ...)

grass-block : image? ~

#(struct:object:image% ...)

plain-block : image? ~

#(struct:object:image% ...)

stone-block-tall : image? ~

#(struct:object:image% ...)

stone-block : image? ~

#(struct:object:image% ...)

wall-block-tall : image? ~

#(struct:object:image% ...)

wall-block : image? ~

#(struct:object:image% ...)

water-block : image? ~

#(struct:object:image% ...)

wood-block : image? ~

#(struct:object:image% ...)

8.3. Items

chest-closed : image? ~

#(struct:object:image% ...)

chest-lid : image? ~

#(struct:object:image% ...)

chest-open : image? ~

#(struct:object:image% ...)

gem-blue : image? ~

#(struct:object:image% ...)

gem-green : image? ~

#(struct:object:image% ...)

gem-orange : image? ~

#(struct:object:image% ...)

heart : image? ~

#(struct:object:image% ...)

key : image? ~

#(struct:object:image% ...)

rock : image? ~

#(struct:object:image% ...)

selector : image? ~

#(struct:object:image% ...)

tree-short : image? ~

#(struct:object:image% ...)

tree-tall : image? ~

#(struct:object:image% ...)

tree-ugly : image? ~

#(struct:object:image% ...)

yellow-star : image? ~

#(struct:object:image% ...)

8.4. Ramps

ramp-east : image? ~

#(struct:object:image% ...)

ramp-north : image? ~

#(struct:object:image% ...)

ramp-south : image? ~

#(struct:object:image% ...)

ramp-west : image? ~

#(struct:object:image% ...)

8.5. Buildings

door-tall-closed : image? ~

#(struct:object:image% ...)

door-tall-open : image? ~

#(struct:object:image% ...)

roof-east : image? ~

#(struct:object:image% ...)

roof-north-east : image? ~

#(struct:object:image% ...)

roof-north-west : image? ~

#(struct:object:image% ...)

roof-north : image? ~

#(struct:object:image% ...)

roof-south-east : image? ~

#(struct:object:image% ...)

roof-south-west : image? ~

#(struct:object:image% ...)

roof-south : image? ~

#(struct:object:image% ...)

roof-west : image? ~

#(struct:object:image% ...)

window-tall : image? ~

#(struct:object:image% ...)

8.6. Shadows

The shadow images are intended to be overlaid on the other blocks when
they appear in certain configurations, as detailed here.

#(struct:object:bitmap% ...) #(struct:object:bitmap% ...)
#(struct:object:bitmap% ...) #(struct:object:bitmap% ...)

shadow-east : image? ~

#(struct:object:image% ...)

shadow-north-east : image? ~

#(struct:object:image% ...)

shadow-north-west : image? ~

#(struct:object:image% ...)

shadow-north : image? ~

#(struct:object:image% ...)

shadow-side-west : image? ~

#(struct:object:image% ...)

shadow-south-east : image? ~

#(struct:object:image% ...)

shadow-south-west : image? ~

#(struct:object:image% ...)

shadow-south : image? ~

#(struct:object:image% ...)

shadow-west : image? ~

#(struct:object:image% ...)

9. Porting World Programs to Universe

Matthias Felleisen, Robby Findler

9.1. The World is Not Enough

With the June 2009 release, we started deprecating the world teachpack;
instead  we recommended the use of the universe teachpack. With the
January 2010 release,  we are also introducing a new image teachpack
and, in support of this second  teachpack, we have separated out the
image functionality from the  functionality for world programs.

In this document, we explain how to port programs that assume the old
world  teachpack into this new setting, one step at a time. Most
importantly,  programs must now import two teachpacks insteead of one:

World Style           Universe Style
  (require htdp/world)  (require 2htdp/universe)
                        (require htdp/image)

The table shows the old style on the left and the new style on the
right. If your programs imported teachpacks via the drscheme teachpack
menu, we recommend that you use the require form from now on;
alternatively, you use the drscheme menu twice to import the  functions
from two teachpacks.

In the next section, we first explain how to port world programs so that
they use the universe teachpack and the old image teachpack. In the
section after that, we list suggestions for changing programs so that
they  no longer rely on the old image functionality but the new one.

In order to distinguish between the various pieces of functionality, we
uniformly prefix old functionality with "htdp:" and new functionality
with  "2htdp:". There is no need to use these prefixes in your programs
of  course.

9.2. Porting World Programs

Here is the first program from the documentation for the world
teachpack:

  (require htdp/world)
   
  ; Number -> Scene
  (define (create-UFO-scene height)
    (htdp:place-image UFO ~
                      50 height
                      (htdp:empty-scene 100 100))) ~
   
  ; Scene
  (define UFO
    (htdp:overlay ~
      (htdp:circle 10 'solid 'red) ~
      (htdp:rectangle 40 4 'solid 'red))) ~
   
  ; — run program run
  (htdp:big-bang 100 100 (/1 28) 0)
  (htdp:on-tick-event add1)
  (htdp:on-redraw create-UFO-scene)

This program defines a function for placing a UFO into a 100 by  100
scene, where UFO is a defined image. The world program itself  consists
of three lines:

* the first one creates the 100 by 100 scene, specifies a rate of 28
  images per second, and 0 as the initial world description;

* the second one says that for each clock tick, the world (a number) is
  increased by 1; and

* the last line tells drscheme to use create-UFO-scene as the function
  that renders the current world as a scene.

Let us now convert this program into the universe setting, step by
step, staring with the require specification, which is converted  as
above:

World Style           Universe Style
  (require htdp/world)  (require 2htdp/universe)
                        (require htdp/image)

The function that renders the world as a scene remains the same:

World Style                        Universe Style
  ; Number -> Scene                  ; Number -> Scene
  (define (create-UFO-scene height)  (define (create-UFO-scene height)
    (htdp:place-image                  (htdp:place-image ~
      UFO                                UFO
      50 height                          50 height
      (htdp:empty-scene 100 100)))       (htdp:empty-scene 100 100))) ~

For the image constant we switch from symbols to strings:

World Style               Universe Style
  ; Scene                   ; Scene
  (define UFO               (define UFO
    (htdp:overlay             (htdp:overlay ~
      (htdp:circle              (htdp:circle ~
       10 'solid 'red)           10 "solid" "red")
      (htdp:rectangle           (htdp:rectangle ~
       40 4 'solid 'red)))       40 4 "solid" "red")))

Strictly speaking, this isn’t necessary, but we intend to replace
symbols  with strings whenever possible because strings are more common
than  symbols.

The most important change concerns the lines that launch the world
program:

World Style                        Universe Style
  (htdp:big-bang 100 100 (/1 28) 0)  (2htdp:big-bang ~
  (htdp:on-tick-event add1)            0
  (htdp:on-redraw create-UFO-scene)    (on-tick add1)
                                       (on-draw create-UFO-scene))

They are turned into a single expression that comes with as many clauses
as there are lines in the old program. As you can see, the  big-bang
expression from the universe teachpack no longer  requires the
specification of the size of the scene or the rate at which  the clock
ticks (though it is possible to supply the clock rate if the default  is
not satisfactory).  Furthermore, the names of the clauses are similar to
the old names but shorter.

The other big change concerns key event handling and mouse event
handling. The respective handlers no longer accept symbols and chars but
strings only. Here is the first key event handler from the documentation
of the world teachpack:

World Style                      Universe Style
  (define (change w a-key-event)   (define (change w a-key-event)
    (cond                            (cond
      [(key=? a-key-event 'left)       [(key=? a-key-event "left")
       (world-go w -DELTA)]             (world-go w -DELTA)]
      [(key=? a-key-event 'right)      [(key=? a-key-event "right")
       (world-go w +DELTA)]             (world-go w +DELTA)]
      [(char? a-key-event)             [(= (string-length a-key-event) 1)
       w]                               w]
      [(key=? a-key-event 'up)         [(key=? a-key-event "up")
       (world-go w -DELTA)]             (world-go w -DELTA)]
      [(key=? a-key-event 'down)       [(key=? a-key-event "down")
       (world-go w +DELTA)]             (world-go w +DELTA)]
      [else                            [else
       w]))                             w]))

Note how the char? clause changed. Since all chars are now  represented
as strings containing one “letter”, the program on the right  just
checks the length of the string. Otherwise, we simply change all
symbols into strings.

If you ever recorded your programs’ work via an animated gif, you can
still  do so. Instead of adding a fifth argument to big-bang, however,
you will need to add a clause of the shape (record? x).

Finally, the universe teachpack implements a richer functionality than
the  world teachpack.

9.3. Porting Image Programs

The universe library also comes with a new image library, 2htdp/image.
Using the old image library still works fine with 2htdp/universe, but
the new image library provides a number of improvements, including
faster image comparison (especially useful in check-expect expressions),
rotating images, scaling images, curves, a number of new polygon shapes,
and more control over line drawing.

To use the new image library in isloation:

World Style           Universe Style
  (require htdp/image)  (require 2htdp/image)

and to use the new image library with the universe teachpack:

World Style           Universe Style
  (require htdp/world)  (require 2htdp/universe)
                        (require 2htdp/image)

Overlay vs Underlay

The htdp:overlay function places its first argument under its second
(and subsequent) arguments and so in 2htdp/image, we decided to call
that function 2htdp:underlay.

World Style               Universe Style
  (htdp:overlay             (2htdp:underlay
   (htdp:rectangle           (2htdp:rectangle ~
    10 20 "solid" "red")      10 20 "solid" "red")
   (htdp:rectangle           (2htdp:rectangle ~
    20 10 "solid" "blue"))    20 10 "solid" "blue"))

No more pinholes

The concept of pinholes from htdp/image has no correspondance in
2htdp/image (we do expect to bring back pinholes in 2htdp/image
eventually, but they will not be as pervasive as they are in
htdp/image).

Instead of a special position in the image that overlay operations are
sensitive to, 2htdp/image has a family of overlay operations, that
overlay images based on their centers or their edges.

Since the default position of the pinhole is in the center for most
images and the default for overlaying and underlaying images in
2htdp/image is based on the center, simple examples (like the one above)
behave the same in both libraries.

But, consider this expression that overlays two images on their
upper-left corners, written using both libraries.

World Style                              Universe Style
  (htdp:overlay                            (2htdp:underlay/align
   (htdp:put-pinhole                        "left" ~
    (htdp:rectangle 10 20 "solid" "red")    "top" ~
    0 0)                                    (2htdp:rectangle ~
   (htdp:put-pinhole                         10 20 "solid" "red") ~
    (htdp:rectangle 20 10 "solid" "blue")   (2htdp:rectangle ~
    0 0))                                    20 10 "solid" "blue"))

In the 2htdp/image version, the programmer uses 2htdp:underlay/align to
specify where the images should be lined up, instead of using the
pinhole.

Outlines in different places

The outline style shapes are now shifted by one pixel for 2htdp/image
images as compared to htdp/image. This means that these two rectangles
draw the same sets of pixels.

World Style                Universe Style
  (htdp:rectangle            (2htdp:rectangle
   11 11 "outline" "black")   10 10 "outline" "black")

See also The Nitty Gritty of Pixels, Pens, and Lines.

Star changed

The 2htdp:star function is a completely different function from
htdp:star. Both produce stars based, on polygons, but 2htdp:star always
produces a five-pointed star. See also 2htdp:star-polygon for more
general star shapes.
