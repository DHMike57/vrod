Operating System

    1 Paths
      1.1 Manipulating Paths
      1.2 More Path Utilities
      1.3 Unix and Mac OS Paths
        1.3.1 Unix Path Representation
      1.4 Windows Paths
        1.4.1 Windows Path Representation

    2 Filesystem
      2.1 Locating Paths
      2.2 Files
      2.3 Directories
      2.4 Detecting Filesystem Changes
      2.5 Declaring Paths Needed at Run Time
      2.6 More File and Directory Utilities

    3 Networking
      3.1 TCP
      3.2 UDP

    4 Processes
      4.1 Simple Subprocesses

    5 Logging
      5.1 Creating Loggers
      5.2 Logging Events
      5.3 Receiving Logged Events
      5.4 Additional Logging Functions

    6 Time
      6.1 Date Utilities

    7 Environment Variables

    8 Environment and Runtime Information

    9 Command-Line Parsing

    10 Additional Operating System Functions

1. Paths

When a Racket procedure takes a filesystem path as an argument, the path
can be provided either as a string or as an instance of the path
datatype. If a string is provided, it is converted to a path using
string->path. Beware that some paths may not be representable as
strings; see Unix Path Representation and Windows Path Representation
for more information. A Racket procedure that generates a filesystem
path always generates a path value.

By default, paths are created and manipulated for the current platform,
but procedures that merely manipulate paths (without using the
filesystem) can manipulate paths using conventions for other supported
platforms. The bytes->path procedure accepts an optional argument that
indicates the platform for the path, either 'unix or 'windows. For other
functions, such as build-path or simplify-path, the behavior is
sensitive to the kind of path that is supplied. Unless otherwise
specified, a procedure that requires a path accepts only paths for the
current platform.

Two path values are equal? when they are use the same convention type
and when their byte-string representations are equal?. A path string (or
byte string) cannot be empty, and it cannot contain a nul character or
byte. When an empty string or a string containing nul is provided as a
path to any procedure except absolute-path?, relative-path?, or
complete-path?, the exn:fail:contract exception is raised.

Most Racket primitives that accept paths first cleanse the path before
using it. Procedures that build paths or merely check the form of a path
do not cleanse paths, with the exceptions of cleanse-path,
expand-user-path, and simplify-path.  For more information about path
cleansing and other platform-specific details, see Unix and Mac OS Paths
and Windows Paths.

1.1. Manipulating Paths

                                        *path?*
(path? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a path value for the current platform (not a string,
and not a path for a different platform), #f otherwise.

                                        *path-string?*
(path-string? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is either a path or string: either a path for the
current platform or a non-empty string without nul characters. Returns
#f otherwise.

                                        *path-for-some-system?*
(path-for-some-system? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a path value for some platform (not a string), #f
otherwise.

                                        *string->path*
(string->path str) -> path? ~
  str : string? ~ ~

Produces a path whose byte-string encoding is (string->bytes/locale str
(char->integer #\?)) on Unix and Mac OS or (string->bytes/utf-8 str) on
Windows.

Beware that the current locale might not encode every string, in which
case string->path can produce the same path for different strs. See also
string->path-element, which should be used instead of string->path when
a string represents a single path element. For information on how
strings and byte strings encode paths, see Unix Path Representation and
Windows Path Representation.

See also string->some-system-path, and see Unix Path Representation and
Windows Path Representation for information on how strings encode paths.

Changed in version 6.1.1.1: Changed Windows conversion to always use
UTF-8.

                                        *bytes->path*
(bytes->path bstr [type]) -> path? ~
  bstr : bytes? ~ ~
  type : (or/c 'unix 'windows) = (system-path-convention-type) ~ ~

Produces a path (for some platform) whose byte-string encoding is bstr.
The optional type specifies the convention to use for the path.

For converting relative path elements from literals, use instead
bytes->path-element, which applies a suitable encoding for individual
elements.

For information on how byte strings encode paths, see Unix Path
Representation and Windows Path Representation.

                                        *path->string*
(path->string path) -> string? ~
  path : path? ~ ~

Produces a string that represents path by decoding path’s byte-string
encoding using the current locale on Unix and Mac OS and by using UTF-8
on Windows. In the former case, ? is used in the result string where
encoding fails, and if the encoding result is the empty string, then the
result is "?".

The resulting string is suitable for displaying to a user,
string-ordering comparisons, etc., but it is not suitable for
re-creating a path (possibly modified) via string->path, since decoding
and re-encoding the path’s byte string may lose information.

Furthermore, for display and sorting based on individual path elements
(such as pathless file names), use path-element->string, instead, to
avoid special encodings use to represent some relative paths. See
Windows Paths for specific information about the conversion of Windows
paths.

See also some-system-path->string.

Changed in version 6.1.1.1: Changed Windows conversion to always use
UTF-8.

                                        *path->bytes*
(path->bytes path) -> bytes? ~
  path : path-for-some-system? ~ ~

Produces path’s byte-string representation. No information is lost in
this translation, so that (bytes->path (path->bytes path)
(path-convention-type path)) always produces a path that is equal? to
path. The path argument can be a path for any platform.

Conversion to and from byte values is useful for marshaling and
unmarshaling paths, but manipulating the byte form of a path is
generally a mistake. In particular, the byte string may start with a
\\?\REL encoding for Windows paths. Instead of path->bytes, use
split-path and path-element->bytes to manipulate individual path
elements.

For information on how byte strings encode paths, see Unix Path
Representation and Windows Path Representation.

                                        *string->path-element*
(string->path-element str) -> path? ~
  str : string? ~ ~

Like string->path, except that str corresponds to a single relative
element in a path, and it is encoded as necessary to convert it to a
path. See Unix and Mac OS Paths and Windows Paths for more information
on the conversion of paths.

If str does not correspond to any path element (e.g., it is an absolute
path, or it can be split), or if it corresponds to an up-directory or
same-directory indicator on Unix and Mac OS, then exn:fail:contract
exception is raised.

Like path->string, information can be lost from str in the
locale-specific conversion to a path.

                                        *bytes->path-element*
(bytes->path-element bstr [type]) -> path-for-some-system? ~
  bstr : bytes? ~ ~
  type : (or/c 'unix 'windows) = (system-path-convention-type) ~ ~

Like bytes->path, except that bstr corresponds to a single relative
element in a path. In terms of conversions and restrictions on bstr,
bytes->path-element is like string->path-element.

The bytes->path-element procedure is generally the best choice for
reconstructing a path based on another path (where the other path is
deconstructed with split-path and path-element->bytes) when ASCII-level
manipulation of path elements is necessary.

                                        *path-element->string*
(path-element->string path) -> string? ~
  path : path-element? ~ ~

Like path->string, except that trailing path separators are removed (as
by split-path). On Windows, any \\?\REL encoding prefix is also removed;
see Windows Paths for more information.

The path argument must be such that split-path applied to path would
return 'relative as its first result and a path as its second result,
otherwise the exn:fail:contract exception is raised.

The path-element->string procedure is generally the best choice for
presenting a pathless file or directory name to a user.

                                        *path-element->bytes*
(path-element->bytes path) -> bytes? ~
  path : path-element? ~ ~

Like path->bytes, except that any encoding prefix is removed, etc., as
for path-element->string.

For any reasonable locale, consecutive ASCII characters in the printed
form of path are mapped to consecutive byte values that match each
character’s code-point value, and a leading or trailing ASCII character
is mapped to a leading or trailing byte, respectively. The path argument
can be a path for any platform.

The path-element->bytes procedure is generally the right choice (in
combination with split-path) for extracting the content of a path to
manipulate it at the ASCII level (then reassembling the result with
bytes->path-element and build-path).

                                        *path<?*
(path<? a-path b-path ...) -> boolean? ~
  a-path : path? ~ ~
  b-path : path? ~ ~

Returns #t if the arguments are sorted, where the comparison for each
pair of paths is the same as using path->bytes and bytes<?.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *path-convention-type*
(path-convention-type path) -> (or/c 'unix 'windows) ~
  path : path-for-some-system? ~ ~

Accepts a path value (not a string) and returns its convention type.

                                        *system-path-convention-type*
(system-path-convention-type) -> (or/c 'unix 'windows) ~

Returns the path convention type of the current platform: 'unix for Unix
and Mac OS, 'windows for Windows.

                                        *build-path*
(build-path base sub ...) -> path-for-some-system? ~
  base : (or/c path-string? path-for-some-system? 'up 'same) ~ ~
  sub : (or/c (and/c (or/c path-string? path-for-some-system?) ~ ~
                     (not/c complete-path?))
              (or/c 'up 'same))

Creates a path given a base path and any number of sub-path extensions.
If base is an absolute path, the result is an absolute path, otherwise
the result is a relative path.

The base and each sub must be either a relative path, the symbol 'up
(indicating the relative parent directory), or the symbol 'same
(indicating the relative current directory).  For Windows paths, if base
is a drive specification (with or without a trailing slash) the first
sub can be an absolute (driveless) path. For all platforms, the last sub
can be a filename.

The base and sub arguments can be paths for any platform. The platform
for the resulting path is inferred from the base and sub arguments,
where string arguments imply a path for the current platform. If
different arguments are for different platforms, the exn:fail:contract
exception is raised. If no argument implies a platform (i.e., all are
'up or 'same), the generated path is for the current platform.

Each sub and base can optionally end in a directory separator. If the
last sub ends in a separator, it is included in the resulting path.

If base or sub is an illegal path string (because it is empty or
contains a nul character), the exn:fail:contract exception is raised.

The build-path procedure builds a path without checking the validity of
the path or accessing the filesystem.

See Unix and Mac OS Paths and Windows Paths for more information on the
construction of paths.

The following examples assume that the current directory is
"/home/joeuser" for Unix examples and "C:\Joe’s Files" for Windows
examples.

  (define p1 (build-path (current-directory) "src" "racket"))
   ; Unix: p1 is "/home/joeuser/src/racket" ~ ~
   ; Windows: p1 is "C:\\Joe's Files\\src\\racket" ~ ~
  (define p2 (build-path 'up 'up "docs" "Racket"))
   ; Unix: p2 is "../../docs/Racket" ~ ~
   ; Windows: p2 is "..\\..\\docs\\Racket" ~ ~
  (build-path p2 p1)
   ; Unix and Windows: raises exn:fail:contract; p1 is absolute ~ ~
  (build-path p1 p2)
   ; Unix: is "/home/joeuser/src/racket/../../docs/Racket" ~ ~
   ; Windows: is "C:\\Joe's Files\\src\\racket\\..\\..\\docs\\Racket" ~ ~

                                        *build-path/convention-type*
(build-path/convention-type type          ~
                            base         
                            sub ...) -> path-for-some-system?
  type : (or/c 'unix 'windows) ~ ~
  base : (or/c path-string? path-for-some-system? 'up 'same) ~ ~
  sub : (or/c (and/c (or/c path-string? path-for-some-system?) ~ ~
                     (not/c complete-path?))
              (or/c 'up 'same))

Like build-path, except a path convention type is specified explicitly.

                                        *absolute-path?*
(absolute-path? path) -> boolean? ~
  path : (or/c path? string? path-for-some-system?) ~ ~

Returns #t if path is an absolute path, #f otherwise. The path argument
can be a path for any platform. If path is not a legal path string
(e.g., it contains a nul character), #f is returned. This procedure does
not access the filesystem.

                                        *relative-path?*
(relative-path? path) -> boolean? ~
  path : (or/c path? string? path-for-some-system?) ~ ~

Returns #t if path is a relative path, #f otherwise. The path argument
can be a path for any platform. If path is not a legal path string
(e.g., it contains a nul character), #f is returned. This procedure does
not access the filesystem.

                                        *complete-path?*
(complete-path? path) -> boolean? ~
  path : (or/c path? string? path-for-some-system?) ~ ~

Returns #t if path is a completely determined path (not relative to a
directory or drive), #f otherwise. The path argument can be a path for
any platform. Note that for Windows paths, an absolute path can omit the
drive specification, in which case the path is neither relative nor
complete. If path is not a legal path string (e.g., it contains a nul
character), #f is returned.

This procedure does not access the filesystem.

                                        *path->complete-path*
(path->complete-path path [base]) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  base : (or/c path-string? path-for-some-system?) ~ ~
       = (current-directory)

Returns path as a complete path. If path is already a complete path, it
is returned as the result. Otherwise, path is resolved with respect to
the complete path base. If base is not a complete path, the
exn:fail:contract exception is raised.

The path and base arguments can be paths for any platform; if they are
for different platforms, the exn:fail:contract exception is raised.

This procedure does not access the filesystem.

                                        *path->directory-path*
(path->directory-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns path if path syntactically refers to a directory and ends in a
separator, otherwise it returns an extended version of path that
specifies a directory and ends with a separator. For example, on Unix
and Mac OS, the path "x/y/" syntactically refers to a directory and ends
in a separator, but "x/y" would be extended to "x/y/", and "x/.." would
be extended to "x/../". The path argument can be a path for any
platform, and the result will be for the same platform.

This procedure does not access the filesystem.

                                        *resolve-path*
(resolve-path path) -> path? ~
  path : path-string? ~ ~

Cleanses path and returns a path that references the same file or
directory as path. If path is a soft link to another path, then the
referenced path is returned (this may be a relative path with respect to
the directory owning path), otherwise path is returned (after
expansion).

On Windows, the path for a link should be simplified syntactically, so
that an up-directory indicator removes a preceding path element
independent of whether the preceding element itself refers to a link.
For relative-paths links, the path should be parsed specially; see
Windows Paths for more information.

Changed in version 6.0.1.12: Added support for links on Windows.

                                        *cleanse-path*
(cleanse-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Cleanses path (as described at the beginning of this chapter) without
consulting the filesystem.

Example:

  > (let ([p (string->some-system-path "tiny//dancer" 'unix)])
      (cleanse-path p))
  #<path:tiny/dancer>

                                        *expand-user-path*
(expand-user-path path) -> path? ~
  path : path-string? ~ ~

Cleanses path. In addition, on Unix and Mac OS, a leading ~ is treated
as user’s home directory and expanded; the username follows the ~
(before a / or the end of the path), where ~ by itself indicates the
home directory of the current user.

                                        *simplify-path*
(simplify-path path [use-filesystem?]) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  use-filesystem? : boolean? = #t ~ ~

Eliminates redundant path separators (except for a single trailing
separator), up-directory .., and same-directory . indicators in path,
and changes / separators to \ separators in Windows paths, such that the
result accesses the same file or directory (if it exists) as path.

In general, the pathname is normalized as much as possible—without
consulting the filesystem if use-filesystem? is #f, and (on Windows)
without changing the case of letters within the path.  If path
syntactically refers to a directory, the result ends with a directory
separator.

When path is simplified and use-filesystem? is true (the default), a
complete path is returned. If path is relative, it is resolved with
respect to the current directory. On Unix and Mac OS, up-directory
indicators are removed taking into account soft links (so that the
resulting path refers to the same directory as before); on Windows,
up-directory indicators are removed by deleting a preceding path
element.

When use-filesystem? is #f, up-directory indicators are removed by
deleting a preceding path element, and the result can be a relative path
with up-directory indicators remaining at the beginning of the path;
up-directory indicators are dropped when they refer to the parent of a
root directory. Similarly, the result can be the same as (build-path
'same) (but with a trailing separator) if eliminating up-directory
indicators leaves only same-directory indicators.

The path argument can be a path for any platform when use-filesystem? is
#f, and the resulting path is for the same platform.

The filesystem might be accessed when use-filesystem? is true, but the
source or simplified path might be a non-existent path. If path cannot
be simplified due to a cycle of links, the exn:fail:filesystem exception
is raised (but a successfully simplified path may still involve a cycle
of links if the cycle did not inhibit the simplification).

See Unix and Mac OS Paths and Windows Paths for more information on
simplifying paths.

Example:

  >
  (let ([p (string->some-system-path "tiny//in/my/head/../../../dancer" 'unix)])
      (simplify-path p #f))
  #<path:tiny/dancer>

                                        *normal-case-path*
(normal-case-path path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns path with “normalized” case characters. For Unix and Mac OS
paths, this procedure always returns the input path, because filesystems
for these platforms can be case-sensitive. For Windows paths, if path
does not start with \\?\, the resulting string uses only lowercase
letters, based on the current locale. In addition, for Windows paths
when the path does not start with \\?\, all /s are converted to \s, and
trailing spaces and .s are removed.

The path argument can be a path for any platform, but beware that
local-sensitive decoding and conversion of the path may be different on
the current platform than for the path’s platform.

This procedure does not access the filesystem.

                                        *split-path*
(split-path path) -> (or/c path-for-some-system? 'relative #f) ~
                     (or/c path-for-some-system? 'up 'same)
                     boolean?
  path : (or/c path-string? path-for-some-system?) ~ ~

Deconstructs path into a smaller path and an immediate directory or file
name.  Three values are returned:

* base is either

  * a path,

  * 'relative if path is an immediate relative directory or filename, or

  * #f if path is a root directory.

* name is either

  * a directory-name path,

  * a filename,

  * 'up if the last part of path specifies the parent directory of the
    preceding path (e.g., .. on Unix), or

  * 'same if the last part of path specifies the same directory as the
    preceding path (e.g., . on Unix).

* must-be-dir? is #t if path explicitly specifies a directory (e.g.,
  with a trailing separator), #f otherwise. Note that must-be-dir? does
  not specify whether name is actually a directory or not, but whether
  path syntactically specifies a directory.

Compared to path, redundant separators (if any) are removed in the
result base and name.  If base is #f, then name cannot be 'up or 'same.
The path argument can be a path for any platform, and resulting paths
for the same platform.

This procedure does not access the filesystem.

See Unix and Mac OS Paths and Windows Paths for more information on
splitting paths.

                                        *explode-path*
(explode-path path) ~
 -> (listof (or/c path-for-some-system? 'up 'same))
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns the list of path elements that constitute path.  If path is
simplified in the sense of simple-form-path, then the result is always a
list of paths, and the first element of the list is a root.

The explode-path function computes its result in time proportional to
the length of path (unlike a loop in that uses split-path, which must
allocate intermediate paths).

                                        *path-replace-extension*
(path-replace-extension path ext) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  ext : (or/c string? bytes?) ~ ~

Returns a path that is the same as path, except that the extension for
the last element of the path (including the extension separator) is
changed to ext. If the last element of path has no extension, then ext
is added to the path.

An extension is defined as a . that is not at the start of the path
element followed by any number of non-. characters/bytes at the end of
the path element, as long as the path element is not a directory
indicator like "..".

The path argument can be a path for any platform, and the result is for
the same platform. If path represents a root, the exn:fail:contract
exception is raised. The given ext typically starts with ., but it is
not required to start with an extension separator.

Examples:

  > (path-replace-extension "x/y.ss" #".rkt")
  #<path:x/y.rkt>
  > (path-replace-extension "x/y.ss" #"")
  #<path:x/y>
  > (path-replace-extension "x/y" #".rkt")
  #<path:x/y.rkt>
  > (path-replace-extension "x/y.tar.gz" #".rkt")
  #<path:x/y.tar.rkt>
  > (path-replace-extension "x/.racketrc" #".rkt")
  #<path:x/.racketrc.rkt>

Added in version 6.5.0.3.

                                        *path-add-extension*
(path-add-extension path ext [sep]) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  ext : (or/c string? bytes?) ~ ~
  sep : (or/c string? bytes?) = #"_" ~ ~

Similar to path-replace-extension, but any existing extension on path is
preserved by replacing the . before the extension with sep, and then the
ext is added to the end.

Examples:

  > (path-add-extension "x/y.ss" #".rkt")
  #<path:x/y_ss.rkt>
  > (path-add-extension "x/y" #".rkt")
  #<path:x/y.rkt>
  > (path-add-extension "x/y.tar.gz" #".rkt")
  #<path:x/y.tar_gz.rkt>
  > (path-add-extension "x/y.tar.gz" #".rkt" #".")
  #<path:x/y.tar.gz.rkt>
  > (path-add-extension "x/.racketrc" #".rkt")
  #<path:x/.racketrc.rkt>

Added in version 6.5.0.3. Changed in version 6.8.0.2: Added the sep
optional argument.

                                        *path-replace-suffix*
(path-replace-suffix path ext) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  ext : (or/c string? bytes?) ~ ~

  NOTE: This function is deprecated; use path-replace-extension,
  instead.

Like path-replace-extension, but treats a leading . in a path element as
an extension separator.

                                        *path-add-suffix*
(path-add-suffix path ext) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  ext : (or/c string? bytes?) ~ ~

  NOTE: This function is deprecated; use path-add-extension, instead.

Like path-add-extension, but treats a leading . in a path element as an
extension separator.

                                        *reroot-path*
(reroot-path path root-path) -> path-for-some-system? ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  root-path : (or/c path-string? path-for-some-system?) ~ ~

Produces a path that extends root-path based on the complete form of
path.

If path is not already complete, is it completed via
path->complete-path, in which case path must be a path for the current
platform. The path argument is also cleansed and case-normalized via
normal-case-path. The path is then appended to root-path; in the case of
Windows paths, a root letter drive becomes a letter path element, while
a root UNC path is prefixed with "UNC" as a path element and the machine
and volume names become path elements.

Examples:

  > (reroot-path (bytes->path #"/home/caprica/baltar" 'unix)
                 (bytes->path #"/earth" 'unix))
  #<path:/earth/home/caprica/baltar>
  > (reroot-path (bytes->path #"c:\\usr\\adama" 'windows) ~ ~
                 (bytes->path #"\\\\earth\\africa\\" 'windows))
  #<windows-path:\\earth\africa\c\usr\adama>
  > (reroot-path (bytes->path #"\\\\galactica\\cac\\adama" 'windows)
                 (bytes->path #"s:\\earth\\africa\\" 'windows)) ~ ~
  #<windows-path:s:\earth\africa\UNC\galactica\cac\adama>

1.2. More Path Utilities

 (require racket/path) package: base ~ ~

The bindings documented in this section are provided by the racket/path
and racket libraries, but not racket/base.

                                        *file-name-from-path*
(file-name-from-path path) -> (or/c path-for-some-system? #f) ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns the last element of path. If path is syntactically a directory
path (see split-path), then the result is #f.

                                        *path-get-extension*
(path-get-extension path) -> (or/c bytes? #f) ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns a byte string that is the extension part of the filename in
path, including the . separator. If the path has no extension, #f is
returned.

See path-replace-extension for the definition of a filename extension.

Examples:

  > (path-get-extension "x/y.rkt")
  #".rkt"
  > (path-get-extension "x/y")
  #f
  > (path-get-extension "x/y.tar.gz")
  #".gz"
  > (path-get-extension "x/.racketrc")
  #f

Added in version 6.5.0.3 of package base.

                                        *path-has-extension?*
(path-has-extension? path ext) -> (or/c bytes? #f) ~
  path : (or/c path-string? path-for-some-system?) ~ ~
  ext : (or/c bytes? string?) ~ ~

Determines whether the last element of path ends with ext but is not
exactly the same as ext.

If ext is a byte string with the shape of an extension (i.e., starting
with .), this check is equivalent to checking whether
(path-get-extension path) produces ext.

Examples:

  > (path-has-extension? "x/y.rkt" #".rkt")
  #t
  > (path-has-extension? "x/y.ss" #".rkt")
  #f
  > (path-has-extension? "x/y" #".rkt")
  #f
  > (path-has-extension? "x/.racketrc" #".racketrc")
  #f
  > (path-has-extension? "x/compiled/y_rkt.zo" #"_rkt.zo")
  #t

Added in version 6.5.0.3 of package base.

                                        *filename-extension*
(filename-extension path) -> (or/c bytes? #f) ~
  path : (or/c path-string? path-for-some-system?) ~ ~

  NOTE: This function is deprecated; use path-get-extension, instead.

Returns a byte string that is the extension part of the filename in path
without the . separator. If path is syntactically a directory (see
split-path) or if the path has no extension, #f is returned.

                                        *find-relative-path*
(find-relative-path  base                                 ~
                     path                                
                    [#:more-than-root? more-than-root?    ~ ~
                     #:more-than-same? more-than-same?    ~ ~
                     #:normalize-case? normalize-case?])  ~ ~
 -> (or/c path-for-some-system? path-string?)
  base : (or/c path-string? path-for-some-system?) ~ ~
  path : (or/c path-string?  path-for-some-system?) ~ ~
  more-than-root? : any/c = #f ~ ~
  more-than-same? : any/c = #t ~ ~
  normalize-case? : any/c = #t ~ ~

Finds a relative pathname with respect to base that names the same file
or directory as path. Both base and path must be simplified in the sense
of simple-form-path. If path shares no subpath in common with base, path
is returned.

If more-than-root? is true, if base and path share only a Unix root in
common, and if neither base nor path is just a root path, then path is
returned.

If path is the same as base, then (build-path 'same) is returned only if
more-than-same? is true. Otherwise, path is returned when path is the
same as base.

If normalize-case? is true (the default), then pairs of path elements to
be compared are first converted via normal-case-path, which means that
path elements are comparsed case-insentively on Windows. If
normalize-case? is #f, then path elements and the path roots match only
if they have the same case.

The result is normally a path in the sense of path?. The result is a
string only if path is provided a string and also returned as the
result.

Changed in version 6.8.0.3 of package base: Made path elements
case-normalized for comparison by default, and added the
#:normalize-case? argument. Changed in version 6.90.0.21: Added the
#:more-than-same? argument.

                                        *normalize-path*
(normalize-path path [wrt]) -> path? ~
  path : path-string? ~ ~
  wrt : (and/c path-string? complete-path?) ~ ~
      = (current-directory)

For most purposes, simple-form-path is the preferred mechanism to
normalize a path, because it works for paths that include non-existent
directory components, and it avoids unnecessarily expanding soft links.

Returns a complete version of path by making the path complete,
expanding the complete path, and resolving all soft links (which
requires consulting the filesystem). If path is relative, then wrt is
used as the base path.

Letter case is not normalized by normalize-path. For this and other
reasons, such as whether the path is syntactically a directory, the
result of normalize-path is not suitable for comparisons that determine
whether two paths refer to the same file or directory (i.e., the
comparison may produce false negatives).

An error is signaled by normalize-path if the input path contains an
embedded path for a non-existent directory, or if an infinite cycle of
soft links is detected.

Example:

  > (equal? (current-directory) (normalize-path "."))
  #t

                                        *path-element?*
(path-element? path) -> boolean? ~
  path : any/c ~ ~

Returns #t if path is a path element: a path value for some platform
(see path-for-some-system?) such that split-path applied to path would
return 'relative as its first result and a path as its second result.
Otherwise, the result is #f.

                                        *path-only*
(path-only path) -> (or/c #f path-for-some-system?) ~
  path : (or/c path-string? path-for-some-system?) ~ ~

Returns path without its final path element in the case that path is not
syntactically a directory; if path has only a single, non-directory path
element, #f is returned. If path is syntactically a directory, then path
is returned unchanged (but as a path, if it was a string).

Examples:

  > (path-only (build-path "a" "b"))
  #<path:a/>
  > (path-only (build-path "a"))
  #f
  > (path-only (path->directory-path (build-path "a")))
  #<path:a/>
  > (path-only (build-path 'up 'up))
  #<path:../..>

                                        *simple-form-path*
(simple-form-path path) -> path? ~
  path : path-string? ~ ~

Returns (simplify-path (path->complete-path path)), which ensures that
the result is a complete path containing no up- or same-directory
indicators.

                                        *some-system-path->string*
(some-system-path->string path) -> string? ~
  path : path-for-some-system? ~ ~

Converts path to a string using a UTF-8 encoding of the path’s bytes.

Use this function when working with paths for a different system (whose
encoding of pathnames might be unrelated to the current locale’s
encoding) and when starting and ending with strings.

                                        *string->some-system-path*
(string->some-system-path str kind) -> path-for-some-system? ~
  str : string? ~ ~
  kind : (or/c 'unix 'windows) ~ ~

Converts str to a kind path using a UTF-8 encoding of the path’s bytes.

Use this function when working with paths for a different system (whose
encoding of pathnames might be unrelated to the current locale’s
encoding) and when starting and ending with strings.

                                        *shrink-path-wrt*
(shrink-path-wrt pth other-pths) -> (or/c #f path?) ~
  pth : path? ~ ~
  other-pths : (listof path?) ~ ~

Returns a suffix of pth that shares nothing in common with the suffixes
of other-pths, or pth, if not possible (e.g. when other-pths is empty or
contains only paths with the same elements as pth).

Examples:

  > (shrink-path-wrt (build-path "racket" "list.rkt")
                     (list (build-path "racket" "list.rkt")
                           (build-path "racket" "base.rkt")))
  #<path:list.rkt>
  > (shrink-path-wrt (build-path "racket" "list.rkt")
                     (list (build-path "racket" "list.rkt")
                           (build-path "racket" "private" "list.rkt")
                           (build-path "racket" "base.rkt")))
  #<path:racket/list.rkt>

1.3. Unix and Mac OS Paths

In a path on Unix and Mac OS, a / separates elements of the path, . as a
path element always means the directory indicated by preceding path, and
.. as a path element always means the parent of the directory indicated
by the preceding path. A leading ~ in a path is not treated specially,
but expand-user-path can be used to convert a leading ~ element to a
user-specific directory. No other character or byte has a special
meaning within a path. Multiple adjacent / are equivalent to a single /
(i.e., they act as a single path separator).

A path root is always /. A path starting with / is an absolute, complete
path, and a path starting with any other character is a relative path.

Any pathname that ends with a / syntactically refers to a directory, as
does any path whose last element is . or ...

A Unix and Mac OS path is cleansed by replacing multiple adjacent /s
with a single /.

For (bytes->path-element bstr), bstr must not contain any /, otherwise
the exn:fail:contract exception is raised. The result of
(path-element->bytes path) or (path-element->string path) is always the
same as the result of (path->bytes path) and (path->string path). Since
that is not the case for other platforms, however, path-element->bytes
and path-element->string should be used when converting individual path
elements.

On Mac OS, Finder aliases are zero-length files.

1.3.1. Unix Path Representation

A path on Unix and Mac OS is natively a byte string. For presentation to
users and for other string-based operations, a path is converted to/from
a string using the current locale’s encoding with ? (encoding) or
#\uFFFD (decoding) in place of errors. Beware that the encoding may not
accommodate all possible paths as distinct strings.

1.4. Windows Paths

In general, a Windows pathname consists of an optional drive specifier
and a drive-specific path. A Windows path can be absolute but still
relative to the current drive; such paths start with a / or \ separator
and are not UNC paths or paths that start with \\?\.

A path that starts with a drive specification is complete. Roughly, a
drive specification is either a Latin letter followed by a colon, a UNC
path of the form \\>machine<\>volume<, or a \\?\ form followed by
something other than REL\>element<, or RED\>element<. (Variants of \\?\
paths are described further below.)

Racket fails to implement the usual Windows path syntax in one way.
Outside of Racket, a pathname "C:rant.txt" can be a drive-specific
relative path. That is, it names a file "rant.txt" on drive "C:", but
the complete path to the file is determined by the current working
directory for drive "C:". Racket does not support drive-specific working
directories (only a working directory across all drives, as reflected by
the current-directory parameter). Consequently, Racket implicitly
converts a path like "C:rant.txt" into "C:\rant.txt".

* Racket-specific: Whenever a path starts with a drive specifier
  >letter<: that is not followed by a / or \, a \ is inserted as the
  path is cleansed.

Otherwise, Racket follows standard Windows path conventions, but also
adds \\?\REL and \\?\RED conventions to  deal with paths inexpressible
in the standard convention, plus  conventions to deal with excessive \s
in \\?\  paths.

In the following, >letter< stands for a Latin letter (case does not
matter), >machine< stands for any sequence of characters that does not
include \ or / and is not ?, >volume< stands for any sequence of
characters that does not include \ or / , and >element< stands for any
sequence of characters that does not include \.

* Trailing spaces and . in a path element are ignored when the element
  is the last one in the path, unless the path starts with \\?\ or the
  element consists of only spaces and .s.

* The following special “files”, which access devices, exist in all
  directories, case-insensitively, and with all possible endings after a
  period or colon, except in pathnames that start with \\?\: "NUL",
  "CON", "PRN", "AUX", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6",
  "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5",
  "LPT6", "LPT7", "LPT8", "LPT9".

* Except for \\?\ paths, /s are equivalent to \s. Except for \\?\ paths
  and the start of UNC paths, multiple adjacent /s and \s count as a
  single \. In a path that starts \\?\ paths, elements can be separated
  by either a single or double \.

* A directory can be accessed with or without a trailing separator. In
  the case of a non-\\?\ path, the trailing separator can be any number
  of /s and \s; in the case of a \\?\ path, a trailing separator must be
  a single \, except that two \s can follow \\?\>letter<:.

* Except for \\?\ paths, a single . as a path element means “the current
  directory,” and a .. as a path element means “the parent directory.”
  Up-directory path elements (i.e., ..) immediately after a drive are
  ignored.

* A pathname that starts \\>machine<\>volume< (where a / can replace any
  \) is a UNC path, and the starting \\>machine<\>volume< counts as the
  drive specifier.

* Normally, a path element cannot contain a character in the range #\x 0
  to #\x 1F nor any of the following characters:

  < > : " / \ |

  Except for \, path elements containing these characters can be
  accessed using a \\?\ path (assuming that the underlying filesystem
  allows the characters).

* In a pathname that starts \\?\>letter<:\, the \\?\>letter<:\ prefix
  counts as the path’s drive, as long as the path does not both contain
  non-drive elements and end with two consecutive \s, and as long as the
  path contains no sequence of three or more \s. Two \s can appear in
  place of the \ before >letter<. A / cannot be used in place of a \
  (but /s can be used in element names, though the result typically does
  not name an actual directory or file).

* In a pathname that starts \\?\UNC\>machine<\>volume<, the
  \\?\UNC\>machine<\>volume< prefix counts as the path’s drive, as long
  as the path does not end with two consecutive \s, and as long as the
  path contains no sequence of three or more \s. Two \s can appear in
  place of the \ before UNC, the \s after UNC, and/or the \s
  after>machine<.  The letters in the UNC part can be uppercase or
  lowercase, and / cannot be used in place of \s (but / can be used in
  element names).

* Racket-specific: A pathname that starts \\?\REL\>element< or
  \\?\REL\\>element< is a relative path, as long as the path does not
  end with two consecutive \s, and as long as the path contains no
  sequence of three or more \s. This Racket-specific path form supports
  relative paths with elements that are not normally expressible in
  Windows paths (e.g., a final element that ends in a space). The REL
  part must be exactly the three uppercase letters, and /s cannot be
  used in place of \s. If the path starts \\?\REL\..  then for as long
  as the path continues with repetitions of \.., each element counts as
  an up-directory element; a single \ must be used to separate the
  up-directory elements. As soon as a second \ is used to separate the
  elements, or as soon as a non-..  element is encountered, the
  remaining elements are all literals (never up-directory elements).
  When a \\?\REL path value is converted to a string (or when the path
  value is written or displayed), the string does not contain the
  starting \\?\REL or the immediately following \s; converting a path
  value to a byte string preserves the \\?\REL prefix.

* Racket-specific: A pathname that starts \\?\RED\>element< or
  \\?\RED\\>element< is a drive-relative path, as long as the path does
  not end with two consecutive \s, and as long as the path contains no
  sequence of three or more \s. This Racket-specific path form supports
  drive-relative paths (i.e., absolute given a drive) with elements that
  are not normally expressible in Windows paths. The RED part must be
  exactly the three uppercase letters, and /s cannot be used in place of
  \s. Unlike \\?\REL paths, a .. element is always a literal path
  element. When a \\?\RED path value is converted to a string (or when
  the path value is written or displayed), the string does not contain
  the starting \\?\RED and it contains a single starting \; converting a
  path value to a byte string preserves the \\?\RED prefix.

Three additional Racket-specific rules provide meanings to character
sequences that are otherwise ill-formed as Windows paths:

* Racket-specific: In a pathname of the form \\?\>any<\\ where >any< is
  any non-empty sequence of characters other than >letter<: or
  \>letter<:, the entire path counts as the path’s (non-existent) drive.

* Racket-specific: In a pathname of the form \\?\>any<\\\>elements<,
  where >any< is any non-empty sequence of characters and >elements< is
  any sequence that does not start with a \, does not end with two \s,
  and does not contain a sequence of three \s, then \\?\>any<\\ counts
  as the path’s (non-existent) drive.

* Racket-specific: In a pathname that starts \\?\ and does not match any
  of the patterns from the preceding bullets, \\?\ counts as the path’s
  (non-existent) drive.

Outside of Racket, except for \\?\ paths, pathnames are  typically
limited to 259 characters. Racket internally converts  pathnames to \\?\
form as needed to avoid this  limit. The operating system cannot access
files through  \\?\ paths that are longer than 32,000 characters or  so.

Where the above descriptions says “character,” substitute “byte” for
interpreting byte strings as paths. The encoding of Windows paths into
bytes preserves ASCII characters, and all special characters mentioned
above are ASCII, so all of the rules are the same.

Beware that the \ path separator is an escape character in Racket
strings. Thus, the path \\?\REL\..\\..  as a string must be written
"\\\\?\\REL\\..\\\\..".

A path that ends with a directory separator syntactically refers to a
directory.  In addition, a path syntactically refers to a directory if
its last element is a same-directory or up-directory indicator (not
quoted by a \\?\ form), or if it refers to a root.

Even on variants of Windows that support symbolic links, up-directory ..
indicators in a path are resolved syntactically, not sensitive to links.
For example, if a path ends with d\..\f and d refers to a symbolic link
that references a directory with a different parent than d, the path
nevertheless refers to f in the same directory as d. A relative-path
link is parsed as if prefixed with \\?\REL paths, except that ..  and .
elements are allowed throughout the path, and any number of redundant /
separators are allowed.

Windows paths are cleansed as follows: In paths that start \\?\,
redundant \s are removed, an extra \ is added in a \\?\REL if an extra
one is not already present to separate up-directory indicators from
literal path elements, and an extra \ is similarly added after \\?\RED
if an extra one is not already present. For other paths, multiple /s and
\s are converted to single /s or \ (except at the beginning of a shared
folder name), and a \ is inserted after the colon in a drive
specification if it is missing.

For (bytes->path-element bstr), /s, colons, trailing dots, trailing
whitespace, and special device names (e.g., “aux”) in bstr are encoded
as a literal part of the path element by using a \\?\REL prefix.  The
bstr argument must not contain a \, otherwise the exn:fail:contract
exception is raised.

For (path-element->bytes path) or (path-element->string path), if the
byte-string form of path starts with a \\?\REL, the prefix is not
included in the result.

For (build-path base-path sub-path ...), trailing spaces and periods are
removed from the last element of base-path and all but the last sub-path
(unless the element consists of only spaces and periods), except for
those that start with \\?\. If base-path starts \\?\, then after each
non-\\?\REL\ and non-\\?\RED\ sub-path is added, all /s in the addition
are converted to \s, multiple consecutive \s are converted to a single
\, added . elements are removed, and added .. elements are removed along
with the preceding element; these conversions are not performed on the
original base-path part of the result or on any \\?\REL\ or \\?\RED\ or
sub-path.  If a \\?\REL\ or \\?\RED\ sub-path is added to a non-\\?\
base-path, the base-path (with any additions up to the \\?\REL\ or
\\?\RED\ sub-path) is simplified and converted to a \\?\ path.  In other
cases, a \ may be added or removed before combining paths to avoid
changing the root meaning of the path (e.g., combining //x and y
produces /x/y, because //x/y would be a UNC path instead of a
drive-relative path).

For (simplify-path path use-filesystem?), path is expanded, and if path
does not start with \\?\, trailing spaces and periods are removed, a /
is inserted after the colon in a drive specification if it is missing,
and a \ is inserted after \\?\ as a root if there are elements and no
extra \ already. Otherwise, if no indicators or redundant separators are
in path, then path is returned.

For (split-path path) producing base, name, and must-be-dir?, splitting
a path that does not start with \\?\ can produce parts that start with
\\?\. For example, splitting C:/x~/aux/ produces \\?\C:\x~\ and
\\?\REL\\aux; the \\?\ is needed in these cases to preserve a trailing
space after x and to avoid referring to the AUX device instead of an
"aux" file.

1.4.1. Windows Path Representation

A path on Windows is natively a sequence of UTF-16 code units, where the
sequence can include unpaired surrogates. This sequence is encoded as a
byte string through an extension of UTF-8, where unpaired surrogates in
the UTF-16 code-unit sequence are converted as if they were
non-surrogate values. The extended encodings are implemented on Windows
as the "platform-UTF-16" and "platform-UTF-8" encodings for
bytes-open-converter.

Racket’s internal representation of a Windows path is a byte string, so
that path->bytes and bytes->path are always inverses. When converting a
path to a native UTF-16 code-unit sequence, #\tab is used in place of
platform-UTF-8 decoding errors (on the grounds that tab is normally
disallowed as a character in a Windows path, unlike #\uFFFD).

A Windows path is converted to a string by treating the platform-UTF-8
encoding as a UTF-8 encoding with #\uFFFD in place of decoding errors.
Similarly, a string is converted to a path by UTF-8 encoding (in which
case no errors are possible).

2. Filesystem

2.1. Locating Paths

                                        *find-system-path*
(find-system-path kind) -> path? ~
  kind : symbol? ~ ~

Returns a machine-specific path for a standard type of path specified by
kind, which must be one of the following:

* 'home-dir — the current user’s home directory.

  On all platforms, if the PLTUSERHOME environment variable is defined
  as a complete path, then the path is used as the user’s home
  directory.

  On Unix and Mac OS, when PLTUSERHOME does not apply, the user’s home
  directory is determined by expanding the path "~", which is expanded
  by first checking for a HOME environment variable. If none is defined,
  the USER and LOGNAME environment variables are consulted (in that
  order) to find a user name, and then system files are consulted to
  locate the user’s home directory.

  On Windows, when PLTUSERHOME does not apply, the user’s home directory
  is the user-specific profile directory as determined by the Windows
  registry. If the registry cannot provide a directory for some reason,
  the value of the USERPROFILE environment variable is used instead, as
  long as it refers to a directory that exists. If USERPROFILE also
  fails, the directory is the one specified by the HOMEDRIVE and
  HOMEPATH environment variables.  If those environment variables are
  not defined, or if the indicated directory still does not exist, the
  directory containing the current executable is used as the home
  directory.

* 'pref-dir — the standard directory for storing the current user’s
  preferences. On Unix, the directory is ".racket" in the user’s home
  directory.  On Windows, it is "Racket" in the user’s home directory if
  determined by PLTUSERHOME, otherwise in the user’s application-data
  folder as specified by the Windows registry; the application-data
  folder is usually "Application Data" in the user’s profile directory.
  On Mac OS, the preferences directory is "Library/Preferences" in the
  user’s home directory. The preferences directory might not exist.

* 'pref-file — a file that contains a symbol-keyed association list of
  preference values. The file’s directory path always matches the result
  returned for 'pref-dir. The file name is "racket-prefs.rktd" on Unix
  and Windows, and it is "org.racket-lang.prefs.rktd" on Mac OS. The
  file’s directory might not exist. See also get-preference.

* 'temp-dir — the standard directory for storing temporary files. On
  Unix and Mac OS, this is the directory specified by the TMPDIR
  environment variable, if it is defined, otherwise it is the first path
  that exists among "/var/tmp", "/usr/tmp", and "/tmp". On Windows, the
  result is the directory specified by the TMP or TEMP environment
  variable, if it is defined, otherwise it is the current directory.

* 'init-dir — the directory containing the initialization file used by
  the Racket executable. It is the same as the user’s home directory.

* 'init-file — the file loaded at start-up by the Racket executable. The
  directory part of the path is the same path as returned for 'init-dir.
  The file name is platform-specific:

  * Unix and Mac OS: ".racketrc"

  * Windows: "racketrc.rktl"

* 'config-dir — a directory for the installation’s configuration. This
  directory is specified by the PLTCONFIGDIR environment variable, and
  it can be overridden by the --config or -G command-line flag.  If no
  environment variable or flag is specified, or if the value is not a
  legal path name, then this directory defaults to an "etc" directory
  relative to the current executable. If the result of (find-system-path
  'config-dir) is a relative path, it is relative to the current
  executable. The directory might not exist.

* 'host-config-dir — like 'config-dir, but when cross-platform build
  mode has been selected (through the -C or --cross argument to racket;
  see [missing]), the result refers to a directory for the current
  system’s installation, instead of for the target system.

* 'addon-dir — a directory for user-specific Racket configuration,
  packages, and extension. This directory is specified by the
  PLTADDONDIR environment variable, and it can be overridden by the
  --addon or -A command-line flag.  If no environment variable or flag
  is specified, or if the value is not a legal path name, then this
  directory defaults to "Library/Racket" in the user’s home directory on
  Mac OS and 'pref-dir otherwise.  The directory might not exist.

* 'doc-dir — the standard directory for storing the current user’s
  documents. On Unix, it’s the user’s home directory.  On Windows, it is
  the user’s home directory if determined by PLTUSERHOME, otherwise it
  is the user’s documents folder as specified by the Windows registry;
  the documents folder is usually "My Documents" in the user’s home
  directory.  On Mac OS, it’s the "Documents" directory in the user’s
  home directory.

* 'desk-dir — the directory for the current user’s desktop. On Unix,
  it’s the user’s home directory. On Windows, it is the user’s home
  directory if determined by PLTUSERHOME, otherwise it is the user’s
  desktop folder as specified by the Windows registry; the desktop
  folder is usually "Desktop" in the user’s home directory. On Mac OS,
  it is "Desktop" in the user’s home directory

* 'sys-dir — the directory containing the operating system for Windows.
  On Unix and Mac OS, the result is "/".

* 'exec-file — the path of the Racket executable as provided by the
  operating system for the current invocation. For some operating
  systems, the path can be relative.

  For GRacket, the executable path is the name of a GRacket executable.

* 'run-file — the path of the current executable; this may be different
  from result for 'exec-file because an alternate path was provided
  through a --name or -N command-line flag to the Racket (or GRacket)
  executable, or because an embedding executable installed an alternate
  path. In particular a “launcher” script created by
  make-racket-launcher sets this path to the script’s path.

* 'collects-dir — a path to the main collection of libraries (see
  [missing]). If this path is relative, then it is relative to the
  executable as reported by (find-system-path 'exec-file)—though the
  latter could be a soft-link or relative to the user’s executable
  search path, so that the two results should be combined with
  find-executable-path.  The 'collects-dir path is normally embedded in
  the Racket executable, but it can be overridden by the --collects or
  -X command-line flag.

* 'host-collects-dir — like 'collects-dir, but when cross-platform build
  mode has been selected (through the -C or --cross argument to racket;
  see [missing]), the result refers to a directory for the current
  system’s installation, instead of for the target system. In
  cross-platform build mode, collection files are normally read from the
  target system’s installation, but some tasks require current-system
  directories (such as the one that holds foreign libraries) that are
  configured relative to the main library-collection path.

* 'orig-dir — the current directory at start-up, which can be useful in
  converting a relative-path result from (find-system-path 'exec-file)
  or (find-system-path 'run-file) to a complete path.

Changed in version 6.0.0.3: Added PLTUSERHOME. Changed in version
6.9.0.1: Added 'host-config-dir and 'host-collects-dir.

                                        *path-list-string->path-list*
(path-list-string->path-list str                 ~
                             default-path-list) 
 -> (listof path?)
  str : (or/c string? bytes?) ~ ~
  default-path-list : (listof path?) ~ ~

Parses a string or byte string containing a list of paths, and returns a
list of path strings. On Unix and Mac OS, paths in a path list are
separated by a :; on Windows, paths are separated by a ;, and all "s in
the string are discarded. Whenever the path list contains an empty path,
the list default-path-list is spliced into the returned list of paths.
Parts of str that do not form a valid path are not included in the
returned list.

                                        *find-executable-path*
(find-executable-path  program         ~
                      [related        
                       deepest?]) -> (or/c path? #f)
  program : path-string? ~ ~
  related : (or/c path-string? #f) = #f ~ ~
  deepest? : any/c = #f ~ ~

Finds a path for the executable program, returning #f if the path cannot
be found.

If related is not #f, then it must be a relative path string, and the
path found for program must be such that the file or directory related
exists in the same directory as the executable. The result is then the
full path for the found related, instead of the path for the executable.

This procedure is used by the Racket executable to find the standard
library collection directory (see [missing]).  In this case, program is
the name used to start Racket and related is "collects".  The related
argument is used because, on Unix and Mac OS, program may involve a
sequence of soft links; in this case, related determines which link in
the chain is relevant.

If related is not #f, then when find-executable-path does not find a
program that is a link to another file path, the search can continue
with the destination of the link. Further links are inspected until
related is found or the end of the chain of links is reached. If
deepest? is #f (the default), then the result corresponds to the first
path in a chain of links for which related is found (and further links
are not actually explored); otherwise, the result corresponds to the
last link in the chain for which related is found.

If program is a pathless name, find-executable-path gets the value of
the PATH environment variable; if this environment variable is defined,
find-executable-path tries each path in PATH as a prefix for program
using the search algorithm described above for path-containing programs.
If the PATH environment variable is not defined, program is prefixed
with the current directory and used in the search algorithm above. (On
Windows, the current directory is always implicitly the first item in
PATH, so find-executable-path checks the current directory first on
Windows.)

2.2. Files

                                        *file-exists?*
(file-exists? path) -> boolean? ~
  path : path-string? ~ ~

Returns #t if a file (not a directory) path exists, #f otherwise.

On Windows, file-exists?  reports #t for all variations of the special
filenames (e.g., "LPT1", "x:/baddir/LPT1").

                                        *link-exists?*
(link-exists? path) -> boolean? ~
  path : path-string? ~ ~

Returns #t if a link path exists, #f otherwise.

The predicates file-exists?  or directory-exists? work on the final
destination of a link or series of links, while link-exists?  only
follows links to resolve the base part of path (i.e., everything except
the last name in the path).

This procedure never raises the exn:fail:filesystem exception.

On Windows, link-exists? reports #t for both symbolic links and
junctions.

Changed in version 6.0.1.12: Added support for links on Windows.

                                        *delete-file*
(delete-file path) -> void? ~
  path : path-string? ~ ~

Deletes the file with path path if it exists, otherwise the
exn:fail:filesystem exception is raised. If path is a link, the link is
deleted rather than the destination of the link.

On Windows, if an initial attempt to delete the file fails with a
permission error and the value of current-force-delete-permissions is
true, then delete-file attempts to change the file’s permissions (to
allow writes) and then delete the file; the permission change followed
by deletion is a non-atomic sequence, with no attempt to revert a
permission change if the deletion fails.

On Windows, delete-file can delete a symbolic link, but not a junction.
Use delete-directory to delete a junction.

On Windows, beware that if a file is deleted while it remains in use by
some process (e.g., a background search indexer), then the file’s
content will eventually go away, but the file’s name remains occupied
until the file is no longer used. As long as the name remains occupied,
attempts to open, delete, or replace the file will trigger a permission
error (as opposed to a file-exists error). A common technique to avoid
this pitfall is to move the file to a generated temporary name before
deleting it. See also delete-directory/files.

Changed in version 6.1.1.7: Changed Windows behavior to use
current-force-delete-permissions.

                                        *rename-file-or-directory*
(rename-file-or-directory  old               ~
                           new              
                          [exists-ok?]) -> void?
  old : path-string? ~ ~
  new : path-string? ~ ~
  exists-ok? : any/c = #f ~ ~

Renames the file or directory with path old—if it exists—to the path
new. If the file or directory is not renamed successfully, the
exn:fail:filesystem exception is raised.

This procedure can be used to move a file/directory to a different
directory (on the same filesystem) as well as rename a file/directory
within a directory. Unless exists-ok?  is provided as a true value, new
cannot refer to an existing file or directory, but the check is not
atomic with the rename operation on Unix and Mac OS. Even if exists-ok?
is true, new cannot refer to an existing file when old is a directory,
and vice versa.

If new exists and is replaced, the replacement is atomic on Unix and Mac
OS, but it is not guaranteed to be atomic on Windows. Furthermore, if
new exists and is opened by any process for reading or writing, then
attempting to replace it will typically fail on Windows. See also
call-with-atomic-output-file.

If old is a link, the link is renamed rather than the destination of the
link, and it counts as a file for replacing any existing new.

On Windows, beware that a directory cannot be renamed if any file within
the directory is open. That constraint is particularly problematic if a
search indexer is running in the background (as in the default Windows
configuration). A possible workaround is to combine copy-directory/files
and delete-directory/files, since the latter can deal with open files,
although that sequence is obviously not atomic and temporarily
duplicates files.

                                        *file-or-directory-modify-seconds*
(file-or-directory-modify-seconds  path          ~
                                  [secs-n]) -> exact-integer?
  path : path-string? ~ ~
  secs-n : #f = #f ~ ~
(file-or-directory-modify-seconds path        
                                  secs-n) -> void?
  path : path-string? ~ ~
  secs-n : exact-integer? ~ ~
(file-or-directory-modify-seconds  path             
                                  [secs-n           
                                   fail-thunk]) -> any
  path : path-string? ~ ~
  secs-n : (or/c exact-integer? #f) = #f ~ ~
  fail-thunk : (-> any) ~ ~
             = (lambda () (raise (make-exn:fail:filesystem ....))) ~ ~

Returns the file or directory’s last modification date in seconds since
midnight UTC, January 1, 1970 (see also Time) when secs-n is not
provided or is #f.

For FAT filesystems on Windows, directories do not have modification
dates. Therefore, the creation date is returned for a directory, but the
modification date is returned for a file.

If secs-n is provided and not #f, the access and modification times of
path are set to the given time.

On error (e.g., if no such file exists), then fail-thunk is called
(through a tail call) to produce the result of the
file-or-directory-modify-seconds call. If fail-thunk is not provided, an
error raises exn:fail:filesystem.

                                        *file-or-directory-permissions*
(file-or-directory-permissions path [mode]) ~
 -> (listof (or/c 'read 'write 'execute))
  path : path-string? ~ ~
  mode : #f = #f ~ ~
(file-or-directory-permissions path mode) -> (integer-in 0 65535)
  path : path-string? ~ ~
  mode : 'bits ~ ~
(file-or-directory-permissions path mode) -> void
  path : path-string? ~ ~
  mode : (integer-in 0 65535) ~ ~

When given one argument or #f as the second argument, returns a list
containing 'read, 'write, and/or 'execute to indicate permission the
given file or directory path by the current user and group. On Unix and
Mac OS, permissions are checked for the current effective user instead
of the real user.

If 'bits is supplied as the second argument, the result is a
platform-specific integer encoding of the file or directory properties
(mostly permissions), and the result is independent of the current user
and group. The lowest nine bits of the encoding are somewhat portable,
reflecting permissions for the file or directory’s owner, members of the
file or directory’s group, or other users:

* #o400 : owner has read permission

* #o200 : owner has write permission

* #o100 : owner has execute permission

* #o040 : group has read permission

* #o020 : group has write permission

* #o010 : group has execute permission

* #o004 : others have read permission

* #o002 : others have write permission

* #o001 : others have execute permission

See also user-read-bit, etc. On Windows, permissions from all three
(owner, group, and others) are always the same, and read and execute
permission are always available. On Unix and Mac OS, higher bits have a
platform-specific meaning.

If an integer is supplied as the second argument, its is used as an
encoding of properties (mostly permissions) to install for the file.

In all modes, the exn:fail:filesystem exception is raised on error
(e.g., if no such file exists).

                                        *file-or-directory-identity*
(file-or-directory-identity path [as-link?]) ~
 -> exact-positive-integer?
  path : path-string? ~ ~
  as-link? : any/c = #f ~ ~

Returns a number that represents the identity of path in terms of the
device and file or directory that it accesses. This function can be used
to check whether two paths correspond to the same filesystem entity
under the assumption that the path’s entity selection does not change.

If as-link? is a true value, then if path refers to a filesystem link,
the identity of the link is returned instead of the identity of the
referenced file or directory (if any).

                                        *file-size*
(file-size path) -> exact-nonnegative-integer? ~
  path : path-string? ~ ~

Returns the (logical) size of the specified file in bytes. On Mac OS,
this size excludes the resource-fork size. On error (e.g., if no such
file exists), the exn:fail:filesystem exception is raised.

                                        *copy-file*
(copy-file src dest [exists-ok?]) -> void? ~
  src : path-string? ~ ~
  dest : path-string? ~ ~
  exists-ok? : any/c = #f ~ ~

Creates the file dest as a copy of src, if dest does not already exist.
If dest already exists and exists-ok? is #f, the copy fails with
exn:fail:filesystem:exists? exception is raised; otherwise, if dest
exists, its content is replaced with the content of src. File
permissions are transferred from src to dest; on Windows, the
modification time of src is also transferred to dest. If src refers to a
link, the target of the link is copied, rather than the link itself; if
dest refers to a link and exists-ok? is true, the target of the link is
updated.

                                        *make-file-or-directory-link*
(make-file-or-directory-link to path) -> void? ~
  to : path-string? ~ ~
  path : path-string? ~ ~

Creates a link path to to. The creation will fail if path already
exists. The to need not refer to an existing file or directory, and to
is not expanded before writing the link. If the link is not created
successfully,the exn:fail:filesystem exception is raised.

On Windows XP and earlier, the exn:fail:unsupported exception is raised.
On later versions of Windows, the creation of links tends to be
disallowed by security policies. Furthermore, a relative-path link is
parsed specially; see Windows Paths for more information. When
make-file-or-directory-link succeeds, it creates a symbolic link as
opposed to a junction.

Changed in version 6.0.1.12: Added support for links on Windows.

                                        *current-force-delete-permissions*
(current-force-delete-permissions) -> boolean? ~
(current-force-delete-permissions any/c) -> void?
  any/c : boolean? ~ ~

A parameter that determines on Windows whether delete-file and
delete-directory attempt to change a file or directory’s permissions to
delete it. The default value is #t.

2.3. Directories

See also: rename-file-or-directory, file-or-directory-modify-seconds,
file-or-directory-permissions.

                                        *current-directory*
(current-directory) -> (and/c path? complete-path?) ~
(current-directory path) -> void?
  path : path-string? ~ ~

A parameter that determines the current directory for resolving relative
paths.

When the parameter procedure is called to set the current directory, the
path argument is cleansed using cleanse-path, simplified using
simplify-path, and then converted to a directory path with
path->directory-path; cleansing and simplification raise an exception if
the path is ill-formed. Thus, the current value of current-directory is
always a cleansed, simplified, complete, directory path.

The path is not checked for existence when the parameter is set.

On Unix and Mac OS, the initial value of the parameter for a Racket
process is taken from the PWD environment variable—if the value of the
environment variable identifies the same directory as the operating
system’s report of the current directory.

                                        *current-directory-for-user*
(current-directory-for-user) -> (and/c path? complete-path?) ~
(current-directory-for-user path) -> void?
  path : path-string? ~ ~

Like current-directory, but use only by srcloc->string for reporting
paths relative to a directory.

Normally, current-directory-for-user should stay at its initial value,
reflecting the directory where a user started a process. A tool such as
DrRacket, however, implicitly lets a user select a directory (for the
file being edited), in which case updating current-directory-for-user
makes sense.

                                        *current-drive*
(current-drive) -> path? ~

Returns the current drive name Windows. For other platforms, the
exn:fail:unsupported exception is raised. The current drive is always
the drive of the current directory.

                                        *directory-exists?*
(directory-exists? path) -> boolean? ~
  path : path-string? ~ ~

Returns #t if path refers to a directory, #f otherwise.

                                        *make-directory*
(make-directory path) -> void? ~
  path : path-string? ~ ~

Creates a new directory with the path path.  If the directory is not
created successfully, the exn:fail:filesystem exception is raised.

                                        *delete-directory*
(delete-directory path) -> void? ~
  path : path-string? ~ ~

Deletes an existing directory with the path path. If the directory is
not deleted successfully, the exn:fail:filesystem exception is raised.

On Windows, if an initial attempt to delete the directory fails with a
permission error and the value of current-force-delete-permissions is
true, then delete-file attempts to change the directory’s permissions
(to allow writes) and then delete the directory; the permission change
followed by deletion is a non-atomic sequence, with no attempt to revert
a permission change if the deletion fails.

Changed in version 6.1.1.7: Changed Windows behavior to use
current-force-delete-permissions.

                                        *directory-list*
(directory-list [path #:build? build?]) -> (listof path?) ~ ~ ~
  path : path-string? = (current-directory) ~ ~
  build? : any/c = #f ~ ~

See also the in-directory sequence constructor.

Returns a list of all files and directories in the directory specified
by path. If build? is #f, the resulting paths are all path elements;
otherwise, the individual results are combined with path using
build-path. On Windows, an element of the result list may start with
\\?\REL\\.

The resulting paths are always sorted using path<?.

                                        *filesystem-root-list*
(filesystem-root-list) -> (listof path?) ~

Returns a list of all current root directories. Obtaining this list can
be particularly slow on Windows.

2.4. Detecting Filesystem Changes

Many operating systems provide notifications for filesystem changes, and
those notifications are reflected in Racket by filesystem change events.

                                        *filesystem-change-evt?*
(filesystem-change-evt? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a filesystem change event, #f otherwise.

                                        *filesystem-change-evt*
(filesystem-change-evt path [failure-thunk]) ~
 -> (or/c filesystem-change-evt? any)
  path : path-string? ~ ~
  failure-thunk : (or/c (-> any) #f) = #f ~ ~

Creates a filesystem change event, which is a synchronizable event that
becomes ready for synchronization after a change to path:

* If path refers to a file, the event becomes ready for synchronization
  when the file’s content or attributes change, or when the file is
  deleted.

* If path refers to a directory, the event becomes ready for
  synchronization if a file or subdirectory is added, renamed, or
  removed within the directory.

The event also becomes ready for synchronization if it is passed to
filesystem-change-evt-cancel.

Finally, depending on the precision of information available from the
operating system, the event may become ready for synchronization under
other circumstances. For example, on Windows, an event for a file
becomes ready when any file changes within in the same directory as the
file.

After a filesystem change event becomes ready for synchronization, it
stays ready for synchronization. The event’s synchronization result is
the event itself.

If the current platform does not support filesystem-change
notifications, then the exn:fail:unsupported exception is raised if
failure-thunk is not provided as a procedure, or failure-thunk is called
in tail position if provided. Similarly, if there is any
operating-system error when creating the event (such as a non-existent
file), then the exn:fail:filesystem exception is raised or failure-thunk
is called.

Creation of a filesystem change event allocates resources at the
operating-system level. The resources are released at latest when the
event is sychronized and ready for synchronization, when the event is
canceled with filesystem-change-evt-cancel, or when the garbage
collector determine that the filesystem change event is unreachable. See
also system-type in 'fs-change mode.

A filesystem change event is placed under the management of the current
custodian when it is created. If the custodian is shut down,
filesystem-change-evt-cancel is applied to the event.

Changed in version 7.3.0.8: Allow #f for failure-thunk.

                                        *filesystem-change-evt-cancel*
(filesystem-change-evt-cancel evt) -> void? ~
  evt : filesystem-change-evt? ~ ~

Causes evt to become immediately ready for synchronization, whether it
was ready or not before, and releases the resources (at the
operating-system level) for tracking filesystem changes.

2.5. Declaring Paths Needed at Run Time

 (require racket/runtime-path) package: base ~ ~

The bindings documented in this section are provided by the
racket/runtime-path library, not racket/base or racket.

The racket/runtime-path library provides forms for accessing files and
directories at run time using a path that are usually relative to an
enclosing source file. Unlike using collection-path, define-runtime-path
exposes each run-time path to tools like the executable and distribution
creators, so that files and directories needed at run time are carried
along in a distribution.

In addition to the bindings described below, racket/runtime-path
provides #%datum in phase level 1, since string constants are often used
as compile-time expressions with define-runtime-path.

                                        *define-runtime-path*
(define-runtime-path id maybe-runtime?-id expr) ~
 
maybe-runtime? = 
               | #:runtime?-id runtime?-id ~ ~

Uses expr as both a compile-time (i.e., phase 1) expression and a
run-time (i.e., phase 0) expression. In either context, expr should
produce a path, a string that represents a path, a list of the form
(list 'lib str ...+), or a list of the form (list 'so str) or (list 'so
str vers). If runtime?-id is provided, then it is bound in the context
of expr to #f for the compile-time instance of expr and #t for the
run-time instance of expr.

For run time, id is bound to a path that is based on the result of expr.
The path is normally computed by taking a relative path result from expr
and adding it to a path for the enclosing file (which is computed as
described below). However, tools like the executable creator can also
arrange (by colluding with racket/runtime-path) to have a different base
path substituted in a generated executable. If expr produces an absolute
path, it is normally returned directly, but again may be replaced by an
executable creator. In all cases, the executable creator preserves the
relative locations of all paths within a given package (treating paths
outside of any package as being together). When expr produces a relative
or absolute path, then the path bound to id is always an absolute path.

If expr produces a list of the form (list 'lib str ...+), the value
bound to id is an absolute path. The path refers to a collection-based
file similar to using the value as a module path.

If expr produces a list of the form (list 'so str) or (list 'so str
vers), the value bound to id can be either str or an absolute path; it
is an absolute path when searching in the Racket-specific shared-object
library directories (as determined by get-lib-search-dirs) locates the
path. In this way, shared-object libraries that are installed
specifically for Racket get carried along in distributions. The search
tries each directory in order; within a directory, the search tries
using str directly, then it tries adding each version specified by
vers—which defaults to '(#f)—along with a platform-specific
shared-library extension—as produced by (system-type 'so-suffix). A vers
can be a string, or it can be a list of strings and #f.

If expr produces a list of the form (list 'share str), the value bound
to id can be either str or an absolute path; it is an absolute path when
searching in the directories reported by find-user-share-dir and
find-share-dir (in that order) locates the path. In this way, files that
are installed in Racket’s "share" directory get carried along in
distributions.

If expr produces a list of the form (list 'module module-path var-ref)
or (list 'so str (list str-or-false ...)), the value bound to id is a
module path index, where module-path is treated as relative (if it is
relative) to the module that is the home of the variable reference
var-ref, where var-ref can be #f if module-path is absolute. In an
executable, the corresponding module is carried along, including all of
its dependencies.

For compile-time, the expr result is used by an executable creator—but
not the result when the containing module is compiled. Instead, expr is
preserved in the module as a compile-time expression (in the sense of
begin-for-syntax). Later, at the time that an executable is created, the
compile-time portion of the module is executed (again), and the result
of expr is the file to be included with the executable. The reason for
the extra compile-time execution is that the result of expr might be
platform-dependent, so the result should not be stored in the
(platform-independent) bytecode form of the module; the platform at
executable-creation time, however, is the same as at run time for the
executable. Note that expr is still evaluated at run-time; consequently,
avoid procedures like collection-path, which depends on the source
installation, and instead use relative paths and forms like (list 'lib
str ...+).

If a path is needed only on some platforms and not on others, use
define-runtime-path-list with an expr that produces an empty list on
platforms where the path is not needed.

Beware that define-runtime-path in a phase level other than 0 does not
cooperate properly with an executable creator. To work around that
limitation, put define-runtime-path in a separate module—perhaps a
submodule created by module—then export the definition, and then the
module containing the definition can be required into any phase level.
Using define-runtime-path in a phase level other than 0 logs a warning
at expansion time.

The enclosing path for a define-runtime-path is determined as follows
from the define-runtime-path syntactic form:

* If the form has a source module according to syntax-source-module,
  then the source location is determined by preserving the original
  expression as a syntax object, extracting its source module path at
  run time (again using syntax-source-module), and then resolving the
  resulting module path index. Note that syntax-source-module is based
  on a syntax object’s lexical information, not its source location.

* If the expression has no source module, the syntax-source location
  associated with the form is used, if is a string or path.

* If no source module is available, and syntax-source produces no path,
  then current-load-relative-directory is used if it is not #f. Finally,
  current-directory is used if all else fails.

In the latter two cases, the path is normally preserved in
(platform-specific) byte form, but if the enclosing path corresponds to
a result of collection-file-path, then the path is record as relative to
the corresponding module path.

Changed in version 6.0.1.6 of package base: Preserve relative paths only
within a package. Changed in version 7.5.0.7: Added support for 'share
in expr.

Examples:

  ; Access a file "data.txt" at run-time that is originally
  ; located in the same directory as the module source file: ~ ~
  (define-runtime-path data-file "data.txt")
  (define (read-data)
    (with-input-from-file data-file
      (lambda ()
        (read-bytes (file-size data-file)))))
   
  ; Load a platform-specific shared object (using ffi-lib)
  ; that is located in a platform-specific sub-directory of the
  ; module's source directory: ~ ~
  (define-runtime-path libfit-path
    (build-path "compiled" "native" (system-library-subpath #f)
                (path-replace-suffix "libfit"
                                     (system-type 'so-suffix))))
  (define libfit (ffi-lib libfit-path))
   
  ; Load a platform-specific shared object that might be installed
  ; as part of the operating system, or might be installed
  ; specifically for Racket: ~ ~
  (define-runtime-path libssl-so
    (case (system-type)
      [(windows) '(so "ssleay32")]
      [else '(so "libssl")]))
  (define libssl (ffi-lib libssl-so))

Changed in version 6.4 of package base: Added #:runtime?-id.

                                        *define-runtime-paths*
(define-runtime-paths (id ...) maybe-runtime?-id expr) ~

Like define-runtime-path, but declares and binds multiple paths at once.
The expr should produce as many values as ids.

                                        *define-runtime-path-list*
(define-runtime-path-list id maybe-runtime?-id expr) ~

Like define-runtime-path, but expr should produce a list of paths.

                                        *define-runtime-module-path-index*
(define-runtime-module-path-index id maybe-runtime?-id module-path-expr) ~

Similar to define-runtime-path, but id is bound to a module path index
that encapsulates the result of module-path-expr relative to the
enclosing module.

Use define-runtime-module-path-index to bind a module path that is
passed to a reflective function like dynamic-require while also creating
a module dependency for building and distributing executables.

                                        *runtime-require*
(runtime-require module-path) ~

Similar to define-runtime-module-path-index, but creates the
distribution dependency without binding a module path index. When
runtime-require is used multiple times within a module with the same
module-path, all but the first use expands to an empty begin.

                                        *define-runtime-module-path*
(define-runtime-module-path id module-path) ~

Similar to define-runtime-path, but id is bound to a resolved module
path. The resolved module path for id corresponds to module-path (with
the same syntax as a module path for require), which can be relative to
the enclosing module.

The define-runtime-module-path-index form is usually preferred, because
it creates a weaker link to the referenced module. Unlike
define-runtime-module-path-index, the define-runtime-module-path form
creates a for-label dependency from an enclosing module to module-path.
Since the dependency is merely for-label, module-path is not
instantiated or visited when the enclosing module is instantiated or
visited (unless such a dependency is created by other requires), but the
code for the referenced module is loaded when the enclosing module is
loaded.

                                        *runtime-paths*
(runtime-paths module-path) ~

This form is mainly for use by tools such as executable builders. It
expands to a quoted list containing the run-time paths declared by
module-path, returning the compile-time results of the declaration
exprs, except that paths are converted to byte strings. The enclosing
module must require (directly or indirectly) the module specified by
module-path, which is an unquoted module path. The resulting list does
not include module paths bound through define-runtime-module-path.

2.6. More File and Directory Utilities

 (require racket/file) package: base ~ ~

The bindings documented in this section are provided by the racket/file
and racket libraries, but not racket/base.

                                        *file->string*
(file->string path [#:mode mode-flag]) -> string? ~ ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Reads all characters from path and returns them as a string. The
mode-flag argument is the same as for open-input-file.

                                        *file->bytes*
(file->bytes path [#:mode mode-flag]) -> bytes? ~ ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Reads all characters from path and returns them as a byte string.  The
mode-flag argument is the same as for open-input-file.

                                        *file->value*
(file->value path [#:mode mode-flag]) -> any ~ ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Reads a single S-expression from path using read. The mode-flag argument
is the same as for open-input-file.

                                        *file->list*
(file->list path [proc #:mode mode-flag]) -> (listof any/c) ~ ~ ~
  path : path-string? ~ ~
  proc : (input-port? . -> . any/c) = read ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Repeatedly calls proc to consume the contents of path, until eof is
produced. The mode-flag argument is the same as for open-input-file.

                                        *file->lines*
(file->lines  path                         ~
             [#:mode mode-flag             ~ ~
              #:line-mode line-mode]) -> (listof string?) ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
            = 'any

Read all characters from path, breaking them into lines. The line-mode
argument is the same as the second argument to read-line, but the
default is 'any instead of 'linefeed. The mode-flag argument is the same
as for open-input-file.

                                        *file->bytes-lines*
(file->bytes-lines  path                         ~
                   [#:mode mode-flag             ~ ~
                    #:line-mode line-mode]) -> (listof bytes?) ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
            = 'any

Like file->lines, but reading bytes and collecting them into lines like
read-bytes-line.

                                        *display-to-file*
(display-to-file  v                           ~
                  path                       
                 [#:mode mode-flag            ~ ~
                  #:exists exists-flag]) -> void? ~ ~
  v : any/c ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Uses display to print v to path. The mode-flag and exists-flag arguments
are the same as for open-output-file.

                                        *write-to-file*
(write-to-file  v                           ~
                path                       
               [#:mode mode-flag            ~ ~
                #:exists exists-flag]) -> void? ~ ~
  v : any/c ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like display-to-file, but using write instead of display.

                                        *display-lines-to-file*
(display-lines-to-file  lst                         ~
                        path                       
                       [#:separator separator       ~ ~
                        #:mode mode-flag            ~ ~
                        #:exists exists-flag]) -> void? ~ ~
  lst : list? ~ ~
  path : path-string? ~ ~
  separator : any/c = #"\n" ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Displays each element of lst to path, adding separator after each
element. The mode-flag and exists-flag arguments are the same as for
open-output-file.

                                        *copy-directory/files*
(copy-directory/files                                              ~
                      src                                         
                      dest                                        
                      #:keep-modify-seconds? keep-modify-seconds?  ~ ~
                      #:preserve-links? preserve-links?)           ~ ~
 -> void?
  src : path-string? ~ ~
  dest : path-string? ~ ~
  keep-modify-seconds? : #f ~ ~
  preserve-links? : #f ~ ~

Copies the file or directory src to dest, raising exn:fail:filesystem if
the file or directory cannot be copied, possibly because dest exists
already. If src is a directory, the copy applies recursively to the
directory’s content. If a source is a link and preserve-links? is #f,
the target of the link is copied rather than the link itself; if
preserve-links? is #t, the link is copied.

If keep-modify-seconds? is #f, then file copies keep only the properties
kept by copy-file. If keep-modify-seconds? is true, then each file copy
also keeps the modification date of the original.

Changed in version 6.3 of package base: Added the #:preserve-links?
argument.

                                        *delete-directory/files*
(delete-directory/files path                            ~
                        #:must-exist? must-exist?) -> void? ~ ~
  path : path-string? ~ ~
  must-exist? : #t ~ ~

Deletes the file or directory specified by path, raising
exn:fail:filesystem if the file or directory cannot be deleted. If path
is a directory, then delete-directory/files is first applied to each
file and directory in path before the directory is deleted.

If must-exist? is true, then exn:fail:filesystem is raised if path does
not exist. If must-exist? is false, then delete-directory/files succeeds
if path does not exist (but a failure is possible if path initially
exists and is removed by another thread or process before
delete-directory/files deletes it).

On Windows, delete-directory/files attempts to move a file into the
temporary-file directory before deleting it, which avoids problems
caused by deleting a file that is currently open (e.g., by a search
indexer running as a background process). If the move attempt fails
(e.g., because the temporary directory is on a different drive than the
file), then the file is deleted directly with delete-file.

Changed in version 7.0 of package base: Added Windows-specific file
deletion.

                                        *find-files*
(find-files                                                       ~
             predicate                                           
            [start-path]                                         
             #:skip-filtered-directory? skip-filtered-directory?  ~ ~
             #:follow-links? follow-links?)                       ~ ~
 -> (listof path?)
  predicate : (path? . -> . any/c) ~ ~
  start-path : (or/c path-string? #f) = #f ~ ~
  skip-filtered-directory? : #f ~ ~
  follow-links? : #f ~ ~

Traverses the filesystem starting at start-path and creates a list of
all files and directories for which predicate returns true. If
start-path is #f, then the traversal starts from (current-directory). In
the resulting list, each directory precedes its content.

The predicate procedure is called with a single argument for each file
or directory. If start-path is #f, the argument is a pathname string
that is relative to the current directory. Otherwise, it is a path
building on start-path. Consequently, supplying (current-directory) for
start-path is different from supplying #f, because predicate receives
complete paths in the former case and relative paths in the latter.
Another difference is that predicate is not called for the current
directory when start-path is #f.

If skip-filtered-directory? is true, then when predicate returns #f for
a directory, the directory’s content is not traversed.

If follow-links? is true, the find-files traversal follows links, and
links are not included in the result. If follow-links? is #f, then links
are not followed, and links are included in the result.

If start-path does not refer to an existing file or directory, then
predicate will be called exactly once with start-path as the argument.

The find-files procedure raises an exception if it encounters a
directory for which directory-list fails.

Changed in version 6.3.0.11 of package base: Added the
#:skip-filtered-directory? argument.

                                        *pathlist-closure*
(pathlist-closure  path-list                        ~
                  [#:path-filter path-filter        ~ ~
                   #:follow-links? follow-links?])  ~ ~
 -> (listof path?)
  path-list : (listof path-string?) ~ ~
  path-filter : (or/c #f (path? . -> . any/c)) = #f ~ ~
  follow-links? : any/c = #f ~ ~

Given a list of paths, either absolute or relative to the current
directory, returns a list such that

* if a nested path is given, all of its ancestors are also included in
  the result (but the same ancestor is not added twice);

* if a path refers to directory, all of its descendants are also
  included in the result, except as omitted by path-filter;

* ancestor directories appear before their descendants in the result
  list, as long as they are not misordered in the given path-list.

If path-filter is a procedure, then it is applied to each descendant of
a directory. If path-filter returns #f, then the descendant (and any of
its descendants, in the case of a subdirectory) are omitted from the
result.

If follow-links? is true, then the traversal of directories and files
follows links, and the link paths are not included in the result. If
follow-links? is #f, then the result list includes paths to link and the
links are not followed.

Changed in version 6.3.0.11 of package base: Added the #:path-filter
argument.

                                        *fold-files*
(fold-files  proc                 ~
             init-val            
            [start-path          
             follow-links?]) -> any
  proc : (or/c (path? (or/c 'file 'dir 'link) any/c ~ ~
                 . -> . any/c)
               (path? (or/c 'file 'dir 'link) any/c
                 . -> . (values any/c any/c)))
  init-val : any/c ~ ~
  start-path : (or/c path-string? #f) = #f ~ ~
  follow-links? : any/c = #t ~ ~

Traverses the filesystem starting at start-path, calling proc on each
discovered file, directory, and link. If start-path is #f, then the
traversal starts from (current-directory).

The proc procedure is called with three arguments for each file,
directory, or link:

* If start-path is #f, the first argument is a pathname string that is
  relative to the current directory. Otherwise, the first argument is a
  pathname that starts with start-path. Consequently, supplying
  (current-directory) for start-path is different from supplying #f,
  because proc receives complete paths in the former case and relative
  paths in the latter. Another difference is that proc is not called for
  the current directory when start-path is #f.

* The second argument is a symbol, either 'file, 'dir, or 'link. The
  second argument can be 'link when follow-links? is #f, in which case
  the filesystem traversal does not follow links. If follow-links? is
  #t, then proc will only get a 'link as a second argument when it
  encounters a dangling symbolic link (one that does not resolve to an
  existing file or directory).

* The third argument is the accumulated result. For the first call to
  proc, the third argument is init-val. For the second call to proc (if
  any), the third argument is the result from the first call, and so on.
  The result of the last call to proc is the result of fold-files.

The proc argument is used in an analogous way to the procedure argument
of foldl, where its result is used as the new accumulated result.  There
is an exception for the case of a directory (when the second argument is
'dir): in this case the procedure may return two values, the second
indicating whether the recursive scan should include the given directory
or not.  If it returns a single value, the directory is scanned.  In the
cases of files or links (when the second argument is 'file or 'link), a
second value is permitted but ignored.

If the start-path is provided but no such path exists, or if paths
disappear during the scan, then an exception is raised.

                                        *make-directory**
(make-directory* path) -> void? ~
  path : path-string? ~ ~

Creates directory specified by path, creating intermediate directories
as necessary, and never failing if path exists already.

If path is a relative path and the current directory does not exist,
then make-directory* will not create the current directory, because it
considers only explicit elements of path.

                                        *make-parent-directory**
(make-parent-directory* path) -> void? ~
  path : path-string? ~ ~

Creates the parent directory of the path specified by path, creating
intermediate directories as necessary, and never failing if an ancestor
of path exists already.

If path is a filesystem root or a relative path with a single path
element, then no directory is created. Like make-directory*, if path is
a relative path and the current directory does not exist, then
make-parent-directory* will not create it.

Added in version 6.1.1.3 of package base.

                                        *make-temporary-file*
(make-temporary-file [template                ~
                      copy-from-filename     
                      directory])        -> path?
  template : string? = "rkttmp~a" ~ ~
  copy-from-filename : (or/c path-string? #f 'directory) = #f ~ ~
  directory : (or/c path-string? #f) = #f ~ ~

Creates a new temporary file and returns a pathname string for the file.
Instead of merely generating a fresh file name, the file is actually
created; this prevents other threads or processes from picking the same
temporary name.

The template argument must be a format string suitable for use with
format and one additional string argument (where the string contains
only digits). If the resulting string is a relative path, it is combined
with the result of (find-system-path 'temp-dir), unless directory is
provided and non-#f, in which case the file name generated from template
is combined with directory to obtain a full path.

The template argument’s default is only the string "rkttmp~a" when there
is no source location information for the callsite of
make-temporary-file (or if make-temporary-file is used in a higher-order
position). If there is such information, then the template string is
based on the source location.

If copy-from-filename is provided as path, the temporary file is created
as a copy of the named file (using copy-file). If copy-from-filename is
#f, the temporary file is created as empty. If copy-from-filename is
'directory, then the temporary “file” is created as a directory.

When a temporary file is created, it is not opened for reading or
writing when the pathname is returned. The client program calling
make-temporary-file is expected to open the file with the desired access
and flags (probably using the 'truncate flag; see open-output-file) and
to delete it when it is no longer needed.

                                        *call-with-atomic-output-file*
(call-with-atomic-output-file                                               ~
                               file                                        
                               proc                                        
                              [#:security-guard security-guard              ~ ~
                               #:rename-fail-handler rename-fail-handler])  ~ ~
 -> any
  file : path-string? ~ ~
  proc : ([port output-port?] [tmp-path path?]  . -> . any) ~ ~
  security-guard : (or/c #f security-guard?) = #f ~ ~
  rename-fail-handler : (or/c #f (exn:fail:filesystem? path> . -> . any)) ~ ~
                      = #f

Opens a temporary file for writing in the same directory as file, calls
proc to write to the temporary file, and then atomically (except on
Windows) moves the temporary file in place of file. The move simply uses
rename-file-or-directory on Unix and Mac OS, and it uses
rename-file-or-directory on Windows if rename-fail-handler is provided;
otherwise, on Windows, the moves uses an extra rename step (see below)
on Windows to avoid problems due to concurrent readers of file.

The proc function is called with an output port for the temporary file,
plus the path of the temporary file. The result of proc is the result of
call-with-atomic-output-file.

The call-with-atomic-output-file function arranges to delete temporary
files on exceptions.

Windows prevents programs from deleting or replacing files that are
open, but it allows renaming of open files. Therefore, on Windows,
call-with-atomic-output-file by default creates a second temporary file
extra-tmp-file, renames file to extra-tmp-file, renames the temporary
file written by proc to file, and finally deletes extra-tmp-file. Since
that process is not atomic, however, rename-file-or-directory is used if
rename-fail-handler is provided, where rename-file-or-directory has some
chance of being atomic, since that the source and destination of the
moves will be in the same directory; any filesystem exception while
attempting to rename the file is send to rename-fail-handler, which can
re-raise the exception or simply return to try again, perhaps after a
delay. In addition to a filesystem exception, the rename-fail-handler
procedure also receives the temporary file path to be moved to path. The
rename-fail-handler argument is used only on Windows.

Changed in version 7.1.0.6 of package base: Added the
#:rename-fail-handler argument.

                                        *get-preference*
(get-preference  name                                         ~
                [failure-thunk                               
                 flush-mode                                  
                 filename                                    
                 #:use-lock? use-lock?                        ~ ~
                 #:timeout-lock-there timeout-lock-there      ~ ~
                 #:lock-there lock-there])               -> any ~ ~
  name : symbol? ~ ~
  failure-thunk : (-> any) = (lambda () #f) ~ ~
  flush-mode : any/c = 'timestamp ~ ~
  filename : (or/c string-path? #f) = #f ~ ~
  use-lock? : any/c = #t ~ ~
  timeout-lock-there : (or/c (path? . -> . any) #f) = #f ~ ~
  lock-there : (or/c (path? . -> . any) #f) ~ ~
             = (make-handle-get-preference-locked
                0.01 name failure-thunk flush-mode filename
                #:lock-there timeout-lock-there) ~ ~

Extracts a preference value from the file designated by
(find-system-path 'pref-file), or by filename if it is provided and is
not #f.  In the former case, if the preference file doesn’t exist,
get-preferences attempts to read an old preferences file, and then a
"racket-prefs.rktd" file in the configuration directory (as reported by
find-config-dir), instead. If none of those files exists, the preference
set is empty.

The preference file should contain a list of symbol–value lists written
with the default parameter settings.  Keys starting with racket:,
mzscheme:, mred:, and plt: in any letter case are reserved for use by
Racket implementors. If the preference file does not contain a list of
symbol–value lists, an error is logged via log-error and failure-thunk
is called.

The result of get-preference is the value associated with name if it
exists in the association list, or the result of calling failure-thunk
otherwise.

Preference settings are cached (weakly) across calls to get-preference,
using (path->complete-path filename) as a cache key. If flush-mode is
provided as #f, the cache is used instead of re-consulting the
preferences file. If flush-mode is provided as 'timestamp (the default),
then the cache is used only if the file has a timestamp that is the same
as the last time the file was read. Otherwise, the file is re-consulted.

On platforms for which preferences-lock-file-mode returns 'file-lock and
when use-lock? is true, preference-file reading is guarded by a lock;
multiple readers can share the lock, but writers take the lock
exclusively. If the preferences file cannot be read because the lock is
unavailable, lock-there is called on the path of the lock file; if
lock-there is #f, an exception is raised. The default lock-there handler
retries about 5 times (with increasing delays between each attempt)
before trying timeout-lock-there, and the default timeout-lock-there
triggers an exception.

See also put-preferences. For a more elaborate preference system, see
preferences:get.

Old preferences files: When a filename is not provided and the file
indicated by (find-system-path 'pref-file) does not exist, the following
paths are checked for compatibility with old versions of Racket:

* Windows: (build-path (find-system-path 'pref-dir) 'up "PLT Scheme"
  "plt-prefs.ss")

* Mac OS: (build-path (find-system-path 'pref-dir)
  "org.plt-scheme.prefs.ss")

* Unix: (expand-user-path "~/.plt-scheme/plt-prefs.ss")

                                        *put-preferences*
(put-preferences  names            ~
                  vals            
                 [locked-proc     
                  filename])  -> void?
  names : (listof symbol?) ~ ~
  vals : list? ~ ~
  locked-proc : (or/c #f (path? . -> . any)) = #f ~ ~
  filename : (or/c #f path-string?) = #f ~ ~

Installs a set of preference values and writes all current values to the
preference file designated by (find-system-path 'pref-file), or filename
if it is supplied and not #f.

The names argument supplies the preference names, and vals must have the
same length as names. Each element of vals must be an instance of a
built-in data type whose write output is readable (i.e., the
print-unreadable parameter is set to #f while writing preferences).

Current preference values are read from the preference file before
updating, and a write lock is held starting before the file read, and
lasting until after the preferences file is updated. The lock is
implemented by the existence of a file in the same directory as the
preference file; see preferences-lock-file-mode for more information. If
the directory of the preferences file does not already exist, it is
created.

If the write lock is already held, then locked-proc is called with a
single argument: the path of the lock file. The default locked-proc
(used when the locked-proc argument is #f) reports an error; an
alternative thunk might wait a while and try again, or give the user the
choice to delete the lock file (in case a previous update attempt
encountered disaster and locks are implemented by the presence of the
lock file).

If filename is #f or not supplied, and the preference file does not
already exist, then values read from the "defaults" collection (if any)
are written for preferences that are not mentioned in names.

                                        *preferences-lock-file-mode*
(preferences-lock-file-mode) -> (or/c 'exists 'file-lock) ~

Reports the way that the lock file is used to implement preference-file
locking on the current platform.

The 'exists mode is currently used on all platforms except Windows. In
'exists mode, the existence of the lock file indicates that a write lock
is held, and readers need no lock (because the preferences file is
atomically updated via rename-file-or-directory).

The 'file-lock mode is currently used on Windows. In 'file-lock mode,
shared and exclusive locks (in the sense of port-try-file-lock?) on the
lock file reflect reader and writer locks on the preference-file
content. (The preference file itself is not locked, because a lock would
interfere with replacing the file via rename-file-or-directory.)

                                        *make-handle-get-preference-locked*
(make-handle-get-preference-locked  delay                    ~
                                    name                    
                                   [failure-thunk           
                                    flush-mode              
                                    filename                
                                    #:lock-there lock-there  ~ ~
                                    #:max-delay max-delay])  ~ ~
 -> (path-string? . -> . any)
  delay : real? ~ ~
  name : symbol? ~ ~
  failure-thunk : (-> any) = (lambda () #f) ~ ~
  flush-mode : any/c = 'timestamp ~ ~
  filename : (or/c path-string? #f) = #f ~ ~
  lock-there : (or/c (path? . -> . any) #f) = #f ~ ~
  max-delay : real? = 0.2 ~ ~

Creates a procedure suitable for use as the #:lock-there argument to
get-preference, where the name, failure-thunk, flush-mode, and filename
are all passed on to get-preference by the result procedure to retry the
preferences lookup.

Before calling get-preference, the result procedure uses (sleep delay)
to pause. Then, if (* 2 delay) is less than max-delay, the result
procedure calls make-handle-get-preference-locked to generate a new
retry procedure to pass to get-preference, but with a delay of (* 2
delay). If (* 2 delay) is not less than max-delay, then get-preference
is called with the given lock-there, instead.

                                        *call-with-file-lock/timeout*
(call-with-file-lock/timeout  filename                     ~
                              kind                        
                              thunk                       
                              failure-thunk               
                             [#:lock-file lock-file        ~ ~
                              #:delay delay                ~ ~
                              #:max-delay max-delay]) -> any ~ ~
  filename : (or/c path-string? #f) ~ ~
  kind : (or/c 'shared 'exclusive) ~ ~
  thunk : (-> any) ~ ~
  failure-thunk : (-> any) ~ ~
  lock-file : (or/c #f path-string?) = #f ~ ~
  delay : (and/c real? (not/c negative?)) = 0.01 ~ ~
  max-delay : (and/c real? (not/c negative?)) = 0.2 ~ ~

Obtains a lock for the filename lock-file and then calls thunk.  The
filename argument specifies a file path prefix that is used only to
generate the lock filename when lock-file is #f.  Specifically, when
lock-file is #f, then call-with-file-lock/timeout uses
make-lock-file-name to build the lock filename. If the lock file does
not yet exist, it is created; beware that the lock file is not deleted
by call-with-file-lock/timeout.

When thunk returns, call-with-file-lock/timeout releases the lock,
returning the result of thunk. The call-with-file-lock/timeout function
will retry after delay seconds and continue retrying with exponential
backoff until delay reaches max-delay. If call-with-file-lock/timeout
fails to obtain the lock, failure-thunk is called in tail position.  The
kind argument specifies whether the lock is 'shared or 'exclusive in the
sense of port-try-file-lock?.

Examples:

  > (call-with-file-lock/timeout filename 'exclusive
      (lambda () (printf "File is locked\n"))
      (lambda () (printf "Failed to obtain lock for file\n")))
  File is locked
  > (call-with-file-lock/timeout #f 'exclusive
      (lambda ()
        (call-with-file-lock/timeout filename 'shared
          (lambda () (printf "Shouldn't get here\n"))
          (lambda () (printf "Failed to obtain lock for file\n"))))
      (lambda () (printf "Shouldn't get here either\n"))
      #:lock-file (make-lock-file-name filename)) ~ ~
  Failed to obtain lock for file

                                        *make-lock-file-name*
(make-lock-file-name path) -> path? ~
  path : (or path-string? path-for-some-system?) ~ ~
(make-lock-file-name dir name) -> path?
  dir : (or path-string? path-for-some-system?) ~ ~
  name : path-element? ~ ~

Creates a lock filename by prepending "_LOCK" on Windows (i.e., when
cross-system-type reports 'windows) or ".LOCK" on other platforms to the
file portion of the path.

Example:

  > (make-lock-file-name "/home/george/project/important-file")
  #<path:/home/george/project/.LOCKimportant-file>

user-read-bit : #o400 ~ ~
user-write-bit : #o200 ~ ~
user-execute-bit : #o100 ~ ~
group-read-bit : #o040 ~ ~
group-write-bit : #o020 ~ ~
group-execute-bit : #o010 ~ ~
other-read-bit : #o004 ~ ~
other-write-bit : #o002 ~ ~
other-execute-bit : #o001 ~ ~

Constants that are useful with file-or-directory-permissions and bitwise
operations such as bitwise-ior, and bitwise-and.

3. Networking

    3.1 TCP
    3.2 UDP

3.1. TCP

 (require racket/tcp) package: base ~ ~

The bindings documented in this section are provided by the racket/tcp
and racket libraries, but not racket/base.

For information about TCP in general, see TCP/IP Illustrated, Volume 1
by W. Richard Stevens.

                                        *tcp-listen*
(tcp-listen  port-no             ~
            [max-allow-wait     
             reuse?             
             hostname])     -> tcp-listener?
  port-no : listen-port-number? ~ ~
  max-allow-wait : exact-nonnegative-integer? = 4 ~ ~
  reuse? : any/c = #f ~ ~
  hostname : (or/c string? #f) = #f ~ ~

Creates a “listening” server on the local machine at the port number
specified by port-no. If port-no is 0 the socket binds to an ephemeral
port, which can be determined by calling tcp-addresses.  The
max-allow-wait argument determines the maximum number of client
connections that can be waiting for acceptance. (When max-allow-wait
clients are waiting acceptance, no new client connections can be made.)

If the reuse? argument is true, then tcp-listen will create a listener
even if the port is involved in a TIME_WAIT state. Such a use of reuse?
defeats certain guarantees of the TCP protocol; see Stevens’s book for
details. Furthermore, on many modern platforms, a true value for reuse?
overrides TIME_WAIT only if the listener was previously created with a
true value for reuse?.

If hostname is #f (the default), then the listener accepts connections
to all of the listening machine’s addresses. Otherwise, the listener
accepts connections only at the interface(s) associated with the given
hostname. For example, providing "127.0.0.1" as hostname creates a
listener that accepts only connections to "127.0.0.1" (the loopback
interface) from the local machine.

                                        *Racket*
(Racket implements a listener with multiple sockets, if necessary, to ~
accommodate multiple addresses with different protocol families. On
Linux, if hostname maps to both IPv4 and IPv6 addresses, then the
behavior depends on whether IPv6 is supported and IPv6 sockets can be
configured to listen to only IPv6 connections: if IPv6 is not supported
or IPv6 sockets are not configurable, then the IPv6 addresses are
ignored; otherwise, each IPv6 listener accepts only IPv6 connections.)

The return value of tcp-listen is a TCP listener. This value can be used
in future calls to tcp-accept, tcp-accept-ready?, and tcp-close.  Each
new TCP listener value is placed into the management of the current
custodian (see [missing]).

If the server cannot be started by tcp-listen, the exn:fail:network
exception is raised.

A TCP listener can be used as a synchronizable event (see [missing]). A
TCP listener is ready for synchronization when tcp-accept would not
block; the synchronization result of a TCP listener is the TCP listener
itself.

                                        *tcp-connect*
(tcp-connect  hostname             ~
              port-no             
             [local-hostname      
              local-port-no]) -> input-port? output-port?
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  local-hostname : (or/c string? #f) = #f ~ ~
  local-port-no : (or/c port-number? #f) = #f ~ ~

Attempts to connect as a client to a listening server.  The hostname
argument is the server host’s Internet address name, and port-no is the
port number where the server is listening.

                                        *If*
(If hostname is associated with multiple addresses, they are tried one ~
at a time until a connection succeeds. The name "localhost" generally
specifies the local machine.)

The optional local-hostname and local-port-no specify the client’s
address and port. If both are #f (the default), the client’s address and
port are selected automatically. If local-hostname is not #f, then
local-port-no must be non-#f. If local-port-no is non-#f and
local-hostname is #f, then the given port is used but the address is
selected automatically.

Two values are returned by tcp-connect: an input port and an output
port. Data can be received from the server through the input port and
sent to the server through the output port.  If the server is a Racket
program, it can obtain ports to communicate to the client with
tcp-accept.  These ports are placed into the management of the current
custodian (see [missing]).

Initially, the returned input port is block-buffered, and the returned
output port is block-buffered. Change the buffer mode using
file-stream-buffer-mode.

Both of the returned ports must be closed to terminate the TCP
connection. When both ports are still open, closing the output port with
close-output-port sends a TCP close to the server (which is seen as an
end-of-file if the server reads the connection through a port). In
contrast, tcp-abandon-port (see below) closes the output port, but does
not send a TCP close until the input port is also closed.

Note that the TCP protocol does not support a state where one end is
willing to send but not read, nor does it include an automatic message
when one end of a connection is fully closed. Instead, the other end of
a connection discovers that one end is fully closed only as a response
to sending data; in particular, some number of writes on the still-open
end may appear to succeed, though writes will eventually produce an
error.

If a connection cannot be established by tcp-connect, the
exn:fail:network exception is raised.

                                        *tcp-connect/enable-break*
(tcp-connect/enable-break  hostname         ~
                           port-no         
                          [local-hostname] 
                           local-port-no)  
 -> input-port? output-port?
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  local-hostname : (or/c string? #f) = #f ~ ~
  local-port-no : (or/c port-number? #f) ~ ~

Like tcp-connect, but breaking is enabled (see [missing]) while trying
to connect. If breaking is disabled when tcp-connect/enable-break is
called, then either ports are returned or the exn:break exception is
raised, but not both.

                                        *tcp-accept*
(tcp-accept listener) -> input-port? output-port? ~
  listener : tcp-listener? ~ ~

Accepts a client connection for the server associated with listener. If
no client connection is waiting on the listening port, the call to
tcp-accept will block. (See also tcp-accept-ready?.)

Two values are returned by tcp-accept: an input port and an output port.
Data can be received from the client through the input port and sent to
the client through the output port.  These ports are placed into the
management of the current custodian (see [missing]).

In terms of buffering and connection states, the ports act the same as
ports from tcp-connect.

If a connection cannot be accepted by tcp-accept, or if the listener has
been closed, the exn:fail:network exception is raised.

                                        *tcp-accept/enable-break*
(tcp-accept/enable-break listener) -> input-port? output-port? ~
  listener : tcp-listener? ~ ~

Like tcp-accept, but breaking is enabled (see [missing]) while trying to
accept a connection. If breaking is disabled when
tcp-accept/enable-break is called, then either ports are returned or the
exn:break exception is raised, but not both.

                                        *tcp-accept-ready?*
(tcp-accept-ready? listener) -> boolean? ~
  listener : tcp-listener? ~ ~

Tests whether an unaccepted client has connected to the server
associated with listener. If a client is waiting, the return value is
#t, otherwise it is #f. A client is accepted with the tcp-accept
procedure, which returns ports for communicating with the client and
removes the client from the list of unaccepted clients.

If the listener has been closed, the exn:fail:network exception is
raised.

                                        *tcp-close*
(tcp-close listener) -> void? ~
  listener : tcp-listener? ~ ~

Shuts down the server associated with listener. All unaccepted clients
receive an end-of-file from the server; connections to accepted clients
are unaffected.

If the listener has already been closed, the exn:fail:network exception
is raised.

The listener’s port number may not become immediately available for new
listeners (with the default reuse? argument of tcp-listen). For further
information, see Stevens’s explanation of the TIME_WAIT TCP state.

                                        *tcp-listener?*
(tcp-listener? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a TCP listener created by tcp-listen, #f otherwise.

                                        *tcp-accept-evt*
(tcp-accept-evt listener) -> evt? ~
  listener : tcp-listener? ~ ~

Returns a synchronizable event (see [missing]) that is ready for
synchronization when tcp-accept on listener would not block. The
synchronization result is a list of two items, which correspond to the
two results of tcp-accept. (If the event is not chosen in a sync, no
connections are accepted.) The ports are placed into the management of
the custodian that is the current custodian (see [missing]) at the time
that tcp-accept-evt is called.

                                        *tcp-abandon-port*
(tcp-abandon-port tcp-port) -> void? ~
  tcp-port : tcp-port? ~ ~

Like close-output-port or close-input-port (depending on whether
tcp-port is an input or output port), but if tcp-port is an output port
and its associated input port is not yet closed, then the other end of
the TCP connection does not receive a TCP close message until the input
port is also closed.

The TCP protocol does not include a “no longer reading” state on
connections, so tcp-abandon-port is equivalent to close-input-port on
input TCP ports.

                                        *tcp-addresses*
(tcp-addresses tcp-port [port-numbers?]) ~
 -> (or/c (values string? string?)
          (values string? port-number?
                  string? listen-port-number?))
  tcp-port : (or/c tcp-port? tcp-listener? udp?) ~ ~
  port-numbers? : any/c = #f ~ ~

Returns two strings when port-numbers? is #f (the default). The first
string is the Internet address for the local machine as viewed by the
given TCP port’s connection, for the TCP listener, or the UDP socket.
(When a machine serves multiple addresses, as it usually does if you
count the loopback device, the result is connection-specific or
listener-specific.) If a listener or UDP socket is given and it has no
specific host, the first string result is "0.0.0.0". The second string
is the Internet address for the other end of the connection, or always
"0.0.0.0" for a listener or unconnected UDP socket.

If port-numbers? is true, then four results are returned: a string for
the local machine’s address, an exact integer between 1 and 65535 for
the local machine’s port number, a string for the remote machine’s
address, and an exact integer between 1 and 65535 for the remote
machine’s port number or 0 for a listener.

If the given port, listener, or socket has been closed, the
exn:fail:network exception is raised.

                                        *tcp-port?*
(tcp-port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a TCP port—which is a port returned by tcp-accept,
tcp-connect, tcp-accept/enable-break, or tcp-connect/enable-break—#f
otherwise.

port-number? : contract? ~ ~

Equivalent to (between/c 1 65535).

Added in version 6.3 of package base.

listen-port-number? : contract? ~ ~

Equivalent to (between/c 0 65535).

Added in version 6.3 of package base.

3.2. UDP

 (require racket/udp) package: base ~ ~

The bindings documented in this section are provided by the racket/udp
and racket libraries, but not racket/base.

For information about UDP in general, see TCP/IP Illustrated, Volume 1
by W. Richard Stevens.

                                        *udp-open-socket*
(udp-open-socket [family-hostname       ~
                  family-port-no]) -> udp?
  family-hostname : (or/c string? #f) = #f ~ ~
  family-port-no : (or/c port-number? #f) = #f ~ ~

Creates and returns a UDP socket to send and receive datagrams
(broadcasting is allowed). Initially, the socket is not bound or
connected to any address or port.

If family-hostname or family-port-no is not #f, then the socket’s
protocol family is determined from these arguments. The socket is not
bound to the hostname or port number. For example, the arguments might
be the hostname and port to which messages will be sent through the
socket, which ensures that the socket’s protocol family is consistent
with the destination. Alternately, the arguments might be the same as
for a future call to udp-bind!, which ensures that the socket’s protocol
family is consistent with the binding. If neither family-hostname nor
family-port-no is non-#f, then the socket’s protocol family is IPv4.

                                        *udp-bind!*
(udp-bind!  udp-socket           ~
            hostname-string     
            port-no             
           [reuse?])        -> void?
  udp-socket : udp? ~ ~
  hostname-string : (or/c string? #f) ~ ~
  port-no : listen-port-number? ~ ~
  reuse? : any/c = #f ~ ~

Binds an unbound udp-socket to the local port number port-no.  If
port-no is 0 the udp-socket is bound to an ephemeral port, which can be
determined by calling udp-addresses.

If hostname-string is #f, then the socket accepts connections to all of
the listening machine’s IP addresses at port-no. Otherwise, the socket
accepts connections only at the IP address associated with the given
name. For example, providing "127.0.0.1" as hostname-string typically
creates a listener that accepts only connections to "127.0.0.1" from the
local machine.

A socket cannot receive datagrams until it is bound to a local address
and port. If a socket is not bound before it is used with a sending
procedure udp-send, udp-send-to, etc., the sending procedure binds the
socket to a random local port. Similarly, if an event from udp-send-evt
or udp-send-to-evt is chosen for a synchronization (see [missing]), the
socket is bound; if the event is not chosen, the socket may or may not
become bound.

The binding of a bound socket cannot be changed, with one exception: on
some systems, if the socket is bound automatically when sending, if the
socket is disconnected via udp-connect!, and if the socket is later used
again in a send, then the later send may change the socket’s automatic
binding.

If udp-socket is already bound or closed, the exn:fail:network exception
is raised.

If the reuse? argument is true, then udp-bind! will set the SO_REUSEADDR
socket option before binding, permitting the sharing of access to a UDP
port between many processes on a single machine when using UDP
multicast.

                                        *udp-connect!*
(udp-connect! udp-socket           ~
              hostname-string     
              port-no)        -> void?
  udp-socket : udp? ~ ~
  hostname-string : (or/c string? #f) ~ ~
  port-no : (or/c port-number? #f) ~ ~

Connects the socket to the indicated remote address and port if
hostname-string is a string and port-no is an exact integer.

If hostname-string is #f, then port-no also must be #f, and the port is
disconnected (if connected). If one of hostname-string or port-no is #f
and the other is not, the exn:fail:contract exception is raised.

A connected socket can be used with udp-send (not udp-send-to), and it
accepts datagrams only from the connected address and port. A socket
need not be connected to receive datagrams.  A socket can be connected,
re-connected, and disconnected any number of times.

If udp-socket is closed, the exn:fail:network exception is raised.

                                        *udp-send-to*
(udp-send-to  udp-socket      ~
              hostname       
              port-no        
              bstr           
             [start-pos      
              end-pos])  -> void?
  udp-socket : udp? ~ ~
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Sends (subbytes bytes start-pos end-pos) as a datagram from the
unconnected udp-socket to the socket at the remote machine
hostname-address on the port port-no. The udp-socket need not be bound
or connected; if it is not bound, udp-send-to binds it to a random local
port. If the socket’s outgoing datagram queue is too full to support the
send, udp-send-to blocks until the datagram can be queued.

If start-pos is greater than the length of bstr, or if end-pos is less
than start-pos or greater than the length of bstr, the exn:fail:contract
exception is raised.

If udp-socket is closed or connected, the exn:fail:network exception is
raised.

                                        *udp-send*
(udp-send udp-socket bstr [start-pos end-pos]) -> void? ~
  udp-socket : udp? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-send-to, except that udp-socket must be connected, and the
datagram goes to the connection target.  If udp-socket is closed or
unconnected, the exn:fail:network exception is raised.

                                        *udp-send-to**
(udp-send-to*  udp-socket      ~
               hostname       
               port-no        
               bstr           
              [start-pos      
               end-pos])  -> boolean?
  udp-socket : udp? ~ ~
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-send-to, but never blocks; if the socket’s outgoing queue is
too full to support the send, #f is returned, otherwise the datagram is
queued and the result is #t.

                                        *udp-send**
(udp-send* udp-socket bstr [start-pos end-pos]) -> boolean? ~
  udp-socket : udp? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-send, except that (like udp-send-to) it never blocks and
returns #f or #t.

                                        *udp-send-to/enable-break*
(udp-send-to/enable-break  udp-socket      ~
                           hostname       
                           port-no        
                           bstr           
                          [start-pos      
                           end-pos])  -> void?
  udp-socket : udp? ~ ~
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-send-to, but breaking is enabled (see [missing]) while trying
to send the datagram. If breaking is disabled when
udp-send-to/enable-break is called, then either the datagram is sent or
the exn:break exception is raised, but not both.

                                        *udp-send/enable-break*
(udp-send/enable-break  udp-socket      ~
                        bstr           
                       [start-pos      
                        end-pos])  -> void?
  udp-socket : udp? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-send, except that breaks are enabled like
udp-send-to/enable-break.

                                        *udp-receive!*
(udp-receive!  udp-socket      ~
               bstr           
              [start-pos      
               end-pos])  -> exact-nonnegative-integer?
                             string?
                             port-number?
  udp-socket : udp? ~ ~
  bstr : (and/c bytes? (not immutable?)) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Accepts up to end-pos-start-pos bytes of udp-socket’s next incoming
datagram into bstr, writing the datagram bytes starting at position
start-pos within bstr. The udp-socket must be bound to a local address
and port (but need not be connected). If no incoming datagram is
immediately available, udp-receive! blocks until one is available.

Three values are returned: the number of received bytes (between 0 and
end-pos-start-pos, a hostname string indicating the source address of
the datagram, and an integer indicating the source port of the datagram.
If the received datagram is longer than end-pos-start-pos bytes, the
remainder is discarded.

If start-pos is greater than the length of bstr, or if end-pos is less
than start-pos or greater than the length of bstr, the exn:fail:contract
exception is raised.

                                        *udp-receive!**
(udp-receive!*  udp-socket  ~
                bstr       
               [start-pos  
                end-pos])  
 -> (or/c exact-nonnegative-integer? #f)
    (or/c string? #f)
    (or/c port-number? #f)
  udp-socket : udp? ~ ~
  bstr : (and/c bytes? (not immutable?)) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-receive!, except that it never blocks. If no datagram is
available, the three result values are all #f.

                                        *udp-receive!/enable-break*
(udp-receive!/enable-break  udp-socket  ~
                            bstr       
                           [start-pos  
                            end-pos])  
 -> exact-nonnegative-integer?
    string?
    port-number?
  udp-socket : udp? ~ ~
  bstr : (and/c bytes? (not immutable?)) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like udp-receive!, but breaking is enabled (see [missing]) while trying
to receive the datagram. If breaking is disabled when
udp-receive!/enable-break is called, then either a datagram is received
or the exn:break exception is raised, but not both.

                                        *udp-set-receive-buffer-size!*
(udp-set-receive-buffer-size! udp-socket      ~
                              size)      -> void?
  udp-socket : udp? ~ ~
  size : exact-positive-integer? ~ ~

Set the receive buffer size (SO_RCVBUF) for udp-socket. Using a larger
buffer can minimize packet loss that can occur due to slow polling of a
connection, including during a major garbage collection.

If size is greater than the maximum allowed by the system, the
exn:fail:network exception is raised.

Added in version 7.1.0.11 of package base.

                                        *udp-close*
(udp-close udp-socket) -> void? ~
  udp-socket : udp? ~ ~

Closes udp-socket, discarding unreceived datagrams.  If the socket is
already closed, the exn:fail:network exception is raised.

                                        *udp?*
(udp? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a socket created by udp-open-socket, #f otherwise.

                                        *udp-bound?*
(udp-bound? udp-socket) -> boolean? ~
  udp-socket : udp? ~ ~

Returns #t if udp-socket is bound to a local address and port, #f
otherwise.

                                        *udp-connected?*
(udp-connected? udp-socket) -> boolean? ~
  udp-socket : udp? ~ ~

Returns #t if udp-socket is connected to a remote address and port, #f
otherwise.

                                        *udp-send-ready-evt*
(udp-send-ready-evt udp-socket) -> evt? ~
  udp-socket : udp? ~ ~

Returns a synchronizable event (see [missing]) that is in a blocking
state when udp-send-to on udp-socket would block. The synchronization
result is the event itself.

                                        *udp-receive-ready-evt*
(udp-receive-ready-evt udp-socket) -> evt? ~
  udp-socket : udp? ~ ~

Returns a synchronizable event (see [missing]) that is in a blocking
state when udp-receive! on udp-socket would block. The synchronization
result is the event itself.

                                        *udp-send-to-evt*
(udp-send-to-evt  udp-socket      ~
                  hostname       
                  port-no        
                  bstr           
                 [start-pos      
                  end-pos])  -> evt?
  udp-socket : udp? ~ ~
  hostname : string? ~ ~
  port-no : port-number? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns a synchronizable event. The event is in a blocking state when
udp-send-to on udp-socket would block. Otherwise, if the event is chosen
in a synchronization, data is sent as for (udp-send-to udp-socket
hostname-address port-no bstr start-pos end-pos), and the
synchronization result is #<void>. (No bytes are sent if the event is
not chosen.)

                                        *udp-send-evt*
(udp-send-evt  udp-socket      ~
               bstr           
              [start-pos      
               end-pos])  -> evt?
  udp-socket : udp? ~ ~
  bstr : bytes? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns a synchronizable event. The event is ready for synchronization
when udp-send on udp-socket would not block. Otherwise, if the event is
chosen in a synchronization, data is sent as for (udp-send-to udp-socket
bstr start-pos end-pos), and the synchronization result is #<void>. (No
bytes are sent if the event is not chosen.) If udp-socket is closed or
unconnected, the exn:fail:network exception is raised during a
synchronization attempt.

                                        *udp-receive!-evt*
(udp-receive!-evt  udp-socket      ~
                   bstr           
                  [start-pos      
                   end-pos])  -> evt?
  udp-socket : udp? ~ ~
  bstr : (and/c bytes? (not immutable?)) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns a synchronizable event. The event is ready for synchronization
when udp-receive on udp-socket would not block. Otherwise, if the event
is chosen in a synchronization, data is received into bstr as for
(udp-receive! udp-socket bytes start-pos end-pos), and the
synchronization result is a list of three values, corresponding to the
three results from udp-receive!. (No bytes are received and the bstr
content is not modified if the event is not chosen.)

                                        *udp-addresses*
(udp-addresses udp-port [port-numbers?]) ~
 -> (or/c (values string? string?)
          (values string? listen-port-number?
                  string? listen-port-number?))
  udp-port : udp? ~ ~
  port-numbers? : any/c = #f ~ ~

Returns two strings when port-numbers? is #f (the default). The first
string is the Internet address for the local machine a viewed by the
given UDP socket’s connection. (For most machines, the answer
corresponds to the current machine’s only Internet address, but when a
machine serves multiple addresses, the result is connection-specific.)
The second string is the Internet address for the other end of the
connection.

If port-numbers? is true, then four results are returned: a string for
the local machine’s address, an exact integer between 1 and 65535 for
the local machine’s port number or 0 if the socket is unbound, a string
for the remote machine’s address, and an exact integer between 1 and
65535 for the remote machine’s port number or 0 if the socket is
unconnected.

If the given port has been closed, the exn:fail:network exception is
raised.

                                        *udp-set-ttl!*
(udp-set-ttl! udp-socket ttl) -> void? ~
  udp-socket : udp? ~ ~
  ttl : byte? ~ ~
(udp-ttl udp-socket) -> byte?
  udp-socket : udp? ~ ~

Time-to-live settings correspond to the IP_TTL setting of the socket.

Sets or retrieves the current time-to-live setting of udp-socket.

Added in version 7.5.0.5 of package base.

                                        *udp-multicast-join-group!*
(udp-multicast-join-group! udp-socket          ~
                           multicast-addr     
                           hostname)      -> void?
  udp-socket : udp? ~ ~
  multicast-addr : string? ~ ~
  hostname : (or/c string? #f) ~ ~
(udp-multicast-leave-group! udp-socket         
                            multicast-addr     
                            hostname)      -> void?
  udp-socket : udp? ~ ~
  multicast-addr : string? ~ ~
  hostname : (or/c string? #f) ~ ~

Adds or removes udp-socket to a named multicast group.

The multicast-addr argument must be a valid IPv4 multicast IP address;
for example, "224.0.0.251" is the appropriate address for the mDNS
protocol. The hostname argument selects the interface that the socket
uses to receive (not send) multicast datagrams; if hostname is #f or
"0.0.0.0", the kernel selects an interface automatically.

Leaving a group requires the same multicast-addr and hostname arguments
that were used to join the group.

                                        *udp-multicast-interface*
(udp-multicast-interface udp-socket) -> string? ~
  udp-socket : udp? ~ ~
(udp-multicast-set-interface! udp-socket     
                              hostname)  -> void?
  udp-socket : udp? ~ ~
  hostname : (or/c string? #f) ~ ~

Retrieves or sets the interface that udp-socket uses to send (not
receive) multicast datagrams. If the result or hostname is either #f or
"0.0.0.0", the kernel automatically selects an interface when a
multicast datagram is sent.

                                        *udp-multicast-set-loopback!*
(udp-multicast-set-loopback! udp-socket      ~
                             loopback?) -> void?
  udp-socket : udp? ~ ~
  loopback? : any/c ~ ~
(udp-multicast-loopback? udp-socket) -> boolean?
  udp-socket : udp? ~ ~

Loopback settings correspond to the IP_MULTICAST_LOOP setting of the
socket.

Sets or checks whether udp-socket receives its own multicast datagrams:
a #t result or a true value for loopback? indicates that self-receipt is
enabled, and #f indicates that self-receipt is disabled.

                                        *udp-multicast-set-ttl!*
(udp-multicast-set-ttl! udp-socket ttl) -> void? ~
  udp-socket : udp? ~ ~
  ttl : byte? ~ ~
(udp-multicast-ttl udp-socket) -> byte?
  udp-socket : udp? ~ ~

Time-to-live settings correspond to the IP_MULTICAST_TTL setting of the
socket.

Sets or retrieves the current time-to-live setting of udp-socket.

The time-to-live setting should almost always be 1, and it is important
that this number is as low as possible. In fact, these functions seldom
should be used at all. See the documentation for your platform’s IP
stack.

4. Processes

                                        *subprocess*
(subprocess  stdout    ~
             stdin    
             stderr   
            [group]   
             command  
             arg ...) 
 -> subprocess?
    (or/c (and/c input-port? file-stream-port?) #f)
    (or/c (and/c output-port? file-stream-port?) #f)
    (or/c (and/c input-port? file-stream-port?) #f)
  stdout : (or/c (and/c output-port? file-stream-port?) #f) ~ ~
  stdin : (or/c (and/c input-port? file-stream-port?) #f) ~ ~
  stderr : (or/c (and/c output-port? file-stream-port?) #f 'stdout) ~ ~
  group : (or/c #f 'new subprocess) ~ ~
        = (and (subprocess-group-enabled) 'new)
  command : path-string? ~ ~
  arg : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
(subprocess  stdout  
             stdin   
             stderr  
            [group]  
             command 
             exact   
             arg)    
 -> subprocess?
    (or/c (and/c input-port? file-stream-port?) #f)
    (or/c (and/c output-port? file-stream-port?) #f)
    (or/c (and/c input-port? file-stream-port?) #f)
  stdout : (or/c (and/c output-port? file-stream-port?) #f) ~ ~
  stdin : (or/c (and/c input-port? file-stream-port?) #f) ~ ~
  stderr : (or/c (and/c output-port? file-stream-port?) #f) ~ ~
  group : (or/c #f 'new subprocess) ~ ~
        = (and (subprocess-group-enabled) 'new)
  command : path-string? ~ ~
  exact : 'exact ~ ~
  arg : string? ~ ~

Creates a new process in the underlying operating system to execute
command asynchronously, providing the new process with environment
variables current-environment-variables. See also system and process
from racket/system.

On Unix and Mac OS, subprocess creation is separate from starting the
program indicated by command. In particular, if command refers to a
non-existent or non-executable file, an error will be reported (via
standard error and a non-0 exit code) in the subprocess, not in the
creating process.

The command argument is a path to a program executable, and the args are
command-line arguments for the program. See find-executable-path for
locating an executable based on the PATH environment variable. On Unix
and Mac OS, command-line arguments are passed as byte strings, and
string args are converted using the current locale’s encoding (see
[missing]). On Windows, command-line arguments are passed as strings,
and byte strings are converted using UTF-8.

On Windows, the first arg can be replaced with 'exact, which triggers a
Windows-specific behavior: the sole arg is used exactly as the
command-line for the subprocess. Otherwise, on Windows, a command-line
string is constructed from command and arg so that a typical Windows
console application can parse it back to an array of arguments. If
'exact is provided on a non-Windows platform, the exn:fail:contract
exception is raised.

For information on the Windows command-line conventions, search for
“command line parsing” at http://msdn.microsoft.com/.

When provided as a port, stdout is used for the launched process’s
standard output, stdin is used for the process’s standard input, and
stderr is used for the process’s standard error.  All provided ports
must be file-stream ports. Any of the ports can be #f, in which case a
system pipe is created and returned by subprocess. The stderr argument
can be 'stdout, in which case the same file-stream port or system pipe
that is supplied as standard output is also used for standard error. For
each port or 'stdout that is provided, no pipe is created and the
corresponding returned value is #f. If stdout or stderr is a port for
which port-waiting-peer? returns true, then subprocess waits for the
port to become ready for writing before proceeding with the subprocess
creation.

If group is 'new, then the new process is created as a new OS-level
process group. In that case, subprocess-kill attempts to terminate all
processes within the group, which may include additional processes
created by the subprocess. Beware that creating a group may interfere
with the job control in an interactive shell, since job control is based
on process groups. See subprocess-kill for details. If group is a
subprocess, then that subprocess must have been created with 'new, and
the new subprocess will be added to the group; adding to the group will
succeed only on Unix and Mac OS, and only in the same cases that
subprocess-kill would have an effect (i.e., the subprocess is not known
to have terminated), otherwise it will fail silently.

The subprocess procedure returns four values:

* a subprocess value representing the created process;

* an input port piped from the process’s standard output, or #f if
  stdout-output-port was a port;

* an output port piped to the process’s standard input, or #f if
  stdin-input-port was a port;

* an input port piped from the process’s standard error, or #f if
  stderr-output-port was a port or 'stdout.

Important: All ports returned from subprocess must be explicitly closed,
usually with close-input-port or close-output-port.

A file-stream port for communicating with a subprocess is normally a
pipe with a limited capacity. Beware of creating deadlock by serializing
a write to a subprocess followed by a read, while the subprocess does
the same, so that both processes end up blocking on a write because the
other end must first read to make room in the pipe. Beware also of
waiting for a subprocess to finish without reading its output, because
the subprocess may be blocked attempting to write output into a full
pipe.

The returned ports are file-stream ports (see [missing]), and they are
placed into the management of the current custodian (see [missing]).
The exn:fail exception is raised when a low-level error prevents the
spawning of a process or the creation of operating system pipes for
process communication.

The current-subprocess-custodian-mode parameter determines whether the
subprocess itself is registered with the current custodian so that a
custodian shutdown calls subprocess-kill for the subprocess.

A subprocess can be used as a synchronizable event (see [missing]). A
subprocess value is ready for synchronization when subprocess-wait would
not block; the synchronization result of a subprocess value is the
subprocess value itself.

Changed in version 6.11.0.1: Added the group argument. Changed in
version 7.4.0.5: Added waiting for a fifo without a reader as stdout
and/or stderr.

                                        *subprocess-wait*
(subprocess-wait subproc) -> void? ~
  subproc : subprocess? ~ ~

Blocks until the process represented by subproc terminates. The subproc
value also can be used with sync and sync/timeout.

                                        *subprocess-status*
(subprocess-status subproc) -> (or/c 'running ~
                                     exact-nonnegative-integer?)
  subproc : subprocess? ~ ~

Returns 'running if the process represented by subproc is still running,
or its exit code otherwise. The exit code is an exact integer, and 0
typically indicates success. If the process terminated due to a fault or
signal, the exit code is non-zero.

                                        *subprocess-kill*
(subprocess-kill subproc force?) -> void? ~
  subproc : subprocess? ~ ~
  force? : any/c ~ ~

Terminates the subprocess represented by subproc. The precise action
depends on whether force? is true, whether the process was created in
its own group by setting the subprocess-group-enabled parameter to a
true value, and the current platform:

* force? is true, not a group, all platforms: Terminates the process if
  the process still running.

* force? is false, not a group, on Unix or Mac OS: Sends the process an
  interrupt signal instead of a kill signal.

* force? is false, not a group, on Windows: No action is taken.

* force? is true, a group, on Unix or Mac OS: Terminates all processes
  in the group, but only if subprocess-status has never produced a
  non-'running result for the subprocess and only if functions like
  subprocess-wait and sync have not detected the subprocess’s
  completion. Otherwise, no action is taken (because the immediate
  process is known to have terminated while the continued existence of
  the group is unknown).

* force? is true, a group, on Windows: Terminates the process if the
  process still running.

* force? is false, a group, on Unix or Mac OS: The same as when force?
  is #t, but when the group is sent a signal, it is an interrupt signal
  instead of a kill signal.

* force? is false, a group, on Windows: All processes in the group
  receive a CTRL-BREAK signal (independent of whether the immediate
  subprocess has terminated).

If an error occurs during termination, the exn:fail exception is raised.

                                        *subprocess-pid*
(subprocess-pid subproc) -> exact-nonnegative-integer? ~
  subproc : subprocess? ~ ~

Returns the operating system’s numerical ID (if any) for the process
represented by subproc. The result is valid only as long as the process
is running.

                                        *subprocess?*
(subprocess? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a subprocess value, #f otherwise.

                                        *current-subprocess-custodian-mode*
(current-subprocess-custodian-mode) ~
 -> (or/c #f 'kill 'interrupt)
(current-subprocess-custodian-mode mode) -> void?
  mode : (or/c #f 'kill 'interrupt) ~ ~

A parameter that determines whether a subprocess (as created by
subprocess or wrappers like process) is registered with the current
custodian. If the parameter value is #f, then the subprocess is not
registered with the custodian—although any created ports are registered.
If the parameter value is 'kill or 'interrupt, then the subprocess is
shut down through subprocess-kill, where 'kill supplies a #t value for
the force? argument and 'interrupt supplies a #f value. The shutdown may
occur either before or after ports created for the subprocess are
closed.

Custodian-triggered shutdown is limited by details of process handling
in the host system. For example, process and system may create an
intermediate shell process to run a program, in which case
custodian-based termination shuts down the shell process and probably
not the process started by the shell. See also subprocess-kill. Process
groups (see subprocess-group-enabled) can address some limitations, but
not all of them.

                                        *subprocess-group-enabled*
(subprocess-group-enabled) -> boolean? ~
(subprocess-group-enabled on?) -> void?
  on? : any/c ~ ~

A parameter that determines whether a subprocess is created as a new
process group by default. See subprocess and subprocess-kill for more
information.

                                        *shell-execute*
(shell-execute verb            ~
               target         
               parameters     
               dir            
               show-mode) -> #f
  verb : (or/c string? #f) ~ ~
  target : string? ~ ~
  parameters : string? ~ ~
  dir : path-string? ~ ~
  show-mode : symbol? ~ ~

Performs the action specified by verb on target in Windows. For
platforms other than Windows, the exn:fail:unsupported exception is
raised.

For example,

  (shell-execute #f "http://racket-lang.org" "" ~ ~
                 (current-directory) 'sw_shownormal)

Opens the Racket home page in a browser window.

The verb can be #f, in which case the operating system will use a
default verb. Common verbs include "open", "edit", "find", "explore",
and "print".

The target is the target for the action, usually a filename path. The
file could be executable, or it could be a file with a recognized
extension that can be handled by an installed application.

The parameters argument is passed on to the system to perform the
action. For example, in the case of opening an executable, the
parameters is used as the command line (after the executable name).

The dir is used as the current directory when performing the action.

The show-mode sets the display mode for a Window affected by the action.
It must be one of the following symbols; the description of each
symbol’s meaning is taken from the Windows API documentation.

* 'sw_hide or 'SW_HIDE — Hides the window and activates another window.

* 'sw_maximize or 'SW_MAXIMIZE — Maximizes the window.

* 'sw_minimize or 'SW_MINIMIZE — Minimizes the window and activates the
  next top-level window in the z-order.

* 'sw_restore or 'SW_RESTORE — Activates and displays the window. If the
  window is minimized or maximized, Windows restores it to its original
  size and position.

* 'sw_show or 'SW_SHOW — Activates the window and displays it in its
  current size and position.

* 'sw_showdefault or 'SW_SHOWDEFAULT — Uses a default.

* 'sw_showmaximized or 'SW_SHOWMAXIMIZED — Activates the window and
  displays it as a maximized window.

* 'sw_showminimized or 'SW_SHOWMINIMIZED — Activates the window and
  displays it as a minimized window.

* 'sw_showminnoactive or 'SW_SHOWMINNOACTIVE — Displays the window as a
  minimized window. The active window remains active.

* 'sw_showna or 'SW_SHOWNA — Displays the window in its current state.
  The active window remains active.

* 'sw_shownoactivate or 'SW_SHOWNOACTIVATE — Displays a window in its
  most recent size and position. The active window remains active.

* 'sw_shownormal or 'SW_SHOWNORMAL — Activates and displays a window. If
  the window is minimized or maximized, Windows restores it to its
  original size and position.

If the action fails, the exn:fail exception is raised. If the action
succeeds, the result is #f.

In future versions of Racket, the result may be a subprocess value if
the operating system did returns a process handle (but if a subprocess
value is returned, its process ID will be 0 instead of the real process
ID).

4.1. Simple Subprocesses

 (require racket/system) package: base ~ ~

The bindings documented in this section are provided by the
racket/system and racket libraries, but not racket/base.

                                        *system*
(system command [#:set-pwd? set-pwd?]) -> boolean? ~ ~ ~
  command : (or/c string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Executes a Unix, Mac OS, or Windows shell command synchronously (i.e.,
the call to system does not return until the subprocess has ended). The
command argument is a string or byte string containing no nul
characters. If the command succeeds, the return value is #t, #f
otherwise.

See also subprocess for notes about error handling and the limited
buffer capacity of subprocess pipes.

If set-pwd? is true, then the PWD environment variable is set to the
value of (current-directory) when starting the shell process.

See also current-subprocess-custodian-mode and subprocess-group-enabled,
which affect the subprocess used to implement system.

The resulting process writes to (current-output-port), reads from
(current-input-port), and logs errors to (current-error-port). To gather
the process’s non-error output to a string, for example, use
with-output-to-string, which sets current-output-port while calling the
given function:

  (with-output-to-string (lambda () (system "date")))

                                        *system**
(system* command arg ... [#:set-pwd? set-pwd?]) -> boolean? ~ ~ ~
  command : path-string? ~ ~
  arg : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~
(system*  command                   
          exact                     
          arg                       
         [#:set-pwd? set-pwd?]) -> boolean? ~ ~
  command : path-string? ~ ~
  exact : 'exact ~ ~
  arg : string? ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like system, except that command is a filename that is executed directly
(instead of through a shell command; see find-executable-path for
locating an executable based on the PATH environment variable), and the
args are the arguments. The executed file is passed the specified string
arguments (which must contain no nul characters).

On Windows, the first argument after command can be 'exact, and the
final arg is a complete command line. See subprocess for details.

                                        *system/exit-code*
(system/exit-code  command                    ~
                  [#:set-pwd? set-pwd?]) -> byte? ~ ~
  command : (or/c string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like system, except that the result is the exit code returned by the
subprocess. A 0 result normally indicates success.

                                        *system*/exit-code*
(system*/exit-code  command                    ~
                    arg ...                   
                   [#:set-pwd? set-pwd?]) -> byte? ~ ~
  command : path-string? ~ ~
  arg : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~
(system*/exit-code  command                   
                    exact                     
                    arg                       
                   [#:set-pwd? set-pwd?]) -> byte? ~ ~
  command : path-string? ~ ~
  exact : 'exact ~ ~
  arg : string? ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like system*, but returns the exit code like system/exit-code.

                                        *process*
(process command [#:set-pwd? set-pwd?]) ~ ~ ~
 -> (list input-port?
          output-port?
          exact-nonnegative-integer?
          input-port?
          ((or/c 'status 'wait 'interrupt 'kill) . -> . any))
  command : (or/c string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Executes a shell command asynchronously (using sh on Unix and Mac OS,
cmd on Windows). The result is a list of five values:

See also subprocess for notes about error handling and the limited
buffer capacity of subprocess pipes.

* an input port piped from the subprocess’s standard output,

* an output port piped to the subprocess’s standard input,

* the system process id of the subprocess,

* an input port piped from the subprocess’s standard error, and

* a procedure of one argument, either 'status, 'wait, 'interrupt,
  'exit-code or 'kill:

  * 'status returns the status of the subprocess as one of 'running,
    'done-ok, or 'done-error.

  * 'exit-code returns the integer exit code of the subprocess or #f if
    it is still running.

  * 'wait blocks execution in the current thread until the subprocess
    has completed.

  * 'interrupt sends the subprocess an interrupt signal on Unix and Mac
    OS, and takes no action on Windows. The result is #<void>.

    On Unix and Mac OS, if command runs a single program, then sh
    typically runs the program in such a way that it replaces sh in the
    same process. For reliable and precise control over process
    creation, however, use process*.

  * 'kill terminates the subprocess and returns #<void>.  Note that the
    immediate process created by process is a shell process that may run
    another program; terminating the shell process may not terminate
    processes that the shell starts, particularly on Windows.

Important: All three ports returned from process must be explicitly
closed with close-input-port or close-output-port.

If set-pwd? is true, then PWD is set in the same way as system.

See also current-subprocess-custodian-mode and subprocess-group-enabled,
which affect the subprocess used to implement process. In particular,
the 'interrupt and 'kill process-control messages are implemented via
subprocess-kill, so they can affect a process group instead of a single
process.

                                        *process**
(process*  command                    ~
           arg ...                   
          [#:set-pwd? set-pwd?]) -> list? ~ ~
  command : path-string? ~ ~
  arg : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~
(process*  command                   
           exact                     
           arg                       
          [#:set-pwd? set-pwd?]) -> list? ~ ~
  command : path-string? ~ ~
  exact : 'exact ~ ~
  arg : string? ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like process, except that command is a filename that is executed
directly like system*, and the args are the arguments. On Windows, as
for system*, the first arg can be replaced with 'exact.

                                        *process/ports*
(process/ports  out                        ~
                in                        
                error-out                 
                command                   
               [#:set-pwd? set-pwd?]) -> list? ~ ~
  out : (or/c #f output-port?) ~ ~
  in : (or/c #f input-port?) ~ ~
  error-out : (or/c #f output-port? 'stdout) ~ ~
  command : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like process, except that out is used for the process’s standard output,
in is used for the process’s standard input, and error-out is used for
the process’s standard error.  Any of the ports can be #f, in which case
a system pipe is created and returned, as in process. If error-out is
'stdout, then standard error is redirected to standard output.  For each
port or 'stdout that is provided, no pipe is created, and the
corresponding value in the returned list is #f.

                                        *process*/ports*
(process*/ports  out                        ~
                 in                        
                 error-out                 
                 command                   
                 arg ...                   
                [#:set-pwd? set-pwd?]) -> list? ~ ~
  out : (or/c #f output-port?) ~ ~
  in : (or/c #f input-port?) ~ ~
  error-out : (or/c #f output-port? 'stdout) ~ ~
  command : path-string? ~ ~
  arg : (or/c path? string-no-nuls? bytes-no-nuls?) ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~
(process*/ports  out                       
                 in                        
                 error-out                 
                 command                   
                 exact                     
                 arg                       
                [#:set-pwd? set-pwd?]) -> list? ~ ~
  out : (or/c #f output-port?) ~ ~
  in : (or/c #f input-port?) ~ ~
  error-out : (or/c #f output-port? 'stdout) ~ ~
  command : path-string? ~ ~
  exact : 'exact ~ ~
  arg : string? ~ ~
  set-pwd? : any/c = (member (system-type) '(unix macosx)) ~ ~

Like process*, but with the port handling of process/ports.

The contracts of system and related functions may signal a contract
error with references to the following functions.

                                        *string-no-nuls?*
(string-no-nuls? x) -> boolean? ~
  x : any/c ~ ~

Ensures that x is a string and does not contain "\u0000".

                                        *bytes-no-nuls?*
(bytes-no-nuls? x) -> boolean? ~
  x : any/c ~ ~

Ensures that x is a byte-string and does not contain #"\0".

5. Logging

A logger accepts events that contain information to be logged for
interested parties. A log receiver represents an interested party that
receives logged events asynchronously. Each event has a topic and level
of detail, and a log receiver subscribes to logging events at a certain
level of detail (and lower) for a specific topic or for all topics. The
levels, in increasing order of detail, are 'none, 'fatal, 'error,
'warning, 'info, and 'debug.

To help organize logged events, a logger can have a default topic and/or
a parent logger. Every event reported to a logger is propagated to its
parent (if any), and the event message is prefixed with the logger’s
topic (if any) if the message doesn’t already have a topic. Furthermore,
events that are propagated from a logger to its parent can be filtered
by level and topic.

On start-up, Racket creates an initial logger that is used to record
events from the core run-time system. For example, a 'debug event is
reported for each garbage collection (see [missing]). For this initial
logger, two log receivers are also created: one that writes events to
the process’s original error output port, and one that writes events to
the system log. The level of written events in each case is
system-specific, and the default can be changed through command-line
flags (see [missing]) or through environment variables:

* If the PLTSTDERR environment variable is defined and is not overridden
  by a command-line flag, it determines the level of the log receiver
  that propagates events to the original error port.

  The environment variable’s value can be a >level<: none, fatal, error,
  warning, info, or debug (from low detail to high detail); all events
  at the corresponding level of detail or lower are printed. After an
  initial >level<, the value can contain whitespace-separated
  specifications of the form >level<@>topic<, which prints events whose
  topics match >topic< only at the given >level< or higher (where a
  >topic< contains any character other than whitespace or @). Leading
  and trailing whitespace is ignored. For example, the value "error
  debug@GC" prints all events at the 'error level and higher, but prints
  events for the topic 'GC at the 'debug level and higher (which
  includes all levels).

  The default is "error".

* If the PLTSTDOUT environment variable is defined and is not overridden
  by a command-line flag, it determines the level of the log receiver
  that propagates events to the original output port. The possible
  values are the same as for PLTSTDERR.

  The default is "none".

* If the PLTSYSLOG environment variable is defined and is not overridden
  by a command-line flag, it determines the level of the log receiver
  that propagates events to the system log. The possible values are the
  same as for PLTSTDERR.

  The default is "none" for Unix or "error" for Windows and Mac OS.

The current-logger parameter determines the current logger that is used
by forms such as log-warning. On start-up, the initial value of this
parameter is the initial logger. The run-time system sometimes uses the
current logger to report events. For example, the bytecode compiler
sometimes reports 'warning events when it detects an expression that
would produce a run-time error if evaluated.

Changed in version 6.6.0.2: Prior to version 6.6.0.2, parsing of
PLTSTDERR and PLTSYSLOG was very strict. Leading and trailing whitespace
was forbidden, and anything other than exactly one space character
separating two specifications was rejected. Changed in version
6.90.0.17: Added PLTSTDOUT.

5.1. Creating Loggers

                                        *logger?*
(logger? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a logger, #f otherwise.

                                        *make-logger*
(make-logger [topic                     ~
              parent                   
              propagate-level          
              propagate-topic ...]     
              ...)                 -> logger?
  topic : (or/c symbol? #f) = #f ~ ~
  parent : (or/c logger? #f) = #f ~ ~
  propagate-level : log-level/c = 'debug ~ ~
  propagate-topic : (or/c #f symbol?) = #f ~ ~

Creates a new logger with an optional topic and parent.

The optional propagate-level and propagate-topic arguments constrain the
events that are propagated from the new logger to parent (when parent is
not #f) in the same way that events are described for a log receiver in
make-log-receiver. By default, all events are propagated to parent.

Changed in version 6.1.1.3: Removed an optional argument to specify a
notification callback, and added propagate-level and propagate-topic
constraints for events to propagate.

                                        *logger-name*
(logger-name logger) -> (or/c symbol? #f) ~
  logger : logger? ~ ~

Reports logger’s default topic, if any.

                                        *current-logger*
(current-logger) -> logger? ~
(current-logger logger) -> void?
  logger : logger? ~ ~

A parameter that determines the current logger.

                                        *define-logger*
(define-logger id maybe-parent) ~
 
maybe-parent = 
             | #:parent parent-expr ~ ~
 
  parent-expr : (or/c logger? #f) ~ ~

Defines log-id-fatal, log-id-error, log-id-warning, log-id-info, and
log-id-debug as forms like log-fatal, log-error,log-warning, log-info,
and log-debug. The define-logger form also defines id-logger, which is a
logger with default topic 'id that is a child of the result of
parent-expr (if parent-expr does not produce #f), or of (current-logger)
if parent-expr not provided; the log-id-fatal, etc. forms use this new
logger. The new logger is created when define-logger is evaluated.

Changed in version 7.1.0.9: Added the #:parent option.

5.2. Logging Events

                                        *log-message*
(log-message  logger                 ~
              level                 
             [topic]                
              message               
             [data                  
              prefix-message?]) -> void?
  logger : logger? ~ ~
  level : log-level/c ~ ~
  topic : (or/c symbol? #f) = (logger-name logger) ~ ~
  message : string? ~ ~
  data : any/c = #f ~ ~
  prefix-message? : any/c = #t ~ ~

Reports an event to logger, which in turn distributes the information to
any log receivers attached to logger or its ancestors that are
interested in events at level or higher.

Log receivers can filter events based on topic.  In addition, if topic
and prefix-message? are not #f, then message is prefixed with the topic
followed by ": " before it is sent to receivers.

Changed in version 6.0.1.10: Added the prefix-message? argument. Changed
in version 7.2.0.7: Made the data argument optional.

                                        *log-level?*
(log-level? logger level [topic]) -> boolean? ~
  logger : logger? ~ ~
  level : log-level/c ~ ~
  topic : (or/c symbol? #f) = #f ~ ~

Reports whether any log receiver attached to logger or one of its
ancestors is interested in level events (or potentially lower) for
topic. If topic is #f, the result indicates whether a log receiver is
interested in events at level for any topic.

Use this function to avoid work generating an event for log-message if
no receiver is interested in the information; this shortcut is built
into log-fatal, log-error, log-warning, log-info, log-debug, and forms
bound by define-logger, however, so it should not be used with those
forms.

The result of this function can change if a garbage collection
determines that a log receiver is no longer accessible (and therefore
that any event information it receives will never become accessible).

Changed in version 6.1.1.3: Added the topic argument.

                                        *log-max-level*
(log-max-level logger [topic]) -> (or/c log-level/c #f) ~
  logger : logger? ~ ~
  topic : (or/c symbol? #f) = #f ~ ~

Similar to log-level?, but reports the maximum-detail level of logging
for which log-level? on logger and topic returns #t. The result is #f if
log-level? with logger and topic currently returns #f for all levels.

Changed in version 6.1.1.3: Added the topic argument.

                                        *log-all-levels*
(log-all-levels logger) -> (list/c (or/c #f log-level/c) ~
                                   (or/c #f symbol?)
                                   ... ...)
  logger : logger? ~ ~

Summarizes the possible results of log-max-level on all possible
interned symbols. The result list contains a sequence of symbols and #f,
where the first, third, etc., list element corresponds to a level, and
the second, fourth, etc., list element indicates a corresponding topic.
The level is the result that log-max-level would produce for the topic,
where the level for the #f topic (which is always present in the result
list) indicates the result for any interned-symbol topic that does not
appear in the list.

The result is suitable as a sequence of arguments to make-log-receiver
(after a logger argument) to create a new receiver for events that
currently have receivers in logger.

Added in version 6.1.1.4.

                                        *log-level-evt*
(log-level-evt logger) -> evt? ~
  logger : logger? ~ ~

Creates a synchronizable event that is ready for synchronization when
the result of log-level?, log-max-level, or log-all-levels can be
different than before log-level-evt was called. The event’s
synchronization result is the event itself.

The condition reported by the event is a conservative approximation: the
event can become ready for synchronization even if the results of
log-level?, log-max-level, and log-all-levels are unchanged.
Nevertheless, the expectation is that events produced by log-level-evt
become ready infrequently, because they are triggered by the creation of
a log receiver.

Added in version 6.1.1.4.

                                        *log-fatal*
(log-fatal string-expr) ~
(log-fatal format-string-expr v ...)
(log-error string-expr)
(log-error format-string-expr v ...)
(log-warning string-expr)
(log-warning format-string-expr v ...)
(log-info string-expr)
(log-info format-string-expr v ...)
(log-debug string-expr)
(log-debug format-string-expr v ...)

Log an event with the current logger, evaluating string-expr or (format
format-string-expr v ...) only if the logger has receivers that are
interested in the event. In addition, the current continuation’s
continuation marks are sent to the logger with the message string.

These form are convenient for using the current logger, but libraries
should generally use a logger for a specific topic—typically through
similar convenience forms generated by define-logger.

For each log-level,

  (log-level string-expr)

is equivalent to

  (let ([l (current-logger)])
    (when (log-level? l 'level)
      (log-message l 'level string-expr
                   (current-continuation-marks))))

while

  (log-level format-string-expr v ...)

is equivalent to

  (log-level (format format-string-expr v ...))

5.3. Receiving Logged Events

                                        *log-receiver?*
(log-receiver? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a log receiver, #f otherwise.

                                        *make-log-receiver*
(make-log-receiver logger level [topic ...] ...) -> log-receiver? ~
  logger : logger? ~ ~
  level : log-level/c ~ ~
  topic : (or/c #f symbol?) = #f ~ ~

Creates a log receiver to receive events of detail level and lower as
reported to logger and its descendants, as long as either topic is #f or
the event’s topic matches topic.

A log receiver is a synchronizable event. It becomes ready for
synchronization when a logging event is received, so use sync to receive
a logged event. The log receiver’s synchronization result is an
immutable vector containing four values: the level of the event as a
symbol, an immutable string for the event message, an arbitrary value
that was supplied as the last argument to log-message when the event was
logged, and a symbol or #f for the event topic.

Multiple pairs of level and topic can be provided to indicate different
specific levels for different topics (where topic defaults to #f only
for the last given level). A level for a #f topic applies only to events
whose topic does not match any other provided topic. If the same topic
is provided multiple times, the level provided with the last instance in
the argument list takes precedence.

5.4. Additional Logging Functions

 (require racket/logging) package: base ~ ~

The bindings documented in this section are provided by the
racket/logging library, not racket/base or racket.

                                        *log-level/c*
(log-level/c v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a valid logging level ('none, 'fatal, 'error,
'warning, 'info, or 'debug), #f otherwise.

Added in version 6.3 of package base.

                                        *with-intercepted-logging*
(with-intercepted-logging  interceptor           ~
                           proc                 
                          [#:logger logger]      ~ ~
                           level                
                          [topic ...]           
                           ...)             -> any
  interceptor : (-> (vector/c ~ ~
                      log-level/c
                      string?
                      any/c
                      (or/c symbol? #f))
                     any)
  proc : (-> any) ~ ~
  logger : logger? = #f ~ ~
  level : log-level/c ~ ~
  topic : (or/c #f symbol?) = #f ~ ~

Runs proc, calling interceptor on any log event that the execution of
proc emits to current-logger at the specified levels and topics. If
#:logger is specified, intercepts events sent to that logger, otherwise
uses a new child logger of the current logger. Returns whatever proc
returns.

Example:

  > (let ([warning-counter 0])
      (with-intercepted-logging
        (lambda (l)
          (when (eq? (vector-ref l 0)
                     'warning)
            (set! warning-counter (add1 warning-counter))))
        (lambda ()
          (log-warning "Warning!")
          (log-warning "Warning again!")
          (+ 2 2))
        'warning)
      warning-counter)
  2

Added in version 6.3 of package base. Changed in version 6.7.0.1: Added
#:logger argument.

                                        *with-logging-to-port*
(with-logging-to-port  port                  ~
                       proc                 
                      [#:logger logger]      ~ ~
                       level                
                      [topic ...]           
                       ...)             -> any
  port : output-port? ~ ~
  proc : (-> any) ~ ~
  logger : logger? = #f ~ ~
  level : log-level/c ~ ~
  topic : (or/c #f symbol?) = #f ~ ~

Runs proc, outputting any logging that the execution of proc emits to
current-logger at the specified levels and topics. If #:logger is
specified, intercepts events sent to that logger, otherwise uses a new
child logger of the current logger. Returns whatever proc returns.

Example:

  > (let ([my-log (open-output-string)])
      (with-logging-to-port my-log
        (lambda ()
          (log-warning "Warning World!")
          (+ 2 2))
        'warning)
      (get-output-string my-log))
  "Warning World!\n"

Added in version 6.3 of package base. Changed in version 6.7.0.1: Added
#:logger argument.

6. Time

                                        *current-seconds*
(current-seconds) -> exact-integer? ~

Returns the current time in seconds since midnight UTC, January 1, 1970.

                                        *current-inexact-milliseconds*
(current-inexact-milliseconds) -> real? ~

Returns the current time in milliseconds since midnight UTC, January 1,
1970. The result may contain fractions of a millisecond.

Example:

  > (current-inexact-milliseconds)
  1289513737015.418

In this example, 1289513737015 is in milliseconds and 418 is in
microseconds.

                                        *seconds->date*
(seconds->date secs-n [local-time?]) -> date*? ~
  secs-n : real? ~ ~
  local-time? : any/c = #t ~ ~

Takes secs-n, a platform-specific time in seconds returned by
current-seconds, file-or-directory-modify-seconds, or 1/1000th of
current-inexact-milliseconds, and returns an instance of the date*
structure type. Note that secs-n can include fractions of a second. If
secs-n is too small or large, the exn:fail exception is raised.

The resulting date* reflects the time according to the local time zone
if local-time? is #t, otherwise it reflects a date in UTC.

                                        *struct*
(struct date (second ~
              minute
              hour
              day
              month
              year
              week-day
              year-day
              dst?
              time-zone-offset)
    #:extra-constructor-name make-date ~ ~
    #:transparent) ~ ~
  second : (integer-in 0 60) ~ ~
  minute : (integer-in 0 59) ~ ~
  hour : (integer-in 0 23) ~ ~
  day : (integer-in 1 31) ~ ~
  month : (integer-in 1 12) ~ ~
  year : exact-integer? ~ ~
  week-day : (integer-in 0 6) ~ ~
  year-day : (integer-in 0 365) ~ ~
  dst? : boolean? ~ ~
  time-zone-offset : exact-integer? ~ ~

Represents a date. The second field reaches 60 only for leap seconds.
The week-day field is 0 for Sunday, 1 for Monday, etc. The year-day
field is 0 for January 1, 1 for January 2, etc.; the year-day field
reaches 365 only in leap years.

The dst? field is #t if the date reflects a daylight-saving adjustment.
The time-zone-offset field reports the number of seconds east of UTC
(GMT) for the current time zone (e.g., Pacific Standard Time is -28800),
including any daylight-saving adjustment (e.g., Pacific Daylight Time is
-25200). When a date record is generated by seconds->date with #f as the
second argument, then the dst? and time-zone-offset fields are #f and 0,
respectively.

The date constructor accepts any value for dst? and converts any non-#f
value to #t.

The value produced for the time-zone-offset field tends to be sensitive
to the value of the TZ environment variable, especially on Unix
platforms; consult the system documentation (usually under tzset) for
details.

See also the racket/date library.

                                        *struct*
(struct date* date (nanosecond time-zone-name) ~
    #:extra-constructor-name make-date*) ~ ~
  nanosecond : (integer-in 0 999999999) ~ ~
  time-zone-name : (and/c string? immutable?) ~ ~

Extends date with nanoseconds and a time zone name, such as "MDT",
"Mountain Daylight Time", or "UTC".

When a date* record is generated by seconds->date with #f as the second
argument, then the time-zone-name field is "UTC".

The date* constructor accepts a mutable string for time-zone-name and
converts it to an immutable one.

                                        *current-milliseconds*
(current-milliseconds) -> exact-integer? ~

Like current-inexact-milliseconds, but coerced to a fixnum (possibly
negative). Since the result is a fixnum, the value increases only over a
limited (though reasonably long) time on a 32-bit platform.

                                        *current-process-milliseconds*
(current-process-milliseconds [scope]) -> exact-integer? ~
  scope : (or/c #f thread? 'subprocesses) = #f ~ ~

Returns an amount of processor time in fixnum milliseconds that has been
consumed by on the underlying operating system, including both user and
system time.

* If scope is #f, the reported time is for all Racket threads and
  places.

* If scope is a thread, the result is specific to the time while the
  thread ran, but it may include time for other places. The more a
  thread synchronizes with other threads, the less precisely per-thread
  processor time is recorded.

* If scope is 'subprocesses, the result is the sum of process times for
  known-completed subprocesses (see Processes)—and known-completed
  children of the subprocesses, etc., on Unix and Mac OS—across all
  places.

The precision of the result is platform-specific, and since the result
is a fixnum, the value increases only over a limited (though reasonably
long) time on a 32-bit platform.

Changed in version 6.1.1.4: Added 'subprocesses mode.

                                        *current-gc-milliseconds*
(current-gc-milliseconds) -> exact-integer? ~

Returns the amount of processor time in fixnum milliseconds that has
been consumed by Racket’s garbage collection so far. This time is a
portion of the time reported by (current-process-milliseconds), and is
similarly limited.

                                        *time-apply*
(time-apply proc lst) -> list? ~
                         exact-integer?
                         exact-integer?
                         exact-integer?
  proc : procedure? ~ ~
  lst : list? ~ ~

Collects timing information for a procedure application.

Four values are returned: a list containing the result(s) of applying
proc to the arguments in lst, the number of milliseconds of CPU time
required to obtain this result, the number of “real” milliseconds
required for the result, and the number of milliseconds of CPU time
(included in the first result) spent on garbage collection.

The reliability of the timing numbers depends on the platform. If
multiple Racket threads are running, then the reported time may include
work performed by other threads.

                                        *time*
(time body ...+) ~

Reports time-apply-style timing information for the evaluation of expr
directly to the current output port.  The result is the result of  the
last body.

6.1. Date Utilities

For more date & time operations, see the Gregor: Date and Time
documentation or srfi/19

 (require racket/date) package: base ~ ~

The bindings documented in this section are provided by the racket/date
library, not racket/base or racket.

                                        *current-date*
(current-date) -> date*? ~

An abbreviation for (seconds->date (* 0.001
(current-inexact-milliseconds))).

                                        *date->string*
(date->string date [time?]) -> string? ~
  date : date? ~ ~
  time? : any/c = #f ~ ~

Converts a date to a string. The returned string contains the time of
day only if time?. See also date-display-format.

                                        *date-display-format*
(date-display-format) -> (or/c 'american ~
                               'chinese
                               'german
                               'indian
                               'irish
                               'iso-8601
                               'rfc2822
                               'julian)
(date-display-format format) -> void?
  format : (or/c 'american ~ ~
                 'chinese
                 'german
                 'indian
                 'irish
                 'iso-8601
                 'rfc2822
                 'julian)

Parameter that determines the date string format. The initial format is
'american.

                                        *date->seconds*
(date->seconds date [local-time?]) -> exact-integer? ~
  date : date? ~ ~
  local-time? : any/c = #t ~ ~

Finds the representation of a date in platform-specific seconds. If the
platform cannot represent the specified date, exn:fail exception is
raised.

The week-day, year-day fields of date are ignored.  The dst? and
time-zone-offset fields of date are also ignored; the date is assumed to
be in local time by default or in UTC if local-time? is #f.

                                        *date*->seconds*
(date*->seconds date [local-time?]) -> real? ~
  date : date? ~ ~
  local-time? : any/c = #t ~ ~

Like date->seconds, but returns an exact number that can include a
fraction of a second based on (date*-nanosecond date) if date is a date*
instance.

                                        *find-seconds*
(find-seconds  second             ~
               minute            
               hour              
               day               
               month             
               year              
              [local-time?]) -> exact-integer?
  second : (integer-in 0 61) ~ ~
  minute : (integer-in 0 59) ~ ~
  hour : (integer-in 0 23) ~ ~
  day : (integer-in 1 31) ~ ~
  month : (integer-in 1 12) ~ ~
  year : exact-nonnegative-integer? ~ ~
  local-time? : any/c = #t ~ ~

Finds the representation of a date in platform-specific seconds. The
arguments correspond to the fields of the date structure—in local time
by default or UTC if local-time? is #f. If the platform cannot represent
the specified date, an error is signaled, otherwise an integer is
returned.

                                        *date->julian/scaliger*
(date->julian/scaliger date) -> exact-integer? ~
  date : date? ~ ~

Converts a date structure (up to 2099 BCE Gregorian) into a Julian date
number. The returned value is not a strict Julian number, but rather
Scaliger’s version, which is off by one for easier calculations.

                                        *julian/scaliger->string*
(julian/scaliger->string date-number) -> string? ~
  date-number : exact-integer? ~ ~

Converts a Julian number (Scaliger’s off-by-one version) into a string.

                                        *date->julian/scalinger*
(date->julian/scalinger date) -> exact-integer? ~
  date : date? ~ ~
(julian/scalinger->string date-number) -> string?
  date-number : exact-integer? ~ ~

The same as date->julian/scaliger and julian/scaliger->string, but
misspelled.

7. Environment Variables

An environment variable set encapsulates a partial mapping from byte
strings to byte strings. A Racket process’s initial environment variable
set is connected to the operating system’s environment variables:
accesses or changes to the set read or change operating-system
environment variables for the Racket process.

Since Windows environment variables are case-insensitive, environment
variable set’s key byte strings on Windows are case-folded. More
precisely, key byte strings are coerced to a UTF-8 encoding of
characters that are converted to lowercase via string-locale-downcase.

The current environment variable set, which is determined by the
current-environment-variables parameter, is propagated to a subprocess
when the subprocess is created.

                                        *environment-variables?*
(environment-variables? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is an environment variable set, #f otherwise.

                                        *current-environment-variables*
(current-environment-variables) -> environment-variables? ~
(current-environment-variables env) -> void?
  env : environment-variables? ~ ~

A parameter that determines the environment variable set that is
propagated to a subprocess and that is used as the default set for
getenv and putenv.

                                        *bytes-environment-variable-name?*
(bytes-environment-variable-name? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a byte string and if it is valid for an environment
variable name. An environment variable name must contain no bytes with
the value 0 or 61, where 61 is (char->integer #\=). On Windows, an
environment variable name also must have a non-zero length.

                                        *make-environment-variables*
(make-environment-variables name val ... ...) ~
 -> environment-variables?
  name : bytes-environment-variable-name? ~ ~
  val : bytes-no-nuls? ~ ~

Creates a fresh environment variable set that is initialized with the
given name to val mappings.

                                        *environment-variables-ref*
(environment-variables-ref env name) ~
 -> (or/c #f (and/c bytes-no-nuls? immutable?))
  env : environment-variables? ~ ~
  name : bytes-environment-variable-name? ~ ~

Returns the mapping for name in env, returning #f if name has no
mapping.

Normally, name should be a byte-string encoding of a string using the
default encoding of the current locale. On Windows, name is coerced to a
UTF-8 encoding and case-normalized.

                                        *environment-variables-set!*
(environment-variables-set!  env             ~
                             name           
                             maybe-bstr     
                            [fail])     -> any
  env : environment-variables? ~ ~
  name : bytes-environment-variable-name? ~ ~
  maybe-bstr : (or/c bytes-no-nuls? #f) ~ ~
  fail : (-> any) = (lambda () ~ ~
                      (raise (make-exn:fail ....))) ~ ~

Changes the mapping for name in env to maybe-bstr.  If maybe-bstr is #f
and env is the initial environment variable set of the Racket process,
then the operating system environment-variable mapping for name is
removed.

Normally, name and maybe-bstr should be a byte-string encoding of a
string using the default encoding of the current locale. On Windows,
name is coerced to a UTF-8 encoding and case-normalized, and maybe-bstr
is coerced to a UTF-8 encoding if env is the initial environment
variable set of the Racket process.

On success, the result of environment-variables-set! is #<void>. If env
is the initial environment variable set of the Racket process, then
attempting to adjust the operating system environment-variable mapping
might fail for some reason, in which case fail is called in tail
position with respect to the environment-variables-set!. The default
fail raises an exception.

                                        *environment-variables-names*
(environment-variables-names env) ~
 -> (listof (and/c bytes-environment-variable-name? immutable?))
  env : environment-variables? ~ ~

Returns a list of byte strings that corresponds to names mapped by env.

                                        *environment-variables-copy*
(environment-variables-copy env) -> environment-variables? ~
  env : environment-variables? ~ ~

Returns an environment variable set that is initialized with the same
mappings as env.

                                        *getenv*
(getenv name) -> (or/c string-no-nuls? #f) ~
  name : string-environment-variable-name? ~ ~
(putenv name value) -> boolean?
  name : string-environment-variable-name? ~ ~
  value : string-no-nuls? ~ ~

Convenience wrappers for environment-variables-ref and
environment-variables-set! that convert between strings and byte strings
using the current locale’s default encoding (using #\? as the
replacement character for encoding errors) and always using the current
environment variable set from current-environment-variables. The putenv
function returns #t for success and #f for failure.

                                        *string-environment-variable-name?*
(string-environment-variable-name? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a string and if its encoding using the current
locale’s encoding is valid for an environment variable name according to
bytes-environment-variable-name?.

8. Environment and Runtime Information

                                        *system-type*
(system-type [mode]) ~
 -> (or/c symbol? string? bytes? exact-positive-integer? vector? #f)
  mode : (or/c 'os 'word 'vm 'gc 'link 'machine 'target-machine ~ ~
               'so-suffix 'so-mode 'fs-change 'cross)
       = 'os

Returns information about the operating system, build mode, or machine
for a running Racket. (Installation tools should use cross-system-type,
instead, to support cross-installation.)

In 'os mode,  the possible symbol results are:

* 'unix

* 'windows

* 'macosx

In 'word mode, the result is either 32 or 64 to indicate whether Racket
is running as a 32-bit program or 64-bit program.

See [missing] for more information about the 'vm and 'gc mode results.

In 'vm mode, the possible symbol results are:

* 'racket

* 'chez-scheme

In 'gc mode, the possible symbol results are:

* 'cgc — when (system-type 'vm) is 'racket

* '3m — when (system-type 'vm) is 'racket

* 'cs — when (system-type 'vm) is 'chez-scheme

In 'link mode, the possible symbol results are:

* 'static (Unix)

* 'shared (Unix)

* 'dll (Windows)

* 'framework (Mac OS)

Future ports of Racket may expand the list of 'os, 'vm, 'gc, and 'link
results.

In 'machine mode, then the result is a string, which contains further
details about the current machine in a platform-specific format.

In 'target-machine mode, the result is a symbol for the running Racket’s
native bytecode format, or it is #f if there is no native format other
than the machine-independent format. If the result is a symbol, then
compile-target-machine? returns #t when applied to the symbol; see also
current-compile-target-machine.

In 'so-suffix mode, then the result is a byte string that represents the
file extension used for shared objects on the current platform. The byte
string starts with a period, so it is suitable as a second argument to
path-replace-suffix.

In 'so-mode mode, then the result is 'local if foreign libraries should
be opened in “local” mode by default (as on most platforms) or 'global
if foreign libraries should be opened in “global” mode.

In 'fs-change mode, the result is an immutable vector of four elements.
Each element is either #f or a symbol, where a symbol indicates the
presence of a property and #f indicates the absence of a property. The
possible symbols, in order, are:

* 'supported — filesystem-change-evt can produce a filesystem change
  event to monitor filesystem changes; if this symbol is not first in
  the vector, all other vector elements are #f

* 'scalable — resources consumed by a filesystem change event are
  effectively limited only by available memory, as opposed to
  file-descriptor limits; this property is #f on Mac OS and BSD variants
  of Unix

* 'low-latency — creation and checking of a filesystem change event is
  practically instantaneous; this property is #f on Linux

* 'file-level — a filesystem change event can track changes at the level
  of a file, as opposed to the file’s directory; this property is #f on
  Windows

In 'cross mode, the result reports whether cross-platform build mode has
been selected (through the -C or --cross argument to racket; see
[missing]). The possible symbols are:

* 'infer — infer cross-platform mode based on whether (system-type) and
  (cross-system-type) report the same symbol

* 'force — use cross-platform mode, even if the current and target
  system types are the same, because the current and target executables
  can be different

Changed in version 6.8.0.2: Added 'vm mode. Changed in version 6.9.0.1:
Added 'cross mode. Changed in version 7.1.0.6: Added 'target-machine
mode.

                                        *system-language+country*
(system-language+country) -> string? ~

Returns a string to identify the current user’s language and country.

On Unix and Mac OS, the string is five characters: two lowercase ASCII
letters for the language, an underscore, and two uppercase ASCII letters
for the country. On Windows, the string can be arbitrarily long, but the
language and country are in English (all ASCII letters or spaces)
separated by an underscore.

On Unix, the result is determined by checking the LC_ALL, LC_TYPE, and
LANG environment variables, in that order (and the result is used if the
environment variable’s value starts with two lowercase ASCII letters, an
underscore, and two uppercase ASCII letters, followed by either nothing
or a period). On Windows and Mac OS, the result is determined by system
calls.

                                        *system-library-subpath*
(system-library-subpath [mode]) -> path? ~
  mode : (or/c 'cgc '3m 'cs #f) = (system-type 'gc) ~ ~

Returns a relative directory path. This string can be used to build
paths to system-specific files. For example, when Racket is running on
Solaris on a Sparc architecture, the subpath starts "sparc-solaris",
while the subpath for Windows on an i386 architecture starts
"win32\\i386".

The optional mode argument specifies the relevant garbage-collection
variant, which one of the possible results of (system-type 'gc): 'cgc,
'3m, or 'cs. It can also be #f, in which case the result is independent
of the garbage-collection variant.

Installation tools should use cross-system-library-subpath, instead, to
support cross-installation.

Changed in version 7.0: Added 'cs mode.

                                        *version*
(version) -> (and/c string? immutable?) ~

Returns an immutable string indicating the currently executing version
of Racket.

                                        *banner*
(banner) -> (and/c string? immutable?) ~

Returns an immutable string for Racket’s start-up banner text (or the
banner text for an embedding program, such as GRacket). The banner
string ends with a newline.

                                        *current-command-line-arguments*
(current-command-line-arguments) ~
 -> (vectorof (and/c string? immutable?))
(current-command-line-arguments argv) -> void?
  argv : (vectorof string?) ~ ~

A parameter that is initialized with command-line arguments when Racket
starts (not including any command-line arguments that were treated as
flags for the system).

On Unix and Mac OS, command-line arguments are provided to the Racket
process as byte strings. The arguments are converted to strings using
bytes->string/locale and #\uFFFD as the encoding-error character.

                                        *current-thread-initial-stack-size*
(current-thread-initial-stack-size) -> exact-positive-integer? ~
(current-thread-initial-stack-size size) -> void?
  size : exact-positive-integer? ~ ~

A parameter that provides a hint about how much space to reserve for a
newly created thread’s local variables. The actual space used by a
computation is affected by JIT compilation, but it is otherwise
platform-independent.

                                        *vector-set-performance-stats!*
(vector-set-performance-stats! results [thd]) -> void? ~
  results : (and/c vector? ~ ~
                   (not/c immutable?))
  thd : (or/c thread? #f) = #f ~ ~

Sets elements in results to report current performance statistics. If
thd is not #f, a particular set of thread-specific statistics are
reported, otherwise a different set of global (within the current place)
statistics are reported.

For global statistics, up to 12 elements are set in the vector, starting
from the beginning. If results has n elements where n < 12, then the n
elements are set to the first n performance-statistics values. The
reported statistics values are as follows, in the order that they are
set within results:

* 0: The same value as returned by current-process-milliseconds.

* 1: The same value as returned by current-milliseconds.

* 2: The same value as returned by current-gc-milliseconds.

* 3: The number of garbage collections performed since start-up within
  the current place.

* 4: The number of thread context switches performed since start-up.

* 5: The number of internal stack overflows handled since start-up.

* 6: The number of threads currently scheduled for execution (i.e.,
  threads that are running, not suspended, and not unscheduled due to a
  synchronization).

* 7: The number of syntax objects read from compiled code since
  start-up.

* 8: The number of hash-table searches performed. When this counter
  reaches the maximum value of a fixnum, it overflows to the most
  negative fixnum.

* 9: The number of additional hash slots searched to complete hash
  searches (using double hashing).  When this counter reaches the
  maximum value of a fixnum, it overflows to the most negative fixnum.

* 10: The number of bytes allocated for machine code that is not
  reported by current-memory-use.

* 11: The peak number of allocated bytes just before a garbage
  collection.

For thread-specific statistics, up to 4 elements are set in the vector:

* 0: #t if the thread is running, #f otherwise (same result as
  thread-running?).

* 1: #t if the thread has terminated, #f otherwise (same result as
  thread-dead?).

* 2: #t if the thread is currently blocked on a synchronizable event (or
  sleeping for some number of milliseconds), #f otherwise.

* 3: The number of bytes currently in use for the thread’s continuation.

Changed in version 6.1.1.8: Added vector position 11 for global
statistics.

9. Command-Line Parsing

 (require racket/cmdline) package: base ~ ~

The bindings documented in this section are provided by the
racket/cmdline and racket libraries, but not racket/base.

                                        *command-line*
(command-line optional-name-expr optional-argv-expr ~
              flag-clause ...
              finish-clause)
 
optional-name-expr = 
                   | #:program name-expr ~ ~
                      
optional-argv-expr = 
                   | #:argv argv-expr ~ ~
                      
       flag-clause = #:multi flag-spec ... ~ ~
                   | #:once-each flag-spec ... ~ ~
                   | #:once-any flag-spec ... ~ ~
                   | #:final flag-spec ... ~ ~
                   | #:usage-help string ... ~ ~
                   | #:help-labels string ... ~ ~
                   | #:ps string ... ~ ~
                      
         flag-spec = (flags id ... help-spec body ...+)
                   | (flags => handler-expr help-expr)
                      
             flags = flag-string
                   | (flag-string ...+)
                      
         help-spec = string
                   | (string-expr ...+)
                      
     finish-clause = 
                   | #:args arg-formals body ...+ ~ ~
                   | #:handlers handlers-exprs ~ ~
                      
       arg-formals = rest-id
                   | (arg ...)
                   | (arg ...+ . rest-id)
                      
               arg = id
                   | [id default-expr]
                      
    handlers-exprs = finish-expr arg-strings-expr
                   | finish-expr arg-strings-expr help-expr
                   | finish-expr arg-strings-expr help-expr
                     unknown-expr

Parses a command line according to the specification in the
flag-clauses.

The name-expr, if provided, should produce a path or string to be used
as the program name for reporting errors when the command-line is
ill-formed. It defaults to (find-system-path 'run-file). When a path is
provided, only the last element of the path is used to report an error.

The argv-expr, if provided, must evaluate to a list or a vector of
strings. It defaults to (current-command-line-arguments).

The command-line is disassembled into flags, each possibly with
flag-specific arguments, followed by (non-flag) arguments. Command-line
strings starting with - or + are parsed as flags, but arguments to flags
are never parsed as flags, and integers and decimal numbers that start
with - or + are not treated as flags. Non-flag arguments in the
command-line must appear after all flags and the flags’ arguments. No
command-line string past the first non-flag argument is parsed as a
flag. The built-in -- flag signals the end of command-line flags; any
command-line string past the -- flag is parsed as a non-flag argument.

A #:multi, #:once-each, #:once-any, or #:final clause introduces a set
of command-line flag specifications. The clause tag indicates how many
times the flag can appear on the command line:

* #:multi — Each flag specified in the set can be represented any number
  of times on the command line; i.e., the flags in the set are
  independent and each flag can be used multiple times.

* #:once-each — Each flag specified in the set can be represented once
  on the command line; i.e., the flags in the set are independent, but
  each flag should be specified at most once. If a flag specification is
  represented in the command line more than once, the exn:fail exception
  is raised.

* #:once-any — Only one flag specified in the set can be represented on
  the command line; i.e., the flags in the set are mutually exclusive.
  If the set is represented in the command line more than once, the
  exn:fail exception is raised.

* #:final — Like #:multi, except that no argument after the flag is
  treated as a flag. Note that multiple #:final flags can be specified
  if they have short names; for example, if -a is a #:final flag, then
  -aa combines two instances of -a in a single command-line argument.

A normal flag specification has four parts:

* flags — a flag string, or a set of flag strings.  If a set of flags is
  provided, all of the flags are equivalent.  Each flag string must be
  of the form "-x" or "+x" for some character x, or "--x" or "++x" for
  some sequence of characters x. An x cannot contain only digits or
  digits plus a single decimal point, since simple (signed) numbers are
  not treated as flags. In addition, the flags "--", "-h", and "--help"
  are predefined and cannot be changed.

* ids — identifier that are bound to the flag’s arguments. The number of
  identifiers determines how many arguments can be provided on the
  command line with the flag, and the names of these identifiers will
  appear in the help message describing the flag. The ids are bound to
  string values in the bodys for handling the flag.

* help-spec — a string or sequence of strings that describes the flag.
  This string is used in the help message generated by the handler for
  the built-in -h (or --help) flag. A single literal string can be
  provided, or any number of expressions that produce strings; in the
  latter case, strings after the first one are displayed on subsequent
  lines.

* bodys — expressions that are evaluated when one of the flags appears
  on the command line. The flags are parsed left-to-right, and each
  sequence of bodys is evaluated as the corresponding flag is
  encountered. When the bodys are evaluated, the preceding ids are bound
  to the arguments provided for the flag on the command line.

A flag specification using => escapes to a more general method of
specifying the handler and help strings. In this case, the handler
procedure and help string list returned by handler-expr and help-expr
are used as in the table argument of parse-command-line.

A #:usage-help clause inserts text lines immediately after the usage
line.  Each string in the clause provides a separate line of text.

A #:help-labels clause inserts text lines into the help table of
command-line flags. Each string in the clause provides a separate line
of text.

A #:ps clause inserts text lines at the end of the help output. Each
string in the clause provides a separate line of text.

After the flag clauses, a final clause handles command-line arguments
that are not parsed as flags:

* Supplying no finish clause is the same as supplying #:args () (void).

* For an #:args finish clause, identifiers in arg-formals are bound to
  the leftover command-line strings in the same way that identifiers are
  bound for a lambda expression. Thus, specifying a single id (without
  parentheses) collects all of the leftover arguments into a list. The
  effective arity of the arg-formals specification determines the number
  of extra command-line arguments that the user can provide, and the
  names of the identifiers in arg-formals are used in the help string.
  When the command-line is parsed, if the number of provided arguments
  cannot be matched to identifiers in arg-formals, the exn:fail
  exception is raised. Otherwise, args clause’s bodys are evaluated to
  handle the leftover arguments, and the result of the last body is the
  result of the command-line expression.

* A #:handlers finish clause escapes to a more general method of
  handling the leftover arguments. In this case, the values of the
  expressions are used like the last two to four arguments
  parse-command-line.

Example:

  (define verbose-mode (make-parameter #f))
  (define profiling-on (make-parameter #f))
  (define optimize-level (make-parameter 0))
  (define link-flags (make-parameter null))
   
  (define file-to-compile
    (command-line
     #:program "compiler" ~ ~
     #:once-each ~ ~
     [("-v" "--verbose") "Compile with verbose messages"
                         (verbose-mode #t)]
     [("-p" "--profile") "Compile with profiling"
                         (profiling-on #t)]
     #:once-any ~ ~
     [("-o" "--optimize-1") "Compile with optimization level 1"
                            (optimize-level 1)]
     ["--optimize-2"        (; show help on separate lines
                             "Compile with optimization level 2,"
                             "which includes all of level 1")
                            (optimize-level 2)]
     #:multi ~ ~
     [("-l" "--link-flags") lf ; flag takes one argument
                            "Add a flag <lf> for the linker"
                            (link-flags (cons lf (link-flags)))]
     #:args (filename) ; expect one command-line argument: <filename> ~ ~
     ; return the argument as a filename to compile
     filename))

                                        *parse-command-line*
(parse-command-line  name                ~
                     argv               
                     table              
                     finish-proc        
                     arg-help-strs      
                    [help-proc          
                     unknown-proc]) -> any
  name : (or/c string? path?) ~ ~
  argv : (or/c (listof string?) (vectorof string?)) ~ ~
  table : (listof (cons/c symbol? list?)) ~ ~
  finish-proc : ((list?) () #:rest list? . ->* . any) ~ ~
  arg-help-strs : (listof string?) ~ ~
  help-proc : (string? . -> . any) = (lambda (str) ....) ~ ~
  unknown-proc : (string? . -> . any) = (lambda (str) ...) ~ ~

Parses a command-line using the specification in table. For an overview
of command-line parsing, see the command-line form, which provides a
more convenient notation for most purposes.

The table argument to this procedural form encodes the information in
command-line’s clauses, except for the args clause.  Instead, arguments
are handled by the finish-proc procedure, and help information about
non-flag arguments is provided in arg-help-strs. In addition, the
finish-proc procedure receives information accumulated while parsing
flags. The help-proc and unknown-proc arguments allow customization that
is not possible with command-line.

When there are no more flags, finish-proc is called with a list of
information accumulated for command-line flags (see below) and the
remaining non-flag arguments from the command-line. The arity of
finish-proc determines the number of non-flag arguments accepted and
required from the command-line. For example, if finish-proc accepts
either two or three arguments, then either one or two non-flag arguments
must be provided on the command-line. The finish-proc procedure can have
any arity (see procedure-arity) except 0 or a list of 0s (i.e., the
procedure must at least accept one or more arguments).

The arg-help-strs argument is a list of strings identifying the expected
(non-flag) command-line arguments, one for each argument. If an
arbitrary number of arguments are allowed, the last string in
arg-help-strs represents all of them.

The help-proc procedure is called with a help string if the -h or --help
flag is included on the command line.  If an unknown flag is
encountered, the unknown-proc procedure is called just like a
flag-handling procedure (as described below); it must at least accept
one argument (the unknown flag), but it may also accept more arguments.
The default help-proc displays the string and exits and the default
unknown-proc raises the exn:fail exception.

A table is a list of flag specification sets. Each set is represented as
a pair of two items: a mode symbol and a list of either help strings or
flag specifications.  A mode symbol is one of 'once-each, 'once-any,
'multi, 'final, 'help-labels, 'usage-help, or 'ps with the same meanings
as the corresponding clause tags in command-line. For the 'help-labels,
'usage-help or 'ps mode, a list of help strings is provided. For the
other modes, a list of flag specifications is provided, where each
specification maps a number of flags to a single handler procedure. A
specification is a list of three items:

* A list of strings for the flags defined by the spec. See command-line
  for information about the format of flag strings.

* A procedure to handle the flag and its arguments when one of the flags
  is found on the command line. The arity of this handler procedure
  determines the number of arguments consumed by the flag: the handler
  procedure is called with a flag string plus the next few arguments
  from the command line to match the arity of the handler procedure. The
  handler procedure must accept at least one argument to receive the
  flag. If the handler accepts arbitrarily many arguments, all of the
  remaining arguments are passed to the handler.  A handler procedure’s
  arity must either be a number or an arity-at-least value.

  The return value from the handler is added to a list that is
  eventually passed to finish-proc. If the handler returns #<void>, no
  value is added onto this list. For all non-#<void> values returned by
  handlers, the order of the values in the list is the same as the order
  of the arguments on the command-line.

* A non-empty list for constructing help information for the spec. The
  first element of the list describes the flag; it can be a string or a
  non-empty list of strings, and in the latter case, each string is
  shown on its own line. Additional elements of the main list must be
  strings to name the expected arguments for the flag. The number of
  extra help strings provided for a spec must match the number of
  arguments accepted by the spec’s handler procedure.

The following example is the same as the core example for command-line,
translated to the procedural form:

  (parse-command-line "compile" (current-command-line-arguments)
    `((once-each
       [("-v" "--verbose")
        ,(lambda (flag) (verbose-mode #t))
        ("Compile with verbose messages")]
       [("-p" "--profile")
        ,(lambda (flag) (profiling-on #t))
        ("Compile with profiling")])
      (once-any
       [("-o" "--optimize-1")
        ,(lambda (flag) (optimize-level 1))
        ("Compile with optimization level 1")]
       [("--optimize-2")
        ,(lambda (flag) (optimize-level 2))
        (("Compile with optimization level 2,"
          "which implies all optimizations of level 1"))])
      (multi
       [("-l" "--link-flags")
        ,(lambda (flag lf) (link-flags (cons lf (link-flags))))
        ("Add a flag <lf> for the linker" "lf")]))
     (lambda (flag-accum file) file)
     '("filename"))

10. Additional Operating System Functions

 (require racket/os) package: base ~ ~

The racket/os library additional functions for querying the operating
system.

Added in version 6.3 of package base.

                                        *gethostname*
(gethostname) -> string? ~

Returns a string for the current machine’s hostname (including its
domain).

                                        *getpid*
(getpid) -> exact-integer? ~

Returns an integer identifying the current process within the operating
system.
