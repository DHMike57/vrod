Datatypes

+[missing] in [missing] introduces Datatypes.

Each pre-defined datatype comes with a set of procedures for
manipulating instances of the datatype.

    1 Equality

    2 Booleans

    3 Numbers

    4 Strings

    5 Byte Strings

    6 Characters

    7 Symbols

    8 Regular Expressions

    9 Keywords

    10 Pairs and Lists

    11 Mutable Pairs and Lists

    12 Vectors

    13 Boxes

    14 Hash Tables

    15 Sequences and Streams

    16 Dictionaries

    17 Sets

    18 Procedures

    19 Void

    20 Undefined

1. Equality

Equality is the concept of whether two values are “the same.” Racket
supports a few different kinds of equality by default, though equal? is
preferred for most use cases.

                                        *equal?*
(equal? v1 v2) -> boolean? ~
  v1 : any/c ~ ~
  v2 : any/c ~ ~

Two values are equal? if and only if they are eqv?, unless otherwise
specified for a particular datatype.

Datatypes with further specification of equal? include strings, byte
strings, pairs, mutable pairs, vectors, boxes, hash tables, and
inspectable structures. In the last six cases, equality is recursively
defined; if both v1 and v2 contain reference cycles, they are equal when
the infinite unfoldings of the values would be equal. See also
gen:equal+hash and prop:impersonator-of.

Examples:

  > (equal? 'yes 'yes)
  #t
  > (equal? 'yes 'no)
  #f
  > (equal? (* 6 7) 42)
  #t
  > (equal? (expt 2 100) (expt 2 100))
  #t
  > (equal? 2 2.0)
  #f
  > (let ([v (mcons 1 2)]) (equal? v v))
  #t
  > (equal? (mcons 1 2) (mcons 1 2))
  #t
  > (equal? (integer->char 955) (integer->char 955))
  #t
  > (equal? (make-string 3 #\z) (make-string 3 #\z))
  #t
  > (equal? #t #t)
  #t

                                        *eqv?*
(eqv? v1 v2) -> boolean? ~
  v1 : any/c ~ ~
  v2 : any/c ~ ~

Two values are eqv? if and only if they are eq?, unless otherwise
specified for a particular datatype.

The number and character datatypes are the only ones for which eqv?
differs from eq?. Two numbers are eqv? when they have the same
exactness, precision, and are both equal and non-zero, both +0.0, both
+0.0f0, both -0.0, both -0.0f0, both +nan.0, or both +nan.f—considering
real and imaginary components separately in the case of complex numbers.
Two characters are eqv? when their char->integer results are equal.

Generally, eqv? is identical to equal? except that the former cannot
recursively compare the contents of compound data types (such as lists
and structs) and cannot be customized by user-defined data types. The
use of eqv? is lightly discouraged in favor of equal?.

Examples:

  > (eqv? 'yes 'yes)
  #t
  > (eqv? 'yes 'no)
  #f
  > (eqv? (* 6 7) 42)
  #t
  > (eqv? (expt 2 100) (expt 2 100))
  #t
  > (eqv? 2 2.0)
  #f
  > (let ([v (mcons 1 2)]) (eqv? v v))
  #t
  > (eqv? (mcons 1 2) (mcons 1 2))
  #f
  > (eqv? (integer->char 955) (integer->char 955))
  #t
  > (eqv? (make-string 3 #\z) (make-string 3 #\z))
  #f
  > (eqv? #t #t)
  #t

                                        *eq?*
(eq? v1 v2) -> boolean? ~
  v1 : any/c ~ ~
  v2 : any/c ~ ~

Return #t if v1 and v2 refer to the same object, #f otherwise. As a
special case among numbers, two fixnums that are = are also the same
according to eq?. See also Object Identity and Comparisons.

Examples:

  > (eq? 'yes 'yes)
  #t
  > (eq? 'yes 'no)
  #f
  > (eq? (* 6 7) 42)
  #t
  > (eq? (expt 2 100) (expt 2 100))
  #f
  > (eq? 2 2.0)
  #f
  > (let ([v (mcons 1 2)]) (eq? v v))
  #t
  > (eq? (mcons 1 2) (mcons 1 2))
  #f
  > (eq? (integer->char 955) (integer->char 955))
  #f
  > (eq? (make-string 3 #\z) (make-string 3 #\z))
  #f
  > (eq? #t #t)
  #t

                                        *equal?/recur*
(equal?/recur v1 v2 recur-proc) -> boolean? ~
  v1 : any/c ~ ~
  v2 : any/c ~ ~
  recur-proc : (any/c any/c -> any/c) ~ ~

Like equal?, but using recur-proc for recursive comparisons (which means
that reference cycles are not handled automatically). Non-#f results
from recur-proc are converted to #t before being returned by
equal?/recur.

Examples:

  > (equal?/recur 1 1 (lambda (a b) #f))
  #t
  > (equal?/recur '(1) '(1) (lambda (a b) #f))
  #f
  > (equal?/recur '#(1 1 1) '#(1 1.2 3/4)
                  (lambda (a b) (<= (abs (- a b)) 0.25)))
  #t

1.1. Object Identity and Comparisons

The eq? operator compares two values, returning #t when the values refer
to the same object. This form of equality is suitable for comparing
objects that support imperative update (e.g., to determine that the
effect of modifying an object through one reference is visible through
another reference). Also, an eq? test evaluates quickly, and eq?-based
hashing is more lightweight than equal?-based hashing in hash tables.

In some cases, however, eq? is unsuitable as a comparison operator,
because the generation of objects is not clearly defined. In particular,
two applications of + to the same two exact integers may or may not
produce results that are eq?, although the results are always equal?.
Similarly, evaluation of a lambda form typically generates a new
procedure object, but it may re-use a procedure object previously
generated by the same source lambda form.

The behavior of a datatype with respect to eq? is generally specified
with the datatype and its associated procedures.

1.2. Equality and Hashing

All comparable values have at least one hash code — an arbitrary integer
(more specifically a fixnum) computed by applying a hash function to the
value. The defining property of these hash codes is that equal values
have equal hash codes. Note that the reverse is not true: two unequal
values can still have equal hash codes. Hash codes are useful for
various indexing and comparison operations, especially in the
implementation of hash tables. See Hash Tables for more information.

                                        *equal-hash-code*
(equal-hash-code v) -> fixnum? ~
  v : any/c ~ ~

Returns a hash code consistent with equal?. For any two calls with
equal? values, the returned number is the same. A hash code is computed
even when v contains a cycle through pairs, vectors, boxes, and/or
inspectable structure fields. Additionally, user-defined data types can
customize how this hash code is computed by implementing gen:equal+hash.

For any v that could be produced by read, if v2 is produced by read for
the same input characters, the (equal-hash-code v) is the same as
(equal-hash-code v2) — even if v and v2 do not exist at the same time
(and therefore could not be compared by calling equal?).

Changed in version 6.4.0.12: Strengthened guarantee for readable values.

                                        *equal-secondary-hash-code*
(equal-secondary-hash-code v) -> fixnum? ~
  v : any/c ~ ~

Like equal-hash-code, but computes a secondary hash code suitable for
use in double hashing.

                                        *eq-hash-code*
(eq-hash-code v) -> fixnum? ~
  v : any/c ~ ~

Returns a hash code consistent with eq?. For any two calls with eq?
values, the returned number is the same.

Equal fixnums are always eq?.

                                        *eqv-hash-code*
(eqv-hash-code v) -> fixnum? ~
  v : any/c ~ ~

Returns a hash code consistent with eqv?. For any two calls with eqv?
values, the returned number is the same.

1.3. Implementing Equality for Custom Types

gen:equal+hash : any/c ~ ~

A generic interface (see [missing]) for types that can be compared for
equality using equal?. The following methods must be implemented:

* equal-proc : (-> any/c any/c (-> any/c any/c boolean?) any/c) — tests
  whether the first two arguments are equal, where both values are
  instances of the structure type to which the generic interface is
  associated (or a subtype of the structure type).

  The third argument is an equal?  predicate to use for recursive
  equality checks; use the given predicate instead of equal? to ensure
  that data cycles are handled properly and to work with equal?/recur
  (but beware that an arbitrary function can be provided to equal?/recur
  for recursive checks, which means that arguments provided to the
  predicate might be exposed to arbitrary code).

  The equal-proc is called for a pair of structures only when they are
  not eq?, and only when they both have a gen:equal+hash value inherited
  from the same structure type. With this strategy, the order in which
  equal? receives two structures does not matter. It also means that, by
  default, a structure sub-type inherits the equality predicate of its
  parent, if any.

* hash-proc : (-> any/c (-> any/c exact-integer?) exact-integer?) —
  computes a hash code for the given structure, like equal-hash-code.
  The first argument is an instance of the structure type (or one of its
  subtypes) to which the generic interface is associated.

  The second argument is an equal-hash-code-like procedure to use for
  recursive hash-code computation; use the given procedure instead of
  equal-hash-code to ensure that data cycles are handled properly.

* hash2-proc : (-> any/c (-> any/c exact-integer?) exact-integer?) —
  computes a secondary hash code for the given structure. This procedure
  is like hash-proc, but analogous to equal-secondary-hash-code.

Take care to ensure that hash-proc and hash2-proc are consistent with
equal-proc. Specifically, hash-proc and hash2-proc should produce the
same value for any two structures for which equal-proc produces a true
value.

When a structure type has no gen:equal+hash implementation, then
transparent structures (i.e., structures with an inspector that is
controlled by the current inspector) are equal? when they are instances
of the same structure type (not counting sub-types), and when they have
equal? field values.  For transparent structures, equal-hash-code and
equal-secondary-hash-code derive hash code using the field values. For
opaque structure types, equal? is the same as eq?, and equal-hash-code
and equal-secondary-hash-code results are based only on eq-hash-code. If
a structure has a prop:impersonator-of property, then the
prop:impersonator-of property takes precedence over gen:equal+hash if
the property value’s procedure returns a non-#f value when applied to
the structure.

Examples:

  (define (farm=? farm1 farm2 recursive-equal?)
    (and (= (farm-apples farm1)
            (farm-apples farm2))
         (= (farm-oranges farm1)
            (farm-oranges farm2))
         (= (farm-sheep farm1)
            (farm-sheep farm2))))
   
  (define (farm-hash-code farm recursive-equal-hash)
    (+ (* 10000 (farm-apples farm))
       (* 100 (farm-oranges farm))
       (* 1 (farm-sheep farm))))
   
  (define (farm-secondary-hash-code farm recursive-equal-hash)
    (+ (* 10000 (farm-sheep farm))
       (* 100 (farm-apples farm))
       (* 1 (farm-oranges farm))))
   
  (struct farm (apples oranges sheep)
    #:methods gen:equal+hash ~ ~
    [(define equal-proc farm=?)
     (define hash-proc  farm-hash-code)
     (define hash2-proc farm-secondary-hash-code)])
   
  (define eastern-farm (farm 5 2 20))
  (define western-farm (farm 18 6 14))
  (define northern-farm (farm 5 20 20))
  (define southern-farm (farm 18 6 14))
   
  > (equal? eastern-farm western-farm)
  #f
  > (equal? eastern-farm northern-farm)
  #f
  > (equal? western-farm southern-farm)
  #t

prop:equal+hash : struct-type-property? ~ ~

A structure type property (see [missing]) that supplies an equality
predicate and hashing functions for a structure type. Using the
prop:equal+hash property is discouraged; the gen:equal+hash generic
interface should be used instead. A prop:equal+hash property value is a
list of three procedures that correspond to the methods of
gen:equal+hash:

* equal-proc : (-> any/c any/c (-> any/c any/c boolean?) any/c)

* hash-proc : (-> any/c (-> any/c exact-integer?) exact-integer?)

* hash2-proc : (-> any/c (-> any/c exact-integer?) exact-integer?)

2. Booleans

True and false booleans are represented by the values #t and #f,
respectively, though operations that depend on a boolean value typically
treat anything other than #f as true. The #t value is always eq? to
itself, and #f is always eq? to itself.

See [missing]     for information on reading     booleans and [missing]
for information on printing booleans.

See also and, or, andmap, and ormap.

                                        *boolean?*
(boolean? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is #t or #f, #f otherwise.

Examples:

  > (boolean? #f)
  #t
  > (boolean? #t)
  #t
  > (boolean? 'true)
  #f

                                        *not*
(not v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is #f, #f otherwise.

Examples:

  > (not #f)
  #t
  > (not #t)
  #f
  > (not 'we-have-no-bananas)
  #f

                                        *immutable?*
(immutable? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is an immutable string, byte string, vector, hash table,
or box, #f otherwise.

Note that immutable? is not a general predicate for immutability
(despite its name). It works only for a handful of datatypes for which a
single predicate—string?, vector?, etc.—recognizes both mutable and
immutable variants of the datatype. In particular, immutable? produces
#f for a pair, even though pairs are immutable, since pair? implies
immutability.

Examples:

  > (immutable? 'hello)
  #f
  > (immutable? "a string")
  #t
  > (immutable? (box 5))
  #f
  > (immutable? #(0 1 2 3))
  #t
  > (immutable? (make-hash))
  #f
  > (immutable? (make-immutable-hash '([a b])))
  #t
  > (immutable? #t)
  #f

2.1. Boolean Aliases

 (require racket/bool) package: base ~ ~

The bindings documented in this section are provided by the racket/bool
and racket libraries, but not racket/base.

true : boolean? ~ ~

An alias for #t.

false : boolean? ~ ~

An alias for #f.

                                        *symbol=?*
(symbol=? a b) -> boolean? ~
  a : symbol? ~ ~
  b : symbol? ~ ~

Returns (equal? a b) (if a and b are symbols).

                                        *boolean=?*
(boolean=? a b) -> boolean? ~
  a : boolean? ~ ~
  b : boolean? ~ ~

Returns (equal? a b) (if a and b are booleans).

                                        *false?*
(false? v) -> boolean? ~
  v : any/c ~ ~

Returns (not v).

                                        *nand*
(nand expr ...) ~

Same as (not (and expr ...)).

Examples:

  > (nand #f #t)
  #t
  > (nand #f (error 'ack "we don't get here"))
  #t

                                        *nor*
(nor expr ...) ~

Same as (not (or expr ...)).

In the two argument case, returns #t if neither of the arguments is a
true value.

Examples:

  > (nor #f #t)
  #f
  > (nor #t (error 'ack "we don't get here"))
  #f

                                        *implies*
(implies expr1 expr2) ~

Checks to be sure that the first expression implies the second.

Same as (if expr1 expr2 #t).

Examples:

  > (implies #f #t)
  #t
  > (implies #f #f)
  #t
  > (implies #t #f)
  #f
  > (implies #f (error 'ack "we don't get here"))
  #t

                                        *xor*
(xor b1 b2) -> any ~
  b1 : any/c ~ ~
  b2 : any/c ~ ~

Returns the exclusive or of b1 and b2.

If exactly one of b1 and b2 is not #f, then return it. Otherwise,
returns #f.

Examples:

  > (xor 11 #f)
  11
  > (xor #f 22)
  22
  > (xor 11 22)
  #f
  > (xor #f #f)
  #f

3. Numbers

+[missing] in [missing] introduces numbers.

All numbers are complex numbers. Some of them are real numbers, and all
of the real numbers that can be represented are also rational numbers,
except for +inf.0 (positive infinity), +inf.f (single-precision variant,
when enabled via read-single-flonum), -inf.0 (negative infinity), -inf.f
(single-precision variant, when enabled), +nan.0 (not-a-number), and
+nan.f (single-precision variant, when enabled). Among the rational
numbers, some are integers, because round applied to the number produces
the same number.

+See [missing] for information on the syntax of number literals.

Orthogonal to those categories, each number is also either an exact
number or an inexact number. Unless otherwise specified, computations
that involve an inexact number produce inexact results. Certain
operations on inexact numbers, however, produce an exact number, such as
multiplying an inexact number with an exact 0. Operations that
mathematically produce irrational numbers for some rational arguments
(e.g., sqrt) may produce inexact results even for exact arguments.

In the case of complex numbers, either the real and imaginary parts are
both exact or inexact with the same precision, or the number has an
exact zero real part and an inexact imaginary part; a complex number
with an exact zero imaginary part is a real number.

Inexact real numbers are implemented as double-precision IEEE
floating-point numbers, also known as flonums, or as single-precision
IEEE floating-point numbers, also known as single-flonums.
Single-flonums are supported only when (single-flonum-available?)
reports #t. Although we write +inf.f, -inf.f, and +nan.f to mean
single-flonums, those forms read as double-precision flonums by default,
since read-single-flonum is #f by default. When single-flonums are
supported, inexact numbers are still represented as flonums by default,
and single precision is used only when a computation starts with
single-flonums.

Inexact numbers can be coerced to exact form, except for the inexact
numbers +inf.0, +inf.f, -inf.0, -inf.f, +nan.0, and +nan.f, which have
no exact form. Dividing a number by exact zero raises an exception;
dividing a non-zero number other than +nan.0 or +nan.f by an inexact
zero returns +inf.0, +inf.f, -inf.0 or -inf.f, depending on the sign and
precision of the dividend. The +nan.0 value is not = to itself, but
+nan.0 is eqv? to itself, and +nan.f is similarly eqv? but not = to
itself. Conversely, (= 0.0 -0.0) is #t, but (eqv? 0.0 -0.0) is #f, and
the same for 0.0 and -0.0 (which are single-precision variants). The
datum -nan.0 refers to the same constant as +nan.0, and -nan.f is the
same as +nan.f.

Calculations with infinities produce results consistent with IEEE
double- or single-precision floating point where IEEE specifies the
result; in cases where IEEE provides no specification, the result
corresponds to the limit approaching infinity, or +nan.0 or +nan.f if no
such limit exists.

The precision and size of exact numbers is limited only by available
memory (and the precision of operations that can produce irrational
numbers). In particular, adding, multiplying, subtracting, and dividing
exact numbers always produces an exact result.

A fixnum is an exact integer whose two’s complement representation fit
into 31 bits on a 32-bit platform or 63 bits on a 64-bit platform;
furthermore, no allocation is required when computing with fixnums. See
also the racket/fixnum module, below.

Two fixnums that are = are also the same according to eq?. Otherwise,
the result of eq? applied to two numbers is undefined, except that
numbers produced by the default reader in read-syntax mode are interned
and therefore eq? when they are eqv?.

Two real numbers are eqv? when they are both inexact with the same
precision or both exact, and when they are = (except for +nan.0, +nan.f,
0.0, 0.0, -0.0, and -0.0, as noted above). Two complex numbers are eqv?
when their real and imaginary parts are eqv?. Two numbers are equal?
when they are eqv?.

See [missing]     for information on reading     numbers and [missing]
for information on printing numbers.

    3.1 Number Types
    3.2 Generic Numerics
      3.2.1 Arithmetic
      3.2.2 Number Comparison
      3.2.3 Powers and Roots
      3.2.4 Trigonometric Functions
      3.2.5 Complex Numbers
      3.2.6 Bitwise Operations
      3.2.7 Random Numbers
      3.2.8 Other Randomness Utilities
      3.2.9 Number–String Conversions
      3.2.10 Extra Constants and Functions
    3.3 Flonums
      3.3.1 Flonum Arithmetic
      3.3.2 Flonum Vectors
    3.4 Fixnums
      3.4.1 Fixnum Arithmetic
      3.4.2 Fixnum Vectors
    3.5 Extflonums
      3.5.1 Extflonum Arithmetic
      3.5.2 Extflonum Constants
      3.5.3 Extflonum Vectors
      3.5.4 Extflonum Byte Strings

3.1. Number Types

                                        *number?*
(number? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v  is a number, #f otherwise.

Examples:

  > (number? 1)
  #t
  > (number? 2+3i)
  #t
  > (number? "hello")
  #f
  > (number? +nan.0)
  #t

                                        *complex?*
(complex? v) -> boolean? ~
  v : any/c ~ ~

Returns (number? v), because all numbers are complex numbers.

                                        *real?*
(real? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is  a real number, #f otherwise.

Examples:

  > (real? 1)
  #t
  > (real? +inf.0)
  #t
  > (real? 2+3i)
  #f
  > (real? 2.0+0.0i)
  #f
  > (real? "hello")
  #f

                                        *rational?*
(rational? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if  v is a rational number, #f otherwise.

Examples:

  > (rational? 1)
  #t
  > (rational? +inf.0)
  #f
  > (rational? "hello")
  #f

                                        *integer?*
(integer? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v  is a number that is an integer, #f otherwise.

Examples:

  > (integer? 1)
  #t
  > (integer? 2.3)
  #f
  > (integer? 4.0)
  #t
  > (integer? +inf.0)
  #f
  > (integer? 2+3i)
  #f
  > (integer? "hello")
  #f

                                        *exact-integer?*
(exact-integer? v) -> boolean? ~
  v : any/c ~ ~

Returns (and (integer? v) (exact? v)).

Examples:

  > (exact-integer? 1)
  #t
  > (exact-integer? 4.0)
  #f

                                        *exact-nonnegative-integer?*
(exact-nonnegative-integer? v) -> boolean? ~
  v : any/c ~ ~

Returns (and (exact-integer? v) (not (negative? v))).

Examples:

  > (exact-nonnegative-integer? 0)
  #t
  > (exact-nonnegative-integer? -1)
  #f

                                        *exact-positive-integer?*
(exact-positive-integer? v) -> boolean? ~
  v : any/c ~ ~

Returns (and (exact-integer? v) (positive? v)).

Examples:

  > (exact-positive-integer? 1)
  #t
  > (exact-positive-integer? 0)
  #f

                                        *inexact-real?*
(inexact-real? v) -> boolean? ~
  v : any/c ~ ~

Returns (and (real? v) (inexact? v)).

                                        *fixnum?*
(fixnum? v) -> boolean? ~
  v : any/c ~ ~

Return #t if v is a fixnum, #f otherwise.

Note: the result of this function is platform-dependent, so using it in
syntax transformers can lead to platform-dependent bytecode files. See
also fixnum-for-every-system?.

                                        *flonum?*
(flonum? v) -> boolean? ~
  v : any/c ~ ~

Return #t if v is a flonum, #f otherwise.

                                        *double-flonum?*
(double-flonum? v) -> boolean? ~
  v : any/c ~ ~

Identical to flonum?.

                                        *single-flonum?*
(single-flonum? v) -> boolean? ~
  v : any/c ~ ~

Return #t if v is a single-flonum (i.e., a single-precision
floating-point number), #f otherwise.

                                        *single-flonum-available?*
(single-flonum-available?) -> boolean? ~

Returns #t if single-flonums are supported on the current platform, #f
otherwise.

Currently, single-flonum-available? produces #t when (system-type 'vm)
produces 'racket, and single-flonum-available? produces #f otherwise.

If the result is #f, then single-flonum? also produces #f for all
arguments.

Added in version 7.3.0.5.

                                        *zero?*
(zero? z) -> boolean? ~
  z : number? ~ ~

Returns (= 0 z).

Examples:

  > (zero? 0)
  #t
  > (zero? -0.0)
  #t

                                        *positive?*
(positive? x) -> boolean? ~
  x : real? ~ ~

Returns (> x 0).

Examples:

  > (positive? 10)
  #t
  > (positive? -10)
  #f
  > (positive? 0.0)
  #f

                                        *negative?*
(negative? x) -> boolean? ~
  x : real? ~ ~

Returns (< x 0).

Examples:

  > (negative? 10)
  #f
  > (negative? -10)
  #t
  > (negative? -0.0)
  #f

                                        *even?*
(even? n) -> boolean? ~
  n : integer? ~ ~

Returns (zero? (modulo n 2)).

Examples:

  > (even? 10.0)
  #t
  > (even? 11)
  #f
  > (even? +inf.0)
  even?: contract violation
    expected: integer ~ ~
    given: +inf.0 ~ ~

                                        *odd?*
(odd? n) -> boolean? ~
  n : integer? ~ ~

Returns (not (even? n)).

Examples:

  > (odd? 10.0)
  #f
  > (odd? 11)
  #t
  > (odd? +inf.0)
  odd?: contract violation
    expected: integer ~ ~
    given: +inf.0 ~ ~

                                        *exact?*
(exact? z) -> boolean? ~
  z : number? ~ ~

Returns #t if z  is an exact number, #f otherwise.

Examples:

  > (exact? 1)
  #t
  > (exact? 1.0)
  #f

                                        *inexact?*
(inexact? z) -> boolean? ~
  z : number? ~ ~

Returns #t if z  is an inexact number, #f otherwise.

Examples:

  > (inexact? 1)
  #f
  > (inexact? 1.0)
  #t

                                        *inexact->exact*
(inexact->exact z) -> exact? ~
  z : number? ~ ~

Coerces z to an  exact number. If z is already exact, it is returned. If
z  is +inf.0, -inf.0, +nan.0,  +inf.f, -inf.f, or +nan.f, then the
exn:fail:contract exception is raised.

Examples:

  > (inexact->exact 1)
  1
  > (inexact->exact 1.0)
  1

                                        *exact->inexact*
(exact->inexact z) -> inexact? ~
  z : number? ~ ~

Coerces z to an  inexact number. If z is already inexact, it is
returned.

Examples:

  > (exact->inexact 1)
  1.0
  > (exact->inexact 1.0)
  1.0

                                        *real->single-flonum*
(real->single-flonum x) -> single-flonum? ~
  x : real? ~ ~

Coerces x to a single-precision floating-point number. If x is already a
single-precision floating-point number, it is returned.

                                        *real->double-flonum*
(real->double-flonum x) -> flonum? ~
  x : real? ~ ~

Coerces x to a double-precision floating-point number. If x is already a
double-precision floating-point number, it is returned.

3.2. Generic Numerics

Most Racket numeric operations work on any kind of number.

3.2.1. Arithmetic

                                        *+*
(+ z ...) -> number?
  z : number? ~ ~

Returns the sum of the zs, adding pairwise from left to  right. If no
arguments are provided, the result is 0.

Examples:

  > (+ 1 2)
  3
  > (+ 1.0 2+3i 5)
  8.0+3.0i
  > (+)
  0

                                        *-*
(- z) -> number?
  z : number? ~ ~
(- z w ...+) -> number?
  z : number? ~ ~
  w : number? ~ ~

When no ws are supplied, returns (- 0 z).  Otherwise, returns the
subtraction of the ws from z  working pairwise from left to right.

Examples:

  > (- 5 3.0)
  2.0
  > (- 1)
  -1
  > (- 2+7i 1 3)
  -2+7i

                                        ***
(* z ...) -> number?
  z : number? ~ ~

Returns the product of the zs, multiplying pairwise from left  to right.
If no arguments are provided, the result is  1. Multiplying any number
by exact 0 produces exact  0.

Examples:

  > (* 2 3)
  6
  > (* 8.0 9)
  72.0
  > (* 1+2i 3+4i)
  -5+10i

                                        */*
(/ z) -> number?
  z : number? ~ ~
(/ z w ...+) -> number?
  z : number? ~ ~
  w : number? ~ ~

When no ws are supplied, returns (/ 1 z).  Otherwise, returns the
division of z by the ws working  pairwise from left to right.

If z is exact 0 and no w is exact  0, then the result is exact 0. If any
w is  exact 0, the exn:fail:contract:divide-by-zero exception is raised.

Examples:

  > (/ 3 4)
  3/4
  > (/ 81 3 3)
  9
  > (/ 10.0)
  0.1
  > (/ 1+2i 3+4i)
  11/25+2/25i

                                        *quotient*
(quotient n m) -> integer? ~
  n : integer? ~ ~
  m : integer? ~ ~

Returns (truncate (/ n m)).

Examples:

  > (quotient 10 3)
  3
  > (quotient -10.0 3)
  -3.0
  > (quotient +inf.0 3)
  quotient: contract violation
    expected: integer? ~ ~
    given: +inf.0 ~ ~
    argument position: 1st ~ ~
    other arguments...: ~ ~
     3

                                        *remainder*
(remainder n m) -> integer? ~
  n : integer? ~ ~
  m : integer? ~ ~

Returns q with the same sign as n such that

* (abs q) is between 0 (inclusive) and (abs m) (exclusive), and

* (+ q (* m (quotient n m))) equals n.

If m is exact 0, the  exn:fail:contract:divide-by-zero exception is
raised.

Examples:

  > (remainder 10 3)
  1
  > (remainder -10.0 3)
  -1.0
  > (remainder 10.0 -3)
  1.0
  > (remainder -10 -3)
  -1
  > (remainder +inf.0 3)
  remainder: contract violation
    expected: integer? ~ ~
    given: +inf.0 ~ ~
    argument position: 1st ~ ~
    other arguments...: ~ ~
     3

                                        *quotient/remainder*
(quotient/remainder n m) -> integer? integer? ~
  n : integer? ~ ~
  m : integer? ~ ~

Returns (values (quotient n m) (remainder n m)), but the  combination
may be computed more efficiently than separate calls to  quotient and
remainder.

Example:

  > (quotient/remainder 10 3)
  3
  1

                                        *modulo*
(modulo n m) -> integer? ~
  n : integer? ~ ~
  m : integer? ~ ~

Returns q with the same sign as m where

* (abs q) is between 0 (inclusive) and (abs m) (exclusive), and

* the difference between q and (- n (* m (quotient n m))) is a multiple
  of m.

If m is exact 0, the  exn:fail:contract:divide-by-zero exception is
raised.

Examples:

  > (modulo 10 3)
  1
  > (modulo -10.0 3)
  2.0
  > (modulo 10.0 -3)
  -2.0
  > (modulo -10 -3)
  -1
  > (modulo +inf.0 3)
  modulo: contract violation
    expected: integer? ~ ~
    given: +inf.0 ~ ~
    argument position: 1st ~ ~
    other arguments...: ~ ~
     3

                                        *add1*
(add1 z) -> number? ~
  z : number? ~ ~

Returns (+ z 1).

                                        *sub1*
(sub1 z) -> number? ~
  z : number? ~ ~

Returns (- z 1).

                                        *abs*
(abs x) -> number? ~
  x : real? ~ ~

Returns the absolute value of  x.

Examples:

  > (abs 1.0)
  1.0
  > (abs -1)
  1

                                        *max*
(max x ...+) -> real? ~
  x : real? ~ ~

Returns the largest of the xs, or +nan.0 if any  x is +nan.0.  If any x
is inexact, the  result is coerced to inexact.  See also argmax.

Examples:

  > (max 1 3 2)
  3
  > (max 1 3 2.0)
  3.0

                                        *min*
(min x ...+) -> real? ~
  x : real? ~ ~

Returns the smallest of the xs, or +nan.0 if any  x is +nan.0.  If any x
is inexact, the  result is coerced to inexact.  See also argmin.

Examples:

  > (min 1 3 2)
  1
  > (min 1 3 2.0)
  1.0

                                        *gcd*
(gcd n ...) -> rational? ~
  n : rational? ~ ~

Returns the greatest common divisor (a non-negative  number) of the ns;
for non-integer ns, the result  is the gcd of the numerators divided  by
the lcm of the denominators.  If no arguments are provided, the result
is 0. If all arguments are zero, the result is zero.

Examples:

  > (gcd 10)
  10
  > (gcd 12 81.0)
  3.0
  > (gcd 1/2 1/3)
  1/6

                                        *lcm*
(lcm n ...) -> rational? ~
  n : rational? ~ ~

Returns the least common multiple (a non-negative number)  of the ns;
non-integer ns, the result is  the absolute value of the product divided
by the  gcd. If no arguments are provided, the result is  1. If any
argument is zero, the result is zero; furthermore,  if any argument is
exact 0, the result is exact 0.

Examples:

  > (lcm 10)
  10
  > (lcm 3 4.0)
  12.0
  > (lcm 1/2 2/3)
  2

                                        *round*
(round x) -> (or/c integer? +inf.0 -inf.0 +nan.0) ~
  x : real? ~ ~

Returns the integer closest to x, resolving ties in favor of  an even
number, but +inf.0, -inf.0, and +nan.0  round to themselves.

Examples:

  > (round 17/4)
  4
  > (round -17/4)
  -4
  > (round 2.5)
  2.0
  > (round -2.5)
  -2.0
  > (round +inf.0)
  +inf.0

                                        *floor*
(floor x) -> (or/c integer? +inf.0 -inf.0 +nan.0) ~
  x : real? ~ ~

Returns the largest integer that is no more than x, but  +inf.0, -inf.0,
and +nan.0 floor to  themselves.

Examples:

  > (floor 17/4)
  4
  > (floor -17/4)
  -5
  > (floor 2.5)
  2.0
  > (floor -2.5)
  -3.0
  > (floor +inf.0)
  +inf.0

                                        *ceiling*
(ceiling x) -> (or/c integer? +inf.0 -inf.0 +nan.0) ~
  x : real? ~ ~

Returns the smallest integer that is at least as large as x,  but
+inf.0, -inf.0, and +nan.0 ceiling to  themselves.

Examples:

  > (ceiling 17/4)
  5
  > (ceiling -17/4)
  -4
  > (ceiling 2.5)
  3.0
  > (ceiling -2.5)
  -2.0
  > (ceiling +inf.0)
  +inf.0

                                        *truncate*
(truncate x) -> (or/c integer? +inf.0 -inf.0 +nan.0) ~
  x : real? ~ ~

Returns the integer farthest from 0 that is not farther from  0 than x,
but +inf.0, -inf.0, and  +nan.0 truncate to themselves.

Examples:

  > (truncate 17/4)
  4
  > (truncate -17/4)
  -4
  > (truncate 2.5)
  2.0
  > (truncate -2.5)
  -2.0
  > (truncate +inf.0)
  +inf.0

                                        *numerator*
(numerator q) -> integer? ~
  q : rational? ~ ~

Coerces q to an exact number, finds the numerator of the  number
expressed in its simplest fractional form, and returns this  number
coerced to the exactness of q.

Examples:

  > (numerator 5)
  5
  > (numerator 17/4)
  17
  > (numerator 2.3)
  2589569785738035.0

                                        *denominator*
(denominator q) -> (and/c integer? positive?) ~
  q : rational? ~ ~

Coerces q to an exact number, finds the denominator of the  number
expressed in its simplest fractional form, and returns this  number
coerced to the exactness of q.

Examples:

  > (denominator 5)
  1
  > (denominator 17/4)
  4
  > (denominator 2.3)
  1125899906842624.0

                                        *rationalize*
(rationalize x tolerance) -> real? ~
  x : real? ~ ~
  tolerance : real? ~ ~

Among the real numbers within (abs tolerance) of x,  returns the one
corresponding to an exact number whose  denominator is the smallest.  If
multiple integers are within  tolerance of x, the one closest to 0 is
used.

Examples:

  > (rationalize 1/4 1/10)
  1/3
  > (rationalize -1/4 1/10)
  -1/3
  > (rationalize 1/4 1/4)
  0
  > (rationalize 11/40 1/4)
  1/2

3.2.2. Number Comparison

                                        *=*
(= z w ...) -> boolean?
  z : number? ~ ~
  w : number? ~ ~

Returns  #t if all of the arguments are numerically equal,  #f
otherwise.  An inexact number is numerically equal to an  exact number
when the exact coercion of the inexact number is the  exact number.
Also, 0.0 and -0.0 are numerically  equal, but +nan.0 is not numerically
equal to itself.

Examples:

  > (= 1 1.0)
  #t
  > (= 1 2)
  #f
  > (= 2+3i 2+3i 2+3i)
  #t
  > (= 1)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *<*
(< x y ...) -> boolean?
  x : real? ~ ~
  y : real? ~ ~

Returns #t if  the arguments in the given order are strictly increasing,
#f otherwise.

Examples:

  > (< 1 1)
  #f
  > (< 1 2 3)
  #t
  > (< 1)
  #t
  > (< 1 +inf.0)
  #t
  > (< 1 +nan.0)
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *<=*
(<= x y ...) -> boolean?
  x : real? ~ ~
  y : real? ~ ~

Returns #t  if the arguments in the given order are non-decreasing,  #f
otherwise.

Examples:

  > (<= 1 1)
  #t
  > (<= 1 2 1)
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *>*
(> x y ...+) -> boolean?
  x : real? ~ ~
  y : real? ~ ~

Returns #t if  the arguments in the given order are strictly decreasing,
#f otherwise.

Examples:

  > (> 1 1)
  #f
  > (> 3 2 1)
  #t
  > (> +inf.0 1)
  #t
  > (> +nan.0 1)
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *>=*
(>= x y ...) -> boolean?
  x : real? ~ ~
  y : real? ~ ~

Returns #t  if the arguments in the given order are non-increasing,  #f
otherwise.

Examples:

  > (>= 1 1)
  #t
  > (>= 1 2 1)
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

3.2.3. Powers and Roots

                                        *sqrt*
(sqrt z) -> number? ~
  z : number? ~ ~

Returns the principal square root of z.  The  result is exact if z is
exact and z’s square root  is rational. See also integer-sqrt.

Examples:

  > (sqrt 4/9)
  2/3
  > (sqrt 2)
  1.4142135623730951
  > (sqrt -1)
  0+1i

                                        *integer-sqrt*
(integer-sqrt n) -> complex? ~
  n : integer? ~ ~

Returns (floor (sqrt n)) for positive n.  The  result is exact if n is
exact.  For  negative n, the result is (* (integer-sqrt (- n)) 0+1i).

Examples:

  > (integer-sqrt 4.0)
  2.0
  > (integer-sqrt 5)
  2
  > (integer-sqrt -4.0)
  0+2.0i
  > (integer-sqrt -4)
  0+2i

                                        *integer-sqrt/remainder*
(integer-sqrt/remainder n) -> complex? integer? ~
  n : integer? ~ ~

Returns (integer-sqrt n) and (- n (expt (integer-sqrt n) 2)).

Examples:

  > (integer-sqrt/remainder 4.0)
  2.0
  0.0
  > (integer-sqrt/remainder 5)
  2
  1

                                        *expt*
(expt z w) -> number? ~
  z : number? ~ ~
  w : number? ~ ~

Returns z raised to the power of w.

If w is  exact 0, the result is exact 1.  If w is 0.0 or -0.0  and z is
a real number  other than exact 1 or 0, the  result is 1.0 (even if z is
+nan.0).

If z is exact 1, the result is exact 1.  If z is 1.0 and w is a real
number, the  result is 1.0 (even if w is +nan.0).

If z is exact 0, the result is as follows:

* w is exact 0 — result is 1

* w is 0.0 or -0.0 — result is 1.0

* real part of w is negative — the exn:fail:contract:divide-by-zero
  exception is raised

* w is nonreal with a nonpositive real part  — the
  exn:fail:contract:divide-by-zero exception is raised

* w is +nan.0 — result is +nan.0

* otherwise — result is 0

Further special cases when w is a real number: These special cases
correspond to pow in C99 [C99], except when z is negative and w is a not
an integer.

* (expt 0.0 w):

  * w is negative — result is +inf.0

  * w is positive — result is 0.0

* (expt -0.0 w):

  * w is negative:

    * w is an odd integer — result is -inf.0

    * w otherwise rational — result is +inf.0

  * w is positive:

    * w is an odd integer — result is -0.0

    * w otherwise rational — result is 0.0

* (expt z -inf.0) for positive z:

  * z is less than 1.0 — result is +inf.0

  * z is greater than 1.0 — result is 0.0

* (expt z +inf.0) for positive z:

  * z is less than 1.0 — result is 0.0

  * z is greater than 1.0 — result is +inf.0

* (expt -inf.0 w) for integer w:

  * w is negative:

    * w is odd — result is -0.0

    * w is even — result is 0.0

  * w is positive:

    * w is odd — result is -inf.0

    * w is even — result is +inf.0

* (expt +inf.0 w):

  * w is negative — result is 0.0

  * w is positive — result is +inf.0

Examples:

  > (expt 2 3)
  8
  > (expt 4 0.5)
  2.0
  > (expt +inf.0 0)
  1

                                        *exp*
(exp z) -> number? ~
  z : number? ~ ~

Returns Euler’s number raised to the power of z. The result  is normally
inexact, but it is exact 1 when z is an  exact 0. See also expt.

Examples:

  > (exp 1)
  2.718281828459045
  > (exp 2+3i)
  -7.315110094901103+1.0427436562359045i
  > (exp 0)
  1

                                        *log*
(log z [b]) -> number? ~
  z : number? ~ ~
  b : number? = (exp 1) ~ ~

Returns the natural logarithm of z.  The result is normally  inexact,
but it is exact 0 when z is an exact  1. When z is exact 0,
exn:fail:contract:divide-by-zero exception is raised.

If b is provided, it serves as an alternative  base. It is equivalent to
(/ (log z) (log b)), but  can potentially run faster. If b is exact  1,
exn:fail:contract:divide-by-zero exception is raised.

Consider using fllogb instead when accuracy is  important.

Examples:

  > (log (exp 1))
  1.0
  > (log 2+3i)
  1.2824746787307684+0.982793723247329i
  > (log 1)
  0
  > (log 100 10)
  2.0
  > (log 8 2)
  3.0
  > (log 5 5)
  1.0

Changed in version 6.9.0.1: Added second argument for arbitrary bases.

3.2.4. Trigonometric Functions

                                        *sin*
(sin z) -> number? ~
  z : number? ~ ~

Returns the sine of z, where z is in radians. The  result is normally
inexact, but it is exact 0 if z  is exact 0.

Examples:

  > (sin 3.14159)
  2.65358979335273e-06
  > (sin 1.0+5.0i)
  62.44551846769653+40.0921657779984i

                                        *cos*
(cos z) -> number? ~
  z : number? ~ ~

Returns the cosine of z, where z is in radians.

Examples:

  > (cos 3.14159)
  -0.9999999999964793
  > (cos 1.0+5.0i)
  40.095806306298826-62.43984868079963i

                                        *tan*
(tan z) -> number? ~
  z : number? ~ ~

Returns the tangent of z, where z is in radians. The  result is normally
inexact, but it is exact 0 if z  is exact 0.

Examples:

  > (tan 0.7854)
  1.0000036732118496
  > (tan 1.0+5.0i)
  8.256719834227411e-05+1.0000377833796008i

                                        *asin*
(asin z) -> number? ~
  z : number? ~ ~

Returns the arcsine in radians of z. The result is normally  inexact,
but it is exact 0 if z is exact 0.

Examples:

  > (asin 0.25)
  0.25268025514207865
  > (asin 1.0+5.0i)
  0.1937931365549322+2.3309746530493123i

                                        *acos*
(acos z) -> number? ~
  z : number? ~ ~

Returns the arccosine in radians of z.

Examples:

  > (acos 0.25)
  1.318116071652818
  > (acos 1.0+5.0i)
  1.3770031902399644-2.3309746530493123i

                                        *atan*
(atan z) -> number? ~
  z : number? ~ ~
(atan y x) -> number?
  y : real? ~ ~
  x : real? ~ ~

In the one-argument case, returns the arctangent of the inexact
approximation of z, except that the result is an exact  0 for z as 0,
and the exn:fail:contract:divide-by-zero exception is raised  for z as
exact 0+1i or exact 0-1i.

In the two-argument case, the result is roughly the same as (atan (/
(exact->inexact y)) (exact->inexact x)), but the signs of y  and x
determine the quadrant of the result. Moreover, a  suitable angle is
returned when y divided by x  produces +nan.0 in the case that neither y
nor  x is +nan.0. Finally, if y is exact  0 and x is a positive number,
the result is  exact 0. If both x and y are exact  0, the
exn:fail:contract:divide-by-zero exception is raised.

Examples:

  > (atan 0.5)
  0.4636476090008061
  > (atan 2 1)
  1.1071487177940904
  > (atan -2 -1)
  -2.0344439357957027
  > (atan 1.0+5.0i)
  1.530881333938778+0.19442614214700213i
  > (atan +inf.0 -inf.0)
  2.356194490192345

Changed in version 7.2.0.2: Changed to raise
exn:fail:contract:divide-by-zero for 0+1i and 0-1i and to produce exact
0 for any positive x (not just exact values) when y is 0.

3.2.5. Complex Numbers

                                        *make-rectangular*
(make-rectangular x y) -> number? ~
  x : real? ~ ~
  y : real? ~ ~

Creates a complex number with x as the real part and y as the imaginary
part. That is, returns (+ x (* y 0+1i)).

Example:

  > (make-rectangular 3 4.0)
  3.0+4.0i

                                        *make-polar*
(make-polar magnitude angle) -> number? ~
  magnitude : real? ~ ~
  angle : real? ~ ~

Creates a complex number which, if thought of as a point, is magnitude
away from the origin and is rotated angle radians counter clockwise from
the positive x-axis. That is, returns (+ (* magnitude (cos angle)) (*
magnitude (sin angle) 0+1i)).

Examples:

  > (make-polar 10 (* pi 1/2))
  6.123233995736766e-16+10.0i
  > (make-polar 10 (* pi 1/4))
  7.0710678118654755+7.071067811865475i

                                        *real-part*
(real-part z) -> real? ~
  z : number? ~ ~

Returns the real part of the complex number z in rectangle  coordinates.

Examples:

  > (real-part 3+4i)
  3
  > (real-part 5.0)
  5.0

                                        *imag-part*
(imag-part z) -> real? ~
  z : number? ~ ~

Returns the imaginary part of the complex number z in  rectangle
coordinates.

Examples:

  > (imag-part 3+4i)
  4
  > (imag-part 5.0)
  0
  > (imag-part 5.0+0.0i)
  0.0

                                        *magnitude*
(magnitude z) -> (and/c real? (not/c negative?)) ~
  z : number? ~ ~

Returns the magnitude of the complex number z in polar  coordinates. A
complex number with +inf.0 or -inf.0  as a component has magnitude
+inf.0, even if the other  component is +nan.0.

Examples:

  > (magnitude -3)
  3
  > (magnitude 3.0)
  3.0
  > (magnitude 3+4i)
  5

Changed in version 7.2.0.2: Changed to always return +inf.0 for a
complex number with a +inf.0 or -inf.0 component.

                                        *angle*
(angle z) -> real? ~
  z : number? ~ ~

Returns the angle of  the complex number z in polar coordinates.

The result is guaranteed to be between (- pi) and  pi, possibly equal to
pi (but never equal  to (- pi)).

Examples:

  > (angle -3)
  3.141592653589793
  > (angle 3.0)
  0
  > (angle 3+4i)
  0.9272952180016122
  > (angle +inf.0+inf.0i)
  0.7853981633974483
  > (angle -1)
  3.141592653589793

3.2.6. Bitwise Operations

                                        *bitwise-ior*
(bitwise-ior n ...) -> exact-integer? ~
  n : exact-integer? ~ ~

Returns  the bitwise “inclusive or” of the ns in their (semi-infinite)
two’s complement representation. If no arguments are provided, the
result is 0.

Examples:

  > (bitwise-ior 1 2)
  3
  > (bitwise-ior -32 1)
  -31

                                        *bitwise-and*
(bitwise-and n ...) -> exact-integer? ~
  n : exact-integer? ~ ~

Returns  the bitwise “and” of the ns in their (semi-infinite) two’s
complement representation. If no arguments are provided, the result  is
-1.

Examples:

  > (bitwise-and 1 2)
  0
  > (bitwise-and -32 -1)
  -32

                                        *bitwise-xor*
(bitwise-xor n ...) -> exact-integer? ~
  n : exact-integer? ~ ~

Returns  the bitwise “exclusive or” of the ns in their (semi-infinite)
two’s complement representation. If no arguments are provided, the
result is 0.

Examples:

  > (bitwise-xor 1 5)
  4
  > (bitwise-xor -32 -1)
  31

                                        *bitwise-not*
(bitwise-not n) -> exact-integer? ~
  n : exact-integer? ~ ~

Returns the  bitwise “not” of n in its (semi-infinite) two’s complement
representation.

Examples:

  > (bitwise-not 5)
  -6
  > (bitwise-not -1)
  0

                                        *bitwise-bit-set?*
(bitwise-bit-set? n m) -> boolean? ~
  n : exact-integer? ~ ~
  m : exact-nonnegative-integer? ~ ~

Returns #t when the mth bit of n is set in n’s         (semi-infinite)
two’s complement representation.

This operation is equivalent to (not (zero? (bitwise-and n
(arithmetic-shift 1 m)))), but it is faster and runs in constant time
when n is positive.

Examples:

  > (bitwise-bit-set? 5 0)
  #t
  > (bitwise-bit-set? 5 2)
  #t
  > (bitwise-bit-set? -5 (expt 2 700))
  #t

                                        *bitwise-bit-field*
(bitwise-bit-field n start end) -> exact-integer? ~
  n : exact-integer? ~ ~
  start : exact-nonnegative-integer? ~ ~
  end : (and/c exact-nonnegative-integer? ~ ~
               (>=/c start))

Extracts the bits between position start and (- end 1) (inclusive) from
n and shifts them down to the least significant portion of the number.

This operation is equivalent to the computation

  (bitwise-and (sub1 (arithmetic-shift 1 (- end start)))
               (arithmetic-shift n (- start)))

but it runs in constant time when n is positive, start and end are
fixnums, and (- end start) is no more than the maximum width of a
fixnum.

Each pair of examples below uses the same numbers, showing the result
both in binary and as integers.

Examples:

  > (format "~b" (bitwise-bit-field (string->number "1101" 2) 1 1))
  "0"
  > (bitwise-bit-field 13 1 1)
  0
  > (format "~b" (bitwise-bit-field (string->number "1101" 2) 1 3))
  "10"
  > (bitwise-bit-field 13 1 3)
  2
  > (format "~b" (bitwise-bit-field (string->number "1101" 2) 1 4))
  "110"
  > (bitwise-bit-field 13 1 4)
  6

                                        *arithmetic-shift*
(arithmetic-shift n m) -> exact-integer? ~
  n : exact-integer? ~ ~
  m : exact-integer? ~ ~

Returns the bitwise “shift” of n in its  (semi-infinite) two’s
complement representation.  If m is  non-negative, the integer n is
shifted left by m bits;  i.e., m new zeros are introduced as rightmost
digits. If  m is negative, n is shifted right by (- m)  bits; i.e., the
rightmost m digits are dropped.

Examples:

  > (arithmetic-shift 1 10)
  1024
  > (arithmetic-shift 255 -3)
  31

                                        *integer-length*
(integer-length n) -> exact-integer? ~
  n : exact-integer? ~ ~

Returns  the number of bits in the (semi-infinite) two’s complement
representation of n after removing all leading zeros (for  non-negative
n) or ones (for negative n).

Examples:

  > (integer-length 8)
  4
  > (integer-length -8)
  3

3.2.7. Random Numbers

When security is a concern, use crypto-random-bytes instead of random.

                                        *random*
(random k [rand-gen]) -> exact-nonnegative-integer? ~
  k : (integer-in 1 4294967087) ~ ~
  rand-gen : pseudo-random-generator? ~ ~
           = (current-pseudo-random-generator)
(random min max [rand-gen]) -> exact-nonnegative-integer?
  min : exact-integer? ~ ~
  max : (integer-in (+ 1 min) (+ 4294967087 min)) ~ ~
  rand-gen : pseudo-random-generator? ~ ~
           = (current-pseudo-random-generator)
(random [rand-gen]) -> (and/c real? inexact? (>/c 0) (</c 1))
  rand-gen : pseudo-random-generator? ~ ~
           = (current-pseudo-random-generator)

When called with an integer argument k, returns a random exact integer
in the range 0 to k-1.

When called with two integer arguments min and max, returns a random
exact integer in the range min to max-1.

When called with zero arguments, returns a random inexact number between
0 and 1, exclusive.

In each case, the number is provided by the given pseudo-random number
generator (which defaults to the current one, as produced by
current-pseudo-random-generator). The generator maintains an internal
state for generating numbers. The random number generator uses a 54-bit
version of L’Ecuyer’s MRG32k3a algorithm [L'Ecuyer02].

Changed in version 6.4: Added support for ranges.

                                        *random-seed*
(random-seed k) -> void? ~
  k : (integer-in 0 (sub1 (expt 2 31))) ~ ~

Seeds the current pseudo-random number generator with k. Seeding a
generator sets its internal state deterministically; that is, seeding a
generator with a particular number forces it to produce a sequence of
pseudo-random numbers that is the same across runs and across platforms.

The random-seed function is convenient for some purposes, but note that
the space of states for a pseudo-random number generator is much larger
that the space of allowed values for k. Use
vector->pseudo-random-generator! to set a pseudo-random number generator
to any of its possible states.

                                        *make-pseudo-random-generator*
(make-pseudo-random-generator) -> pseudo-random-generator? ~

Returns a new pseudo-random number generator. The new generator is
seeded with a number derived from (current-milliseconds).

                                        *pseudo-random-generator?*
(pseudo-random-generator? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a pseudo-random number generator, #f otherwise.

                                        *current-pseudo-random-generator*
(current-pseudo-random-generator) -> pseudo-random-generator? ~
(current-pseudo-random-generator rand-gen) -> void?
  rand-gen : pseudo-random-generator? ~ ~

A parameter that determines the pseudo-random number generator used by
random.

                                        *pseudo-random-generator->vector*
(pseudo-random-generator->vector rand-gen) ~
 -> pseudo-random-generator-vector?
  rand-gen : pseudo-random-generator? ~ ~

Produces a vector that represents the complete internal state of
rand-gen. The vector is suitable as an argument to
vector->pseudo-random-generator to recreate the generator in its current
state (across runs and across platforms).

                                        *vector->pseudo-random-generator*
(vector->pseudo-random-generator vec) ~
 -> pseudo-random-generator?
  vec : pseudo-random-generator-vector? ~ ~

Produces a pseudo-random number generator whose internal state
corresponds to vec.

                                        *vector->pseudo-random-generator!*
(vector->pseudo-random-generator! rand-gen      ~
                                  vec)     -> void?
  rand-gen : pseudo-random-generator? ~ ~
  vec : pseudo-random-generator-vector? ~ ~

Like vector->pseudo-random-generator, but changes rand-gen to the given
state, instead of creating a new generator.

                                        *pseudo-random-generator-vector?*
(pseudo-random-generator-vector? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a vector of six exact integers, where the first three
integers are in the range 0 to 4294967086, inclusive; the last three
integers are in the range 0 to 4294944442, inclusive; at least one of
the first three integers is non-zero; and at least one of the last three
integers is non-zero. Otherwise, the result is #f.

3.2.8. Other Randomness Utilities

 (require racket/random) package: base ~ ~

                                        *crypto-random-bytes*
(crypto-random-bytes n) -> bytes? ~
  n : exact-positive-integer? ~ ~

Provides an interface to randomness from the underlying operating
system. Use crypto-random-bytes instead of random wherever security is a
concern.

Returns n random bytes. On Unix systems, the bytes are obtained from
"/dev/urandom", while Windows uses the RtlGenRand system function.

Example:

  > (crypto-random-bytes 14)
  #"\0\1\1\2\3\5\b\r\25\"7Y\220\351"

Added in version 6.3 of package base.

                                        *random-ref*
(random-ref seq [rand-gen]) -> any/c ~
  seq : sequence? ~ ~
  rand-gen : pseudo-random-generator? ~ ~
           = (current-pseudo-random-generator)

Returns a random element of the sequence. Like sequence-length, does not
terminate on infinite sequences, and evaluates the entire sequence.

Added in version 6.4 of package base.

                                        *random-sample*
(random-sample  seq                                ~
                n                                 
               [rand-gen                          
                #:replacement? replacement?]) -> (listof any/c) ~ ~
  seq : sequence? ~ ~
  n : exact-positive-integer? ~ ~
  rand-gen : pseudo-random-generator? ~ ~
           = (current-pseudo-random-generator)
  replacement? : any/c = #t ~ ~

Returns a list of n elements of seq, picked at random, listed in any
order. If replacement? is non-false, elements are drawn with
replacement, which allows for duplicates.

Like sequence-length, does not terminate on infinite sequences, and
evaluates the entire sequence.

Added in version 6.4 of package base.

3.2.9. Number–String Conversions

                                        *number->string*
(number->string z [radix]) -> string? ~
  z : number? ~ ~
  radix : (or/c 2 8 10 16) = 10 ~ ~

Returns a string that is the printed form of z (see [missing])  in the
base specified by radix. If z is inexact,  radix must be 10, otherwise
the  exn:fail:contract exception is raised.

Examples:

  > (number->string 3.0)
  "3.0"
  > (number->string 255 8)
  "377"

                                        *string->number*
(string->number  s              ~
                [radix         
                 convert-mode  
                 decimal-mode  
                 single-mode]) 
 -> (or/c number? #f string? extflonum?)
  s : string? ~ ~
  radix : (integer-in 2 16) = 10 ~ ~
  convert-mode : (or/c 'number-or-false 'read) ~ ~
               = 'number-or-false
  decimal-mode : (or/c 'decimal-as-inexact 'decimal-as-exact) ~ ~
               = (if (read-decimal-as-inexact)
                     'decimal-as-inexact
                     'decimal-as-exact)
  single-mode : (or/c 'single 'double) ~ ~
              = (if (read-single-flonum)
                    'single
                    'double)

Reads and returns a number datum from s (see [missing]). The optional
radix argument specifies the default base for the number, which can be
overridden by #b, #o, #d, or #x in the string.

If convert-mode is 'number-or-false, the result is #f if s does not
parse exactly as a number datum (with no whitespace). If convert-mode is
'read, the result can be an extflonum, and it can be a string that
contains an error message if read of s would report a reader exception
(but the result can still be #f if read would report a symbol).

The decimal-mode argument controls number parsing the same way that the
read-decimal-as-inexact parameter affects read.

The single-mode argument controls number parsing the same way that the
read-single-flonum parameter affects read.

Examples:

  > (string->number "3.0+2.5i")
  3.0+2.5i
  > (string->number "hello")
  #f
  > (string->number "111" 7)
  57
  > (string->number "#b111" 7)
  7
  > (string->number "#e+inf.0" 10 'read)
  "no exact representation for +inf.0"
  > (string->number "10.3" 10 'read 'decimal-as-exact)
  103/10

Changed in version 6.8.0.2: Added the convert-mode and decimal-mode
arguments. Changed in version 7.3.0.5: Added the single-mode argument.

                                        *real->decimal-string*
(real->decimal-string n [decimal-digits]) -> string? ~
  n : real? ~ ~
  decimal-digits : exact-nonnegative-integer? = 2 ~ ~

Prints n into a string and returns the string. The printed form of n
shows exactly decimal-digits digits after the decimal point. The printed
form uses a minus sign if n is negative, and it does not use a plus sign
if n is positive.

Before printing, n is converted to an exact number, multiplied by (expt
10 decimal-digits), rounded, and then divided again by (expt 10
decimal-digits).  The result of this process is an exact number whose
decimal representation has no more than decimal-digits digits after the
decimal (and it is padded with trailing zeros if necessary).

Examples:

  > (real->decimal-string pi)
  "3.14"
  > (real->decimal-string pi 5)
  "3.14159"

                                        *integer-bytes->integer*
(integer-bytes->integer  bstr             ~
                         signed?         
                        [big-endian?     
                         start           
                         end])       -> exact-integer?
  bstr : bytes? ~ ~
  signed? : any/c ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Converts the machine-format number encoded in bstr to an exact integer.
The start and end arguments specify the substring to decode, where (-
end start) must be 1, 2, 4, or 8. If signed? is true, then the bytes are
decoded as a two’s-complement number, otherwise it is decoded as an
unsigned integer. If big-endian? is true, then the first byte’s value
provides the most significant eight bits of the number, otherwise the
first byte provides the least-significant eight bits, and so on.

Changed in version 6.10.0.1: Added support for decoding a 1-byte string.

                                        *integer->integer-bytes*
(integer->integer-bytes  n                ~
                         size-n          
                         signed?         
                        [big-endian?     
                         dest-bstr       
                         start])     -> bytes?
  n : exact-integer? ~ ~
  size-n : (or/c 1 2 4 8) ~ ~
  signed? : any/c ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  dest-bstr : (and/c bytes? (not/c immutable?)) ~ ~
            = (make-bytes size-n)
  start : exact-nonnegative-integer? = 0 ~ ~

Converts the exact integer n to a machine-format number encoded in a
byte string of length size-n, which must be 1, 2, 4, or 8. If signed? is
true, then the number is encoded as two’s complement, otherwise it is
encoded as an unsigned bit stream. If big-endian? is true, then the most
significant eight bits of the number are encoded in the first byte of
the resulting byte string, otherwise the least-significant bits are
encoded in the first byte, and so on.

The dest-bstr argument must be a mutable byte string of length size-n.
The encoding of n is written into dest-bstr starting at offset start,
and dest-bstr is returned as the result.

If n cannot be encoded in a byte string of the requested size and
format, the exn:fail:contract exception is raised. If dest-bstr is not
of length size-n, the exn:fail:contract exception is raised.

Changed in version 6.10.0.1: Added support for encoding a 1-byte value.

                                        *floating-point-bytes->real*
(floating-point-bytes->real  bstr             ~
                            [big-endian?     
                             start           
                             end])       -> flonum?
  bstr : bytes? ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Converts the IEEE floating-point number encoded in bstr from position
start (inclusive) to end (exclusive) to an inexact real number. The
difference between start an end must be either 4 or 8 bytes. If
big-endian? is true, then the first byte’s ASCII value provides the most
significant eight bits of the IEEE representation, otherwise the first
byte provides the least-significant eight bits, and so on.

                                        *real->floating-point-bytes*
(real->floating-point-bytes  x                ~
                             size-n          
                            [big-endian?     
                             dest-bstr       
                             start])     -> bytes?
  x : real? ~ ~
  size-n : (or/c 4 8) ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  dest-bstr : (and/c bytes? (not/c immutable?)) ~ ~
            = (make-bytes size-n)
  start : exact-nonnegative-integer? = 0 ~ ~

Converts the real number x to its IEEE representation in a byte string
of length size-n, which must be 4 or 8. If big-endian? is true, then the
most significant eight bits of the number are encoded in the first byte
of the resulting byte string, otherwise the least-significant bits are
encoded in the first character, and so on.

The dest-bstr argument must be a mutable byte string of length size-n.
The encoding of n is written into dest-bstr starting with byte start,
and dest-bstr is returned as the result.

If dest-bstr is provided and it has less than start plus size-n bytes,
the exn:fail:contract exception is raised.

                                        *system-big-endian?*
(system-big-endian?) -> boolean? ~

Returns #t if the native encoding of numbers is big-endian for the
machine running Racket, #f if the native encoding is little-endian.

3.2.10. Extra Constants and Functions

 (require racket/math) package: base ~ ~

The bindings documented in this section are provided by the racket/math
and racket libraries, but not racket/base.

pi : flonum? ~ ~

An approximation of π, the ratio of a circle’s circumference to its
diameter.

Examples:

  > pi
  3.141592653589793
  > (cos pi)
  -1.0

pi.f : (or/c single-flonum? flonum?) ~ ~

The same value as pi, but as a single-precision floating-point number if
the current platform supports it.

Changed in version 7.3.0.5 of package base: Allow value to be a
double-precision flonum.

                                        *degrees->radians*
(degrees->radians x) -> real? ~
  x : real? ~ ~

Converts an x-degree angle to radians.

Examples:

  > (degrees->radians 180)
  3.141592653589793
  > (sin (degrees->radians 45))
  0.7071067811865475

                                        *radians->degrees*
(radians->degrees x) -> real? ~
  x : real? ~ ~

Converts x radians to degrees.

Examples:

  > (radians->degrees pi)
  180.0
  > (radians->degrees (* 1/4 pi))
  45.0

                                        *sqr*
(sqr z) -> number? ~
  z : number? ~ ~

Returns (* z z).

                                        *sgn*
(sgn x) -> (or/c (=/c -1) (=/c 0) (=/c 1) +nan.0 +nan.f) ~
  x : real? ~ ~

Returns the sign of x as either -1, 0 (or a signed-zero variant, when
inexact), 1, or not-a-number.

Examples:

  > (sgn 10)
  1
  > (sgn -10.0)
  -1.0
  > (sgn 0)
  0
  > (sgn -0.0)
  -0.0
  > (sgn 0.0)
  0.0
  > (sgn +nan.0)
  +nan.0
  > (sgn +inf.0)
  1.0
  > (sgn -inf.0)
  -1.0

                                        *conjugate*
(conjugate z) -> number? ~
  z : number? ~ ~

Returns the complex conjugate of z.

Examples:

  > (conjugate 1)
  1
  > (conjugate 3+4i)
  3-4i

                                        *sinh*
(sinh z) -> number? ~
  z : number? ~ ~

Returns the hyperbolic sine of z.

                                        *cosh*
(cosh z) -> number? ~
  z : number? ~ ~

Returns the hyperbolic cosine of z.

                                        *tanh*
(tanh z) -> number? ~
  z : number? ~ ~

Returns the hyperbolic tangent of z.

                                        *exact-round*
(exact-round x) -> exact-integer? ~
  x : rational? ~ ~

Equivalent to (inexact->exact (round x)).

                                        *exact-floor*
(exact-floor x) -> exact-integer? ~
  x : rational? ~ ~

Equivalent to (inexact->exact (floor x)).

                                        *exact-ceiling*
(exact-ceiling x) -> exact-integer? ~
  x : rational? ~ ~

Equivalent to (inexact->exact (ceiling x)).

                                        *exact-truncate*
(exact-truncate x) -> exact-integer? ~
  x : rational? ~ ~

Equivalent to (inexact->exact (truncate x)).

                                        *order-of-magnitude*
(order-of-magnitude r) -> (and/c exact? integer?) ~
  r : (and/c real? positive?) ~ ~

Computes the greatest exact integer m such that:

  (<= (expt 10 m)
      (inexact->exact r))

Hence also:

  (< (inexact->exact r)
     (expt 10 (add1 m)))

Examples:

  > (order-of-magnitude 999)
  2
  > (order-of-magnitude 1000)
  3
  > (order-of-magnitude 1/100)
  -2
  > (order-of-magnitude 1/101)
  -3

                                        *nan?*
(nan? x) -> boolean? ~
  x : real? ~ ~

Returns #t if x is eqv? to +nan.0 or +nan.f; otherwise #f.

                                        *infinite?*
(infinite? x) -> boolean? ~
  x : real? ~ ~

Returns #t if x is +inf.0, -inf.0, +inf.f, -inf.f; otherwise #f.

                                        *positive-integer?*
(positive-integer? x) -> boolean? ~
  x : any/c ~ ~

Like exact-positive-integer?, but also returns #t for positive inexact?
integers.

Added in version 6.8.0.2 of package base.

                                        *negative-integer?*
(negative-integer? x) -> boolean? ~
  x : any/c ~ ~

The same as (and (integer? x) (negative? x)).

Added in version 6.8.0.2 of package base.

                                        *nonpositive-integer?*
(nonpositive-integer? x) -> boolean? ~
  x : any/c ~ ~

The same as (and (integer? x) (not (positive? x))).

Added in version 6.8.0.2 of package base.

                                        *nonnegative-integer?*
(nonnegative-integer? x) -> boolean? ~
  x : any/c ~ ~

Like exact-nonnegative-integer?, but also returns #t for non-negative
inexact? integers.

Added in version 6.8.0.2 of package base.

                                        *natural?*
(natural? x) -> boolean? ~
  x : any/c ~ ~

An alias for exact-nonnegative-integer?.

Added in version 6.8.0.2 of package base.

3.3. Flonums

 (require racket/flonum) package: base ~ ~

The racket/flonum library provides operations like fl+ that consume and
produce only flonums. Flonum-specific operations can provide better
performance when used consistently, and they are as safe as generic
operations like +.

+See also [missing] in [missing].

3.3.1. Flonum Arithmetic

                                        *fl+*
(fl+ a ...) -> flonum? ~
  a : flonum? ~ ~
(fl- a b ...) -> flonum?
  a : flonum? ~ ~
  b : flonum? ~ ~
(fl* a ...) -> flonum?
  a : flonum? ~ ~
(fl/ a b ...) -> flonum?
  a : flonum? ~ ~
  b : flonum? ~ ~
(flabs a) -> flonum?
  a : flonum? ~ ~

Like +, -, *, /, and abs, but constrained to consume flonums. The result
is always a flonum.

Changed in version 7.0.0.13 of package base: Allow zero or more
arguments for fl+ and fl* and one or more arguments for fl- and fl/.

                                        *fl=*
(fl= a b ...) -> boolean? ~
  a : flonum? ~ ~
  b : flonum? ~ ~
(fl< a b ...) -> boolean?
  a : flonum? ~ ~
  b : flonum? ~ ~
(fl> a b ...) -> boolean?
  a : flonum? ~ ~
  b : flonum? ~ ~
(fl<= a b ...) -> boolean?
  a : flonum? ~ ~
  b : flonum? ~ ~
(fl>= a b ...) -> boolean?
  a : flonum? ~ ~
  b : flonum? ~ ~
(flmin a b ...) -> flonum?
  a : flonum? ~ ~
  b : flonum? ~ ~
(flmax a b ...) -> flonum?
  a : flonum? ~ ~
  b : flonum? ~ ~

Like =, <, >, <=, >=, min, and max, but constrained to consume flonums.

Changed in version 7.0.0.13 of package base: Allow one argument, in
addition to allowing two or more.

                                        *flround*
(flround a) -> flonum? ~
  a : flonum? ~ ~
(flfloor a) -> flonum?
  a : flonum? ~ ~
(flceiling a) -> flonum?
  a : flonum? ~ ~
(fltruncate a) -> flonum?
  a : flonum? ~ ~

Like round, floor, ceiling, and truncate, but constrained to consume
flonums.

                                        *flsin*
(flsin a) -> flonum? ~
  a : flonum? ~ ~
(flcos a) -> flonum?
  a : flonum? ~ ~
(fltan a) -> flonum?
  a : flonum? ~ ~
(flasin a) -> flonum?
  a : flonum? ~ ~
(flacos a) -> flonum?
  a : flonum? ~ ~
(flatan a) -> flonum?
  a : flonum? ~ ~
(fllog a) -> flonum?
  a : flonum? ~ ~
(flexp a) -> flonum?
  a : flonum? ~ ~
(flsqrt a) -> flonum?
  a : flonum? ~ ~

Like sin, cos, tan, asin, acos, atan, log, exp, and sqrt, but
constrained to consume and produce flonums. The result is +nan.0 when a
number outside the range -1.0 to 1.0 is given to flasin or flacos, or
when a negative number is given to fllog or flsqrt.

                                        *flexpt*
(flexpt a b) -> flonum? ~
  a : flonum? ~ ~
  b : flonum? ~ ~

Like expt, but constrained to consume and produce flonums.

Due to the result constraint, the results compared to expt differ in the
following cases: These special cases correspond to pow in C99 [C99].

* (flexpt -1.0 +inf.0) — 1.0

* (flexpt a +inf.0) where a is negative — (expt (abs a) +inf.0)

* (flexpt a -inf.0) where a is negative — (expt (abs a) -inf.0)

* (expt -inf.0 b) where b is a non-integer:

  * b is negative — 0.0

  * b is positive — +inf.0

* (flexpt a b) where a is negative and b is not an integer — +nan.0

                                        *->fl*
(->fl a) -> flonum?
  a : exact-integer? ~ ~

Like exact->inexact, but constrained to consume exact integers, so the
result is always a flonum.

                                        *fl->exact-integer*
(fl->exact-integer a) -> exact-integer? ~
  a : flonum? ~ ~

Like inexact->exact, but constrained to consume an integer flonum, so
the result is always an exact integer.

                                        *make-flrectangular*
(make-flrectangular a b) ~
 -> (and/c complex?
           (lambda (c) (flonum? (real-part c)))
           (lambda (c) (flonum? (imag-part c))))
  a : flonum? ~ ~
  b : flonum? ~ ~
(flreal-part a) -> flonum?
  a : (and/c complex? ~ ~
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))
(flimag-part a) -> flonum?
  a : (and/c complex? ~ ~
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))

Like make-rectangular, real-part, and imag-part, but both parts of the
complex number must be inexact.

                                        *flrandom*
(flrandom rand-gen) -> (and flonum? (>/c 0) (</c 1)) ~
  rand-gen : pseudo-random-generator? ~ ~

Equivalent to (random rand-gen).

3.3.2. Flonum Vectors

A flvector is like a vector, but it holds only inexact real numbers.
This representation can be more compact, and unsafe operations on
flvectors (see racket/unsafe/ops) can execute more efficiently than
unsafe operations on vectors of inexact reals.

An f64vector as provided by ffi/vector stores the same kinds of values
as a flvector, but with extra indirections that make f64vectors more
convenient for working with foreign libraries. The lack of indirections
makes unsafe flvector access more efficient.

Two flvectors are equal? if they have the same length, and if the values
in corresponding slots of the flvectors are equal?.

A printed flvector starts with #fl(, optionally with a number between
the #fl and (. See [missing]     for information on reading
flvectors and [missing]     for information on printing flvectors.

                                        *flvector?*
(flvector? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a flvector, #f otherwise.

                                        *flvector*
(flvector x ...) -> flvector? ~
  x : flonum? ~ ~

Creates a flvector containing the given inexact real numbers.

Example:

  > (flvector 2.0 3.0 4.0 5.0)
  (flvector 2.0 3.0 4.0 5.0)

                                        *make-flvector*
(make-flvector size [x]) -> flvector? ~
  size : exact-nonnegative-integer? ~ ~
  x : flonum? = 0.0 ~ ~

Creates a flvector with size elements, where every slot in the flvector
is filled with x.

Example:

  > (make-flvector 4 3.0)
  (flvector 3.0 3.0 3.0 3.0)

                                        *flvector-length*
(flvector-length vec) -> exact-nonnegative-integer? ~
  vec : flvector? ~ ~

Returns the length of vec (i.e., the number of slots in the flvector).

                                        *flvector-ref*
(flvector-ref vec pos) -> flonum? ~
  vec : flvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the inexact real number in slot pos of vec. The first slot is
position 0, and the last slot is one less than (flvector-length vec).

                                        *flvector-set!*
(flvector-set! vec pos x) -> flonum? ~
  vec : flvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  x : flonum? ~ ~

Sets the inexact real number in slot pos of vec. The first slot is
position 0, and the last slot is one less than (flvector-length vec).

                                        *flvector-copy*
(flvector-copy vec [start end]) -> flvector? ~
  vec : flvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length v) ~ ~

Creates a fresh flvector of size (- end start), with all of the elements
of vec from start (inclusive) to end (exclusive).

                                        *in-flvector*
(in-flvector vec [start stop step]) -> sequence? ~
  vec : flvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~

Returns a sequence equivalent to vec when no optional arguments are
supplied.

The optional arguments start, stop, and step are as in in-vector.

A in-flvector application can provide better performance for flvector
iteration when it appears directly in a for clause.

                                        *for/flvector*
(for/flvector maybe-length (for-clause ...) body ...) ~
(for*/flvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr ~ ~
             | #:length length-expr #:fill fill-expr ~ ~
 
  length-expr : exact-nonnegative-integer? ~ ~
  fill-expr : flonum? ~ ~

Like for/vector or for*/vector, but for flvectors. The default fill-expr
produces 0.0.

                                        *shared-flvector*
(shared-flvector x ...) -> flvector? ~
  x : flonum? ~ ~

Creates a flvector containing the given inexact real numbers. For
communication among places, the new flvector is allocated in the shared
memory space.

Example:

  > (shared-flvector 2.0 3.0 4.0 5.0)
  (flvector 2.0 3.0 4.0 5.0)

                                        *make-shared-flvector*
(make-shared-flvector size [x]) -> flvector? ~
  size : exact-nonnegative-integer? ~ ~
  x : flonum? = 0.0 ~ ~

Creates a flvector with size elements, where every slot in the flvector
is filled with x. For communication among places, the new flvector is
allocated in the shared memory space.

Example:

  > (make-shared-flvector 4 3.0)
  (flvector 3.0 3.0 3.0 3.0)

3.4. Fixnums

 (require racket/fixnum) package: base ~ ~

The racket/fixnum library provides operations like fx+ that consume and
produce only fixnums. The operations in this library are meant to be
safe versions of unsafe operations like unsafe-fx+. These safe
operations are generally no faster than using generic primitives like +.

The expected use of the racket/fixnum library is for code where the
require of racket/fixnum is replaced with

  (require (filtered-in
            (λ (name)
              (and (regexp-match #rx"^unsafe-fx" name)
                   (regexp-replace #rx"unsafe-" name "")))
            racket/unsafe/ops))

to drop in unsafe versions of the library. Alternately, when
encountering crashes with code that uses unsafe fixnum operations, use
the racket/fixnum library to help debug the problems.

3.4.1. Fixnum Arithmetic

                                        *fx+*
(fx+ a ...) -> fixnum? ~
  a : fixnum? ~ ~
(fx- a b ...) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fx* a ...) -> fixnum?
  a : fixnum? ~ ~
(fxquotient a b) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxremainder a b) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxmodulo a b) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxabs a) -> fixnum?
  a : fixnum? ~ ~

Safe versions of unsafe-fx+, unsafe-fx-, unsafe-fx*, unsafe-fxquotient,
unsafe-fxremainder, unsafe-fxmodulo, and unsafe-fxabs. The
exn:fail:contract:non-fixnum-result exception is raised if the
arithmetic result would not be a fixnum.

Changed in version 7.0.0.13 of package base: Allow zero or more
arguments for fx+ and fx* and one or more arguments for fx-.

                                        *fxand*
(fxand a ...) -> fixnum? ~
  a : fixnum? ~ ~
(fxior a ...) -> fixnum?
  a : fixnum? ~ ~
(fxxor a ...) -> fixnum?
  a : fixnum? ~ ~
(fxnot a) -> fixnum?
  a : fixnum? ~ ~
(fxlshift a b) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxrshift a b) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~

Safe versions of unsafe-fxand, unsafe-fxior, unsafe-fxxor, unsafe-fxnot,
unsafe-fxlshift, and unsafe-fxrshift.  The
exn:fail:contract:non-fixnum-result exception is raised if the
arithmetic result would not be a fixnum.

Changed in version 7.0.0.13 of package base: Allow any number of
arguments for fxand, fxior, and fxxor.

                                        *fx=*
(fx= a b ...) -> boolean? ~
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fx< a b ...) -> boolean?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fx> a b ...) -> boolean?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fx<= a b ...) -> boolean?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fx>= a b ...) -> boolean?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxmin a b ...) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~
(fxmax a b ...) -> fixnum?
  a : fixnum? ~ ~
  b : fixnum? ~ ~

Safe versions of unsafe-fx=, unsafe-fx<,  unsafe-fx>, unsafe-fx<=,
unsafe-fx>=,  unsafe-fxmin, and unsafe-fxmax.

Changed in version 7.0.0.13 of package base: Allow one argument, in
addition to allowing two or more.

                                        *fx->fl*
(fx->fl a) -> flonum? ~
  a : fixnum? ~ ~
(fl->fx fl) -> fixnum?
  fl : flonum? ~ ~

Conversion between fixnums and flonums with truncation in the case of
converting a flonum to a fixnum.

The fx->fl function is the same as exact->inexact or ->fl constrained to
a fixnum argument.

The fl->fx function is the same as truncate followed by inexact->exact
or fl->exact-integer constrained to returning a fixnum. If the truncated
flonum does not fit into a fixnum, the exn:fail:contract exception is
raised.

Changed in version 7.7.0.8 of package base: Changed fl->fx to truncate.

                                        *fixnum-for-every-system?*
(fixnum-for-every-system? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a fixnum and is represented by fixnum by every Racket
implementation, #f otherwise.

Added in version 7.3.0.11 of package base.

3.4.2. Fixnum Vectors

A fxvector is like a vector, but it holds only fixnums. The only
advantage of a fxvector over a vector is that a shared version can be
created with functions like shared-fxvector.

Two fxvectors are equal? if they have the same length, and if the values
in corresponding slots of the fxvectors are equal?.

A printed fxvector starts with #fx(, optionally with a number between
the #fx and (. See [missing]     for information on reading
fxvectors and [missing]     for information on printing fxvectors.

                                        *fxvector?*
(fxvector? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a fxvector, #f otherwise.

                                        *fxvector*
(fxvector x ...) -> fxvector? ~
  x : fixnum? ~ ~

Creates a fxvector containing the given fixnums.

Example:

  > (fxvector 2 3 4 5)
  (fxvector 2 3 4 5)

                                        *make-fxvector*
(make-fxvector size [x]) -> fxvector? ~
  size : exact-nonnegative-integer? ~ ~
  x : fixnum? = 0 ~ ~

Creates a fxvector with size elements, where every slot in the fxvector
is filled with x.

Example:

  > (make-fxvector 4 3)
  (fxvector 3 3 3 3)

                                        *fxvector-length*
(fxvector-length vec) -> exact-nonnegative-integer? ~
  vec : fxvector? ~ ~

Returns the length of vec (i.e., the number of slots in the fxvector).

                                        *fxvector-ref*
(fxvector-ref vec pos) -> fixnum? ~
  vec : fxvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the fixnum in slot pos of vec. The first slot is position 0, and
the last slot is one less than (fxvector-length vec).

                                        *fxvector-set!*
(fxvector-set! vec pos x) -> fixnum? ~
  vec : fxvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  x : fixnum? ~ ~

Sets the fixnum in slot pos of vec. The first slot is position 0, and
the last slot is one less than (fxvector-length vec).

                                        *fxvector-copy*
(fxvector-copy vec [start end]) -> fxvector? ~
  vec : fxvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length v) ~ ~

Creates a fresh fxvector of size (- end start), with all of the elements
of vec from start (inclusive) to end (exclusive).

                                        *in-fxvector*
(in-fxvector vec [start stop step]) -> sequence? ~
  vec : fxvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~

Returns a sequence equivalent to vec when no optional arguments are
supplied.

The optional arguments start, stop, and step are as in in-vector.

An in-fxvector application can provide better performance for fxvector
iteration when it appears directly in a for clause.

                                        *for/fxvector*
(for/fxvector maybe-length (for-clause ...) body ...) ~
(for*/fxvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr ~ ~
             | #:length length-expr #:fill fill-expr ~ ~
 
  length-expr : exact-nonnegative-integer? ~ ~
  fill-expr : fixnum? ~ ~

Like for/vector or for*/vector, but for fxvectors. The default fill-expr
produces 0.

                                        *shared-fxvector*
(shared-fxvector x ...) -> fxvector? ~
  x : fixnum? ~ ~

Creates a fxvector containing the given fixnums. For communication among
places, the new fxvector is allocated in the shared memory space.

Example:

  > (shared-fxvector 2 3 4 5)
  (fxvector 2 3 4 5)

                                        *make-shared-fxvector*
(make-shared-fxvector size [x]) -> fxvector? ~
  size : exact-nonnegative-integer? ~ ~
  x : fixnum? = 0 ~ ~

Creates a fxvector with size elements, where every slot in the fxvector
is filled with x. For communication among places, the new fxvector is
allocated in the shared memory space.

Example:

  > (make-shared-fxvector 4 3)
  (fxvector 3 3 3 3)

3.5. Extflonums

 (require racket/extflonum) package: base ~ ~

An extflonum is an extended-precision (80-bit) floating-point number.
Extflonum arithmetic is supported on platforms with extended-precision
hardware and where the extflonum implementation does not conflict with
normal double-precision arithmetic (i.e., on x86 and x86_64 platforms
when Racket is compiled to use SSE instructions for floating-point
operations, and on Windows when "longdouble.dll" is available).

A extflonum is not a number in the sense of number?. Only
extflonum-specific operations such as extfl+ perform extflonum
arithmetic.

A literal extflonum is written like an inexact number, but using an
explicit t or T exponent marker (see [missing]). For example, 3.5t0 is
an extflonum. The extflonum values for infinity are +inf.t and -inf.t.
The extflonum value for not-a-number is +nan.t.

If (extflonum-available?) produces #f, then all operations exported by
racket/extflonum raise exn:fail:unsupported, except for extflonum?,
extflonum-available?, and extflvector? (which always work). The reader
(see [missing]) always accepts extflonum input; when extflonum
operations are not supported, printing an extflonum from the reader uses
its source notation (as opposed to normalizing the format).

Two extflonums are equal? if extfl= produces #t for the extflonums. If
extflonums are not supported in a platform, extflonums are equal? only
if they are eq?.

                                        *extflonum?*
(extflonum? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is an extflonum, #f otherwise.

                                        *extflonum-available?*
(extflonum-available?) -> boolean? ~

Returns #t if extflonum operations are supported on the current
platform, #f otherwise.

3.5.1. Extflonum Arithmetic

                                        *extfl+*
(extfl+ a b) -> extflonum? ~
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl- a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl* a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl/ a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extflabs a) -> extflonum?
  a : extflonum? ~ ~

Like fl+, fl-, fl*, fl/, and flabs, but for extflonums.

                                        *extfl=*
(extfl= a b) -> boolean? ~
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl< a b) -> boolean?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl> a b) -> boolean?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl<= a b) -> boolean?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extfl>= a b) -> boolean?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extflmin a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~
(extflmax a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~

Like fl=, fl<, fl>, fl<=, fl>=, flmin, and flmax, but for extflonums.

                                        *extflround*
(extflround a) -> extflonum? ~
  a : extflonum? ~ ~
(extflfloor a) -> extflonum?
  a : extflonum? ~ ~
(extflceiling a) -> extflonum?
  a : extflonum? ~ ~
(extfltruncate a) -> extflonum?
  a : extflonum? ~ ~

Like flround, flfloor, flceiling, and fltruncate, but for extflonums.

                                        *extflsin*
(extflsin a) -> extflonum? ~
  a : extflonum? ~ ~
(extflcos a) -> extflonum?
  a : extflonum? ~ ~
(extfltan a) -> extflonum?
  a : extflonum? ~ ~
(extflasin a) -> extflonum?
  a : extflonum? ~ ~
(extflacos a) -> extflonum?
  a : extflonum? ~ ~
(extflatan a) -> extflonum?
  a : extflonum? ~ ~
(extfllog a) -> extflonum?
  a : extflonum? ~ ~
(extflexp a) -> extflonum?
  a : extflonum? ~ ~
(extflsqrt a) -> extflonum?
  a : extflonum? ~ ~
(extflexpt a b) -> extflonum?
  a : extflonum? ~ ~
  b : extflonum? ~ ~

Like flsin, flcos, fltan, flasin, flacos, flatan, fllog, flexp, and
flsqrt, and flexpt, but for extflonums.

                                        *->extfl*
(->extfl a) -> extflonum?
  a : exact-integer? ~ ~
(extfl->exact-integer a) -> exact-integer?
  a : extflonum? ~ ~
(real->extfl a) -> extflonum?
  a : real? ~ ~
(extfl->exact a) -> (and/c real? exact?)
  a : extflonum? ~ ~
(extfl->fx a) -> fixnum?
  a : extflonum? ~ ~
(fx->extfl a) -> extflonum?
  a : fixnum? ~ ~
(extfl->inexact a) -> flonum?
  a : extflonum? ~ ~

The first six are like ->fl, fl->exact-integer, real->double-flonum,
inexact->exact, fl->fx, and fx->fl, but for extflonums. The
extfl->inexact function converts a extflonum to its closest flonum
approximation.

Changed in version 7.7.0.8 of package base: Changed extfl->fx to
truncate.

3.5.2. Extflonum Constants

pi.t : extflonum? ~ ~

Like pi, but with 80 bits precision.

3.5.3. Extflonum Vectors

An extflvector is like an flvector, but it holds only extflonums. See
also [missing].

Two extflvectors are equal? if they have the same length, and if the
values in corresponding slots of the extflvectors are equal?.

                                        *extflvector?*
(extflvector? v) -> boolean? ~
  v : any/c ~ ~
(extflvector x ...) -> extflvector?
  x : extflonum? ~ ~
(make-extflvector size [x]) -> extflvector?
  size : exact-nonnegative-integer? ~ ~
  x : extflonum? = 0.0t0 ~ ~
(extflvector-length vec) -> exact-nonnegative-integer?
  vec : extflvector? ~ ~
(extflvector-ref vec pos) -> extflonum?
  vec : extflvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~
(extflvector-set! vec pos x) -> extflonum?
  vec : extflvector? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  x : extflonum? ~ ~
(extflvector-copy vec [start end]) -> extflvector?
  vec : extflvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length v) ~ ~

Like flvector?, flvector, make-flvector, flvector-length, flvector-ref,
flvector-set, and flvector-copy, but for extflvectors.

                                        *in-extflvector*
(in-extflvector vec [start stop step]) -> sequence? ~
  vec : extflvector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~
(for/extflvector maybe-length (for-clause ...) body ...)
(for*/extflvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr ~ ~
             | #:length length-expr #:fill fill-expr ~ ~
 
  length-expr : exact-nonnegative-integer? ~ ~
  fill-expr : extflonum? ~ ~

Like in-flvector, for/flvector, and for*/flvector, but for extflvectors.

                                        *shared-extflvector*
(shared-extflvector x ...) -> extflvector? ~
  x : extflonum? ~ ~
(make-shared-extflvector size [x]) -> extflvector?
  size : exact-nonnegative-integer? ~ ~
  x : extflonum? = 0.0t0 ~ ~

Like shared-flvector and make-shared-flvector, but for extflvectors.

3.5.4. Extflonum Byte Strings

                                        *floating-point-bytes->extfl*
(floating-point-bytes->extfl  bstr             ~
                             [big-endian?     
                              start           
                              end])       -> extflonum?
  bstr : bytes? ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Like floating-point-bytes->real, but  for extflonums: Converts the
extended-precision floating-point number encoded in bstr from position
start (inclusive) to end (exclusive) to an extflonum. The difference
between start an end must be 10 bytes.

                                        *extfl->floating-point-bytes*
(extfl->floating-point-bytes  x                ~
                             [big-endian?     
                              dest-bstr       
                              start])     -> bytes?
  x : extflonum? ~ ~
  big-endian? : any/c = (system-big-endian?) ~ ~
  dest-bstr : (and/c bytes? (not/c immutable?)) ~ ~
            = (make-bytes 10)
  start : exact-nonnegative-integer? = 0 ~ ~

Like real->floating-point-bytes, but  for extflonums: Converts x to its
representation in a byte string of length 10.

4. Strings

+[missing] in [missing] introduces strings.

A string is a fixed-length array of characters.

A string can be mutable or immutable. When an immutable string is
provided to a procedure like string-set!, the exn:fail:contract
exception is raised. String constants generated by the default reader
(see [missing]) are immutable, and they are interned in read-syntax
mode. Use immutable? to check whether a string is immutable.

Two strings are equal? when they have the same length and contain the
same sequence of characters.

A string can be used as a single-valued sequence (see Sequences). The
characters of the string serve as elements of the sequence. See also
in-string.

See [missing]     for information on reading     strings and [missing]
for information on printing strings.

See also: immutable?, symbol->string, bytes->string/utf-8.

4.1. String Constructors, Selectors, and Mutators

                                        *string?*
(string? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v  is a string, #f otherwise.

Examples:

  > (string? "Apple")
  #t
  > (string? 'apple)
  #f

                                        *make-string*
(make-string k [char]) -> string? ~
  k : exact-nonnegative-integer? ~ ~
  char : char? = #\nul ~ ~

Returns a new mutable string of length k where each position in the
string is initialized with the character char.

Example:

  > (make-string 5 #\z)
  "zzzzz"

                                        *string*
(string char ...) -> string? ~
  char : char? ~ ~

Returns a new mutable string whose length is the number of provided
chars, and whose positions are initialized with the given chars.

Example:

  > (string #\A #\p #\p #\l #\e)
  "Apple"

                                        *string->immutable-string*
(string->immutable-string str) -> (and/c string? immutable?) ~
  str : string? ~ ~

Returns an immutable string with the same content as  str, returning str
itself if str is  immutable.

                                        *string-length*
(string-length str) -> exact-nonnegative-integer? ~
  str : string? ~ ~

Returns the length of str.

Example:

  > (string-length "Apple")
  5

                                        *string-ref*
(string-ref str k) -> char? ~
  str : string? ~ ~
  k : exact-nonnegative-integer? ~ ~

Returns the character at position k in str.  The first position in the
string corresponds to 0, so the  position k must be less than the length
of the string,  otherwise the exn:fail:contract exception is raised.

Example:

  > (string-ref "Apple" 0)
  #\A

                                        *string-set!*
(string-set! str k char) -> void? ~
  str : (and/c string? (not/c immutable?)) ~ ~
  k : exact-nonnegative-integer? ~ ~
  char : char? ~ ~

Changes the  character position k in str to char.  The first  position
in the string corresponds to 0, so the position  k must be less than the
length of the string, otherwise the  exn:fail:contract exception is
raised.

Examples:

  > (define s (string #\A #\p #\p #\l #\e))
  > (string-set! s 4 #\y)
  > s
  "Apply"

                                        *substring*
(substring str start [end]) -> string? ~
  str : string? ~ ~
  start : exact-nonnegative-integer? ~ ~
  end : exact-nonnegative-integer? = (string-length str) ~ ~

Returns a new mutable string that is (- end start)  characters long, and
that contains the same characters as  str from start inclusive to end
exclusive.  The first position in a string corresponds to 0, so  the
start and end arguments must be less than or  equal to the length of
str, and end must be greater  than or equal to start, otherwise the
exn:fail:contract exception is raised.

Examples:

  > (substring "Apple" 1 3)
  "pp"
  > (substring "Apple" 1)
  "pple"

                                        *string-copy*
(string-copy str) -> string? ~
  str : string? ~ ~

Returns  (substring str 0).

Examples:

  > (define s1 "Yui")
  > (define pilot (string-copy s1))
  > (list s1 pilot)
  '("Yui" "Yui")
  > (for ([i (in-naturals)] [ch '(#\R #\e #\i)])
      (string-set! pilot i ch))
  > (list s1 pilot)
  '("Yui" "Rei")

                                        *string-copy!*
(string-copy!  dest            ~
               dest-start     
               src            
              [src-start      
               src-end])  -> void?
  dest : (and/c string? (not/c immutable?)) ~ ~
  dest-start : exact-nonnegative-integer? ~ ~
  src : string? ~ ~
  src-start : exact-nonnegative-integer? = 0 ~ ~
  src-end : exact-nonnegative-integer? = (string-length src) ~ ~

Changes the characters of dest starting at position  dest-start to match
the characters in src from  src-start (inclusive) to src-end
(exclusive),  where the first position in a string corresponds to 0. The
strings dest and src can be the same string, and in  that case the
destination region can overlap with the source region;  the destination
characters after the copy match the source characters  from before the
copy. If any of dest-start,  src-start, or src-end are out of range
(taking into  account the sizes of the strings and the source and
destination  regions), the exn:fail:contract exception is raised.

Examples:

  > (define s (string #\A #\p #\p #\l #\e))
  > (string-copy! s 4 "y")
  > (string-copy! s 0 s 3 4)
  > s
  "lpply"

                                        *string-fill!*
(string-fill! dest char) -> void? ~
  dest : (and/c string? (not/c immutable?)) ~ ~
  char : char? ~ ~

Changes dest so that every position in the  string is filled with char.

Examples:

  > (define s (string #\A #\p #\p #\l #\e))
  > (string-fill! s #\q)
  > s
  "qqqqq"

                                        *string-append*
(string-append str ...) -> string? ~
  str : string? ~ ~

Returns a new mutable string that is as long as the sum of the given
strs’ lengths, and that contains the concatenated characters of the
given strs. If no strs are provided, the result is a zero-length string.

Example:

  > (string-append "Apple" "Banana")
  "AppleBanana"

                                        *string-append-immutable*
(string-append-immutable str ...) -> (and/c string? immutable?) ~
  str : string? ~ ~

The same as string-append, but the result is an immutable string.

Examples:

  > (string-append-immutable "Apple" "Banana")
  "AppleBanana"
  > (immutable? (string-append-immutable "A" "B"))
  #t

Added in version 7.5.0.14.

                                        *string->list*
(string->list str) -> (listof char?) ~
  str : string? ~ ~

Returns a new  list of characters corresponding to the content of str.
That is,  the length of the list is (string-length str), and the
sequence of characters in str is the same sequence in the  result list.

Example:

  > (string->list "Apple")
  '(#\A #\p #\p #\l #\e)

                                        *list->string*
(list->string lst) -> string? ~
  lst : (listof char?) ~ ~

Returns a new  mutable string whose content is the list of characters in
lst.  That is, the length of the string is (length lst), and  the
sequence of characters in lst is the same sequence in  the result
string.

Example:

  > (list->string (list #\A #\p #\p #\l #\e))
  "Apple"

                                        *build-string*
(build-string n proc) -> string? ~
  n : exact-nonnegative-integer? ~ ~
  proc : (exact-nonnegative-integer? . -> . char?) ~ ~

Creates a string of n characters by applying proc to the integers from 0
to (sub1 n) in order. If str is the resulting string, then (string-ref
str i) is the character produced by (proc i).

Example:

  > (build-string 5 (lambda (i) (integer->char (+ i 97))))
  "abcde"

4.2. String Comparisons

                                        *string=?*
(string=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Returns  #t if all of the arguments are equal?.

Examples:

  > (string=? "Apple" "apple")
  #f
  > (string=? "a" "as" "a")
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string<?*
(string<? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Returns #t if the arguments are lexicographically sorted  increasing,
where individual characters are ordered by  char<?, #f otherwise.

Examples:

  > (string<? "Apple" "apple")
  #t
  > (string<? "apple" "Apple")
  #f
  > (string<? "a" "b" "c")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string<=?*
(string<=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but checks whether the arguments are nondecreasing.

Examples:

  > (string<=? "Apple" "apple")
  #t
  > (string<=? "apple" "Apple")
  #f
  > (string<=? "a" "b" "b")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string>?*
(string>? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but checks whether the arguments are decreasing.

Examples:

  > (string>? "Apple" "apple")
  #f
  > (string>? "apple" "Apple")
  #t
  > (string>? "c" "b" "a")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string>=?*
(string>=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but checks whether the arguments are nonincreasing.

Examples:

  > (string>=? "Apple" "apple")
  #f
  > (string>=? "apple" "Apple")
  #t
  > (string>=? "c" "b" "b")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-ci=?*
(string-ci=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Returns #t if all of the arguments are equal? after  locale-insensitive
case-folding via string-foldcase.

Examples:

  > (string-ci=? "Apple" "apple")
  #t
  > (string-ci=? "a" "a" "a")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-ci<?*
(string-ci<? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but checks whether the arguments would be in  increasing
order if each was first case-folded using  string-foldcase (which is
locale-insensitive).

Examples:

  > (string-ci<? "Apple" "apple")
  #f
  > (string-ci<? "apple" "banana")
  #t
  > (string-ci<? "a" "b" "c")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-ci<=?*
(string-ci<=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string-ci<?, but checks whether the arguments would be
nondecreasing after case-folding.

Examples:

  > (string-ci<=? "Apple" "apple")
  #t
  > (string-ci<=? "apple" "Apple")
  #t
  > (string-ci<=? "a" "b" "b")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-ci>?*
(string-ci>? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string-ci<?, but checks whether the arguments would be decreasing
after case-folding.

Examples:

  > (string-ci>? "Apple" "apple")
  #f
  > (string-ci>? "banana" "Apple")
  #t
  > (string-ci>? "c" "b" "a")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-ci>=?*
(string-ci>=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string-ci<?, but checks whether the arguments would be
nonincreasing after case-folding.

Examples:

  > (string-ci>=? "Apple" "apple")
  #t
  > (string-ci>=? "apple" "Apple")
  #t
  > (string-ci>=? "c" "b" "b")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

4.3. String Conversions

                                        *string-upcase*
(string-upcase str) -> string? ~
  str : string? ~ ~

Returns a string  whose characters are the upcase conversion of the
characters in  str. The conversion uses Unicode’s locale-independent
conversion rules that map code-point sequences to code-point  sequences
(instead of simply mapping a 1-to-1 function on code points  over the
string), so the string produced by the conversion can be  longer than
the input string.

Examples:

  > (string-upcase "abc!")
  "ABC!"
  > (string-upcase "Straße")
  "STRASSE"

                                        *string-downcase*
(string-downcase string) -> string? ~
  string : string? ~ ~

Like  string-upcase, but the downcase conversion.

Examples:

  > (string-downcase "aBC!")
  "abc!"
  > (string-downcase "Straße")
  "straße"
  > (string-downcase "ΚΑΟΣ")
  "καος"
  > (string-downcase "Σ")
  "σ"

                                        *string-titlecase*
(string-titlecase string) -> string? ~
  string : string? ~ ~

Like  string-upcase, but the titlecase conversion only for the  first
character in each sequence of cased characters in str  (ignoring
case-ignorable characters).

Examples:

  > (string-titlecase "aBC  twO")
  "Abc  Two"
  > (string-titlecase "y2k")
  "Y2K"
  > (string-titlecase "main straße")
  "Main Straße"
  > (string-titlecase "stra ße")
  "Stra Sse"

                                        *string-foldcase*
(string-foldcase string) -> string? ~
  string : string? ~ ~

Like  string-upcase, but the case-folding conversion.

Examples:

  > (string-foldcase "aBC!")
  "abc!"
  > (string-foldcase "Straße")
  "strasse"
  > (string-foldcase "ΚΑΟΣ")
  "καοσ"

                                        *string-normalize-nfd*
(string-normalize-nfd string) -> string? ~
  string : string? ~ ~

Returns a string that is the Unicode normalized form D of string. If the
given string is already in the corresponding Unicode normal form, the
string may be returned directly as the result (instead of a newly
allocated string).

                                        *string-normalize-nfkd*
(string-normalize-nfkd string) -> string? ~
  string : string? ~ ~

Like string-normalize-nfd, but for normalized form KD.

                                        *string-normalize-nfc*
(string-normalize-nfc string) -> string? ~
  string : string? ~ ~

Like string-normalize-nfd, but for normalized form C.

                                        *string-normalize-nfkc*
(string-normalize-nfkc string) -> string? ~
  string : string? ~ ~

Like string-normalize-nfd, but for normalized form KC.

4.4. Locale-Specific String Operations

                                        *string-locale=?*
(string-locale=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string=?, but the strings are compared in a  locale-specific way,
based on the value of current-locale. See  [missing] for more
information on locales.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale<?*
(string-locale<? str1 str2 ...+) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but the sort order compares strings in a  locale-specific
way, based on the value of current-locale. In  particular, the sort
order may not be simply a lexicographic  extension of character
ordering.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale>?*
(string-locale>? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string>?, but locale-specific like  string-locale<?.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale-ci=?*
(string-locale-ci=? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string-locale=?, but strings are compared  using rules that are
both locale-specific and case-insensitive  (depending on what
“case-insensitive” means for the current  locale).

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale-ci<?*
(string-locale-ci<? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string<?, but both locale-sensitive and  case-insensitive like
string-locale-ci=?.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale-ci>?*
(string-locale-ci>? str1 str2 ...) -> boolean? ~
  str1 : string? ~ ~
  str2 : string? ~ ~

Like string>?, but both locale-sensitive and  case-insensitive like
string-locale-ci=?.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *string-locale-upcase*
(string-locale-upcase string) -> string? ~
  string : string? ~ ~

Like string-upcase, but using locale-specific case-conversion rules
based on the value of current-locale.

                                        *string-locale-downcase*
(string-locale-downcase string) -> string? ~
  string : string? ~ ~

Like string-downcase, but using locale-specific case-conversion rules
based on the value of current-locale.

4.5. Additional String Functions

 (require racket/string) package: base ~ ~

The bindings documented in this section are provided by the
racket/string and racket libraries, but not racket/base.

                                        *string-append**
(string-append* str ... strs) -> string? ~
  str : string? ~ ~
  strs : (listof string?) ~ ~

Like string-append, but the last argument is used as a list of arguments
for string-append, so (string-append* str ... strs) is the same as
(apply string-append str ... strs).  In other words, the relationship
between string-append and string-append* is similar to the one between
list and list*.

Examples:

  > (string-append* "a" "b" '("c" "d"))
  "abcd"
  > (string-append* (cdr (append* (map (lambda (x) (list ", " x))
                                       '("Alpha" "Beta" "Gamma")))))
  "Alpha, Beta, Gamma"

                                        *string-join*
(string-join  strs                             ~
             [sep                             
              #:before-first before-first      ~ ~
              #:before-last before-last        ~ ~
              #:after-last after-last])   -> string? ~ ~
  strs : (listof string?) ~ ~
  sep : string? = " " ~ ~
  before-first : string? = "" ~ ~
  before-last : string? = sep ~ ~
  after-last : string? = "" ~ ~

Appends the strings in strs, inserting sep between each pair of strings
in strs.  before-last, before-first, and after-last are analogous to the
inputs of add-between: they specify an alternate separator between the
last two strings, a prefix string, and a suffix string respectively.

Examples:

  > (string-join '("one" "two" "three" "four"))
  "one two three four"
  > (string-join '("one" "two" "three" "four") ", ")
  "one, two, three, four"
  > (string-join '("one" "two" "three" "four") " potato ")
  "one potato two potato three potato four"
  > (string-join '("x" "y" "z") ", "
                 #:before-first "Todo: " ~ ~
                 #:before-last " and " ~ ~
                 #:after-last ".") ~ ~
  "Todo: x, y and z."

                                        *string-normalize-spaces*
(string-normalize-spaces  str                      ~
                         [sep                     
                          space                   
                          #:trim? trim?            ~ ~
                          #:repeat? repeat?]) -> string? ~ ~
  str : string? ~ ~
  sep : (or/c string? regexp?) = #px"\\s+" ~ ~
  space : string? = " " ~ ~
  trim? : any/c = #t ~ ~
  repeat? : any/c = #f ~ ~

Normalizes spaces in the input str by trimming it (using string-trim and
sep) and replacing all whitespace sequences in the result with space,
which defaults to a single space.

Example:

  > (string-normalize-spaces "  foo bar  baz \r\n\t")
  "foo bar baz"

The result of (string-normalize-spaces str sep space) is the same as
(string-join (string-split str sep ....) space).

                                        *string-replace*
(string-replace str from to [#:all? all?]) -> string? ~ ~ ~
  str : string? ~ ~
  from : (or/c string? regexp?) ~ ~
  to : string? ~ ~
  all? : any/c = #t ~ ~

Returns str with all occurrences of from replaced with by to. If from is
a string, it is matched literally (as opposed to being used as a regular
expression).

By default, all occurrences are replaced, but only the first match is
replaced if all? is #f.

Example:

  > (string-replace "foo bar baz" "bar" "blah")
  "foo blah baz"

                                        *string-split*
(string-split  str                      ~
              [sep                     
               #:trim? trim?            ~ ~
               #:repeat? repeat?]) -> (listof string?) ~ ~
  str : string? ~ ~
  sep : (or/c string? regexp?) = #px"\\s+" ~ ~
  trim? : any/c = #t ~ ~
  repeat? : any/c = #f ~ ~

Splits the input str on sep, returning a list of substrings of str that
are separated by sep, defaulting to splitting the input on whitespaces.
The input is first trimmed using sep (see string-trim), unless trim? is
#f. Empty matches are handled in the same way as for regexp-split. As a
special case, if str is the empty string after trimming, the result is
'() instead of '("").

Like string-trim, provide sep to use a different separator, and repeat?
controls matching repeated sequences.

Examples:

  > (string-split "  foo bar  baz \r\n\t")
  '("foo" "bar" "baz")
  > (string-split "  ")
  '()
  > (string-split "  " #:trim? #f) ~ ~
  '("" "")

                                        *string-trim*
(string-trim  str                      ~
             [sep                     
              #:left? left?            ~ ~
              #:right? right?          ~ ~
              #:repeat? repeat?]) -> string? ~ ~
  str : string? ~ ~
  sep : (or/c string? regexp?) = #px"\\s+" ~ ~
  left? : any/c = #t ~ ~
  right? : any/c = #t ~ ~
  repeat? : any/c = #f ~ ~

Trims the input str by removing prefix and suffix sep, which defaults to
whitespace. A string sep is matched literally (as opposed to being used
as a regular expression).

Use #:left? #f or #:right? #f to suppress trimming the corresponding
side.  When repeat? is #f (the default), only one match is removed from
each side; when repeat? is true, all initial or trailing matches are
trimmed (which is an alternative to using a regular expression sep that
contains +).

Examples:

  > (string-trim "  foo bar  baz \r\n\t")
  "foo bar  baz"
  > (string-trim "  foo bar  baz \r\n\t" " " #:repeat? #t) ~ ~
  "foo bar  baz \r\n\t"
  > (string-trim "aaaxaayaa" "aa")
  "axaay"

                                        *non-empty-string?*
(non-empty-string? x) -> boolean? ~
  x : any/c ~ ~

Returns #t if x is a string and is not empty; returns #f otherwise.

Added in version 6.3 of package base.

                                        *string-contains?*
(string-contains? s contained) -> boolean? ~
  s : string? ~ ~
  contained : string? ~ ~
(string-prefix? s prefix) -> boolean?
  s : string? ~ ~
  prefix : string? ~ ~
(string-suffix? s suffix) -> boolean?
  s : string? ~ ~
  suffix : string? ~ ~

Checks whether s includes at any location, start with, or ends with the
second argument, respectively.

Examples:

  > (string-prefix? "Racket" "R")
  #t
  > (string-prefix? "Jacket" "R")
  #f
  > (string-suffix? "Racket" "et")
  #t
  > (string-contains? "Racket" "ack")
  #t

Added in version 6.3 of package base.

4.6. Converting Values to Strings

 (require racket/format) package: base ~ ~

The bindings documented in this section are provided by the
racket/format and racket libraries, but not racket/base.

The racket/format library provides functions for converting Racket
values to strings. In addition to features like padding and numeric
formatting, the functions have the virtue of being shorter than format
(with format string), number->string, or string-append.

                                        *~a*
(~a  v                                         
     ...                                       
    [#:separator separator                      ~ ~
     #:width width                              ~ ~
     #:max-width max-width                      ~ ~
     #:min-width min-width                      ~ ~
     #:limit-marker limit-marker                ~ ~
     #:limit-prefix? limit-prefix?              ~ ~
     #:align align                              ~ ~
     #:pad-string pad-string                    ~ ~
     #:left-pad-string left-pad-string          ~ ~
     #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = "" ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "" ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~

Converts each v to a string in display mode—that is, like (format "~a"
v)—then concatentates the results with separator between consecutive
items, and then pads or truncates the string to be at least min-width
characters and at most max-width characters.

Examples:

  > (~a "north")
  "north"
  > (~a 'south)
  "south"
  > (~a #"east")
  "east"
  > (~a #\w "e" 'st)
  "west"
  > (~a (list "red" 'green #"blue"))
  "(red green blue)"
  > (~a 17)
  "17"
  > (~a #e1e20)
  "100000000000000000000"
  > (~a pi)
  "3.141592653589793"
  > (~a (expt 6.1 87))
  "2.1071509386211452e+68"

The ~a function is primarily useful for strings, numbers, and other
atomic data. The ~v and ~s functions are better suited to compound data.

Let s be the concatenated string forms of the vs plus separators. If s
is longer than max-width characters, it is truncated to exactly
max-width characters. If s is shorter than min-width characters, it is
padded to exactly min-width characters. Otherwise s is returned
unchanged. If min-width is greater than max-width, an exception is
raised.

If s is longer than max-width characters, it is truncated and the end of
the string is replaced with limit-marker. If limit-marker is longer than
max-width, an exception is raised. If limit-prefix? is #t, the beginning
of the string is truncated instead of the end.

Examples:

  > (~a "abcde" #:max-width 5) ~ ~
  "abcde"
  > (~a "abcde" #:max-width 4) ~ ~
  "abcd"
  > (~a "abcde" #:max-width 4 #:limit-marker "*") ~ ~
  "abc*"
  > (~a "abcde" #:max-width 4 #:limit-marker "...") ~ ~
  "a..."
  > (~a "The quick brown fox" #:max-width 15 #:limit-marker "") ~ ~
  "The quick brown"
  > (~a "The quick brown fox" #:max-width 15 #:limit-marker "...") ~ ~
  "The quick br..."
  > (~a "The quick brown
  fox" #:max-width 15 #:limit-marker "..." #:limit-prefix? #f) ~ ~
  "The quick br..."

If s is shorter than min-width, it is padded to at least min-width
characters. If align is 'left, then only right padding is added; if
align is 'right, then only left padding is added; and if align is
'center, then roughly equal amounts of left padding and right padding
are added.

Padding is specified as a non-empty string. Left padding consists of
left-pad-string repeated in its entirety as many times as possible
followed by a prefix of left-pad-string to fill the remaining space. In
contrast, right padding consists of a suffix of right-pad-string
followed by a number of copies of right-pad-string in its entirety. Thus
left padding starts with the start of left-pad-string and right padding
ends with the end of right-pad-string.

Examples:

  > (~a "apple" #:min-width 20 #:align 'left) ~ ~
  "apple               "
  > (~a "pear" #:min-width 20 #:align 'left #:right-pad-string " .") ~ ~
  "pear . . . . . . . ."
  > (~a "plum" #:min-width 20 #:align 'right #:left-pad-string ". ") ~ ~
  ". . . . . . . . plum"
  > (~a "orange" #:min-width 20 #:align 'center ~ ~
                  #:left-pad-string "- " #:right-pad-string " -") ~ ~
  "- - - -orange- - - -"

Use width to set both max-width and min-width simultaneously, ensuring
that the resulting string is exactly width characters long:

  > (~a "terse" #:width 6) ~ ~
  "terse "
  > (~a "loquacious" #:width 6) ~ ~
  "loquac"

                                        *~v*
(~v  v                                         
     ...                                       
    [#:separator separator                      ~ ~
     #:width width                              ~ ~
     #:max-width max-width                      ~ ~
     #:min-width min-width                      ~ ~
     #:limit-marker limit-marker                ~ ~
     #:limit-prefix? limit-prefix?              ~ ~
     #:align align                              ~ ~
     #:pad-string pad-string                    ~ ~
     #:left-pad-string left-pad-string          ~ ~
     #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = " " ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "..." ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~

Like ~a, but each value is converted like (format "~v" v), the default
separator is " ", and the default limit marker is "...".

Examples:

  > (~v "north")
  "\"north\""
  > (~v 'south)
  "'south"
  > (~v #"east")
  "#\"east\""
  > (~v #\w)
  "#\\w"
  > (~v (list "red" 'green #"blue"))
  "'(\"red\" green #\"blue\")"

Use ~v to produce text that talks about Racket values.

Example:

  > (let ([nums (for/list ([i 10]) i)])
      (~a "The even numbers in " (~v nums)
          " are " (~v (filter even? nums)) "."))
  "The even numbers in '(0 1 2 3 4 5 6 7 8 9) are '(0 2 4 6 8)."

                                        *~s*
(~s  v                                         
     ...                                       
    [#:separator separator                      ~ ~
     #:width width                              ~ ~
     #:max-width max-width                      ~ ~
     #:min-width min-width                      ~ ~
     #:limit-marker limit-marker                ~ ~
     #:limit-prefix? limit-prefix?              ~ ~
     #:align align                              ~ ~
     #:pad-string pad-string                    ~ ~
     #:left-pad-string left-pad-string          ~ ~
     #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = " " ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "..." ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~

Like ~a, but each value is converted like (format "~s" v), the default
separator is " ", and the default limit marker is "...".

Examples:

  > (~s "north")
  "\"north\""
  > (~s 'south)
  "south"
  > (~s #"east")
  "#\"east\""
  > (~s #\w)
  "#\\w"
  > (~s (list "red" 'green #"blue"))
  "(\"red\" green #\"blue\")"

                                        *~e*
(~e  v                                         
     ...                                       
    [#:separator separator                      ~ ~
     #:width width                              ~ ~
     #:max-width max-width                      ~ ~
     #:min-width min-width                      ~ ~
     #:limit-marker limit-marker                ~ ~
     #:limit-prefix? limit-prefix?              ~ ~
     #:align align                              ~ ~
     #:pad-string pad-string                    ~ ~
     #:left-pad-string left-pad-string          ~ ~
     #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = " " ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "..." ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~

Like ~a, but each value is converted like (format "~e" v), the default
separator is " ", and the default limit marker is "...".

Examples:

  > (~e "north")
  "\"north\""
  > (~e 'south)
  "'south"
  > (~e #"east")
  "#\"east\""
  > (~e #\w)
  "#\\w"
  > (~e (list "red" 'green #"blue"))
  "'(\"red\" green #\"blue\")"

                                        *~r*
(~r  x                                     
    [#:sign sign                            ~ ~
     #:base base                            ~ ~
     #:precision precision                  ~ ~
     #:notation notation                    ~ ~
     #:format-exponent format-exponent      ~ ~
     #:min-width min-width                  ~ ~
     #:pad-string pad-string])         -> string? ~ ~
  x : rational? ~ ~
  sign : (or/c #f '+ '++ 'parens ~ ~
               (let ([ind (or/c string? (list/c string? string?))])
                 (list/c ind ind ind)))
       = #f
  base : (or/c (integer-in 2 36) (list/c 'up (integer-in 2 36))) ~ ~
       = 10
  precision : (or/c exact-nonnegative-integer?              = 6 ~ ~
                    (list/c '= exact-nonnegative-integer?))
  notation : (or/c 'positional 'exponential ~ ~
                   (-> rational? (or/c 'positional 'exponential)))
           = 'positional
  format-exponent : (or/c #f string? (-> exact-integer? string?)) ~ ~
                  = #f
  min-width : exact-positive-integer? = 1 ~ ~
  pad-string : non-empty-string? = " " ~ ~

Converts the rational number x to a string in either positional or
exponential notation, depending on notation. The exactness or
inexactness of x does not affect its formatting.

The optional arguments control number formatting:

* notation — determines whether the number is printed in positional or
  exponential notation. If notation is a function, it is applied to x to
  get the notation to be used.

  Examples:

    > (~r 12345)
    "12345"
    > (~r 12345 #:notation 'exponential) ~ ~
    "1.2345e+04"
    > (let ([pick-notation
             (lambda (x)
               (if (or (< (abs x) 0.001) (> (abs x) 1000))
                   'exponential
                   'positional))])
        (for/list ([i (in-range 1 5)])
          (~r (expt 17 i) #:notation pick-notation))) ~ ~
    '("17" "289" "4.913e+03" "8.3521e+04")

* precision — controls the number of digits after the decimal point (or
  more accurately, the radix point). When x is formatted in exponential
  form, precision applies to the significand.

  If precision is a natural number, then up to precision digits are
  displayed, but trailing zeroes are dropped, and if all digits after
  the decimal point are dropped the decimal point is also dropped. If
  precision is (list '= digits), then exactly digits digits after the
  decimal point are used, and the decimal point is never dropped.

  Examples:

    > (~r pi)
    "3.141593"
    > (~r pi #:precision 4) ~ ~
    "3.1416"
    > (~r pi #:precision 0) ~ ~
    "3"
    > (~r 1.5 #:precision 4) ~ ~
    "1.5"
    > (~r 1.5 #:precision '(= 4)) ~ ~
    "1.5000"
    > (~r 50 #:precision 2) ~ ~
    "50"
    > (~r 50 #:precision '(= 2)) ~ ~
    "50.00"
    > (~r 50 #:precision '(= 0)) ~ ~
    "50."

* min-width — if x would normally be printed with fewer than min-width
  digits (including the decimal point but not including the sign
  indicator), the digits are left-padded using pad-string.

  Examples:

    > (~r 17)
    "17"
    > (~r 17 #:min-width 4) ~ ~
    "  17"
    > (~r -42 #:min-width 4) ~ ~
    "-  42"
    > (~r 1.5 #:min-width 4) ~ ~
    " 1.5"
    > (~r 1.5 #:precision 4 #:min-width 10) ~ ~
    "       1.5"
    > (~r 1.5 #:precision '(= 4) #:min-width 10) ~ ~
    "    1.5000"
    > (~r #e1e10 #:min-width 6) ~ ~
    "10000000000"

* pad-string — specifies the string used to pad the number to at least
  min-width characters (not including the sign indicator). The padding
  is placed between the sign and the normal digits of x.

  Examples:

    > (~r 17 #:min-width 4 #:pad-string "0") ~ ~
    "0017"
    > (~r -42 #:min-width 4 #:pad-string "0") ~ ~
    "-0042"

* sign — controls how the sign of the number is indicated:

  * If sign is #f (the default), no sign output is generated if x is
    either positive or zero, and a minus sign is prefixed if x is
    negative.

    Example:

      > (for/list ([x '(17 0 -42)]) (~r x))
      '("17" "0" "-42")

  * If sign is '+, no sign output is generated if x is zero, a plus sign
    is prefixed if x is positive, and a minus sign is prefixed if x is
    negative.

    Example:

      > (for/list ([x '(17 0 -42)]) (~r x #:sign '+)) ~ ~
      '("+17" "0" "-42")

  * If sign is '++, a plus sign is prefixed if x is zero or positive,
    and a minus sign is prefixed if x is negative.

    Example:

      > (for/list ([x '(17 0 -42)]) (~r x #:sign '++)) ~ ~
      '("+17" "+0" "-42")

  * If sign is 'parens, no sign output is generated if x is zero or
    positive, and the number is enclosed in parentheses if x is
    negative.

    Example:

      > (for/list ([x '(17 0 -42)]) (~r x #:sign 'parens)) ~ ~
      '("17" "0" "(42)")

  * If sign is (list pos-ind zero-ind neg-ind), then pos-ind, zero-ind,
    and neg-ind are used to indicate positive, zero, and negative
    numbers, respectively. Each indicator is either a string to be used
    as a prefix or a list containing two strings: a prefix and a suffix.

    Example:

      > (let ([sign-table '(("" " up") "an even " ("" " down"))])
          (for/list ([x '(17 0 -42)]) (~r x #:sign sign-table))) ~ ~
      '("17 up" "an even 0" "42 down")

    The default behavior is equivalent to '("" "" "-"); the 'parens mode
    is equivalent to '("" "" ("(" ")")).

* base — controls the base that x is formatted in. If base is a number
  greater than 10, then lower-case letters are used. If base is (list
  'up base*) and base* is greater than 10, then upper-case letters are
  used.

  Examples:

    > (~r 100 #:base 7) ~ ~
    "202"
    > (~r 4.5 #:base 2) ~ ~
    "100.1"
    > (~r 3735928559 #:base 16) ~ ~
    "deadbeef"
    > (~r 3735928559 #:base '(up 16)) ~ ~
    "DEADBEEF"
    > (~r 3735928559 #:base '(up 16) #:notation 'exponential) ~ ~
    "D.EADBEF*16^+07"

* format-exponent — determines how the exponent is displayed.

  If format-exponent is a string, the exponent is displayed with an
  explicit sign (as with a sign of '++) and at least two digits,
  separated from the significand by the “exponent marker”
  format-exponent:

    > (~r 1234 #:notation 'exponential #:format-exponent "E") ~ ~
    "1.234E+03"

  If format-exponent is #f, the “exponent marker” is "e" if base is 10
  and a string involving base otherwise:

    > (~r 1234 #:notation 'exponential) ~ ~
    "1.234e+03"
    > (~r 1234 #:notation 'exponential #:base 8) ~ ~
    "2.322*8^+03"

  If format-exponent is a procedure, it is applied to the exponent and
  the resulting string is appended to the significand:

    > (~r 1234 #:notation 'exponential ~ ~
               #:format-exponent (lambda (e) (format "E~a" e))) ~ ~
    "1.234E3"

                                        *~.a*
(~.a  v                                         
      ...                                       
     [#:separator separator                      ~ ~
      #:width width                              ~ ~
      #:max-width max-width                      ~ ~
      #:min-width min-width                      ~ ~
      #:limit-marker limit-marker                ~ ~
      #:limit-prefix? limit-prefix?              ~ ~
      #:align align                              ~ ~
      #:pad-string pad-string                    ~ ~
      #:left-pad-string left-pad-string          ~ ~
      #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = "" ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "" ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~
(~.v  v                                         
      ...                                       
     [#:separator separator                      ~ ~
      #:width width                              ~ ~
      #:max-width max-width                      ~ ~
      #:min-width min-width                      ~ ~
      #:limit-marker limit-marker                ~ ~
      #:limit-prefix? limit-prefix?              ~ ~
      #:align align                              ~ ~
      #:pad-string pad-string                    ~ ~
      #:left-pad-string left-pad-string          ~ ~
      #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = " " ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "..." ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~
(~.s  v                                         
      ...                                       
     [#:separator separator                      ~ ~
      #:width width                              ~ ~
      #:max-width max-width                      ~ ~
      #:min-width min-width                      ~ ~
      #:limit-marker limit-marker                ~ ~
      #:limit-prefix? limit-prefix?              ~ ~
      #:align align                              ~ ~
      #:pad-string pad-string                    ~ ~
      #:left-pad-string left-pad-string          ~ ~
      #:right-pad-string right-pad-string]) -> string? ~ ~
  v : any/c ~ ~
  separator : string? = " " ~ ~
  width : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  max-width : (or/c exact-nonnegative-integer? +inf.0) ~ ~
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0) ~ ~
  limit-marker : string? = "..." ~ ~
  limit-prefix? : boolean? = #f ~ ~
  align : (or/c 'left 'center 'right) = 'left ~ ~
  pad-string : non-empty-string? = " " ~ ~
  left-pad-string : non-empty-string? = pad-string ~ ~
  right-pad-string : non-empty-string? = pad-string ~ ~

Like ~a, ~v, and ~s, but each v is formatted like (format "~.a" v),
(format "~.v" v), and (format "~.s" v), respectively.

5. Byte Strings

+[missing] in [missing] introduces byte strings.

A byte string is a fixed-length array of bytes. A  byte is an exact
integer between 0 and  255 inclusive.

A byte string can be mutable or immutable. When an immutable byte string
is provided to a procedure like bytes-set!, the exn:fail:contract
exception is raised. Byte-string constants generated by the default
reader (see [missing]) are immutable, and they are interned in
read-syntax mode. Use immutable? to check whether a byte string is
immutable.

Two byte strings are equal? when they have the same length and contain
the same sequence of bytes.

A byte string can be used as a single-valued sequence (see Sequences).
The bytes of the string serve as elements of the sequence. See also
in-bytes.

See [missing]     for information on reading     byte strings and
[missing]     for information on printing byte strings.

See also: immutable?.

5.1. Byte String Constructors, Selectors, and Mutators

                                        *bytes?*
(bytes? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v  is a byte string, #f otherwise.

Examples:

  > (bytes? #"Apple")
  #t
  > (bytes? "Apple")
  #f

                                        *make-bytes*
(make-bytes k [b]) -> bytes? ~
  k : exact-nonnegative-integer? ~ ~
  b : byte? = 0 ~ ~

Returns a new mutable byte string of length k where each position in the
byte string is initialized with the byte b.

Example:

  > (make-bytes 5 65)
  #"AAAAA"

                                        *bytes*
(bytes b ...) -> bytes? ~
  b : byte? ~ ~

Returns a new mutable byte string whose length is the number of provided
bs, and whose positions are initialized with the given bs.

Example:

  > (bytes 65 112 112 108 101)
  #"Apple"

                                        *bytes->immutable-bytes*
(bytes->immutable-bytes bstr) -> (and/c bytes? immutable?) ~
  bstr : bytes? ~ ~

Returns an immutable byte string with the same content  as bstr,
returning bstr itself if bstr is  immutable.

Examples:

  > (bytes->immutable-bytes (bytes 65 65 65))
  #"AAA"
  > (define b (bytes->immutable-bytes (make-bytes 5 65)))
  > (bytes->immutable-bytes b)
  #"AAAAA"
  > (eq? (bytes->immutable-bytes b) b)
  #t

                                        *byte?*
(byte? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is  a byte (i.e., an exact integer between 0 and 255
inclusive), #f otherwise.

Examples:

  > (byte? 65)
  #t
  > (byte? 0)
  #t
  > (byte? 256)
  #f
  > (byte? -1)
  #f

                                        *bytes-length*
(bytes-length bstr) -> exact-nonnegative-integer? ~
  bstr : bytes? ~ ~

Returns the length of bstr.

Example:

  > (bytes-length #"Apple")
  5

                                        *bytes-ref*
(bytes-ref bstr k) -> byte? ~
  bstr : bytes? ~ ~
  k : exact-nonnegative-integer? ~ ~

Returns the character at position k in bstr.  The first position in the
bytes corresponds to 0, so the  position k must be less than the length
of the bytes,  otherwise the exn:fail:contract exception is raised.

Example:

  > (bytes-ref #"Apple" 0)
  65

                                        *bytes-set!*
(bytes-set! bstr k b) -> void? ~
  bstr : (and/c bytes? (not/c immutable?)) ~ ~
  k : exact-nonnegative-integer? ~ ~
  b : byte? ~ ~

Changes the  character position k in bstr to b.  The first  position in
the byte string corresponds to 0, so the position  k must be less than
the length of the bytes, otherwise the  exn:fail:contract exception is
raised.

Examples:

  > (define s (bytes 65 112 112 108 101))
  > (bytes-set! s 4 121)
  > s
  #"Apply"

                                        *subbytes*
(subbytes bstr start [end]) -> bytes? ~
  bstr : bytes? ~ ~
  start : exact-nonnegative-integer? ~ ~
  end : exact-nonnegative-integer? = (bytes-length str) ~ ~

Returns  a new mutable byte string that is (- end start) bytes long,
and that contains the same bytes as bstr from start  inclusive to end
exclusive.  The start and  end arguments must be less than or equal to
the length of  bstr, and end must be greater than or equal to  start,
otherwise the exn:fail:contract exception is raised.

Examples:

  > (subbytes #"Apple" 1 3)
  #"pp"
  > (subbytes #"Apple" 1)
  #"pple"

                                        *bytes-copy*
(bytes-copy bstr) -> bytes? ~
  bstr : bytes? ~ ~

Returns (subbytes str 0).

                                        *bytes-copy!*
(bytes-copy!  dest            ~
              dest-start     
              src            
             [src-start      
              src-end])  -> void?
  dest : (and/c bytes? (not/c immutable?)) ~ ~
  dest-start : exact-nonnegative-integer? ~ ~
  src : bytes? ~ ~
  src-start : exact-nonnegative-integer? = 0 ~ ~
  src-end : exact-nonnegative-integer? = (bytes-length src) ~ ~

Changes the bytes of dest starting at position  dest-start to match the
bytes in src from  src-start (inclusive) to src-end (exclusive). The
byte strings dest and src can be the same byte  string, and in that case
the destination region can overlap with the  source region; the
destination bytes after the copy match the source  bytes from before the
copy. If any of dest-start,  src-start, or src-end are out of range
(taking into  account the sizes of the byte strings and the source and
destination  regions), the exn:fail:contract exception is raised.

Examples:

  > (define s (bytes 65 112 112 108 101))
  > (bytes-copy! s 4 #"y")
  > (bytes-copy! s 0 s 3 4)
  > s
  #"lpply"

                                        *bytes-fill!*
(bytes-fill! dest b) -> void? ~
  dest : (and/c bytes? (not/c immutable?)) ~ ~
  b : byte? ~ ~

Changes dest so that every position in the  bytes is filled with b.

Examples:

  > (define s (bytes 65 112 112 108 101))
  > (bytes-fill! s 113)
  > s
  #"qqqqq"

                                        *bytes-append*
(bytes-append bstr ...) -> bytes? ~
  bstr : bytes? ~ ~

Returns a new mutable byte string that is as long as the sum of the
given bstrs’ lengths, and that contains the concatenated bytes of the
given bstrs. If no bstrs are provided, the result is a zero-length byte
string.

Example:

  > (bytes-append #"Apple" #"Banana")
  #"AppleBanana"

                                        *bytes->list*
(bytes->list bstr) -> (listof byte?) ~
  bstr : bytes? ~ ~

Returns a new  list of bytes corresponding to the content of bstr. That
is,  the length of the list is (bytes-length bstr), and the  sequence of
bytes in bstr is the same sequence in the  result list.

Example:

  > (bytes->list #"Apple")
  '(65 112 112 108 101)

                                        *list->bytes*
(list->bytes lst) -> bytes? ~
  lst : (listof byte?) ~ ~

Returns a new  mutable byte string whose content is the list of bytes in
lst.  That is, the length of the byte string is (length lst), and  the
sequence of bytes in lst is the same sequence in  the result byte
string.

Example:

  > (list->bytes (list 65 112 112 108 101))
  #"Apple"

                                        *make-shared-bytes*
(make-shared-bytes k [b]) -> bytes? ~
  k : exact-nonnegative-integer? ~ ~
  b : byte? = 0 ~ ~

Returns a new mutable byte string of length k where each position in the
byte string is initialized with the byte b. For communication among
places, the new byte string is allocated in the shared memory space.

Example:

  > (make-shared-bytes 5 65)
  #"AAAAA"

                                        *shared-bytes*
(shared-bytes b ...) -> bytes? ~
  b : byte? ~ ~

Returns a new mutable byte string whose length is the number of provided
bs, and whose positions are initialized with the given bs. For
communication among places, the new byte string is allocated in the
shared memory space.

Example:

  > (shared-bytes 65 112 112 108 101)
  #"Apple"

5.2. Byte String Comparisons

                                        *bytes=?*
(bytes=? bstr1 bstr2 ...) -> boolean? ~
  bstr1 : bytes? ~ ~
  bstr2 : bytes? ~ ~

Returns  #t if all of the arguments are eqv?.

Examples:

  > (bytes=? #"Apple" #"apple")
  #f
  > (bytes=? #"a" #"as" #"a")
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *bytes<?*
(bytes<? bstr1 bstr2 ...) -> boolean? ~
  bstr1 : bytes? ~ ~
  bstr2 : bytes? ~ ~

Returns #t if the arguments are lexicographically sorted  increasing,
where individual bytes are ordered by <,  #f otherwise.

Examples:

  > (bytes<? #"Apple" #"apple")
  #t
  > (bytes<? #"apple" #"Apple")
  #f
  > (bytes<? #"a" #"b" #"c")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *bytes>?*
(bytes>? bstr1 bstr2 ...) -> boolean? ~
  bstr1 : bytes? ~ ~
  bstr2 : bytes? ~ ~

Like bytes<?, but checks whether the arguments are decreasing.

Examples:

  > (bytes>? #"Apple" #"apple")
  #f
  > (bytes>? #"apple" #"Apple")
  #t
  > (bytes>? #"c" #"b" #"a")
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

5.3. Bytes to/from Characters, Decoding and Encoding

                                        *bytes->string/utf-8*
(bytes->string/utf-8 bstr [err-char start end]) -> string? ~
  bstr : bytes? ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Produces a string by decoding the start to end  substring of bstr as a
UTF-8 encoding of Unicode code  points.  If err-char is not #f, then it
is used for  bytes that fall in the range 128 to 255 but are  not part
of a valid encoding sequence. (This rule is consistent with  reading
characters from a port; see [missing] for more  details.)  If err-char
is #f, and if the  start to end substring of bstr is not a  valid UTF-8
encoding overall, then the exn:fail:contract exception is raised.

Example:

  > (bytes->string/utf-8 (bytes 195 167 195 176 195 182 194 163))
  "çðö£"

                                        *bytes->string/locale*
(bytes->string/locale  bstr          ~
                      [err-char     
                       start        
                       end])    -> string?
  bstr : bytes? ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Produces a string by decoding the start to end substring of bstr using
the current locale’s encoding (see also [missing]). If err-char is not
#f, it is used for each byte in bstr that is not part of a valid
encoding; if err-char is #f, and if the start to end substring of bstr
is not a valid encoding overall, then the exn:fail:contract exception is
raised.

                                        *bytes->string/latin-1*
(bytes->string/latin-1  bstr          ~
                       [err-char     
                        start        
                        end])    -> string?
  bstr : bytes? ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Produces a string by decoding the start to end substring  of bstr as a
Latin-1 encoding of Unicode code points; i.e.,  each byte is translated
directly to a character using  integer->char, so the decoding always
succeeds.  The err-char  argument is ignored, but present for
consistency with the other  operations.

Example:

  > (bytes->string/latin-1 (bytes 254 211 209 165))
  "þÓÑ¥"

                                        *string->bytes/utf-8*
(string->bytes/utf-8 str [err-byte start end]) -> bytes? ~
  str : string? ~ ~
  err-byte : (or/c #f byte?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (string-length str) ~ ~

Produces a byte string by encoding the start to end  substring of str
via UTF-8 (always succeeding). The  err-byte argument is ignored, but
included for consistency with  the other operations.

Examples:

  > (define b
      (bytes->string/utf-8
       (bytes 195 167 195 176 195 182 194 163)))
  > (string->bytes/utf-8 b)
  #"\303\247\303\260\303\266\302\243"
  > (bytes->string/utf-8 (string->bytes/utf-8 b))
  "çðö£"

                                        *string->bytes/locale*
(string->bytes/locale str [err-byte start end]) -> bytes? ~
  str : string? ~ ~
  err-byte : (or/c #f byte?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (string-length str) ~ ~

Produces a string by encoding the start to end substring of str using
the current locale’s encoding (see also [missing]). If err-byte is not
#f, it is used for each character in str that cannot be encoded for the
current locale; if err-byte is #f, and if the start to end substring of
str cannot be encoded, then the exn:fail:contract exception is raised.

                                        *string->bytes/latin-1*
(string->bytes/latin-1  str           ~
                       [err-byte     
                        start        
                        end])    -> bytes?
  str : string? ~ ~
  err-byte : (or/c #f byte?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (string-length str) ~ ~

Produces a string by encoding the start to end substring  of str using
Latin-1; i.e., each character is translated  directly to a byte using
char->integer. If err-byte is  not #f, it is used for each character in
str whose  value is greater than 255.  If err-byte is #f, and if the
start to end substring of str has a character  with a value greater than
255, then the  exn:fail:contract exception is raised.

Examples:

  > (define b
      (bytes->string/latin-1 (bytes 254 211 209 165)))
  > (string->bytes/latin-1 b)
  #"\376\323\321\245"
  > (bytes->string/latin-1 (string->bytes/latin-1 b))
  "þÓÑ¥"

                                        *string-utf-8-length*
(string-utf-8-length str [start end]) -> exact-nonnegative-integer? ~
  str : string? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (string-length str) ~ ~

Returns the length in bytes of the UTF-8 encoding of str’s  substring
from start to end, but without actually  generating the encoded bytes.

Examples:

  > (string-utf-8-length
      (bytes->string/utf-8 (bytes 195 167 195 176 195 182 194 163)))
  8
  > (string-utf-8-length "hello")
  5

                                        *bytes-utf-8-length*
(bytes-utf-8-length bstr [err-char start end]) ~
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes? ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns the length in characters of the UTF-8 decoding of  bstr’s
substring from start to end, but without  actually generating the
decoded characters. If err-char is  #f and the substring is not a UTF-8
encoding overall, the  result is #f. Otherwise, err-char is used to
resolve  decoding errors as in bytes->string/utf-8.

Examples:

  > (bytes-utf-8-length (bytes 195 167 195 176 195 182 194 163))
  4
  > (bytes-utf-8-length (make-bytes 5 65))
  5

                                        *bytes-utf-8-ref*
(bytes-utf-8-ref bstr [skip err-char start end]) -> (or/c char? #f) ~
  bstr : bytes? ~ ~
  skip : exact-nonnegative-integer? = 0 ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns the skipth character in the UTF-8 decoding of  bstr’s substring
from start to end, but without  actually generating the other decoded
characters. If the substring is  not a UTF-8 encoding up to the skipth
character (when  err-char is #f), or if the substring decoding produces
fewer than skip characters, the result is #f. If  err-char is not #f, it
is used to resolve decoding  errors as in bytes->string/utf-8.

Examples:

  > (bytes-utf-8-ref (bytes 195 167 195 176 195 182 194 163) 0)
  #\ç
  > (bytes-utf-8-ref (bytes 195 167 195 176 195 182 194 163) 1)
  #\ð
  > (bytes-utf-8-ref (bytes 195 167 195 176 195 182 194 163) 2)
  #\ö
  > (bytes-utf-8-ref (bytes 65 66 67 68) 0)
  #\A
  > (bytes-utf-8-ref (bytes 65 66 67 68) 1)
  #\B
  > (bytes-utf-8-ref (bytes 65 66 67 68) 2)
  #\C

                                        *bytes-utf-8-index*
(bytes-utf-8-index  bstr      ~
                    skip     
                   [err-char 
                    start    
                    end])    
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes? ~ ~
  skip : exact-nonnegative-integer? ~ ~
  err-char : (or/c #f char?) = #f ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~ ~

Returns the offset in bytes into bstr at which the skipth  character’s
encoding starts in the UTF-8 decoding of bstr’s  substring from start to
end (but without actually  generating the other decoded characters). The
result is relative to  the start of bstr, not to start. If the substring
is not  a UTF-8 encoding up to the skipth character (when  err-char is
#f), or if the substring decoding produces  fewer than skip characters,
the result is #f. If  err-char is not #f, it is used to resolve decoding
errors as in bytes->string/utf-8.

Examples:

  > (bytes-utf-8-index (bytes 195 167 195 176 195 182 194 163) 0)
  0
  > (bytes-utf-8-index (bytes 195 167 195 176 195 182 194 163) 1)
  2
  > (bytes-utf-8-index (bytes 195 167 195 176 195 182 194 163) 2)
  4
  > (bytes-utf-8-index (bytes 65 66 67 68) 0)
  0
  > (bytes-utf-8-index (bytes 65 66 67 68) 1)
  1
  > (bytes-utf-8-index (bytes 65 66 67 68) 2)
  2

5.4. Bytes to Bytes Encoding Conversion

                                        *bytes-open-converter*
(bytes-open-converter from-name to-name) ~
 -> (or/c bytes-converter? #f)
  from-name : string? ~ ~
  to-name : string? ~ ~

Produces a byte converter to go from the encoding named by from-name to
the encoding named by to-name. If the requested conversion pair is not
available, #f is returned instead of a converter.

Certain encoding combinations are always available:

* (bytes-open-converter "UTF-8" "UTF-8") — the identity conversion,
  except that encoding errors in the input lead to a decoding failure.

* (bytes-open-converter "UTF-8-permissive" "UTF-8") — the identity
  conversion, except that any input byte that is not part of a valid
  encoding sequence is effectively replaced by the UTF-8 encoding
  sequence for #\uFFFD.  (This handling of invalid sequences is
  consistent with the interpretation of port bytes streams into
  characters; see [missing].)

* (bytes-open-converter "" "UTF-8") — converts from the current locale’s
  default encoding (see [missing]) to UTF-8.

* (bytes-open-converter "UTF-8" "") — converts from UTF-8 to the current
  locale’s default encoding (see [missing]).

* (bytes-open-converter "platform-UTF-8" "platform-UTF-16") — converts
  UTF-8 to UTF-16 on Unix and Mac OS, where each UTF-16 code unit is a
  sequence of two bytes ordered by the current platform’s endianness. On
  Windows, the input can include encodings that are not valid UTF-8, but
  which naturally extend the UTF-8 encoding to support unpaired
  surrogate code units, and the output is a sequence of UTF-16 code
  units (as little-endian byte pairs), potentially including unpaired
  surrogates.

* (bytes-open-converter "platform-UTF-8-permissive" "platform-UTF-16") —
  like (bytes-open-converter "platform-UTF-8" "platform-UTF-16"), but an
  input byte that is not part of a valid UTF-8 encoding sequence (or
  valid for the unpaired-surrogate extension on Windows) is effectively
  replaced with (char->integer #\?).

* (bytes-open-converter "platform-UTF-16" "platform-UTF-8") — converts
  UTF-16 (bytes ordered by the current platform’s endianness) to UTF-8
  on Unix and Mac OS. On Windows, the input can include UTF-16 code
  units that are unpaired surrogates, and the corresponding output
  includes an encoding of each surrogate in a natural extension of
  UTF-8. On Unix and Mac OS, surrogates are assumed to be paired: a pair
  of bytes with the bits #xD800 starts a surrogate pair, and the #x03FF
  bits are used from the pair and following pair (independent of the
  value of the #xDC00 bits). On all platforms, performance may be poor
  when decoding from an odd offset within an input byte string.

A newly opened byte converter is registered with the current custodian
(see [missing]), so that the converter is closed when the custodian is
shut down. A converter is not registered with a custodian (and does not
need to be closed) if it is one of the guaranteed combinations not
involving "" on Unix, or if it is any of the guaranteed combinations
(including "") on Windows and Mac OS.

In the Racket software distributions for Windows, a suitable "iconv.dll"
is included with "libmzschVERS.dll".

The set of available encodings and combinations varies by platform,
depending on the iconv library that is installed; the from-name and
to-name arguments are passed on to iconv_open. On Windows, "iconv.dll"
or "libiconv.dll" must be in the same directory as "libmzschVERS.dll"
(where VERS is a version number), in the user’s path, in the system
directory, or in the current executable’s directory at run time, and the
DLL must either supply _errno or link to "msvcrt.dll" for _errno;
otherwise, only the guaranteed combinations are available.

Use bytes-convert with the result to convert byte strings.

                                        *bytes-close-converter*
(bytes-close-converter converter) -> void ~
  converter : bytes-converter? ~ ~

Closes the given converter, so that it can no longer be used with
bytes-convert or bytes-convert-end.

                                        *bytes-convert*
(bytes-convert  converter       ~
                src-bstr       
               [src-start-pos  
                src-end-pos    
                dest-bstr      
                dest-start-pos 
                dest-end-pos]) 
 -> (or/c bytes? exact-nonnegative-integer?)
    exact-nonnegative-integer?
    (or/c 'complete 'continues 'aborts 'error)
  converter : bytes-converter? ~ ~
  src-bstr : bytes? ~ ~
  src-start-pos : exact-nonnegative-integer? = 0 ~ ~
  src-end-pos : exact-nonnegative-integer? ~ ~
              = (bytes-length src-bstr)
  dest-bstr : (or/c bytes? #f) = #f ~ ~
  dest-start-pos : exact-nonnegative-integer? = 0 ~ ~
  dest-end-pos : (or/c exact-nonnegative-integer? #f) ~ ~
               = (and dest-bstr
                      (bytes-length dest-bstr))

Converts the bytes from src-start-pos to src-end-pos in src-bstr.

If dest-bstr is not #f, the converted bytes are written into dest-bstr
from dest-start-pos to dest-end-pos. If dest-bstr is #f, then a newly
allocated byte string holds the conversion results, and if dest-end-pos
is not #f, the size of the result byte string is no more than (-
dest-end-pos dest-start-pos).

The result of bytes-convert is three values:

* result-bstr or dest-wrote-amt — a byte string if dest-bstr is #f or
  not provided, or the number of bytes written into dest-bstr otherwise.

* src-read-amt — the number of bytes successfully converted from
  src-bstr.

* 'complete, 'continues, 'aborts, or 'error — indicates how conversion
  terminated:

  * 'complete: The entire input was processed, and src-read-amt will be
    equal to (- src-end-pos src-start-pos).

  * 'continues: Conversion stopped due to the limit on the result size
    or the space in dest-bstr; in this case, fewer than (- dest-end-pos
    dest-start-pos) bytes may be returned if more space is needed to
    process the next complete encoding sequence in src-bstr.

  * 'aborts: The input stopped part-way through an encoding sequence,
    and more input bytes are necessary to continue. For example, if the
    last byte of input is 195 for a "UTF-8-permissive" decoding, the
    result is 'aborts, because another byte is needed to determine how
    to use the 195 byte.

  * 'error: The bytes starting at (+ src-start-pos src-read-amt) bytes
    in src-bstr do not form a legal encoding sequence. This result is
    never produced for some encodings, where all byte sequences are
    valid encodings. For example, since "UTF-8-permissive" handles an
    invalid UTF-8 sequence by dropping characters or generating “?,”
    every byte sequence is effectively valid.

Applying a converter accumulates state in the converter (even when the
third result of bytes-convert is 'complete). This state can affect both
further processing of input and further generation of output, but only
for conversions that involve “shift sequences” to change modes within a
stream. To terminate an input sequence and reset the converter, use
bytes-convert-end.

Examples:

  > (define convert (bytes-open-converter "UTF-8" "UTF-16"))
  > (bytes-convert convert (bytes 65 66 67 68))
  #"\377\376A\0B\0C\0D\0"
  4
  'complete
  > (bytes 195 167 195 176 195 182 194 163)
  #"\303\247\303\260\303\266\302\243"
  > (bytes-convert convert (bytes 195 167 195 176 195 182 194 163))
  #"\347\0\360\0\366\0\243\0"
  8
  'complete
  > (bytes-close-converter convert)

                                        *bytes-convert-end*
(bytes-convert-end  converter       ~
                   [dest-bstr      
                    dest-start-pos 
                    dest-end-pos]) 
 -> (or/c bytes? exact-nonnegative-integer?)
    (or/c 'complete 'continues)
  converter : bytes-converter? ~ ~
  dest-bstr : (or/c bytes? #f) = #f ~ ~
  dest-start-pos : exact-nonnegative-integer? = 0 ~ ~
  dest-end-pos : (or/c exact-nonnegative-integer? #f) ~ ~
               = (and dest-bstr
                      (bytes-length dest-bstr))

Like bytes-convert, but instead of converting bytes, this procedure
generates an ending sequence for the conversion (sometimes called a
“shift sequence”), if any. Few encodings use shift sequences, so this
function will succeed with no output for most encodings. In any case,
successful output of a (possibly empty) shift sequence resets the
converter to its initial state.

The result of bytes-convert-end is two values:

* result-bstr or dest-wrote-amt — a byte string if dest-bstr is #f or
  not provided, or the number of bytes written into dest-bstr otherwise.

* 'complete or 'continues — indicates whether conversion completed. If
  'complete, then an entire ending sequence was produced. If 'continues,
  then the conversion could not complete due to the limit on the result
  size or the space in dest-bstr, and the first result is either an
  empty byte string or 0.

                                        *bytes-converter?*
(bytes-converter? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a byte converter produced by bytes-open-converter, #f
otherwise.

Examples:

  > (bytes-converter? (bytes-open-converter "UTF-8" "UTF-16"))
  #t
  > (bytes-converter? (bytes-open-converter "whacky" "not likely"))
  #f
  > (define b (bytes-open-converter "UTF-8" "UTF-16"))
  > (bytes-close-converter b)
  > (bytes-converter? b)
  #t

                                        *locale-string-encoding*
(locale-string-encoding) -> any ~

Returns a string for the current locale’s encoding (i.e., the encoding
normally identified by ""). See also system-language+country.

5.5. Additional Byte String Functions

 (require racket/bytes) package: base ~ ~

The bindings documented in this section are provided by the racket/bytes
and racket libraries, but not racket/base.

                                        *bytes-append**
(bytes-append* str ... strs) -> bytes? ~
  str : bytes? ~ ~
  strs : (listof bytes?) ~ ~

Like bytes-append, but the last argument is used as a list of arguments
for bytes-append, so (bytes-append* str ... strs) is the same as (apply
bytes-append str ... strs).  In other words, the relationship between
bytes-append and bytes-append* is similar to the one between list and
list*.

Examples:

  > (bytes-append* #"a" #"b" '(#"c" #"d"))
  #"abcd"
  > (bytes-append* (cdr (append* (map (lambda (x) (list #", " x))
                                       '(#"Alpha" #"Beta" #"Gamma")))))
  #"Alpha, Beta, Gamma"

                                        *bytes-join*
(bytes-join strs sep) -> bytes? ~
  strs : (listof bytes?) ~ ~
  sep : bytes? ~ ~

Appends the byte strings in strs, inserting sep between each pair of
bytes in strs.

Example:

  > (bytes-join '(#"one" #"two" #"three" #"four") #" potato ")
  #"one potato two potato three potato four"

6. Characters

+[missing] in [missing] introduces characters.

Characters range over Unicode scalar values, which includes characters
whose values range from #x0 to #x10FFFF, but not including #xD800 to
#xDFFF. The scalar values are a subset of the Unicode code points.

Two characters are eqv? if they correspond to the same scalar value. For
each scalar value less than 256, character values that are eqv? are also
eq?. Characters produced by the default reader are interned in
read-syntax mode.

See [missing]     for information on reading     characters and
[missing]     for information on printing characters.

Changed in version 6.1.1.8: Updated from Unicode 5.0.1 to Unicode 7.0.0.

6.1. Characters and Scalar Values

                                        *char?*
(char? v) -> boolean? ~
  v : any/c ~ ~

Return #t if v is a character, #f otherwise.

                                        *char->integer*
(char->integer char) -> exact-integer? ~
  char : char? ~ ~

Returns a character’s code-point number.

Example:

  > (char->integer #\A)
  65

                                        *integer->char*
(integer->char k) -> char? ~
  k : (and/c exact-integer? ~ ~
             (or/c (integer-in 0 55295)
                   (integer-in 57344 1114111)))

Return the character whose code-point number is k. For k less than 256,
the result is the same object for the same k.

Example:

  > (integer->char 65)
  #\A

                                        *char-utf-8-length*
(char-utf-8-length char) -> (integer-in 1 6) ~
  char : char? ~ ~

Produces the same result as (bytes-length (string->bytes/utf-8 (string
char))).

6.2. Character Comparisons

                                        *char=?*
(char=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Returns #t if all of the arguments are eqv?.

Examples:

  > (char=? #\a #\a)
  #t
  > (char=? #\a #\A #\a)
  #f

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char<?*
(char<? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Returns #t if the arguments are sorted increasing, where two characters
are ordered by their scalar values, #f otherwise.

Examples:

  > (char<? #\A #\a)
  #t
  > (char<? #\a #\A)
  #f
  > (char<? #\a #\b #\c)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char<=?*
(char<=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char<?, but checks whether the arguments are nondecreasing.

Examples:

  > (char<=? #\A #\a)
  #t
  > (char<=? #\a #\A)
  #f
  > (char<=? #\a #\b #\b)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char>?*
(char>? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char<?, but checks whether the arguments are decreasing.

Examples:

  > (char>? #\A #\a)
  #f
  > (char>? #\a #\A)
  #t
  > (char>? #\c #\b #\a)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char>=?*
(char>=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char<?, but checks whether the arguments are nonincreasing.

Examples:

  > (char>=? #\A #\a)
  #f
  > (char>=? #\a #\A)
  #t
  > (char>=? #\c #\b #\b)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char-ci=?*
(char-ci=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Returns #t if all of the arguments are eqv? after  locale-insensitive
case-folding via char-foldcase.

Examples:

  > (char-ci=? #\A #\a)
  #t
  > (char-ci=? #\a #\a #\a)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char-ci<?*
(char-ci<? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char<?, but checks whether the arguments would be in  increasing
order if each was first case-folded using  char-foldcase (which is
locale-insensitive).

Examples:

  > (char-ci<? #\A #\a)
  #f
  > (char-ci<? #\a #\b)
  #t
  > (char-ci<? #\a #\b #\c)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char-ci<=?*
(char-ci<=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char-ci<?, but checks whether the arguments would be nondecreasing
after case-folding.

Examples:

  > (char-ci<=? #\A #\a)
  #t
  > (char-ci<=? #\a #\A)
  #t
  > (char-ci<=? #\a #\b #\b)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char-ci>?*
(char-ci>? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char-ci<?, but checks whether the arguments would be decreasing
after case-folding.

Examples:

  > (char-ci>? #\A #\a)
  #f
  > (char-ci>? #\b #\A)
  #t
  > (char-ci>? #\c #\b #\a)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

                                        *char-ci>=?*
(char-ci>=? char1 char2 ...) -> boolean? ~
  char1 : char? ~ ~
  char2 : char? ~ ~

Like char-ci<?, but checks whether the arguments would be nonincreasing
after case-folding.

Examples:

  > (char-ci>=? #\A #\a)
  #t
  > (char-ci>=? #\a #\A)
  #t
  > (char-ci>=? #\c #\b #\b)
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

6.3. Classifications

                                        *char-alphabetic?*
(char-alphabetic? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char has the Unicode “Alphabetic” property.

                                        *char-lower-case?*
(char-lower-case? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char has the Unicode “Lowercase” property.

                                        *char-upper-case?*
(char-upper-case? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char has the Unicode “Uppercase” property.

                                        *char-title-case?*
(char-title-case? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char’s Unicode general category is Lt, #f otherwise.

                                        *char-numeric?*
(char-numeric? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char has the Unicode “Numeric” property.

                                        *char-symbolic?*
(char-symbolic? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char’s Unicode general category is Sm, Sc, Sk, or So, #f
otherwise.

                                        *char-punctuation?*
(char-punctuation? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char’s Unicode general category is Pc, Pd, Ps, Pe, Pi, Pf,
or Po, #f otherwise.

                                        *char-graphic?*
(char-graphic? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char’s Unicode general category is Ll, Lm, Lo, Lt, Lu, Nd,
Nl, No, Mn, Mc, or Me, or if one of the following produces #t when
applied to char: char-alphabetic?, char-numeric?, char-symbolic?, or
char-punctuation?.

                                        *char-whitespace?*
(char-whitespace? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char has the Unicode “White_Space” property.

                                        *char-blank?*
(char-blank? char) -> boolean? ~
  char : char? ~ ~

Returns #t if char’s Unicode general category is Zs or if char is #\tab.
(These correspond to horizontal whitespace.)

                                        *char-iso-control?*
(char-iso-control? char) -> boolean? ~
  char : char? ~ ~

Return #t if char is between #\nul and #\u001F inclusive or #\rubout and
#\u009F inclusive.

                                        *char-general-category*
(char-general-category char) -> symbol? ~
  char : char? ~ ~

Returns a symbol representing the character’s Unicode general category,
which is 'lu, 'll, 'lt, 'lm, 'lo, 'mn, 'mc, 'me, 'nd, 'nl, 'no, 'ps,
'pe, 'pi, 'pf, 'pd, 'pc, 'po, 'sc, 'sm, 'sk, 'so, 'zs, 'zp, 'zl, 'cc,
'cf, 'cs, 'co, or 'cn.

                                        *make-known-char-range-list*
(make-known-char-range-list) ~
 -> (listof (list/c exact-nonnegative-integer?
                    exact-nonnegative-integer?
                    boolean?))

Produces a list of three-element lists, where each three-element list
represents a set of consecutive code points for which the Unicode
standard specifies character properties. Each three-element list
contains two integers and a boolean; the first integer is a starting
code-point value (inclusive), the second integer is an ending code-point
value (inclusive), and the boolean is #t when all characters in the
code-point range have identical results for all of the character
predicates above, have analogous transformations (shifting by the same
amount, if any, in code-point space) for char-downcase, char-upcase, and
char-titlecase, and have the same decomposition–normalization behavior.
The three-element lists are ordered in the overall result list such that
later lists represent larger code-point values, and all three-element
lists are separated from every other by at least one code-point value
that is not specified by Unicode.

6.4. Character Conversions

                                        *char-upcase*
(char-upcase char) -> char? ~
  char : char? ~ ~

Produces a character consistent with the 1-to-1 code point mapping
defined by Unicode. If char has no upcase mapping, char-upcase produces
char.

String procedures, such as string-upcase, handle the case where Unicode
defines a locale-independent mapping from the code point to a code-point
sequence (in addition to the 1-1 mapping on scalar values).

Examples:

  > (char-upcase #\a)
  #\A
  > (char-upcase #\λ)
  #\Λ
  > (char-upcase #\space)
  #\space

                                        *char-downcase*
(char-downcase char) -> char? ~
  char : char? ~ ~

Like char-upcase, but for the Unicode downcase mapping.

Examples:

  > (char-downcase #\A)
  #\a
  > (char-downcase #\Λ)
  #\λ
  > (char-downcase #\space)
  #\space

                                        *char-titlecase*
(char-titlecase char) -> char? ~
  char : char? ~ ~

Like char-upcase, but for the Unicode titlecase mapping.

Examples:

  > (char-upcase #\a)
  #\A
  > (char-upcase #\λ)
  #\Λ
  > (char-upcase #\space)
  #\space

                                        *char-foldcase*
(char-foldcase char) -> char? ~
  char : char? ~ ~

Like char-upcase, but for the Unicode case-folding mapping.

Examples:

  > (char-foldcase #\A)
  #\a
  > (char-foldcase #\Σ)
  #\σ
  > (char-foldcase #\ς)
  #\σ
  > (char-foldcase #\space)
  #\space

7. Symbols

+[missing] in [missing] introduces symbols.

A symbol is like an immutable string, but symbols are normally interned,
so that two symbols with the same character content are normally eq?.
All symbols produced by the default reader (see [missing]) are interned.

The two procedures string->uninterned-symbol and gensym generate
uninterned symbols, i.e., symbols that are not eq?, eqv?, or equal? to
any other symbol, although they may print the same as other symbols.

The procedure string->unreadable-symbol returns an unreadable symbol
that is partially interned.  The default reader (see [missing]) never
produces a unreadable symbol, but two calls to string->unreadable-symbol
with equal? strings produce eq? results. An unreadable symbol can print
the same as an interned or uninterned symbol. Unreadable symbols are
useful in expansion and compilation to avoid collisions with symbols
that appear in the source; they are usually not generated directly, but
they can appear in the result of functions like identifier-binding.

Interned and unreadable symbols are only weakly held by the internal
symbol table. This weakness can never affect the result of an eq?, eqv?,
or equal? test, but a symbol may disappear when placed into a weak box
(see [missing]) used as the key in a weak hash table (see Hash Tables),
or used as an ephemeron key (see [missing]).

See [missing]     for information on reading     symbols and [missing]
for information on printing symbols.

                                        *symbol?*
(symbol? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is  a symbol, #f otherwise.

Examples:

  > (symbol? 'Apple)
  #t
  > (symbol? 10)
  #f

                                        *symbol-interned?*
(symbol-interned? sym) -> boolean? ~
  sym : symbol? ~ ~

Returns #t if sym is  interned, #f otherwise.

Examples:

  > (symbol-interned? 'Apple)
  #t
  > (symbol-interned? (gensym))
  #f
  > (symbol-interned? (string->unreadable-symbol "Apple"))
  #f

                                        *symbol-unreadable?*
(symbol-unreadable? sym) -> boolean? ~
  sym : symbol? ~ ~

Returns #t if sym is  an unreadable symbol, #f otherwise.

Examples:

  > (symbol-unreadable? 'Apple)
  #f
  > (symbol-unreadable? (gensym))
  #f
  > (symbol-unreadable? (string->unreadable-symbol "Apple"))
  #t

                                        *symbol->string*
(symbol->string sym) -> string? ~
  sym : symbol? ~ ~

Returns a freshly  allocated mutable string whose characters are the
same as in  sym.

See also symbol->immutable-string from racket/symbol.

Example:

  > (symbol->string 'Apple)
  "Apple"

                                        *string->symbol*
(string->symbol str) -> symbol? ~
  str : string? ~ ~

Returns an  interned symbol whose characters are the same as in  str.

Examples:

  > (string->symbol "Apple")
  'Apple
  > (string->symbol "1")
  '|1|

                                        *string->uninterned-symbol*
(string->uninterned-symbol str) -> symbol? ~
  str : string? ~ ~

Like  (string->symbol str), but the resulting symbol is a new
uninterned symbol. Calling string->uninterned-symbol  twice with the
same str returns two distinct symbols.

Examples:

  > (string->uninterned-symbol "Apple")
  'Apple
  > (eq? 'a (string->uninterned-symbol "a"))
  #f
  > (eq? (string->uninterned-symbol "a")
         (string->uninterned-symbol "a"))
  #f

                                        *string->unreadable-symbol*
(string->unreadable-symbol str) -> symbol? ~
  str : string? ~ ~

Like  (string->symbol str), but the resulting symbol is a new
unreadable symbol. Calling string->unreadable-symbol  twice with
equivalent strs returns the same symbol, but  read never produces the
symbol.

Examples:

  > (string->unreadable-symbol "Apple")
  'Apple
  > (eq? 'a (string->unreadable-symbol "a"))
  #f
  > (eq? (string->unreadable-symbol "a")
         (string->unreadable-symbol "a"))
  #t

                                        *gensym*
(gensym [base]) -> symbol? ~
  base : (or/c string? symbol?) = "g" ~ ~

Returns a new uninterned symbol with an automatically-generated name.
The optional base argument is a prefix symbol or string.

Example:

  > (gensym "apple")
  'apple422

                                        *symbol<?*
(symbol<? a-sym b-sym ...) -> boolean? ~
  a-sym : symbol? ~ ~
  b-sym : symbol? ~ ~

Returns #t if the arguments are sorted, where the comparison for each
pair of symbols is the same as using symbol->string with
string->bytes/utf-8 and bytes<?.

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

7.1. Additional Symbol Functions

 (require racket/symbol) package: base ~ ~

The bindings documented in this section are provided by the
racket/symbol and racket libraries, but not racket/base.

Added in version 7.6 of package base.

                                        *symbol->immutable-string*
(symbol->immutable-string sym) -> (and/c string? immutable?) ~
  sym : symbol? ~ ~

Like symbol->string, but the result is an immutable string, not
necessarily freshly allocated.

Examples:

  > (symbol->immutable-string 'Apple)
  "Apple"
  > (immutable? (symbol->immutable-string 'Apple))
  #t

Added in version 7.6 of package base.

8. Regular Expressions

+[missing] in [missing] introduces regular expressions.

Regular expressions are specified as strings or byte strings, using the
same pattern language as either the Unix utility egrep or Perl. A
string-specified pattern produces a character regexp matcher, and a
byte-string pattern produces a byte regexp matcher. If a character
regexp is used with a byte string or input port, it matches UTF-8
encodings (see [missing]) of matching character streams; if a byte
regexp is used with a character string, it matches bytes in the UTF-8
encoding of the string.

A regular expression that is represented as a string or byte string can
be compiled to a regexp value, which can be used more efficiently by
functions such as regexp-match compared to the string or byte string
form. The regexp and byte-regexp procedures convert a string or byte
string (respectively) into a regexp value using a syntax of regular
expressions that is most compatible to egrep. The pregexp and
byte-pregexp procedures produce a regexp value using a slightly
different syntax of regular expressions that is more compatible with
Perl.

Two regexp values are equal? if they have the same source, use the same
pattern language, and are both character regexps or both byte regexps.

A literal or printed regexp value starts with #rx or #px. See [missing]
for information on reading     regular expressions and [missing]     for
information on printing regular expressions. Regexp values produced by
the default reader are interned in read-syntax mode.

The internal size of a regexp value is limited to 32 kilobytes; this
limit roughly corresponds to a source string with 32,000 literal
characters or 5,000 operators.

8.1. Regexp Syntax

The following syntax specifications describe the content of a string
that represents a regular expression. The syntax of the corresponding
string may involve extra escape characters. For example, the regular
expression (.*)\1 can be represented with the string "(.*)\\1" or the
regexp constant #rx"(.*)\\1"; the \ in the regular expression must be
escaped to include it in a string or regexp constant.

The regexp and pregexp syntaxes share a common core:

 >regexp< ::= >pces<                 Match >pces< ~ ~
           |  >regexp<|>regexp<      Match either >regexp<, try left first        ex1
 >pces<   ::=                        Match empty ~ ~
           |  >pce<>pces<            Match >pce< followed by >pces<
 >pce<    ::= >repeat<               Match >repeat<, longest possible             ex3 ~ ~
           |  >repeat<?              Match >repeat<, shortest possible            ex6
           |  >atom<                 Match >atom< exactly once
 >repeat< ::= >atom<*                Match >atom< 0 or more times                 ex3 ~ ~
           |  >atom<+                Match >atom< 1 or more times                 ex4
           |  >atom<?                Match >atom< 0 or 1 times                    ex5
 >atom<   ::= (>regexp<)             Match sub-expression >regexp< and report     ex11 ~ ~
           |  [>rng<]                Match any character in >rng<                 ex2
           |  [^>rng<]               Match any character not in >rng<             ex12
           |  .                      Match any (except newline in multi mode)     ex13
           |  ^                      Match start (or after newline in multi mode) ex14
           |  $                      Match end (or before newline in multi mode)  ex15
           |  >literal<              Match a single literal character             ex1
           |  (?>mode<:>regexp<)     Match >regexp< using >mode<                  ex35 ~ ~
           |  (?>>regexp<)           Match >regexp<, only first possible
           |  >look<                 Match empty if >look< matches
           |  (?>tst<>pces<|>pces<)  Match 1st >pces< if >tst<, else 2nd >pces<   ex36
           |  (?>tst<>pces<)         Match >pces< if >tst<, empty if not >tst<
           |  \ at end of pattern    Match the nul character (ASCII 0)
 >rng<    ::= ]                      >rng< contains ] only                        ex27 ~ ~
           |  -                      >rng< contains - only                        ex28
           |  >mrng<                 >rng< contains everything in >mrng<
           |  >mrng<-                >rng< contains - and everything in >mrng<
 >mrng<   ::= ]>lrng<                >mrng< contains ] and everything in >lrng<   ex29 ~ ~
           |  ->lrng<                >mrng< contains - and everything in >lrng<   ex29
           |  >lirng<                >mrng< contains everything in >lirng<
 >lirng<  ::= >riliteral<            >lirng< contains a literal character ~ ~
           |  >riliteral<->rliteral< >lirng< contains Unicode range inclusive     ex22
           |  >lirng<>lrng<          >lirng< contains everything in both
 >lrng<   ::= ^                      >lrng< contains ^                            ex30 ~ ~
           |  >rliteral<->rliteral<  >lrng< contains Unicode range inclusive
           |  ^>lrng<                >lrng< contains ^ and more
           |  >lirng<                >lrng< contains everything in >lirng<
 >look<   ::= (?=>regexp<)           Match if >regexp< matches                    ex31 ~ ~
           |  (?!>regexp<)           Match if >regexp< doesn't match              ex32
           |  (?<=>regexp<)          Match if >regexp< matches preceding          ex33
           |  (?<!>regexp<)          Match if >regexp< doesn't match preceding    ex34
 >tst<    ::= (>n<)                  True if >n<th ( has a match ~ ~
           |  >look<                 True if >look< matches                       ex36
 >mode<   ::=                        Like the enclosing mode ~ ~
           |  >mode<i                Like >mode<, but case-insensitive            ex35
           |  >mode<-i               Like >mode<, but sensitive
           |  >mode<s                Like >mode<, but not in multi mode
           |  >mode<-s               Like >mode<, but in multi mode
           |  >mode<m                Like >mode<, but in multi mode
           |  >mode<-m               Like >mode<, but not in multi mode

The following completes the grammar for regexp, which treats { and } as
literals, \ as a literal within ranges, and \ as a literal producer
outside of ranges.

 >literal<   ::= Any character except (, ), *, +, ?, [, ., ^, \, or | ~ ~
              |  \>aliteral<                                          Match >aliteral< ex21
 >aliteral<  ::= Any character ~ ~
 >riliteral< ::= Any character except ], -, or ^ ~ ~
 >rliteral<  ::= Any character except ] or - ~ ~

The following completes the grammar for pregexp, which uses { and }
bounded repetition and uses \ for meta-characters both inside and
outside of ranges.

 >repeat<    ::= ...                                                           ... ~ ~
              |  >atom<{>n<}                                                   Match >atom< exactly >n< times                 ex7
              |  >atom<{>n<,}                                                  Match >atom< >n< or more times                 ex8
              |  >atom<{,>m<}                                                  Match >atom< between 0 and >m< times           ex9
              |  >atom<{>n<,>m<}                                               Match >atom< between >n< and >m< times         ex10
              |  >atom<{}                                                      Match >atom< 0 or more times
 >atom<      ::= ...                                                           ... ~ ~
              |  \>n<                                                          Match latest reported match for >n<th (        ex16
              |  >class<                                                       Match any character in >class<
              |  \b                                                            Match \w* boundary                             ex17
              |  \B                                                            Match where \b does not                        ex18
              |  \p{>property<}                                                Match (UTF-8 encoded) in >property<            ex19
              |  \P{>property<}                                                Match (UTF-8 encoded) not in >property<        ex20
 >literal<   ::= Any character except (, ), *, +, ?, [, ], {, }, ., ^, \, or | ~ ~
              |  \>aliteral<                                                   Match >aliteral<                               ex21
 >aliteral<  ::= Any character except a-z, A-Z, 0-9 ~ ~
 >lirng<     ::= ...                                                           ... ~ ~
              |  >class<                                                       >lirng< contains all characters in >class<
              |  >posix<                                                       >lirng< contains all characters in >posix<     ex26
              |  \>eliteral<                                                   >lirng< contains >eliteral<
 >riliteral< ::= Any character except ], \, -, or ^ ~ ~
 >rliteral<  ::= Any character except ], \, or - ~ ~
 >eliteral<  ::= Any character except a-z, A-Z ~ ~
 >class<     ::= \d                                                            Contains 0-9                                   ex23 ~ ~
              |  \D                                                            Contains characters not in \d
              |  \w                                                            Contains a-z, A-Z, 0-9, _                      ex24
              |  \W                                                            Contains characters not in \w
              |  \s                                                            Contains space, tab, newline, formfeed, return ex25
              |  \S                                                            Contains characters not in \s
 >posix<     ::= [:alpha:]                                                     Contains a-z, A-Z ~ ~
              |  [:upper:]                                                     Contains A-Z ~ ~
              |  [:lower:]                                                     Contains a-z                                   ex26 ~ ~
              |  [:digit:]                                                     Contains 0-9 ~ ~
              |  [:xdigit:]                                                    Contains 0-9, a-f, A-F ~ ~
              |  [:alnum:]                                                     Contains a-z, A-Z, 0-9 ~ ~
              |  [:word:]                                                      Contains a-z, A-Z, 0-9, _ ~ ~
              |  [:blank:]                                                     Contains space and tab ~ ~
              |  [:space:]                                                     Contains space, tab, newline, formfeed, return ~ ~
              |  [:graph:]                                                     Contains all ASCII characters that use ink ~ ~
              |  [:print:]                                                     Contains space, tab, and ASCII ink users ~ ~
              |  [:cntrl:]                                                     Contains all characters with scalar value < 32 ~ ~
              |  [:ascii:]                                                     Contains all ASCII characters ~ ~
 >property<  ::= >category<                                                    Includes all characters in >category< ~ ~
              |  ^>category<                                                   Includes all characters not in >category<

In case-insensitive mode, a backreference of the form \>n< matches
case-insensitively only with respect to ASCII characters.

The Unicode categories follow.

 >category< ::= Ll Letter, lowercase                       ex19 ~ ~
             |  Lu Letter, uppercase
             |  Lt Letter, titlecase
             |  Lm Letter, modifier
             |  L& Union of Ll, Lu, Lt, and Lm
             |  Lo Letter, other
             |  L  Union of L& and Lo
             |  Nd Number, decimal digit
             |  Nl Number, letter
             |  No Number, other
             |  N  Union of Nd, Nl, and No
             |  Ps Punctuation, open
             |  Pe Punctuation, close
             |  Pi Punctuation, initial quote
             |  Pf Punctuation, final quote
             |  Pc Punctuation, connector
             |  Pd Punctuation, dash
             |  Po Punctuation, other
             |  P  Union of Ps, Pe, Pi, Pf, Pc, Pd, and Po
             |  Mn Mark, non-spacing
             |  Mc Mark, spacing combining
             |  Me Mark, enclosing
             |  M  Union of Mn, Mc, and Me
             |  Sc Symbol, currency
             |  Sk Symbol, modifier
             |  Sm Symbol, math
             |  So Symbol, other
             |  S  Union of Sc, Sk, Sm, and So
             |  Zl Separator, line
             |  Zp Separator, paragraph
             |  Zs Separator, space
             |  Z  Union of Zl, Zp, and Zs
             |  Cc Other, control
             |  Cf Other, format
             |  Cs Other, surrogate
             |  Cn Other, not assigned
             |  Co Other, private use
             |  C  Union of Cc, Cf, Cs, Cn, and Co
             |  .  Union of all Unicode categories

Examples:

  > (regexp-match #rx"a|b" "cat") ; ex1
  '("a")
  > (regexp-match #rx"[at]" "cat") ; ex2
  '("a")
  > (regexp-match #rx"ca*[at]" "caaat") ; ex3
  '("caaat")
  > (regexp-match #rx"ca+[at]" "caaat") ; ex4
  '("caaat")
  > (regexp-match #rx"ca?t?" "ct") ; ex5
  '("ct")
  > (regexp-match #rx"ca*?[at]" "caaat") ; ex6
  '("ca")
  > (regexp-match #px"ca{2}" "caaat") ; ex7, uses #px
  '("caa")
  > (regexp-match #px"ca{2,}t" "catcaat") ; ex8, uses #px
  '("caat")
  > (regexp-match #px"ca{,2}t" "caaatcat") ; ex9, uses #px
  '("cat")
  > (regexp-match #px"ca{1,2}t" "caaatcat") ; ex10, uses #px
  '("cat")
  > (regexp-match #rx"(c*)(a*)" "caat") ; ex11
  '("caa" "c" "aa")
  > (regexp-match #rx"[^ca]" "caat") ; ex12
  '("t")
  > (regexp-match #rx".(.)." "cat") ; ex13
  '("cat" "a")
  > (regexp-match #rx"^a|^c" "cat") ; ex14
  '("c")
  > (regexp-match #rx"a$|t$" "cat") ; ex15
  '("t")
  > (regexp-match #px"c(.)\\1t" "caat") ; ex16, uses #px
  '("caat" "a")
  > (regexp-match #px".\\b." "cat in hat") ; ex17, uses #px
  '("t ")
  > (regexp-match #px".\\B." "cat in hat") ; ex18, uses #px
  '("ca")
  > (regexp-match #px"\\p{Ll}" "Cat") ; ex19, uses #px
  '("a")
  > (regexp-match #px"\\P{Ll}" "cat!") ; ex20, uses #px
  '("!")
  > (regexp-match #rx"\\|" "c|t") ; ex21
  '("|")
  > (regexp-match #rx"[a-f]*" "cat") ; ex22
  '("ca")
  > (regexp-match #px"[a-f\\d]*" "1cat") ; ex23, uses #px
  '("1ca")
  > (regexp-match #px" [\\w]" "cat hat") ; ex24, uses #px
  '(" h")
  > (regexp-match #px"t[\\s]" "cat\nhat") ; ex25, uses #px
  '("t\n")
  > (regexp-match #px"[[:lower:]]+" "Cat") ; ex26, uses #px
  '("at")
  > (regexp-match #rx"[]]" "c]t") ; ex27
  '("]")
  > (regexp-match #rx"[-]" "c-t") ; ex28
  '("-")
  > (regexp-match #rx"[]a[]+" "c[a]t") ; ex29
  '("[a]")
  > (regexp-match #rx"[a^]+" "ca^t") ; ex30
  '("a^")
  > (regexp-match #rx".a(?=p)" "cat nap") ; ex31
  '("na")
  > (regexp-match #rx".a(?!t)" "cat nap") ; ex32
  '("na")
  > (regexp-match #rx"(?<=n)a." "cat nap") ; ex33
  '("ap")
  > (regexp-match #rx"(?<!c)a." "cat nap") ; ex34
  '("ap")
  > (regexp-match #rx"(?i:a)[tp]" "cAT nAp") ; ex35
  '("Ap")
  > (regexp-match #rx"(?(?<=c)a|b)+" "cabal") ; ex36
  '("ab")

8.2. Additional Syntactic Constraints

In addition to matching a grammar, regular expressions must meet two
syntactic restrictions:

* In a >repeat< other than >atom<?, the >atom< must not match an empty
  sequence.

* In a (?<=>regexp<) or (?<!>regexp<), the >regexp< must match a bounded
  sequence only.

These constraints are checked syntactically by the following type
system. A type [n, m] corresponds to an expression that matches between
n and m characters. In the rule for (>Regexp<), N means the number such
that the opening parenthesis is the Nth opening parenthesis for
collecting match reports.  Non-emptiness is inferred for a backreference
pattern, \>N<, so that a backreference can be used for repetition
patterns; in the case of mutual dependencies among backreferences, the
inference chooses the fixpoint that maximizes non-emptiness.  Finiteness
is not inferred for backreferences (i.e., a backreference is assumed to
match an arbitrarily large sequence).

        >regexp<1 : [n1, m1]   >regexp<2 : [n2, m2]  ~ ~
      >regexp<1|>regexp<2 : [min(n1, n2), max(m1, m2)]  ~ ~
                              
            >pce< : [n1, m1]   >pces< : [n2, m2]  ~ ~
                >pce<>pces< : [n1+n2, m1+m2]  ~ ~
                              
       >repeat< : [n, m]      >atom< : [n, m]   n > 0  ~ ~
       >repeat<? : [0, m]        >atom<* : [0, ∞]  ~ ~
                              
        >atom< : [n, m]   n > 0     >atom< : [n, m]  ~ ~
           >atom<+ : [1, ∞]         >atom<? : [0, m]  ~ ~
                              
                  >atom< : [n, m]   n > 0  ~ ~
                >atom<{>n<} : [n*>n<, m*>n<]  ~ ~
                              
                  >atom< : [n, m]   n > 0  ~ ~
                 >atom<{>n<,} : [n*>n<, ∞]  ~ ~
                              
                  >atom< : [n, m]   n > 0  ~ ~
                 >atom<{,>m<} : [0, m*>m<]  ~ ~
                              
                  >atom< : [n, m]   n > 0  ~ ~
              >atom<{>n<,>m<} : [n*>n<, m*>m<]  ~ ~
                              
                     >regexp< : [n, m]  ~ ~
                 (>regexp<) : [n, m]   αN=n  ~ ~
                              
                     >regexp< : [n, m]  ~ ~
                (?>mode<:>regexp<) : [n, m]  ~ ~
                              
        >regexp< : [n, m]         >regexp< : [n, m]  ~ ~
      (?=>regexp<) : [0, 0]     (?!>regexp<) : [0, 0]  ~ ~
                              
  >regexp< : [n, m]   m < ∞     >regexp< : [n, m]   m < ∞  ~ ~
   (?<=>regexp<) : [0, 0]        (?<!>regexp<) : [0, 0]  ~ ~
                              
                     >regexp< : [n, m]  ~ ~
                   (?>>regexp<) : [n, m]  ~ ~
                              
 >tst< : [n0, m0]   >pces<1 : [n1, m1]   >pces<2 : [n2, m2]  ~ ~
    (?>tst<>pces<1|>pces<2) : [min(n1, n2), max(m1, m2)]  ~ ~
                              
            >tst< : [n0, m0]   >pces< : [n1, m1]  ~ ~
                  (?>tst<>pces<) : [0, m1]  ~ ~
                              
   (>n<) : [αN, ∞]   [>rng<] : [1, 1]   [^>rng<] : [1, 1] ~ ~
                              
            . : [1, 1]   ^ : [0, 0]   $ : [0, 0] ~ ~
                              
   >literal< : [1, 1]   \>n< : [αN, ∞]   >class< : [1, 1] ~ ~
                              
                 \b : [0, 0]   \B : [0, 0] ~ ~
                              
     \p{>property<} : [1, 6]   \P{>property<} : [1, 6] ~ ~

8.3. Regexp Constructors

                                        *regexp?*
(regexp? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a regexp value created by regexp or pregexp, #f
otherwise.

                                        *pregexp?*
(pregexp? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a regexp value created by pregexp (not regexp), #f
otherwise.

                                        *byte-regexp?*
(byte-regexp? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a regexp value created by byte-regexp or
byte-pregexp, #f otherwise.

                                        *byte-pregexp?*
(byte-pregexp? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a regexp value created by byte-pregexp (not
byte-regexp), #f otherwise.

                                        *regexp*
(regexp str) -> regexp? ~
  str : string? ~ ~
(regexp str handler) -> any
  str : string? ~ ~
  handler : (or/c #f (string? -> any)) ~ ~

Takes a string representation of a regular expression (using the syntax
in Regexp Syntax) and compiles it into a regexp value. Other regular
expression procedures accept either a string or a regexp value as the
matching pattern. If a regular expression string is used multiple times,
it is faster to compile the string once to a regexp value and use it for
repeated matches instead of using the string each time.

If handler is provided and not #f, it is called and its result is
returned when str is not a valid representation of a regular expression;
the argument to handler is a string that describes the problem with str.
If handler is #f or not provided, then exn:fail:contract exception is
raised.

The object-name procedure returns the source string for a regexp value.

Examples:

  > (regexp "ap*le")
  #rx"ap*le"
  > (object-name #rx"ap*le")
  "ap*le"
  > (regexp "+" (λ (s) (list s)))
  '("`+' follows nothing in pattern")

Changed in version 6.5.0.1: Added the handler argument.

                                        *pregexp*
(pregexp str) -> pregexp? ~
  str : string? ~ ~
(pregexp str handler) -> any
  str : string? ~ ~
  handler : (or/c #f (string? -> any)) ~ ~

Like regexp, except that it uses a slightly different syntax (see Regexp
Syntax). The result can be used with regexp-match, etc., just like the
result from regexp.

Examples:

  > (pregexp "ap*le")
  #px"ap*le"
  > (regexp? #px"ap*le")
  #t
  > (pregexp "+" (λ (s) (vector s)))
  '#("`+' follows nothing in pattern")

Changed in version 6.5.0.1: Added the handler argument.

                                        *byte-regexp*
(byte-regexp bstr) -> byte-regexp? ~
  bstr : bytes? ~ ~
(byte-regexp bstr handler) -> any
  bstr : bytes? ~ ~
  handler : (or/c #f (bytes? -> any)) ~ ~

Takes a byte-string representation of a regular expression (using the
syntax in Regexp Syntax) and compiles it into a byte-regexp value.

If handler is provided, it is called and its result is returned if str
is not a valid representation of a regular expression.

The object-name procedure returns the source byte string for a regexp
value.

Examples:

  > (byte-regexp #"ap*le")
  #rx#"ap*le"
  > (object-name #rx#"ap*le")
  #"ap*le"
  > (byte-regexp "ap*le")
  byte-regexp: contract violation
    expected: bytes? ~ ~
    given: "ap*le" ~ ~
  > (byte-regexp #"+" (λ (s) (list s)))
  '("`+' follows nothing in pattern")

Changed in version 6.5.0.1: Added the handler argument.

                                        *byte-pregexp*
(byte-pregexp bstr) -> byte-pregexp? ~
  bstr : bytes? ~ ~
(byte-pregexp bstr handler) -> any
  bstr : bytes? ~ ~
  handler : (or/c #f (bytes? -> any)) ~ ~

Like byte-regexp, except that it uses a slightly different syntax (see
Regexp Syntax). The result can be used with regexp-match, etc., just
like the result from byte-regexp.

Examples:

  > (byte-pregexp #"ap*le")
  #px#"ap*le"
  > (byte-pregexp #"+" (λ (s) (vector s)))
  '#("`+' follows nothing in pattern")

Changed in version 6.5.0.1: Added the handler argument.

                                        *regexp-quote*
(regexp-quote str [case-sensitive?]) -> string? ~
  str : string? ~ ~
  case-sensitive? : any/c = #t ~ ~
(regexp-quote bstr [case-sensitive?]) -> bytes?
  bstr : bytes? ~ ~
  case-sensitive? : any/c = #t ~ ~

Produces a string or byte string suitable for use with regexp to match
the literal sequence of characters in str or sequence of bytes in bstr.
If case-sensitive? is true (the default), the resulting regexp matches
letters in str or bytes case-sensitively, otherwise it matches
case-insensitively.

Examples:

  > (regexp-match "." "apple.scm")
  '("a")
  > (regexp-match (regexp-quote ".") "apple.scm")
  '(".")

                                        *regexp-max-lookbehind*
(regexp-max-lookbehind pattern) -> exact-nonnegative-integer? ~
  pattern : (or/c regexp? byte-regexp?) ~ ~

Returns the maximum number of bytes that pattern may consult before the
starting position of a match to determine the match. For example, the
pattern (?<=abc)d consults three bytes preceding a matching d, while
e(?<=a..)d consults two bytes before a matching ed. A ^ pattern may
consult a preceding byte to determine whether the current position is
the start of the input or of a line.

8.4. Regexp Matching

                                        *regexp-match*
(regexp-match  pattern         ~
               input          
              [start-pos      
               end-pos        
               output-port    
               input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or (string? input) (path? input)))
        (or/c #f (cons/c string? (listof (or/c string? #f))))
        (or/c #f (cons/c bytes?  (listof (or/c bytes?  #f)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  output-port : (or/c output-port? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Attempts to match pattern (a string, byte string, regexp value, or
byte-regexp value) once to a portion of input.  The matcher finds a
portion of input that matches and is closest to the start of the input
(after start-pos).

If input is a path, it is converted to a byte string with path->bytes if
pattern is a byte string or a byte-based regexp. Otherwise, input is
converted to a string with path->string.

The optional start-pos and end-pos arguments select a portion of input
for matching; the default is the entire string or the stream up to an
end-of-file. When input is a string, start-pos is a character position;
when input is a byte string, then start-pos is a byte position; and when
input is an input port, start-pos is the number of bytes to skip before
starting to match. The end-pos argument can be #f, which corresponds to
the end of the string or an end-of-file in the stream; otherwise, it is
a character or byte position, like start-pos. If input is an input port,
and if an end-of-file is reached before start-pos bytes are skipped,
then the match fails.

In pattern, a start-of-string ^ refers to the first position of input
after start-pos, assuming that input-prefix is #"".  The end-of-input $
refers to the end-posth position or (in the case of an input port) an
end-of-file, whichever comes first.

The input-prefix specifies bytes that effectively precede input for the
purposes of ^ and other look-behind matching. For example, a #"" prefix
means that ^ matches at the beginning of the stream, while a #"\n"
input-prefix means that a start-of-line ^ can match the beginning of the
input, while a start-of-file ^ cannot.

If the match fails, #f is returned. If the match succeeds, a list
containing strings or byte string, and possibly #f, is returned. The
list contains strings only if input is a string and pattern is not a
byte regexp. Otherwise, the list contains byte strings (substrings of
the UTF-8 encoding of input, if input is a string).

The first [byte] string in a result list is the portion of input that
matched pattern. If two portions of input can match pattern, then the
match that starts earliest is found.

Additional [byte] strings are returned in the list if pattern contains
parenthesized sub-expressions (but not when the opening parenthesis is
followed by ?). Matches for the sub-expressions are provided in the
order of the opening parentheses in pattern. When sub-expressions occur
in branches of an | “or” pattern, in a * “zero or more” pattern, or
other places where the overall pattern can succeed without a match for
the sub-expression, then a #f is returned for the sub-expression if it
did not contribute to the final match. When a single sub-expression
occurs within a * “zero or more” pattern or other multiple-match
positions, then the rightmost match associated with the sub-expression
is returned in the list.

If the optional output-port is provided as an output port, the part of
input from its beginning (not start-pos) that precedes the match is
written to the port. All of input up to end-pos is written to the port
if no match is found. This functionality is most useful when input is an
input port.

When matching an input port, a match failure reads up to end-pos bytes
(or end-of-file), even if pattern begins with a start-of-string ^; see
also regexp-try-match. On success, all bytes up to and including the
match are eventually read from the port, but matching proceeds by first
peeking bytes from the port (using peek-bytes-avail!), and then
(re‑)reading matching bytes to discard them after the match result is
determined. Non-matching bytes may be read and discarded before the
match is determined. The matcher peeks in blocking mode only as far as
necessary to determine a match, but it may peek extra bytes to fill an
internal buffer if immediately available (i.e., without blocking).
Greedy repeat operators in pattern, such as * or +, tend to force
reading the entire content of the port (up to end-pos) to determine a
match.

If the input port is read simultaneously by another thread, or if the
port is a custom port with inconsistent reading and peeking procedures
(see [missing]), then the bytes that are peeked and used for matching
may be different than the bytes read and discarded after the match
completes; the matcher inspects only the peeked bytes. To avoid such
interleaving, use regexp-match-peek (with a progress-evt argument)
followed by port-commit-peeked.

Examples:

  > (regexp-match #rx"x." "12x4x6")
  '("x4")
  > (regexp-match #rx"y." "12x4x6")
  #f
  > (regexp-match #rx"x." "12x4x6" 3)
  '("x6")
  > (regexp-match #rx"x." "12x4x6" 3 4)
  #f
  > (regexp-match #rx#"x." "12x4x6")
  '(#"x4")
  > (regexp-match #rx"x." "12x4x6" 0 #f (current-output-port))
  12
  '("x4")
  > (regexp-match #rx"(-[0-9]*)+" "a-12--345b")
  '("-12--345" "-345")

                                        *regexp-match**
(regexp-match*  pattern                      ~
                input                       
               [start-pos                   
                end-pos                     
                input-prefix                
                #:match-select match-select  ~ ~
                #:gap-select? gap-select])   ~ ~
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or (string? input) (path? input)))
        (listof (or/c string? (listof (or/c #f string?))))
        (listof (or/c bytes? (listof (or/c #f bytes?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  match-select : (or/c (list? . -> . (or/c any/c list?)) = car ~ ~
                       #f)
  gap-select : any/c = #f ~ ~

Like regexp-match, but the result is a list of strings or byte strings
corresponding to a sequence of matches of pattern in input.

The pattern is used in order to find matches, where each match attempt
starts at the end of the last match, and ^ is allowed to match the
beginning of the input (if input-prefix is #"") only for the first
match.  Empty matches are handled like other matches, returning a
zero-length string or byte sequence (they are more useful in making this
a complement of regexp-split), but pattern is restricted from matching
an empty sequence immediately after an empty match.

If input contains no matches (in the range start-pos to end-pos), null
is returned. Otherwise, each item in the resulting list is a distinct
substring or byte sequence from input that matches pattern. The end-pos
argument can be #f to match to the end of input (which corresponds to an
end-of-file if input is an input port).

Examples:

  > (regexp-match* #rx"x." "12x4x6")
  '("x4" "x6")
  > (regexp-match* #rx"x*" "12x4x6")
  '("" "" "x" "" "x" "" "")

match-select specifies the collected results.  The default of car means
that the result is the list of matches without returning parenthesized
sub-patterns.  It can be given as a ‘selector’ function which chooses an
item from a list, or it can choose a list of items.  For example, you
can use cdr to get a list of lists of parenthesized sub-patterns
matches, or values (as an identity function) to get the full matches as
well.  (Note that the selector must choose an element of its input list
or a list of elements, but it must not inspect its input as they can be
either a list of strings or a list of position pairs.  Furthermore, the
selector must be consistent in its choice(s).)

Examples:

  > (regexp-match* #rx"x(.)" "12x4x6" #:match-select cadr) ~ ~
  '("4" "6")
  > (regexp-match* #rx"x(.)" "12x4x6" #:match-select values) ~ ~
  '(("x4" "4") ("x6" "6"))

In addition, specifying gap-select as a non-#f value will make the
result an interleaved list of the matches as well as the separators
between them matches, starting and ending with a separator. In this
case, match-select can be given as #f to return only the separators,
making such uses equivalent to regexp-split.

Examples:

  >
  (regexp-match* #rx"x(.)" "12x4x6" #:match-select cadr #:gap-select? #t) ~ ~
  '("12" "4" "" "6" "")
  > (regexp-match* #rx"x(.)" "12x4x6" #:match-select #f #:gap-select? #t) ~ ~
  '("12" "" "")

                                        *regexp-try-match*
(regexp-try-match  pattern         ~
                   input          
                  [start-pos      
                   end-pos        
                   output-port    
                   input-prefix]) 
 -> (or/c #f (cons/c bytes? (listof (or/c bytes? #f))))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  output-port : (or/c output-port? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match on input ports, except that if the match fails, no
characters are read and discarded from in.

This procedure is especially useful with a pattern that begins with a
start-of-string ^ or with a non-#f end-pos, since each limits the amount
of peeking into the port. Otherwise, beware that a large portion of the
stream may be peeked (and therefore pulled into memory) before the match
succeeds or fails.

                                        *regexp-match-positions*
(regexp-match-positions  pattern         ~
                         input          
                        [start-pos      
                         end-pos        
                         output-port    
                         input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  output-port : (or/c output-port? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match, but returns a list of number pairs (and #f) instead
of a list of strings. Each pair of numbers refers to a range of
characters or bytes in input. If the result for the same arguments with
regexp-match would be a list of byte strings, the resulting ranges
correspond to byte ranges; in that case, if input is a character string,
the byte ranges correspond to bytes in the UTF-8 encoding of the string.

Range results are returned in a substring- and subbytes-compatible
manner, independent of start-pos. In the case of an input port, the
returned positions indicate the number of bytes that were read,
including start-pos, before the first matching byte.

Examples:

  > (regexp-match-positions #rx"x." "12x4x6")
  '((2 . 4))
  > (regexp-match-positions #rx"x." "12x4x6" 3)
  '((4 . 6))
  > (regexp-match-positions #rx"(-[0-9]*)+" "a-12--345b")
  '((1 . 9) (5 . 9))

                                        *regexp-match-positions**
(regexp-match-positions*  pattern                        ~
                          input                         
                         [start-pos                     
                          end-pos                       
                          input-prefix                  
                          #:match-select match-select])  ~ ~
 -> (or/c (listof (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?))
          (listof (listof (or/c #f (cons/c exact-nonnegative-integer?
                                           exact-nonnegative-integer?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  match-select : (list? . -> . (or/c any/c list?)) = car ~ ~

Like regexp-match-positions, but returns multiple matches like
regexp-match*.

Examples:

  > (regexp-match-positions* #rx"x." "12x4x6")
  '((2 . 4) (4 . 6))
  > (regexp-match-positions* #rx"x(.)" "12x4x6" #:match-select cadr) ~ ~
  '((3 . 4) (5 . 6))

Note that unlike regexp-match*, there is no #:gap-select? input keyword,
as this information can be easily inferred from the resulting matches.

                                        *regexp-match?*
(regexp-match?  pattern             ~
                input              
               [start-pos          
                end-pos            
                output-port        
                input-prefix]) -> boolean?
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  output-port : (or/c output-port? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match, but returns merely #t when the match succeeds, #f
otherwise.

Examples:

  > (regexp-match? #rx"x." "12x4x6")
  #t
  > (regexp-match? #rx"y." "12x4x6")
  #f

                                        *regexp-match-exact?*
(regexp-match-exact? pattern input) -> boolean? ~
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path?) ~ ~

Like regexp-match?, but #t is only returned when the entire content of
input matches pattern.

Examples:

  > (regexp-match-exact? #rx"x." "12x4x6")
  #f
  > (regexp-match-exact? #rx"1.*x." "12x4x6")
  #t

                                        *regexp-match-peek*
(regexp-match-peek  pattern         ~
                    input          
                   [start-pos      
                    end-pos        
                    progress       
                    input-prefix]) 
 -> (or/c (cons/c bytes? (listof (or/c bytes? #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match on input ports, but only peeks bytes from input
instead of reading them. Furthermore, instead of an output port, the
last optional argument is a progress event for input (see
port-progress-evt). If progress becomes ready, then the match stops
peeking from input and returns #f. The progress argument can be #f, in
which case the peek may continue with inconsistent information if
another process meanwhile reads from input.

Examples:

  > (define p (open-input-string "a abcd"))
  > (regexp-match-peek ".*bc" p)
  '(#"a abc")
  > (regexp-match-peek ".*bc" p 2)
  '(#"abc")
  > (regexp-match ".*bc" p 2)
  '(#"abc")
  > (peek-char p)
  #\d
  > (regexp-match ".*bc" p)
  #f
  > (peek-char p)
  #<eof>

                                        *regexp-match-peek-positions*
(regexp-match-peek-positions  pattern         ~
                              input          
                             [start-pos      
                              end-pos        
                              progress       
                              input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match-positions on input ports, but only peeks bytes from
input instead of reading them, and with a progress argument like
regexp-match-peek.

                                        *regexp-match-peek-immediate*
(regexp-match-peek-immediate  pattern         ~
                              input          
                             [start-pos      
                              end-pos        
                              progress       
                              input-prefix]) 
 -> (or/c (cons/c bytes? (listof (or/c bytes? #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match-peek, but it attempts to match only bytes that are
available from input without blocking.  The match fails if
not-yet-available characters might be used to match pattern.

                                        *regexp-match-peek-positions-immediate*
(regexp-match-peek-positions-immediate  pattern         ~
                                        input          
                                       [start-pos      
                                        end-pos        
                                        progress       
                                        input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-match-peek-positions, but it attempts to match only bytes
that are available from input without blocking. The match fails if
not-yet-available characters might be used to match pattern.

                                        *regexp-match-peek-positions**
(regexp-match-peek-positions*  pattern                        ~
                               input                         
                              [start-pos                     
                               end-pos                       
                               input-prefix                  
                               #:match-select match-select])  ~ ~
 -> (or/c (listof (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?))
          (listof (listof (or/c #f (cons/c exact-nonnegative-integer?
                                           exact-nonnegative-integer?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  match-select : (list? . -> . (or/c any/c list?)) = car ~ ~

Like regexp-match-peek-positions, but returns multiple matches like
regexp-match-positions*.

                                        *regexp-match/end*
(regexp-match/end  pattern       ~
                   input        
                  [start-pos    
                   end-pos      
                   output-port  
                   input-prefix 
                   count])      
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or/c (string? input) (path? input)))
        (or/c #f (cons/c string? (listof (or/c string? #f))))
        (or/c #f (cons/c bytes?  (listof (or/c bytes?  #f)))))
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  output-port : (or/c output-port? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  count : exact-nonnegative-integer? = 1 ~ ~

Like regexp-match, but with a second result: a byte string of up to
count bytes that correspond to the input (possibly including the
input-prefix) leading to the end of the match; the second result is #f
if no match is found.

The second result can be useful as an input-prefix for attempting a
second match on input starting from the end of the first match. In that
case, use regexp-max-lookbehind to determine an appropriate value for
count.

                                        *regexp-match-positions/end*
(regexp-match-positions/end  pattern       ~
                             input        
                            [start-pos    
                             end-pos      
                             input-prefix 
                             count])      
 -> (listof (cons/c exact-nonnegative-integer?
                    exact-nonnegative-integer?))
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? path? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  count : exact-nonnegative-integer? = 1 ~ ~
(regexp-match-peek-positions/end  pattern      
                                  input        
                                 [start-pos    
                                  end-pos      
                                  progress     
                                  input-prefix 
                                  count])      
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  count : exact-nonnegative-integer? = 1 ~ ~
(regexp-match-peek-positions-immediate/end  pattern      
                                            input        
                                           [start-pos    
                                            end-pos      
                                            progress     
                                            input-prefix 
                                            count])      
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : input-port? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  progress : (or/c evt #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~
  count : exact-nonnegative-integer? = 1 ~ ~

Like regexp-match-positions, etc., but with a second result like
regexp-match/end.

8.5. Regexp Splitting

                                        *regexp-split*
(regexp-split  pattern         ~
               input          
              [start-pos      
               end-pos        
               input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (string? input))
        (cons/c string? (listof string?))
        (cons/c bytes? (listof bytes?)))
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes? input-port?) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

The complement of regexp-match*: the result is a list of strings (if
pattern is a string or character regexp and input is a string) or byte
strings (otherwise) from input that are separated by matches to pattern.
Adjacent matches are separated with "" or #"". Zero-length matches are
treated the same as for regexp-match*.

If input contains no matches (in the range start-pos to end-pos), the
result is a list containing input’s content (from start-pos to end-pos)
as a single element. If a match occurs at the beginning of input (at
start-pos), the resulting list will start with an empty string or byte
string, and if a match occurs at the end (at end-pos), the list will end
with an empty string or byte string. The end-pos argument can be #f, in
which case splitting goes to the end of input (which corresponds to an
end-of-file if input is an input port).

Examples:

  > (regexp-split #rx" +" "12  34")
  '("12" "34")
  > (regexp-split #rx"." "12  34")
  '("" "" "" "" "" "" "")
  > (regexp-split #rx"" "12  34")
  '("" "1" "2" " " " " "3" "4" "")
  > (regexp-split #rx" *" "12  34")
  '("" "1" "2" "" "3" "4" "")
  > (regexp-split #px"\\b" "12, 13 and 14.")
  '("" "12" ", " "13" " " "and" " " "14" ".")
  > (regexp-split #rx" +" "")
  '("")

8.6. Regexp Substitution

                                        *regexp-replace*
(regexp-replace  pattern         ~
                 input          
                 insert         
                [input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (string? input))
        string?
        bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes?) ~ ~
  insert : (or/c string? bytes? ~ ~
                 ((string?) () #:rest (listof string?) . ->* . string?) ~ ~
                 ((bytes?) () #:rest (listof bytes?) . ->* . bytes?)) ~ ~
  input-prefix : bytes? = #"" ~ ~

Performs a match using pattern on input, and then returns a string or
byte string in which the matching portion of input is replaced with
insert.  If pattern matches no part of input, then input is returned
unmodified.

The insert argument can be either a (byte) string, or a function that
returns a (byte) string. In the latter case, the function is applied on
the list of values that regexp-match would return (i.e., the first
argument is the complete match, and then one argument for each
parenthesized sub-expression) to obtain a replacement (byte) string.

If pattern is a string or character regexp and input is a string, then
insert must be a string or a procedure that accept strings, and the
result is a string. If pattern is a byte string or byte regexp, or if
input is a byte string, then insert as a string is converted to a byte
string, insert as a procedure is called with a byte string, and the
result is a byte string.

If insert contains &, then & is replaced with the matching portion of
input before it is substituted into the match’s place.  If insert
contains \>n< for some integer >n<, then it is replaced with the >n<th
matching sub-expression from input. A & and \0 are aliases. If the >n<th
sub-expression was not used in the match, or if >n< is greater than the
number of sub-expressions in pattern, then \>n< is replaced with the
empty string.

To substitute a literal & or \, use \& and \\, respectively, in insert.
A \$ in insert is equivalent to an empty sequence; this can be used to
terminate a number >n< following \. If a \ in insert is followed by
anything other than a digit, &, \, or $, then the \ by itself is treated
as \0.

Note that the \ described in the previous paragraphs is a character or
byte of input. To write such an input as a Racket string literal, an
escaping \ is needed before the \. For example, the Racket constant
"\\1" is \1.

Examples:

  > (regexp-replace #rx"mi" "mi casa" "su")
  "su casa"
  > (regexp-replace #rx"mi" "mi casa" string-upcase)
  "MI casa"
  > (regexp-replace #rx"([Mm])i ([a-zA-Z]*)" "Mi Casa" "\\1y \\2")
  "My Casa"
  > (regexp-replace #rx"([Mm])i ([a-zA-Z]*)" "mi cerveza Mi Mi Mi"
                    "\\1y \\2")
  "my cerveza Mi Mi Mi"
  > (regexp-replace #rx"x" "12x4x6" "\\\\")
  "12\\4x6"
  > (display (regexp-replace #rx"x" "12x4x6" "\\\\"))
  12\4x6

                                        *regexp-replace**
(regexp-replace*  pattern             ~
                  input              
                  insert             
                 [start-pos          
                  end-pos            
                  input-prefix]) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  input : (or/c string? bytes?) ~ ~
  insert : (or/c string? bytes? ~ ~
                 ((string?) () #:rest (listof string?) . ->* . string?) ~ ~
                 ((bytes?) () #:rest (listof bytes?) . ->* . bytes?)) ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : (or/c exact-nonnegative-integer? #f) = #f ~ ~
  input-prefix : bytes? = #"" ~ ~

Like regexp-replace, except that every instance of pattern in input is
replaced with insert, instead of just the first match. Only
non-overlapping instances of pattern in input are replaced, so instances
of pattern within inserted strings are not replaced recursively.
Zero-length matches are treated the same as in regexp-match*.

The optional start-pos and end-pos arguments select a portion of input
for matching; the default is the entire string or the stream up to an
end-of-file.

Examples:

  > (regexp-replace* #rx"([Mm])i ([a-zA-Z]*)" "mi cerveza Mi Mi Mi"
                     "\\1y \\2")
  "my cerveza My Mi Mi"
  > (regexp-replace* #rx"([Mm])i ([a-zA-Z]*)" "mi cerveza Mi Mi Mi"
                     (lambda (all one two)
                       (string-append (string-downcase one) "y"
                                      (string-upcase two))))
  "myCERVEZA myMI Mi"
  > (regexp-replace* #px"\\w" "hello world" string-upcase 0 5)
  "HELLO world"
  > (display (regexp-replace* #rx"x" "12x4x6" "\\\\"))
  12\4\6

                                        *regexp-replaces*
(regexp-replaces input replacements) -> (or/c string? bytes?) ~
  input : (or/c string? bytes?) ~ ~
  replacements : (listof ~ ~
                  (list/c (or/c string? bytes? regexp? byte-regexp?)
                          (or/c string? bytes?
                              ((string?) () #:rest (listof string?) . ->* . string?) ~ ~
                              ((bytes?) () #:rest (listof bytes?) . ->* . bytes?)))) ~ ~

Performs a chain of regexp-replace* operations, where each element in
replacements specifies a replacement as a (list pattern replacement).
The replacements are done in order, so later replacements can apply to
previous insertions.

Examples:

  > (regexp-replaces "zero-or-more?"
                     '([#rx"-" "_"] [#rx"(.*)\\?$" "is_\\1"]))
  "is_zero_or_more"
  > (regexp-replaces "zero-or-more?"
                     '([#rx"e" "o"] [#rx"o" "oo"]))
  "zooroo-oor-mooroo?"

                                        *regexp-replace-quote*
(regexp-replace-quote str) -> string? ~
  str : string? ~ ~
(regexp-replace-quote bstr) -> bytes?
  bstr : bytes? ~ ~

Produces a string suitable for use as the third argument to
regexp-replace to insert the literal sequence of characters in str or
bytes in bstr as a replacement. Concretely, every \ and & in str or bstr
is protected by a quoting \.

Examples:

  > (regexp-replace #rx"UT" "Go UT!" "A&M")
  "Go AUTM!"
  > (regexp-replace #rx"UT" "Go UT!" (regexp-replace-quote "A&M"))
  "Go A&M!"

9. Keywords

+[missing] in [missing] introduces keywords.

A keyword is like an interned symbol, but its printed form starts with
#:, and a keyword cannot be used as an identifier. Furthermore, a
keyword by itself is not a valid expression, though a keyword can be
quoted to form an expression that produces the symbol.

Two keywords are eq? if and only if they print the same (i.e., keywords
are always interned).

Like symbols, keywords are only weakly held by the internal keyword
table; see Symbols for more information.

See [missing]     for information on reading     keywords and [missing]
for information on printing keywords.

                                        *keyword?*
(keyword? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a keyword, #f otherwise.

Examples:

  > (keyword? '#:apple) ~ ~
  #t
  > (keyword? 'define)
  #f
  > (keyword? '#:define) ~ ~
  #t

                                        *keyword->string*
(keyword->string keyword) -> string? ~
  keyword : keyword? ~ ~

Returns a string for the displayed form of keyword, not including the
leading #:.

See also keyword->immutable-string from racket/keyword.

Example:

  > (keyword->string '#:apple) ~ ~
  "apple"

                                        *string->keyword*
(string->keyword str) -> keyword? ~
  str : string? ~ ~

Returns a keyword whose displayed form is the same as that of str, but
with a leading #:.

Example:

  > (string->keyword "apple")
  '#:apple

                                        *keyword<?*
(keyword<? a-keyword b-keyword ...) -> boolean? ~
  a-keyword : keyword? ~ ~
  b-keyword : keyword? ~ ~

Returns #t if the arguments are sorted, where the comparison for each
pair of keywords is the same as using keyword->string with
string->bytes/utf-8 and bytes<?.

Example:

  > (keyword<? '#:apple '#:banana) ~ ~
  #t

Changed in version 7.0.0.13: Allow one argument, in addition to allowing
two or more.

9.1. Additional Keyword Functions

 (require racket/keyword) package: base ~ ~

The bindings documented in this section are provided by the
racket/keyword and racket libraries, but not racket/base.

Added in version 7.6 of package base.

                                        *keyword->immutable-string*
(keyword->immutable-string sym) -> (and/c string? immutable?) ~
  sym : keyword? ~ ~

Like keyword->string, but the result is an immutable string, not
necessarily freshly allocated.

Examples:

  > (keyword->immutable-string '#:apple) ~ ~
  "apple"
  > (immutable? (keyword->immutable-string '#:apple)) ~ ~
  #t

Added in version 7.6 of package base.

10. Pairs and Lists

+[missing] in [missing] introduces pairs and lists.

A pair combines exactly two values. The first value is accessed with the
car procedure, and the second value is accessed with the cdr procedure.
Pairs are not mutable (but see Mutable Pairs and Lists).

A list is recursively defined: it is either the constant null, or it is
a pair whose second value is a list.

A list can be used as a single-valued sequence (see Sequences). The
elements of the list serve as elements of the sequence. See also
in-list.

Cyclic data structures can be created using only immutable pairs via
read or make-reader-graph. If starting with a pair and using some number
of cdrs returns to the starting pair, then the pair is not a list.

See [missing]     for information on reading     pairs and lists and
[missing]     for information on printing pairs and lists.

10.1. Pair Constructors and Selectors

                                        *pair?*
(pair? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a pair, #f otherwise.

Examples:

  > (pair? 1)
  #f
  > (pair? (cons 1 2))
  #t
  > (pair? (list 1 2))
  #t
  > (pair? '(1 2))
  #t
  > (pair? '())
  #f

                                        *null?*
(null? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is the empty list, #f otherwise.

Examples:

  > (null? 1)
  #f
  > (null? '(1 2))
  #f
  > (null? '())
  #t
  > (null? (cdr (list 1)))
  #t

                                        *cons*
(cons a d) -> pair? ~
  a : any/c ~ ~
  d : any/c ~ ~

Returns a newly allocated pair whose first element is a and second
element is d.

Examples:

  > (cons 1 2)
  '(1 . 2)
  > (cons 1 '())
  '(1)

                                        *car*
(car p) -> any/c ~
  p : pair? ~ ~

Returns the first element of the pair p.

Examples:

  > (car '(1 2))
  1
  > (car (cons 2 3))
  2

                                        *cdr*
(cdr p) -> any/c ~
  p : pair? ~ ~

Returns the second element of the pair p.

Examples:

  > (cdr '(1 2))
  '(2)
  > (cdr '(1))
  '()

null : null? ~ ~

The empty list.

Examples:

  > null
  '()
  > '()
  '()
  > (eq? '() null)
  #t

                                        *list?*
(list? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a list: either the empty list, or a pair whose second
element is a list.  This procedure effectively takes constant time due
to internal caching (so that any necessary traversals of pairs can in
principle count as an extra cost of allocating the pairs).

Examples:

  > (list? '(1 2))
  #t
  > (list? (cons 1 (cons 2 '())))
  #t
  > (list? (cons 1 2))
  #f

                                        *list*
(list v ...) -> list? ~
  v : any/c ~ ~

Returns a newly allocated list containing the vs as its elements.

Examples:

  > (list 1 2 3 4)
  '(1 2 3 4)
  > (list (list 1 2) (list 3 4))
  '((1 2) (3 4))

                                        *list**
(list* v ... tail) -> any/c ~
  v : any/c ~ ~
  tail : any/c ~ ~

Like list, but the last argument is used as the tail of the result,
instead of the final element.  The result is a list only if the last
argument is a list.

Examples:

  > (list* 1 2)
  '(1 . 2)
  > (list* 1 2 (list 3 4))
  '(1 2 3 4)

                                        *build-list*
(build-list n proc) -> list? ~
  n : exact-nonnegative-integer? ~ ~
  proc : (exact-nonnegative-integer? . -> . any) ~ ~

Creates a list of n elements by applying proc to the integers from 0 to
(sub1 n) in order.  If lst is the resulting list, then (list-ref lst i)
is the value produced by (proc i).

Examples:

  > (build-list 10 values)
  '(0 1 2 3 4 5 6 7 8 9)
  > (build-list 5 (lambda (x) (* x x)))
  '(0 1 4 9 16)

10.2. List Operations

                                        *length*
(length lst) -> exact-nonnegative-integer? ~
  lst : list? ~ ~

Returns the number of elements in lst.

Examples:

  > (length (list 1 2 3 4))
  4
  > (length '())
  0

                                        *list-ref*
(list-ref lst pos) -> any/c ~
  lst : pair? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the element of lst at position pos, where the list’s first
element is position 0.  If the list has pos or fewer elements, then the
exn:fail:contract exception is raised.

The lst argument need not actually be a list; lst must merely start with
a chain of at least (add1 pos) pairs.

Examples:

  > (list-ref (list 'a 'b 'c) 0)
  'a
  > (list-ref (list 'a 'b 'c) 1)
  'b
  > (list-ref (list 'a 'b 'c) 2)
  'c
  > (list-ref (cons 1 2) 0)
  1
  > (list-ref (cons 1 2) 1)
  list-ref: index reaches a non-pair
    index: 1 ~ ~
    in: '(1 . 2) ~ ~

                                        *list-tail*
(list-tail lst pos) -> any/c ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the list after the first pos elements of lst. If the list has
fewer than pos elements, then the exn:fail:contract exception is raised.

The lst argument need not actually be a list; lst must merely start with
a chain of at least pos pairs.

Examples:

  > (list-tail (list 1 2 3 4 5) 2)
  '(3 4 5)
  > (list-tail (cons 1 2) 1)
  2
  > (list-tail (cons 1 2) 2)
  list-tail: index reaches a non-pair
    index: 2 ~ ~
    in: '(1 . 2) ~ ~
  > (list-tail 'not-a-pair 0)
  'not-a-pair

                                        *append*
(append lst ...) -> list? ~
  lst : list? ~ ~
(append lst ... v) -> any/c
  lst : list? ~ ~
  v : any/c ~ ~

When given all list arguments, the result is a list that contains all of
the elements of the given lists in order.  The last argument is used
directly in the tail of the result.

The last argument need not be a list, in which case the result is an
“improper list.”

Examples:

  > (append (list 1 2) (list 3 4))
  '(1 2 3 4)
  > (append (list 1 2) (list 3 4) (list 5 6) (list 7 8))
  '(1 2 3 4 5 6 7 8)

                                        *reverse*
(reverse lst) -> list? ~
  lst : list? ~ ~

Returns a list that has the same elements as lst, but in reverse order.

Example:

  > (reverse (list 1 2 3 4))
  '(4 3 2 1)

10.3. List Iteration

                                        *map*
(map proc lst ...+) -> list? ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Applies proc to the elements of the lsts from the first elements to the
last.  The proc argument must accept the same number of arguments as the
number of supplied lsts, and all lsts must have the same number of
elements.  The result is a list containing each result of proc in order.

Examples:

  > (map (lambda (number)
           (+ 1 number))
         '(1 2 3 4))
  '(2 3 4 5)
  > (map (lambda (number1 number2)
           (+ number1 number2))
         '(1 2 3 4)
         '(10 100 1000 10000))
  '(11 102 1003 10004)

                                        *andmap*
(andmap proc lst ...+) -> any ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Similar to map in the sense that proc is applied to each element of lst,
but

The andmap function is actually closer to foldl than map, since andmap
doesn’t produce a list.  Still, (andmap f (list x y z)) is equivalent to
(and (f x) (f y) (f z)) in the same way that (map f (list x y z)) is
equivalent to (list (f x) (f y) (f z)).

* the result is #f if any application of proc produces #f, in which case
  proc is not applied to later elements of the lsts; and

* the result is that of proc applied to the last elements of the lsts;
  more specifically, the application of proc to the last elements in the
  lsts is in tail position with respect to the andmap call.

If the lsts are empty, then #t is returned.

Examples:

  > (andmap positive? '(1 2 3))
  #t
  > (andmap positive? '(1 2 a))
  positive?: contract violation
    expected: real? ~ ~
    given: 'a ~ ~
  > (andmap positive? '(1 -2 a))
  #f
  > (andmap + '(1 2 3) '(4 5 6))
  9

                                        *ormap*
(ormap proc lst ...+) -> any ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Similar to map in the sense that proc is applied to each element of lst,
but

To continue the andmap note above, (ormap f (list x y z)) is equivalent
to (or (f x) (f y) (f z)).

* the result is #f if every application of proc produces #f; and

* the result is that of the first application of proc producing a value
  other than #f, in which case proc is not applied to later elements of
  the lsts; the application of proc to the last elements of the lsts is
  in tail position with respect to the ormap call.

If the lsts are empty, then #f is returned.

Examples:

  > (ormap eq? '(a b c) '(a b c))
  #t
  > (ormap positive? '(1 2 a))
  #t
  > (ormap + '(1 2 3) '(4 5 6))
  5

                                        *for-each*
(for-each proc lst ...+) -> void? ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Similar to map, but proc is called only for its effect, and its result
(which can be any number of values) is ignored.

Example:

  > (for-each (lambda (arg)
                (printf "Got ~a\n" arg)
                23)
              '(1 2 3 4))
  Got 1
  Got 2
  Got 3
  Got 4

                                        *foldl*
(foldl proc init lst ...+) -> any/c ~
  proc : procedure? ~ ~
  init : any/c ~ ~
  lst : list? ~ ~

Like map, foldl applies a procedure to the elements of one or more
lists.  Whereas map combines the return values into a list, foldl
combines the return values in an arbitrary way that is determined by
proc.

If foldl is called with n lists, then proc must take n+1 arguments.  The
extra argument is the combined return values so far.  The proc is
initially invoked with the first item of each list, and the final
argument is init.  In subsequent invocations of proc, the last argument
is the return value from the previous invocation of proc.  The input
lsts are traversed from left to right, and the result of the whole foldl
application is the result of the last application of proc.  If the lsts
are empty, the result is init.

Unlike foldr, foldl processes the lsts in constant space (plus the space
for each call to proc).

Examples:

  > (foldl cons '() '(1 2 3 4))
  '(4 3 2 1)
  > (foldl + 0 '(1 2 3 4))
  10
  > (foldl (lambda (a b result)
             (* result (- a b)))
           1
           '(1 2 3)
           '(4 5 6))
  -27

                                        *foldr*
(foldr proc init lst ...+) -> any/c ~
  proc : procedure? ~ ~
  init : any/c ~ ~
  lst : list? ~ ~

Like foldl, but the lists are traversed from right to left. Unlike
foldl, foldr processes the lsts in space proportional to the length of
lsts (plus the space for each call to proc).

Examples:

  > (foldr cons '() '(1 2 3 4))
  '(1 2 3 4)
  > (foldr (lambda (v l) (cons (add1 v) l)) '() '(1 2 3 4))
  '(2 3 4 5)

10.4. List Filtering

                                        *filter*
(filter pred lst) -> list? ~
  pred : procedure? ~ ~
  lst : list? ~ ~

Returns a list with the elements of lst for which pred produces a true
value.  The pred procedure is applied to each element from first to
last.

Example:

  > (filter positive? '(1 -2 3 4 -5))
  '(1 3 4)

                                        *remove*
(remove v lst [proc]) -> list? ~
  v : any/c ~ ~
  lst : list? ~ ~
  proc : procedure? = equal? ~ ~

Returns a list that is like lst, omitting the first element of lst that
is equal to v using the comparison procedure proc (which must accept two
arguments).

Examples:

  > (remove 2 (list 1 2 3 2 4))
  '(1 3 2 4)
  > (remove 2 (list 1 2 3 2 4) =)
  '(1 3 2 4)
  > (remove '(2) (list '(1) '(2) '(3)))
  '((1) (3))
  > (remove "2" (list "1" "2" "3"))
  '("1" "3")
  > (remove #\c (list #\a #\b #\c))
  '(#\a #\b)

                                        *remq*
(remq v lst) -> list? ~
  v : any/c ~ ~
  lst : list? ~ ~

Returns (remove v lst eq?).

Examples:

  > (remq 2 (list 1 2 3 4 5))
  '(1 3 4 5)
  > (remq '(2) (list '(1) '(2) '(3)))
  '((1) (2) (3))
  > (remq "2" (list "1" "2" "3"))
  '("1" "3")
  > (remq #\c (list #\a #\b #\c))
  '(#\a #\b)

                                        *remv*
(remv v lst) -> list? ~
  v : any/c ~ ~
  lst : list? ~ ~

Returns (remove v lst eqv?).

Examples:

  > (remv 2 (list 1 2 3 4 5))
  '(1 3 4 5)
  > (remv '(2) (list '(1) '(2) '(3)))
  '((1) (2) (3))
  > (remv "2" (list "1" "2" "3"))
  '("1" "3")
  > (remv #\c (list #\a #\b #\c))
  '(#\a #\b)

                                        *remove**
(remove* v-lst lst [proc]) -> list? ~
  v-lst : list? ~ ~
  lst : list? ~ ~
  proc : procedure? = equal? ~ ~

Like remove, but removes from lst every instance of every element of
v-lst.

Example:

  > (remove* (list 1 2) (list 1 2 3 2 4 5 2))
  '(3 4 5)

                                        *remq**
(remq* v-lst lst) -> list? ~
  v-lst : list? ~ ~
  lst : list? ~ ~

Returns (remove* v-lst lst eq?).

Example:

  > (remq* (list 1 2) (list 1 2 3 2 4 5 2))
  '(3 4 5)

                                        *remv**
(remv* v-lst lst) -> list? ~
  v-lst : list? ~ ~
  lst : list? ~ ~

Returns (remove* v-lst lst eqv?).

Example:

  > (remv* (list 1 2) (list 1 2 3 2 4 5 2))
  '(3 4 5)

                                        *sort*
(sort  lst                              ~
       less-than?                      
      [#:key extract-key                ~ ~
       #:cache-keys? cache-keys?]) -> list? ~ ~
  lst : list? ~ ~
  less-than? : (any/c any/c . -> . any/c) ~ ~
  extract-key : (any/c . -> . any/c) = (lambda (x) x) ~ ~
  cache-keys? : boolean? = #f ~ ~

Returns a list sorted according to the less-than? procedure, which takes
two elements of lst and returns a true value if the first is less (i.e.,
should be sorted earlier) than the second.

The sort is stable; if two elements of lst are “equal” (i.e., less-than?
does not return a true value when given the pair in either order), then
the elements preserve their relative order from lst in the output list.
To preserve this guarantee, use sort with a strict comparison functions
(e.g., < or string<?; not <= or string<=?).

Because of the peculiar fact that the IEEE-754 number system specifies
that +nan.0 is neither greater nor less than nor equal to any other
number, sorting lists containing this value may produce a surprising
result.

The #:key argument extract-key is used to extract a key value for
comparison from each list element.  That is, the full comparison
procedure is essentially

  (lambda (x y)
    (less-than? (extract-key x) (extract-key y)))

By default, extract-key is applied to two list elements for every
comparison, but if cache-keys? is true, then the extract-key function is
used exactly once for each list item. Supply a true value for
cache-keys? when extract-key is an expensive operation; for example, if
file-or-directory-modify-seconds is used to extract a timestamp for
every file in a list, then cache-keys? should be #t to minimize
file-system calls, but if extract-key is car, then cache-keys?  should
be #f.  As another example, providing extract-key as (lambda (x)
(random)) and #t for cache-keys? effectively shuffles the list.

Examples:

  > (sort '(1 3 4 2) <)
  '(1 2 3 4)
  > (sort '("aardvark" "dingo" "cow" "bear") string<?)
  '("aardvark" "bear" "cow" "dingo")
  > (sort '(("aardvark") ("dingo") ("cow") ("bear"))
          #:key car string<?) ~ ~
  '(("aardvark") ("bear") ("cow") ("dingo"))

10.5. List Searching

                                        *member*
(member v lst [is-equal?]) -> (or/c list? #f) ~
  v : any/c ~ ~
  lst : list? ~ ~
  is-equal? : (any/c any/c -> any/c) = equal? ~ ~

Locates the first element of lst that is equal? to v.  If such an
element exists, the tail of lst starting with that element is returned.
Otherwise, the result is #f.

Examples:

  > (member 2 (list 1 2 3 4))
  '(2 3 4)
  > (member 9 (list 1 2 3 4))
  #f
  > (member #'x (list #'x #'y) free-identifier=?)
  '(#<syntax:eval:454:0 x> #<syntax:eval:454:0 y>)
  > (member #'a (list #'x #'y) free-identifier=?)
  #f

                                        *memv*
(memv v lst) -> (or/c list? #f) ~
  v : any/c ~ ~
  lst : list? ~ ~

Like member, but finds an element using eqv?.

Examples:

  > (memv 2 (list 1 2 3 4))
  '(2 3 4)
  > (memv 9 (list 1 2 3 4))
  #f

                                        *memq*
(memq v lst) -> (or/c list? #f) ~
  v : any/c ~ ~
  lst : list? ~ ~

Like member, but finds an element using eq?.

Examples:

  > (memq 2 (list 1 2 3 4))
  '(2 3 4)
  > (memq 9 (list 1 2 3 4))
  #f

                                        *memf*
(memf proc lst) -> (or/c list? #f) ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Like member, but finds an element using the predicate proc; an element
is found when proc applied to the element returns a true value.

Example:

  > (memf (lambda (arg)
            (> arg 9))
          '(7 8 9 10 11))
  '(10 11)

                                        *findf*
(findf proc lst) -> any/c ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Like memf, but returns the element or #f instead of a tail of lst or #f.

Example:

  > (findf (lambda (arg)
             (> arg 9))
           '(7 8 9 10 11))
  10

                                        *assoc*
(assoc v lst [is-equal?]) -> (or/c pair? #f) ~
  v : any/c ~ ~
  lst : (listof pair?) ~ ~
  is-equal? : (any/c any/c -> any/c) = equal? ~ ~

Locates the first element of lst whose car is equal to v according to
is-equal?.  If such an element exists, the pair (i.e., an element of
lst) is returned.  Otherwise, the result is #f.

Examples:

  > (assoc 3 (list (list 1 2) (list 3 4) (list 5 6)))
  '(3 4)
  > (assoc 9 (list (list 1 2) (list 3 4) (list 5 6)))
  #f
  > (assoc 3.5
           (list (list 1 2) (list 3 4) (list 5 6))
           (lambda (a b) (< (abs (- a b)) 1)))
  '(3 4)

                                        *assv*
(assv v lst) -> (or/c pair? #f) ~
  v : any/c ~ ~
  lst : (listof pair?) ~ ~

Like assoc, but finds an element using eqv?.

Example:

  > (assv 3 (list (list 1 2) (list 3 4) (list 5 6)))
  '(3 4)

                                        *assq*
(assq v lst) -> (or/c pair? #f) ~
  v : any/c ~ ~
  lst : (listof pair?) ~ ~

Like assoc, but finds an element using eq?.

Example:

  > (assq 'c (list (list 'a 'b) (list 'c 'd) (list 'e 'f)))
  '(c d)

                                        *assf*
(assf proc lst) -> (or/c pair? #f) ~
  proc : procedure? ~ ~
  lst : (listof pair?) ~ ~

Like assoc, but finds an element using the predicate proc; an element is
found when proc applied to the car of an lst element returns a true
value.

Example:

  > (assf (lambda (arg)
            (> arg 2))
          (list (list 1 2) (list 3 4) (list 5 6)))
  '(3 4)

10.6. Pair Accessor Shorthands

                                        *caar*
(caar v) -> any/c ~
  v : (cons/c pair? any/c) ~ ~

Returns (car (car v)).

Example:

  > (caar '((1 2) 3 4))
  1

                                        *cadr*
(cadr v) -> any/c ~
  v : (cons/c any/c pair?) ~ ~

Returns (car (cdr v)).

Example:

  > (cadr '((1 2) 3 4))
  3

                                        *cdar*
(cdar v) -> any/c ~
  v : (cons/c pair? any/c) ~ ~

Returns (cdr (car v)).

Example:

  > (cdar '((7 6 5 4 3 2 1) 8 9))
  '(6 5 4 3 2 1)

                                        *cddr*
(cddr v) -> any/c ~
  v : (cons/c any/c pair?) ~ ~

Returns (cdr (cdr v)).

Example:

  > (cddr '(2 1))
  '()

                                        *caaar*
(caaar v) -> any/c ~
  v : (cons/c (cons/c pair? any/c) any/c) ~ ~

Returns (car (car (car v))).

Example:

  > (caaar '(((6 5 4 3 2 1) 7) 8 9))
  6

                                        *caadr*
(caadr v) -> any/c ~
  v : (cons/c any/c (cons/c pair? any/c)) ~ ~

Returns (car (car (cdr v))).

Example:

  > (caadr '(9 (7 6 5 4 3 2 1) 8))
  7

                                        *cadar*
(cadar v) -> any/c ~
  v : (cons/c (cons/c any/c pair?) any/c) ~ ~

Returns (car (cdr (car v))).

Example:

  > (cadar '((7 6 5 4 3 2 1) 8 9))
  6

                                        *caddr*
(caddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c pair?)) ~ ~

Returns (car (cdr (cdr v))).

Example:

  > (caddr '(3 2 1))
  1

                                        *cdaar*
(cdaar v) -> any/c ~
  v : (cons/c (cons/c pair? any/c) any/c) ~ ~

Returns (cdr (car (car v))).

Example:

  > (cdaar '(((6 5 4 3 2 1) 7) 8 9))
  '(5 4 3 2 1)

                                        *cdadr*
(cdadr v) -> any/c ~
  v : (cons/c any/c (cons/c pair? any/c)) ~ ~

Returns (cdr (car (cdr v))).

Example:

  > (cdadr '(9 (7 6 5 4 3 2 1) 8))
  '(6 5 4 3 2 1)

                                        *cddar*
(cddar v) -> any/c ~
  v : (cons/c (cons/c any/c pair?) any/c) ~ ~

Returns (cdr (cdr (car v))).

Example:

  > (cddar '((7 6 5 4 3 2 1) 8 9))
  '(5 4 3 2 1)

                                        *cdddr*
(cdddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c pair?)) ~ ~

Returns (cdr (cdr (cdr v))).

Example:

  > (cdddr '(3 2 1))
  '()

                                        *caaaar*
(caaaar v) -> any/c ~
  v : (cons/c (cons/c (cons/c pair? any/c) any/c) any/c) ~ ~

Returns (car (car (car (car v)))).

Example:

  > (caaaar '((((5 4 3 2 1) 6) 7) 8 9))
  5

                                        *caaadr*
(caaadr v) -> any/c ~
  v : (cons/c any/c (cons/c (cons/c pair? any/c) any/c)) ~ ~

Returns (car (car (car (cdr v)))).

Example:

  > (caaadr '(9 ((6 5 4 3 2 1) 7) 8))
  6

                                        *caadar*
(caadar v) -> any/c ~
  v : (cons/c (cons/c any/c (cons/c pair? any/c)) any/c) ~ ~

Returns (car (car (cdr (car v)))).

Example:

  > (caadar '((7 (5 4 3 2 1) 6) 8 9))
  5

                                        *caaddr*
(caaddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c (cons/c pair? any/c))) ~ ~

Returns (car (car (cdr (cdr v)))).

Example:

  > (caaddr '(9 8 (6 5 4 3 2 1) 7))
  6

                                        *cadaar*
(cadaar v) -> any/c ~
  v : (cons/c (cons/c (cons/c any/c pair?) any/c) any/c) ~ ~

Returns (car (cdr (car (car v)))).

Example:

  > (cadaar '(((6 5 4 3 2 1) 7) 8 9))
  5

                                        *cadadr*
(cadadr v) -> any/c ~
  v : (cons/c any/c (cons/c (cons/c any/c pair?) any/c)) ~ ~

Returns (car (cdr (car (cdr v)))).

Example:

  > (cadadr '(9 (7 6 5 4 3 2 1) 8))
  6

                                        *caddar*
(caddar v) -> any/c ~
  v : (cons/c (cons/c any/c (cons/c any/c pair?)) any/c) ~ ~

Returns (car (cdr (cdr (car v)))).

Example:

  > (caddar '((7 6 5 4 3 2 1) 8 9))
  5

                                        *cadddr*
(cadddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c (cons/c any/c pair?))) ~ ~

Returns (car (cdr (cdr (cdr v)))).

Example:

  > (cadddr '(4 3 2 1))
  1

                                        *cdaaar*
(cdaaar v) -> any/c ~
  v : (cons/c (cons/c (cons/c pair? any/c) any/c) any/c) ~ ~

Returns (cdr (car (car (car v)))).

Example:

  > (cdaaar '((((5 4 3 2 1) 6) 7) 8 9))
  '(4 3 2 1)

                                        *cdaadr*
(cdaadr v) -> any/c ~
  v : (cons/c any/c (cons/c (cons/c pair? any/c) any/c)) ~ ~

Returns (cdr (car (car (cdr v)))).

Example:

  > (cdaadr '(9 ((6 5 4 3 2 1) 7) 8))
  '(5 4 3 2 1)

                                        *cdadar*
(cdadar v) -> any/c ~
  v : (cons/c (cons/c any/c (cons/c pair? any/c)) any/c) ~ ~

Returns (cdr (car (cdr (car v)))).

Example:

  > (cdadar '((7 (5 4 3 2 1) 6) 8 9))
  '(4 3 2 1)

                                        *cdaddr*
(cdaddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c (cons/c pair? any/c))) ~ ~

Returns (cdr (car (cdr (cdr v)))).

Example:

  > (cdaddr '(9 8 (6 5 4 3 2 1) 7))
  '(5 4 3 2 1)

                                        *cddaar*
(cddaar v) -> any/c ~
  v : (cons/c (cons/c (cons/c any/c pair?) any/c) any/c) ~ ~

Returns (cdr (cdr (car (car v)))).

Example:

  > (cddaar '(((6 5 4 3 2 1) 7) 8 9))
  '(4 3 2 1)

                                        *cddadr*
(cddadr v) -> any/c ~
  v : (cons/c any/c (cons/c (cons/c any/c pair?) any/c)) ~ ~

Returns (cdr (cdr (car (cdr v)))).

Example:

  > (cddadr '(9 (7 6 5 4 3 2 1) 8))
  '(5 4 3 2 1)

                                        *cdddar*
(cdddar v) -> any/c ~
  v : (cons/c (cons/c any/c (cons/c any/c pair?)) any/c) ~ ~

Returns (cdr (cdr (cdr (car v)))).

Example:

  > (cdddar '((7 6 5 4 3 2 1) 8 9))
  '(4 3 2 1)

                                        *cddddr*
(cddddr v) -> any/c ~
  v : (cons/c any/c (cons/c any/c (cons/c any/c pair?))) ~ ~

Returns (cdr (cdr (cdr (cdr v)))).

Example:

  > (cddddr '(4 3 2 1))
  '()

10.7. Additional List Functions and Synonyms

 (require racket/list) package: base ~ ~

The bindings documented in this section are provided by the racket/list
and racket libraries, but not racket/base.

empty : null? ~ ~

The empty list.

Examples:

  > empty
  '()
  > (eq? empty null)
  #t

                                        *cons?*
(cons? v) -> boolean? ~
  v : any/c ~ ~

The same as (pair? v).

Example:

  > (cons? '(1 2))
  #t

                                        *empty?*
(empty? v) -> boolean? ~
  v : any/c ~ ~

The same as (null? v).

Examples:

  > (empty? '(1 2))
  #f
  > (empty? '())
  #t

                                        *first*
(first lst) -> any/c ~
  lst : list? ~ ~

The same as (car lst), but only for lists (that are not empty).

Example:

  > (first '(1 2 3 4 5 6 7 8 9 10))
  1

                                        *rest*
(rest lst) -> list? ~
  lst : list? ~ ~

The same as (cdr lst), but only for lists (that are not empty).

Example:

  > (rest '(1 2 3 4 5 6 7 8 9 10))
  '(2 3 4 5 6 7 8 9 10)

                                        *second*
(second lst) -> any ~
  lst : list? ~ ~

Returns the second element of the list.

Example:

  > (second '(1 2 3 4 5 6 7 8 9 10))
  2

                                        *third*
(third lst) -> any ~
  lst : list? ~ ~

Returns the third element of the list.

Example:

  > (third '(1 2 3 4 5 6 7 8 9 10))
  3

                                        *fourth*
(fourth lst) -> any ~
  lst : list? ~ ~

Returns the fourth element of the list.

Example:

  > (fourth '(1 2 3 4 5 6 7 8 9 10))
  4

                                        *fifth*
(fifth lst) -> any ~
  lst : list? ~ ~

Returns the fifth element of the list.

Example:

  > (fifth '(1 2 3 4 5 6 7 8 9 10))
  5

                                        *sixth*
(sixth lst) -> any ~
  lst : list? ~ ~

Returns the sixth element of the list.

Example:

  > (sixth '(1 2 3 4 5 6 7 8 9 10))
  6

                                        *seventh*
(seventh lst) -> any ~
  lst : list? ~ ~

Returns the seventh element of the list.

Example:

  > (seventh '(1 2 3 4 5 6 7 8 9 10))
  7

                                        *eighth*
(eighth lst) -> any ~
  lst : list? ~ ~

Returns the eighth element of the list.

Example:

  > (eighth '(1 2 3 4 5 6 7 8 9 10))
  8

                                        *ninth*
(ninth lst) -> any ~
  lst : list? ~ ~

Returns the ninth element of the list.

Example:

  > (ninth '(1 2 3 4 5 6 7 8 9 10))
  9

                                        *tenth*
(tenth lst) -> any ~
  lst : list? ~ ~

Returns the tenth element of the list.

Example:

  > (tenth '(1 2 3 4 5 6 7 8 9 10))
  10

                                        *last*
(last lst) -> any ~
  lst : list? ~ ~

Returns the last element of the list.

Example:

  > (last '(1 2 3 4 5 6 7 8 9 10))
  10

                                        *last-pair*
(last-pair p) -> pair? ~
  p : pair? ~ ~

Returns the last pair of a (possibly improper) list.

Example:

  > (last-pair '(1 2 3 4))
  '(4)

                                        *make-list*
(make-list k v) -> list? ~
  k : exact-nonnegative-integer? ~ ~
  v : any/c ~ ~

Returns a newly constructed list of length k, holding v in all
positions.

Example:

  > (make-list 7 'foo)
  '(foo foo foo foo foo foo foo)

                                        *list-update*
(list-update lst pos updater) -> list? ~
  lst : list? ~ ~
  pos : (and/c (>=/c 0) (</c (length lst))) ~ ~
  updater : (-> any/c any/c) ~ ~

Returns a list that is the same as lst except at the specified index.
The element at the specified index is (updater (list-ref lst pos)).

Example:

  > (list-update '(zero one two) 1 symbol->string)
  '(zero "one" two)

Added in version 6.3 of package base.

                                        *list-set*
(list-set lst pos value) -> list? ~
  lst : list? ~ ~
  pos : (and/c (>=/c 0) (</c (length lst))) ~ ~
  value : any/c ~ ~

Returns a list that is the same as lst except at the specified index.
The element at the specified index is value.

Example:

  > (list-set '(zero one two) 2 "two")
  '(zero one "two")

Added in version 6.3 of package base.

                                        *index-of*
(index-of lst v [is-equal?]) -> (or/c exact-nonnegative-integer? #f) ~
  lst : list? ~ ~
  v : any/c ~ ~
  is-equal? : (any/c any/c . -> . any/c) = equal? ~ ~

Like member, but returns the index of the first element found instead of
the tail of the list.

Example:

  > (index-of '(1 2 3 4) 3)
  2

Added in version 6.7.0.3 of package base.

                                        *index-where*
(index-where lst proc) -> (or/c exact-nonnegative-integer? #f) ~
  lst : list? ~ ~
  proc : (any/c . -> . any/c) ~ ~

Like index-of but with the predicate-searching behavior of memf.

Example:

  > (index-where '(1 2 3 4) even?)
  1

Added in version 6.7.0.3 of package base.

                                        *indexes-of*
(indexes-of lst v [is-equal?]) ~
 -> (listof exact-nonnegative-integer?)
  lst : list? ~ ~
  v : any/c ~ ~
  is-equal? : (any/c any/c . -> . any/c) = equal? ~ ~

Like index-of, but returns the a list of all the indexes where the
element occurs in the list instead of just the first one.

Example:

  > (indexes-of '(1 2 1 2 1) 2)
  '(1 3)

Added in version 6.7.0.3 of package base.

                                        *indexes-where*
(indexes-where lst proc) -> (listof exact-nonnegative-integer?) ~
  lst : list? ~ ~
  proc : (any/c . -> . any/c) ~ ~

Like indexes-of but with the predicate-searching behavior of
index-where.

Example:

  > (indexes-where '(1 2 3 4) even?)
  '(1 3)

Added in version 6.7.0.3 of package base.

                                        *take*
(take lst pos) -> list? ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh list whose elements are the first pos elements of lst.
If lst has fewer than pos elements, the exn:fail:contract exception is
raised.

The lst argument need not actually be a list; lst must merely start with
a chain of at least pos pairs.

Examples:

  > (take '(1 2 3 4 5) 2)
  '(1 2)
  > (take 'non-list 0)
  '()

                                        *drop*
(drop lst pos) -> any/c ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Just like list-tail.

                                        *split-at*
(split-at lst pos) -> list? any/c ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the same result as

  (values (take lst pos) (drop lst pos))

except that it can be faster.

                                        *takef*
(takef lst pred) -> list? ~
  lst : any/c ~ ~
  pred : procedure? ~ ~

Returns a fresh list whose elements are taken successively from lst as
long as they satisfy pred.  The returned list includes up to, but not
including, the first element in lst for which pred returns #f.

The lst argument need not actually be a list; the chain of pairs in lst
will be traversed until a non-pair is encountered.

Examples:

  > (takef '(2 4 5 8) even?)
  '(2 4)
  > (takef '(2 4 6 8) odd?)
  '()
  > (takef '(2 4 . 6) even?)
  '(2 4)

                                        *dropf*
(dropf lst pred) -> any/c ~
  lst : any/c ~ ~
  pred : procedure? ~ ~

Drops elements from the front of lst as long as they satisfy pred.

Examples:

  > (dropf '(2 4 5 8) even?)
  '(5 8)
  > (dropf '(2 4 6 8) odd?)
  '(2 4 6 8)

                                        *splitf-at*
(splitf-at lst pred) -> list? any/c ~
  lst : any/c ~ ~
  pred : procedure? ~ ~

Returns the same result as

  (values (takef lst pred) (dropf lst pred))

except that it can be faster.

                                        *take-right*
(take-right lst pos) -> any/c ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the list’s pos-length tail. If lst has fewer than pos elements,
then the exn:fail:contract exception is raised.

The lst argument need not actually be a list; lst must merely end with a
chain of at least pos pairs.

Examples:

  > (take-right '(1 2 3 4 5) 2)
  '(4 5)
  > (take-right 'non-list 0)
  'non-list

                                        *drop-right*
(drop-right lst pos) -> list? ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh list whose elements are the prefix of lst, dropping its
pos-length tail.  If lst has fewer than pos elements, then the
exn:fail:contract exception is raised.

The lst argument need not actually be a list; lst must merely end with a
chain of at least pos pairs.

Examples:

  > (drop-right '(1 2 3 4 5) 2)
  '(1 2 3)
  > (drop-right 'non-list 0)
  '()

                                        *split-at-right*
(split-at-right lst pos) -> list? any/c ~
  lst : any/c ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the same result as

  (values (drop-right lst pos) (take-right lst pos))

except that it can be faster.

Examples:

  > (split-at-right '(1 2 3 4 5 6) 3)
  '(1 2 3)
  '(4 5 6)
  > (split-at-right '(1 2 3 4 5 6) 4)
  '(1 2)
  '(3 4 5 6)

                                        *takef-right*
(takef-right lst pred) -> any/c ~
  lst : any/c ~ ~
  pred : procedure? ~ ~
(dropf-right lst pred) -> list?
  lst : any/c ~ ~
  pred : procedure? ~ ~
(splitf-at-right lst pred) -> list? any/c
  lst : any/c ~ ~
  pred : procedure? ~ ~

Like takef, dropf, and splitf-at, but combined with the from-right
functionality of take-right, drop-right, and split-at-right.

                                        *list-prefix?*
(list-prefix? l r [same?]) -> boolean? ~
  l : list? ~ ~
  r : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~

True if l is a prefix of r.

Example:

  > (list-prefix? '(1 2) '(1 2 3 4 5))
  #t

Added in version 6.3 of package base.

                                        *take-common-prefix*
(take-common-prefix l r [same?]) -> list? ~
  l : list? ~ ~
  r : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~

Returns the longest common prefix of l and r.

Example:

  > (take-common-prefix '(a b c d) '(a b x y z))
  '(a b)

Added in version 6.3 of package base.

                                        *drop-common-prefix*
(drop-common-prefix l r [same?]) -> list? list? ~
  l : list? ~ ~
  r : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~

Returns the tails of l and r with the common   prefix removed.

Example:

  > (drop-common-prefix '(a b c d) '(a b x y z))
  '(c d)
  '(x y z)

Added in version 6.3 of package base.

                                        *split-common-prefix*
(split-common-prefix l r [same?]) -> list? list? list? ~
  l : list? ~ ~
  r : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~

Returns the longest common prefix together with the tails of   l and r
with the common prefix removed.

Example:

  > (split-common-prefix '(a b c d) '(a b x y z))
  '(a b)
  '(c d)
  '(x y z)

Added in version 6.3 of package base.

                                        *add-between*
(add-between  lst                              ~
              v                               
             [#:before-first before-first      ~ ~
              #:before-last before-last        ~ ~
              #:after-last after-last          ~ ~
              #:splice? splice?])         -> list? ~ ~
  lst : list? ~ ~
  v : any/c ~ ~
  before-first : list? = '() ~ ~
  before-last : any/c = v ~ ~
  after-last : list? = '() ~ ~
  splice? : any/c = #f ~ ~

Returns a list with the same elements as lst, but with v between each
pair of elements in lst; the last pair of elements will have before-last
between them, instead of v (but before-last defaults to v).

If splice? is true, then v and before-last should be lists, and the list
elements are spliced into the result.  In addition, when splice? is
true, before-first and after-last are inserted before the first element
and after the last element respectively.

Examples:

  > (add-between '(x y z) 'and)
  '(x and y and z)
  > (add-between '(x) 'and)
  '(x)
  > (add-between '("a" "b" "c" "d") "," #:before-last "and") ~ ~
  '("a" "," "b" "," "c" "and" "d")
  > (add-between '(x y z) '(-) #:before-last '(- -) ~ ~
                 #:before-first '(begin) #:after-last '(end LF) ~ ~
                 #:splice? #t) ~ ~
  '(begin x - y - - z end LF)

                                        *append**
(append* lst ... lsts) -> list? ~
  lst : list? ~ ~
  lsts : (listof list?) ~ ~
(append* lst ... lsts) -> any/c
  lst : list? ~ ~
  lsts : list? ~ ~

Like append, but the last argument is used as a list of arguments for
append, so (append* lst ... lsts) is the same as (apply append lst ...
lsts).  In other words, the relationship between append and append* is
similar to the one between list and list*.

Examples:

  > (append* '(a) '(b) '((c) (d)))
  '(a b c d)
  > (cdr (append* (map (lambda (x) (list ", " x))
                       '("Alpha" "Beta" "Gamma"))))
  '("Alpha" ", " "Beta" ", " "Gamma")

                                        *flatten*
(flatten v) -> list? ~
  v : any/c ~ ~

Flattens an arbitrary S-expression structure of pairs into a list. More
precisely, v is treated as a binary tree where pairs are interior nodes,
and the resulting list contains all of the non-null leaves of the tree
in the same order as an inorder traversal.

Examples:

  > (flatten '((a) b (c (d) . e) ()))
  '(a b c d e)
  > (flatten 'a)
  '(a)

                                        *check-duplicates*
(check-duplicates  lst                             ~
                  [same?                          
                   #:key extract-key               ~ ~
                   #:default failure-result]) -> any ~ ~
  lst : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~
  extract-key : (-> any/c any/c) = (lambda (x) x) ~ ~
  failure-result : failure-result/c = (lambda () #f) ~ ~

Returns the first duplicate item in lst. More precisely, it returns the
first x such that there was a previous y where (same? (extract-key x)
(extract-key y)).

If no duplicate is found, then failure-result determines the result:

* If failure-result is a procedure, it is called (through a tail call)
  with no arguments to produce the result.

* Otherwise, failure-result is returned as the result.

The same? argument should be an equivalence predicate such as equal? or
eqv? or a dictionary. The procedures equal?, eqv?, and eq? automatically
use a dictionary for speed.

Examples:

  > (check-duplicates '(1 2 3 4))
  #f
  > (check-duplicates '(1 2 3 2 1))
  2
  > (check-duplicates '((a 1) (b 2) (a 3)) #:key car) ~ ~
  '(a 3)
  > (check-duplicates '(1 2 3 4 5 6)
                      (lambda (x y) (equal? (modulo x 3) (modulo y 3))))
  4
  > (check-duplicates '(1 2 3 4) #:default "no duplicates") ~ ~
  "no duplicates"

Added in version 6.3 of package base. Changed in version 6.11.0.2: Added
the #:default optional argument.

                                        *remove-duplicates*
(remove-duplicates  lst                      ~
                   [same?                   
                    #:key extract-key]) -> list? ~ ~
  lst : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~
  extract-key : (any/c . -> . any/c) = (lambda (x) x) ~ ~

Returns a list that has all items in lst, but without duplicate items,
where same? determines whether two elements of the list are equivalent.
The resulting list is in the same order as lst, and for any item that
occurs multiple times, the first one is kept.

The #:key argument extract-key is used to extract a key value from each
list element, so two items are considered equal if (same? (extract-key
x) (extract-key y)) is true.

Examples:

  > (remove-duplicates '(a b b a))
  '(a b)
  > (remove-duplicates '(1 2 1.0 0))
  '(1 2 1.0 0)
  > (remove-duplicates '(1 2 1.0 0) =)
  '(1 2 0)

                                        *filter-map*
(filter-map proc lst ...+) -> list? ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Like (map proc lst ...), except that, if proc returns #false, that
element is omitted from the resulting list. In other words, filter-map
is equivalent to (filter (lambda (x) x) (map proc lst ...)), but more
efficient, because filter-map avoids building the intermediate list.

Example:

  > (filter-map (lambda (x) (and (negative? x) (abs x))) '(1 2 -3 -4 8))
  '(3 4)

                                        *count*
(count proc lst ...+) -> exact-nonnegative-integer? ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Returns (length (filter-map proc lst ...)), but without building the
intermediate list.

Example:

  > (count positive? '(1 -1 2 3 -2 5))
  4

                                        *partition*
(partition pred lst) -> list? list? ~
  pred : procedure? ~ ~
  lst : list? ~ ~

Similar to filter, except that two values are returned: the items for
which pred returns a true value, and the items for which pred returns
#f.

The result is the same as

  (values (filter pred lst) (filter (negate pred) lst))

but pred is applied to each item in lst only once.

Example:

  > (partition even? '(1 2 3 4 5 6))
  '(2 4 6)
  '(1 3 5)

                                        *range*
(range end) -> list? ~
  end : real? ~ ~
(range start end [step]) -> list?
  start : real? ~ ~
  end : real? ~ ~
  step : real? = 1 ~ ~

Similar to in-range, but returns lists.

The resulting list holds numbers starting at start and whose successive
elements are computed by adding step to their predecessor until end
(excluded) is reached.  If no starting point is provided, 0 is used. If
no step argument is provided, 1 is used.

Like in-range, a range application can provide better performance when
it appears directly in a for clause.

Examples:

  > (range 10)
  '(0 1 2 3 4 5 6 7 8 9)
  > (range 10 20)
  '(10 11 12 13 14 15 16 17 18 19)
  > (range 20 40 2)
  '(20 22 24 26 28 30 32 34 36 38)
  > (range 20 10 -1)
  '(20 19 18 17 16 15 14 13 12 11)
  > (range 10 15 1.5)
  '(10 11.5 13.0 14.5)

Changed in version 6.7.0.4 of package base: Adjusted to cooperate with
for in the same way that in-range does.

                                        *append-map*
(append-map proc lst ...+) -> list? ~
  proc : procedure? ~ ~
  lst : list? ~ ~

Returns (append* (map proc lst ...)).

Example:

  > (append-map vector->list '(#(1) #(2 3) #(4)))
  '(1 2 3 4)

                                        *filter-not*
(filter-not pred lst) -> list? ~
  pred : (any/c . -> . any/c) ~ ~
  lst : list? ~ ~

Like filter, but the meaning of the pred predicate is reversed: the
result is a list of all items for which pred returns #f.

Example:

  > (filter-not even? '(1 2 3 4 5 6))
  '(1 3 5)

                                        *shuffle*
(shuffle lst) -> list? ~
  lst : list? ~ ~

Returns a list with all elements from lst, randomly shuffled.

Examples:

  > (shuffle '(1 2 3 4 5 6))
  '(2 3 1 4 5 6)
  > (shuffle '(1 2 3 4 5 6))
  '(2 4 1 5 3 6)
  > (shuffle '(1 2 3 4 5 6))
  '(2 3 4 5 6 1)

                                        *combinations*
(combinations lst) -> list? ~
  lst : list? ~ ~
(combinations lst size) -> list?
  lst : list? ~ ~
  size : exact-nonnegative-integer? ~ ~

Wikipedia combinations

Return a list of all combinations of elements in the input list (aka the
powerset of lst). If size is given, limit results to combinations of
size elements.

Examples:

  > (combinations '(1 2 3))
  '(() (1) (2) (1 2) (3) (1 3) (2 3) (1 2 3))
  > (combinations '(1 2 3) 2)
  '((1 2) (1 3) (2 3))

                                        *in-combinations*
(in-combinations lst) -> sequence? ~
  lst : list? ~ ~
(in-combinations lst size) -> sequence?
  lst : list? ~ ~
  size : exact-nonnegative-integer? ~ ~

Returns a sequence of all combinations of elements in the input list,
or all combinations of length size if size is given. Builds combinations
one-by-one instead of all at once.

Examples:

  > (time (begin (combinations (range 15)) (void)))
  cpu time: 14 real time: 14 gc time: 0
  > (time (begin (in-combinations (range 15)) (void)))
  cpu time: 0 real time: 0 gc time: 0

                                        *permutations*
(permutations lst) -> list? ~
  lst : list? ~ ~

Returns a list of all permutations of the input list.  Note that this
function works without inspecting the elements, and therefore it ignores
repeated elements (which will result in repeated permutations). Raises
an error if the input list contains more than 256 elements.

Examples:

  > (permutations '(1 2 3))
  '((1 2 3) (2 1 3) (1 3 2) (3 1 2) (2 3 1) (3 2 1))
  > (permutations '(x x))
  '((x x) (x x))

                                        *in-permutations*
(in-permutations lst) -> sequence? ~
  lst : list? ~ ~

Returns a sequence of all permutations of the input list.  It is
equivalent to (in-list (permutations l)) but much faster since it builds
the permutations one-by-one on each iteration Raises an error if the
input list contains more than 256 elements.

                                        *argmin*
(argmin proc lst) -> any/c ~
  proc : (-> any/c real?) ~ ~
  lst : (and/c pair? list?) ~ ~

Returns the first element in the list lst that minimizes the result of
proc.  Signals an error on an empty list. See also min.

Examples:

  > (argmin car '((3 pears) (1 banana) (2 apples)))
  '(1 banana)
  > (argmin car '((1 banana) (1 orange)))
  '(1 banana)

                                        *argmax*
(argmax proc lst) -> any/c ~
  proc : (-> any/c real?) ~ ~
  lst : (and/c pair? list?) ~ ~

Returns the first element in the list lst that maximizes the result of
proc.  Signals an error on an empty list. See also max.

Examples:

  > (argmax car '((3 pears) (1 banana) (2 apples)))
  '(3 pears)
  > (argmax car '((3 pears) (3 oranges)))
  '(3 pears)

                                        *group-by*
(group-by key lst [same?]) -> (listof list?) ~
  key : (-> any/c any/c) ~ ~
  lst : list? ~ ~
  same? : (any/c any/c . -> . any/c) = equal? ~ ~

Groups the given list into equivalence classes, with equivalence being
determined by same?. Within each equivalence class, group-by preserves
the ordering of the original list. Equivalence classes themselves are in
order of first appearance in the input.

Example:

  >
  (group-by (lambda (x) (modulo x 3)) '(1 2 1 2 54 2 5 43 7 2 643 1 2 0))
  '((1 1 43 7 643 1) (2 2 2 5 2 2) (54 0))

Added in version 6.3 of package base.

                                        *cartesian-product*
(cartesian-product lst ...) -> (listof list?) ~
  lst : list? ~ ~

Computes the n-ary cartesian product of the given lists.

Examples:

  > (cartesian-product '(1 2 3) '(a b c))
  '((1 a) (1 b) (1 c) (2 a) (2 b) (2 c) (3 a) (3 b) (3 c))
  > (cartesian-product '(4 5 6) '(d e f) '(#t #f))
  '((4 d #t)
    (4 d #f)
    (4 e #t)
    (4 e #f)
    (4 f #t)
    (4 f #f)
    (5 d #t)
    (5 d #f)
    (5 e #t)
    (5 e #f)
    (5 f #t)
    (5 f #f)
    (6 d #t)
    (6 d #f)
    (6 e #t)
    (6 e #f)
    (6 f #t)
    (6 f #f))

Added in version 6.3 of package base.

                                        *remf*
(remf pred lst) -> list? ~
  pred : procedure? ~ ~
  lst : list? ~ ~

Returns a list that is like lst, omitting the first element of lst for
which pred produces a true value.

Example:

  > (remf negative? '(1 -2 3 4 -5))
  '(1 3 4 -5)

Added in version 6.3 of package base.

                                        *remf**
(remf* pred lst) -> list? ~
  pred : procedure? ~ ~
  lst : list? ~ ~

Like remf, but removes all the elements for which pred produces a true
value.

Example:

  > (remf* negative? '(1 -2 3 4 -5))
  '(1 3 4)

Added in version 6.3 of package base.

10.8. Immutable Cyclic Data

                                        *make-reader-graph*
(make-reader-graph v) -> any/c ~
  v : any/c ~ ~

Returns a value like v, with placeholders created by make-placeholder
replaced with the values that they contain, and with placeholders
created by make-hash-placeholder with an immutable hash table.  No part
of v is mutated; instead, parts of v are copied as necessary to
construct the resulting graph, where at most one copy is created for any
given value.

Since the copied values can be immutable, and since the copy is also
immutable, make-reader-graph can create cycles involving only immutable
pairs, vectors, boxes, and hash tables.

Only the following kinds of values are copied and traversed to detect
placeholders:

* pairs

* vectors, both mutable and immutable

* boxes, both mutable and immutable

* hash tables, both mutable and immutable

* instances of a prefab structure type

* placeholders created by make-placeholder and make-hash-placeholder

Due to these restrictions, make-reader-graph creates exactly the same
sort of cyclic values as read.

Example:

  > (let* ([ph (make-placeholder #f)]
           [x (cons 1 ph)])
      (placeholder-set! ph x)
      (make-reader-graph x))
  #0='(1 . #0#)

                                        *placeholder?*
(placeholder? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a placeholder created by make-placeholder, #f
otherwise.

                                        *make-placeholder*
(make-placeholder v) -> placeholder? ~
  v : any/c ~ ~

Returns a placeholder for use with placeholder-set!  and
make-reader-graph. The v argument supplies the initial value for the
placeholder.

                                        *placeholder-set!*
(placeholder-set! ph datum) -> void? ~
  ph : placeholder? ~ ~
  datum : any/c ~ ~

Changes the value of ph to v.

                                        *placeholder-get*
(placeholder-get ph) -> any/c ~
  ph : placeholder? ~ ~

Returns the value of ph.

                                        *hash-placeholder?*
(hash-placeholder? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a placeholder created by make-hash-placeholder, #f
otherwise.

                                        *make-hash-placeholder*
(make-hash-placeholder assocs) -> hash-placeholder? ~
  assocs : (listof pair?) ~ ~

Like make-immutable-hash, but produces a table placeholder for use with
make-reader-graph.

                                        *make-hasheq-placeholder*
(make-hasheq-placeholder assocs) -> hash-placeholder? ~
  assocs : (listof pair?) ~ ~

Like make-immutable-hasheq, but produces a table placeholder for use
with make-reader-graph.

                                        *make-hasheqv-placeholder*
(make-hasheqv-placeholder assocs) -> hash-placeholder? ~
  assocs : (listof pair?) ~ ~

Like make-immutable-hasheqv, but produces a table placeholder for use
with make-reader-graph.

11. Mutable Pairs and Lists

A mutable pair is like a pair created by cons, but it supports set-mcar!
and set-mcdr! mutation operations to change the parts of the mutable
pair (like traditional Lisp and Scheme pairs).

A mutable list is analogous to a list created with pairs, but instead
created with mutable pairs.

A mutable pair is not a pair; they are completely separate datatypes.
Similarly, a mutable list is not a list, except that the empty list is
also the empty mutable list. Instead of programming with mutable pairs
and mutable lists, data structures such as pairs, lists, and hash tables
are practically always better choices.

A mutable list can be used as a single-valued sequence (see Sequences).
The elements of the mutable list serve as elements of the sequence. See
also in-mlist.

11.1. Mutable Pair Constructors and Selectors

                                        *mpair?*
(mpair? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a mutable pair, #f otherwise.

                                        *mcons*
(mcons a d) -> mpair? ~
  a : any/c ~ ~
  d : any/c ~ ~

Returns a newly allocated mutable pair whose first element is a and
second element is d.

                                        *mcar*
(mcar p) -> any/c ~
  p : mpair? ~ ~

Returns the first element of the mutable pair p.

                                        *mcdr*
(mcdr p) -> any/c ~
  p : mpair? ~ ~

Returns the second element of the mutable pair p.

                                        *set-mcar!*
(set-mcar! p v) -> void? ~
  p : mpair? ~ ~
  v : any/c ~ ~

Changes the mutable pair p so that its first element is v.

                                        *set-mcdr!*
(set-mcdr! p v) -> void? ~
  p : mpair? ~ ~
  v : any/c ~ ~

Changes the mutable pair p so that its second element is v.

12. Vectors

+[missing] in [missing] introduces vectors.

A vector is a fixed-length array with constant-time access and update of
the vector slots, which are numbered from 0 to one less than the number
of slots in the vector.

Two vectors are equal? if they have the same length, and if the values
in corresponding slots of the vectors are equal?.

A vector can be mutable or immutable. When an immutable vector is
provided to a procedure like vector-set!, the exn:fail:contract
exception is raised. Vectors generated by the default reader (see
[missing]) are immutable. Use immutable? to check whether a vector is
immutable.

A vector can be used as a single-valued sequence (see Sequences). The
elements of the vector serve as elements of the sequence. See also
in-vector.

A literal or printed vector starts with #(, optionally with a number
between the # and (. See [missing]     for information on reading
vectors and [missing]     for information on printing vectors.

                                        *vector?*
(vector? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a vector, #f otherwise.

                                        *make-vector*
(make-vector size [v]) -> vector? ~
  size : exact-nonnegative-integer? ~ ~
  v : any/c = 0 ~ ~

Returns a mutable vector with size slots, where all slots are
initialized to contain v.

                                        *vector*
(vector v ...) -> vector? ~
  v : any/c ~ ~

Returns a newly allocated mutable vector with as many slots as provided
vs, where the slots are initialized to contain the given vs in order.

                                        *vector-immutable*
(vector-immutable v ...) -> (and/c vector? ~
                                   immutable?)
  v : any/c ~ ~

Returns a newly allocated immutable vector with as many slots as
provided vs, where the slots are contain the given vs in order.

                                        *vector-length*
(vector-length vec) -> exact-nonnegative-integer? ~
  vec : vector? ~ ~

Returns the length of vec (i.e., the number of slots in the vector).

                                        *vector-ref*
(vector-ref vec pos) -> any/c ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the element in slot pos of vec. The first slot is position 0,
and the last slot is one less than (vector-length vec).

                                        *vector-set!*
(vector-set! vec pos v) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~ ~
  pos : exact-nonnegative-integer? ~ ~
  v : any/c ~ ~

Updates the slot pos of vec to contain v.

                                        *vector*-length*
(vector*-length vec) -> exact-nonnegative-integer? ~
  vec : (and/c vector? (not/c impersonator?)) ~ ~
(vector*-ref vec pos) -> any/c
  vec : (and/c vector? (not/c impersonator?)) ~ ~
  pos : exact-nonnegative-integer? ~ ~
(vector*-set! vec pos v) -> void?
  vec : (and/c vector? (not/c immutable?)  (not/c impersonator?)) ~ ~
  pos : exact-nonnegative-integer? ~ ~
  v : any/c ~ ~

Like vector-length, vector-ref, and vector-set!, but constrained to work
on vectors that are not impersonators.

Added in version 6.90.0.15.

                                        *vector-cas!*
(vector-cas! vec pos old-v new-v) -> boolean? ~
  vec : (and/c vector? (not/c immutable?) (not/c impersonator?)) ~ ~
  pos : exact-nonnegative-integer? ~ ~
  old-v : any/c ~ ~
  new-v : any/c ~ ~

Compare and set operation for vectors. See box-cas!.

Added in version 6.11.0.2.

                                        *vector->list*
(vector->list vec) -> list? ~
  vec : vector? ~ ~

Returns a list with the same length and elements as vec.

                                        *list->vector*
(list->vector lst) -> vector? ~
  lst : list? ~ ~

Returns a mutable vector with the same length and elements as lst.

                                        *vector->immutable-vector*
(vector->immutable-vector vec) -> (and/c vector? immutable?) ~
  vec : vector? ~ ~

Returns an immutable vector with the same length and elements as vec. If
vec is itself immutable, then it is returned as the result.

                                        *vector-fill!*
(vector-fill! vec v) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~ ~
  v : any/c ~ ~

Changes all slots of vec to contain v.

                                        *vector-copy!*
(vector-copy!  dest            ~
               dest-start     
               src            
              [src-start      
               src-end])  -> void?
  dest : (and/c vector? (not/c immutable?)) ~ ~
  dest-start : exact-nonnegative-integer? ~ ~
  src : vector? ~ ~
  src-start : exact-nonnegative-integer? = 0 ~ ~
  src-end : exact-nonnegative-integer? = (vector-length src) ~ ~

Changes the elements of dest starting at position  dest-start to match
the elements in src from  src-start (inclusive) to src-end (exclusive).
The  vectors dest and src can be the same vector, and in  that case the
destination region can overlap with the source region;  the destination
elements after the copy match the source elements  from before the copy.
If any of dest-start,  src-start, or src-end are out of range (taking
into  account the sizes of the vectors and the source and destination
regions), the exn:fail:contract exception is raised.

Examples:

  > (define v (vector 'A 'p 'p 'l 'e))
  > (vector-copy! v 4 #(y))
  > (vector-copy! v 0 v 3 4)
  > v
  '#(l p p l y)

                                        *vector->values*
(vector->values vec [start-pos end-pos]) -> any ~
  vec : vector? ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = (vector-length vec) ~ ~

Returns end-pos - start-pos values, which are the elements of vec from
start-pos (inclusive) to end-pos (exclusive). If start-pos or end-pos
are greater than (vector-length vec), or if end-pos is less than
start-pos, the exn:fail:contract exception is raised.

                                        *build-vector*
(build-vector n proc) -> vector? ~
  n : exact-nonnegative-integer? ~ ~
  proc : (exact-nonnegative-integer? . -> . any/c) ~ ~

Creates a vector of n elements by applying proc to the integers from 0
to (sub1 n) in order. If vec is the resulting vector, then (vector-ref
vec i) is the value produced by (proc i).

Example:

  > (build-vector 5 add1)
  '#(1 2 3 4 5)

12.1. Additional Vector Functions

 (require racket/vector) package: base ~ ~

The bindings documented in this section are provided by the
racket/vector and racket libraries, but not racket/base.

                                        *vector-empty?*
(vector-empty? v) -> boolean? ~
  v : vector? ~ ~

Returns #t if v is empty (i.e. its length is 0), #f otherwise.

Added in version 7.4.0.4 of package base.

                                        *vector-set*!*
(vector-set*! vec pos v ... ...) -> void? ~
  vec : (and/c vector? (not/c immutable?)) ~ ~
  pos : exact-nonnegative-integer? ~ ~
  v : any/c ~ ~

Updates each slot pos of vec to contain each v. The update takes place
from the left so later updates overwrite earlier updates.

                                        *vector-map*
(vector-map proc vec ...+) -> vector? ~
  proc : procedure? ~ ~
  vec : vector? ~ ~

Applies proc to the elements of the vecs from the  first elements to the
last. The proc argument must accept  the same number of arguments as the
number of supplied vecs,  and all vecs must have the same number of
elements.  The  result is a fresh vector containing each result of proc
in  order.

Example:

  > (vector-map + #(1 2) #(3 4))
  '#(4 6)

                                        *vector-map!*
(vector-map! proc vec ...+) -> vector? ~
  proc : procedure? ~ ~
  vec : (and/c vector? (not/c immutable?)) ~ ~

Like vector-map, but result of proc is inserted into  the first vec at
the index that the arguments to  proc were taken from. The result is the
first vec.

Examples:

  > (define v (vector 1 2 3 4))
  > (vector-map! add1 v)
  '#(2 3 4 5)
  > v
  '#(2 3 4 5)

                                        *vector-append*
(vector-append vec ...) -> vector? ~
  vec : vector? ~ ~

Creates a fresh vector that contains all of the elements of the given
vectors in order.

Example:

  > (vector-append #(1 2) #(3 4))
  '#(1 2 3 4)

                                        *vector-take*
(vector-take vec pos) -> vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh vector whose elements are the first pos elements of vec.
If vec has fewer than pos elements, then the exn:fail:contract exception
is raised.

Example:

  > (vector-take #(1 2 3 4) 2)
  '#(1 2)

                                        *vector-take-right*
(vector-take-right vec pos) -> vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh vector whose elements are the last pos elements of vec.
If vec has fewer than pos elements, then the exn:fail:contract exception
is raised.

Example:

  > (vector-take-right #(1 2 3 4) 2)
  '#(3 4)

                                        *vector-drop*
(vector-drop vec pos) -> vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh vector whose elements are the elements of vec  after the
first pos elements.  If vec has fewer  than pos elements, then the
exn:fail:contract exception is raised.

Example:

  > (vector-drop #(1 2 3 4) 2)
  '#(3 4)

                                        *vector-drop-right*
(vector-drop-right vec pos) -> vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns a fresh vector whose elements are the prefix of vec, dropping
its pos-length tail.  If vec has fewer than pos elements, then the
exn:fail:contract exception is raised.

Examples:

  > (vector-drop-right #(1 2 3 4) 1)
  '#(1 2 3)
  > (vector-drop-right #(1 2 3 4) 3)
  '#(1)

                                        *vector-split-at*
(vector-split-at vec pos) -> vector? vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the same result as

  (values (vector-take vec pos) (vector-drop vec pos))

except that it can be faster.

Example:

  > (vector-split-at #(1 2 3 4 5) 2)
  '#(1 2)
  '#(3 4 5)

                                        *vector-split-at-right*
(vector-split-at-right vec pos) -> vector? vector? ~
  vec : vector? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns the same result as

  (values (vector-take-right vec pos) (vector-drop-right vec pos))

except that it can be faster.

Example:

  > (vector-split-at-right #(1 2 3 4 5) 2)
  '#(1 2 3)
  '#(4 5)

                                        *vector-copy*
(vector-copy vec [start end]) -> vector? ~
  vec : vector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length v) ~ ~

Creates a fresh vector of size (- end start), with all of the elements
of vec from start (inclusive) to end (exclusive).

Examples:

  > (vector-copy #(1 2 3 4))
  '#(1 2 3 4)
  > (vector-copy #(1 2 3 4) 3)
  '#(4)
  > (vector-copy #(1 2 3 4) 2 3)
  '#(3)

                                        *vector-filter*
(vector-filter pred vec) -> vector? ~
  pred : procedure? ~ ~
  vec : vector? ~ ~

Returns a fresh vector with the elements of vec for which  pred produces
a true value. The pred procedure is  applied to each element from first
to last.

Example:

  > (vector-filter even? #(1 2 3 4 5 6))
  '#(2 4 6)

                                        *vector-filter-not*
(vector-filter-not pred vec) -> vector? ~
  pred : procedure? ~ ~
  vec : vector? ~ ~

Like vector-filter, but the meaning of the pred predicate is reversed:
the result is a vector of all items for which pred returns #f.

Example:

  > (vector-filter-not even? #(1 2 3 4 5 6))
  '#(1 3 5)

                                        *vector-count*
(vector-count proc vec ...+) -> exact-nonnegative-integer? ~
  proc : procedure? ~ ~
  vec : vector? ~ ~

Returns the number of elements of the vec ... (taken in parallel) on
which proc does not evaluate to #f.

Examples:

  > (vector-count even? #(1 2 3 4 5))
  2
  > (vector-count = #(1 2 3 4 5) #(5 4 3 2 1))
  1

                                        *vector-argmin*
(vector-argmin proc vec) -> any/c ~
  proc : (-> any/c real?) ~ ~
  vec : vector? ~ ~

This returns the first element in the non-empty vector vec that
minimizes the result of proc.

Examples:

  > (vector-argmin car #((3 pears) (1 banana) (2 apples)))
  '(1 banana)
  > (vector-argmin car #((1 banana) (1 orange)))
  '(1 banana)

                                        *vector-argmax*
(vector-argmax proc vec) -> any/c ~
  proc : (-> any/c real?) ~ ~
  vec : vector? ~ ~

This returns the first element in the non-empty vector vec that
maximizes the result of proc.

Examples:

  > (vector-argmax car #((3 pears) (1 banana) (2 apples)))
  '(3 pears)
  > (vector-argmax car #((3 pears) (3 oranges)))
  '(3 pears)

                                        *vector-member*
(vector-member v vec) -> (or/c natural-number/c #f) ~
  v : any/c ~ ~
  vec : vector? ~ ~

Locates the first element of vec that is equal? to  v. If such an
element exists, the index of that element in  vec is returned.
Otherwise, the result is #f.

Examples:

  > (vector-member 2 (vector 1 2 3 4))
  1
  > (vector-member 9 (vector 1 2 3 4))
  #f

                                        *vector-memv*
(vector-memv v vec) -> (or/c natural-number/c #f) ~
  v : any/c ~ ~
  vec : vector? ~ ~

Like vector-member, but finds an element using eqv?.

Examples:

  > (vector-memv 2 (vector 1 2 3 4))
  1
  > (vector-memv 9 (vector 1 2 3 4))
  #f

                                        *vector-memq*
(vector-memq v vec) -> (or/c natural-number/c #f) ~
  v : any/c ~ ~
  vec : vector? ~ ~

Like vector-member, but finds an element using eq?.

Examples:

  > (vector-memq 2 (vector 1 2 3 4))
  1
  > (vector-memq 9 (vector 1 2 3 4))
  #f

                                        *vector-sort*
(vector-sort  vec                              ~
              less-than?                      
             [start                           
              end                             
              #:key key                        ~ ~
              #:cache-keys? cache-keys?]) -> vector? ~ ~
  vec : vector? ~ ~
  less-than? : (any/c any/c . -> . any/c) ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length vec) ~ ~
  key : (any/c . -> . any/c) = (λ (x) x) ~ ~
  cache-keys? : boolean? = #f ~ ~

Like sort, but operates on vectors; a  fresh vector of length (- end
start) is  returned containing the elements from indices  start
(inclusive) through end (exclusive)  of vec, but in sorted order (i.e.,
vec is  not modified). This sort is stable (i.e., the order of “equal”
elements is preserved).

Examples:

  > (define v1 (vector 4 3 2 1))
  > (vector-sort v1 <)
  '#(1 2 3 4)
  > v1
  '#(4 3 2 1)
  > (define v2 (vector '(4) '(3) '(2) '(1)))
  > (vector-sort v2 < 1 3 #:key car) ~ ~
  '#((2) (3))
  > v2
  '#((4) (3) (2) (1))

Added in version 6.6.0.5 of package base.

                                        *vector-sort!*
(vector-sort!  vec                              ~
               less-than?                      
              [start                           
               end                             
               #:key key                        ~ ~
               #:cache-keys? cache-keys?]) -> void? ~ ~
  vec : (and/c vector? (not/c immutable?)) ~ ~
  less-than? : (any/c any/c . -> . any/c) ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  end : exact-nonnegative-integer? = (vector-length vec) ~ ~
  key : (any/c . -> . any/c) = (λ (x) x) ~ ~
  cache-keys? : boolean? = #f ~ ~

Like vector-sort, but updates indices  start (inclusive) through end
(exclusive)  of vec by sorting them according to the less-than?
procedure.

Examples:

  > (define v1 (vector 4 3 2 1))
  > (vector-sort! v1 <)
  > v1
  '#(1 2 3 4)
  > (define v2 (vector '(4) '(3) '(2) '(1)))
  > (vector-sort! v2 < 1 3 #:key car) ~ ~
  > v2
  '#((4) (2) (3) (1))

Added in version 6.6.0.5 of package base.

13. Boxes

+[missing] in [missing] introduces boxes.

A box is like a single-element vector, normally used as minimal mutable
storage.

A box can be mutable or immutable. When an immutable box is provided to
a procedure like set-box!, the exn:fail:contract exception is raised.
Box constants generated by the default reader (see [missing]) are
immutable. Use immutable? to check whether a box is immutable.

A literal or printed box starts with #&. See [missing]     for
information on reading     boxes and [missing]     for information on
printing boxes.

                                        *box?*
(box? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a box, #f otherwise.

                                        *box*
(box v) -> box? ~
  v : any/c ~ ~

Returns a new mutable box that contains v.

                                        *box-immutable*
(box-immutable v) -> (and/c box? immutable?) ~
  v : any/c ~ ~

Returns a new immutable box that contains v.

                                        *unbox*
(unbox box) -> any/c ~
  box : box? ~ ~

Returns the content of box.

For any v, (unbox (box v)) and (unbox (box-immutable v)) returns v.

                                        *set-box!*
(set-box! box v) -> void? ~
  box : (and/c box? (not/c immutable?)) ~ ~
  v : any/c ~ ~

Sets the content of box to v.

                                        *unbox**
(unbox* box) -> any/c ~
  box : (and box? (not/c impersonator?)) ~ ~
(set-box*! box v) -> void?
  box : (and/c box? (not/c immutable?) (not/c impersonator?)) ~ ~
  v : any/c ~ ~

Like unbox and set-box!, but constrained to work on boxes that are not
impersonators.

Added in version 6.90.0.15.

                                        *box-cas!*
(box-cas! box old new) -> boolean? ~
  box : (and/c box? (not/c immutable?) (not/c impersonator?)) ~ ~
  old : any/c ~ ~
  new : any/c ~ ~

Atomically updates the contents of box to new, provided that box
currently contains a value that is eq? to old, and returns #t in that
case.  If box does not contain old, then the result is #f.

If no other threads or futures attempt to access box, the operation is
equivalent to

  (and (eq? old (unbox loc)) (set-box! loc new) #t)

except that box-cas! can spuriously fail on some platforms. That is,
with low probability, the result can be #f with the value in box left
unchanged, even if box contains old.

When Racket is compiled with support for futures, box-cas! is guaranteed
to use a hardware compare and set operation. Uses of box-cas! be
performed safely in a future (i.e., allowing the future thunk to
continue in parallel). See also [missing].

14. Hash Tables

+[missing] in [missing] introduces hash tables.

A hash table (or simply hash) maps each of its keys to a single value.
For a given hash table, keys are equivalent via equal?, eqv?, or eq?,
and keys are retained either strongly or weakly (see [missing]). A hash
table is also either mutable or immutable. Immutable hash tables support
effectively constant-time access and update, just like mutable hash
tables; the constant on immutable operations is usually larger, but the
functional nature of immutable hash tables can pay off in certain
algorithms. Use immutable? to check whether a hash table is immutable.

Immutable hash tables actually provide O(log N) access and update. Since
N is limited by the address space so that log N is limited to less than
30 or 62 (depending on the platform), log N can be treated reasonably as
a constant.

For equal?-based hashing, the built-in hash functions on strings, pairs,
lists, vectors, prefab or transparent structures, etc., take time
proportional to the size of the value. The hash code for a compound data
structure, such as a list or vector, depends on hashing each item of the
container, but the depth of such recursive hashing is limited (to avoid
potential problems with cyclic data). For a non-list pair, both car and
cdr hashing is treated as a deeper hash, but the cdr of a list is
treated as having the same hashing depth as the list.

A hash table can be used as a two-valued sequence (see Sequences). The
keys and values of the hash table serve as elements of the sequence
(i.e., each element is a key and its associated value). If a mapping is
added to or removed from the hash table during iteration, then an
iteration step may fail with exn:fail:contract, or the iteration may
skip or duplicate keys and values.  See also in-hash, in-hash-keys,
in-hash-values, and in-hash-pairs.

Two hash tables cannot be equal? unless they use the same key-comparison
procedure (equal?, eqv?, or eq?), both hold keys strongly or weakly, and
have the same mutability. Empty immutable hash tables are eq? when they
are equal?.

Changed in version 7.2.0.9: Made empty immutable hash tables eq? when
they are equal?.

Caveats concerning concurrent modification: A mutable hash table can be
manipulated with hash-ref, hash-set!, and hash-remove! concurrently by
multiple threads, and the operations are protected by a table-specific
semaphore as needed. Three caveats apply, however:

* If a thread is terminated while applying hash-ref, hash-ref-key,
  hash-set!, hash-remove!, hash-ref!, or hash-update! to a hash table
  that uses equal? or eqv? key comparisons, all current and future
  operations on the hash table may block indefinitely.

* The hash-map, hash-for-each, and hash-clear! procedures do not use the
  table’s semaphore to guard the traversal as a whole. Changes by one
  thread to a hash table can affect the keys and values seen by another
  thread part-way through its traversal of the same hash table.

* The hash-update! and hash-ref! functions use a table’s semaphore
  independently for the hash-ref and hash-set! parts of their
  functionality, which means that the update as a whole is not “atomic.”

Caveat concerning mutable keys: If a key in an equal?-based hash table
is mutated (e.g., a key string is modified with string-set!), then the
hash table’s behavior for insertion and lookup operations becomes
unpredictable.

A literal or printed hash table starts with #hash, #hasheqv, or #hasheq.
See [missing]     for information on reading     hash tables and
[missing]     for information on printing hash tables.

                                        *hash?*
(hash? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a hash table, #f otherwise.

                                        *hash-equal?*
(hash-equal? hash) -> boolean? ~
  hash : hash? ~ ~

Returns #t if hash compares keys with equal?, #f if it compares with eq?
or eqv?.

                                        *hash-eqv?*
(hash-eqv? hash) -> boolean? ~
  hash : hash? ~ ~

Returns #t if hash compares keys with eqv?, #f if it compares with
equal? or eq?.

                                        *hash-eq?*
(hash-eq? hash) -> boolean? ~
  hash : hash? ~ ~

Returns #t if hash compares keys with eq?, #f if it compares with equal?
or eqv?.

                                        *hash-weak?*
(hash-weak? hash) -> boolean? ~
  hash : hash? ~ ~

Returns #t if hash retains its keys weakly, #f if it retains keys
strongly.

                                        *hash*
(hash key val ... ...) -> (and/c hash? hash-equal? immutable?) ~
  key : any/c ~ ~
  val : any/c ~ ~
(hasheq key val ... ...) -> (and/c hash? hash-eq? immutable?)
  key : any/c ~ ~
  val : any/c ~ ~
(hasheqv key val ... ...) -> (and/c hash? hash-eqv? immutable?)
  key : any/c ~ ~
  val : any/c ~ ~

Creates an immutable hash table with each given key mapped to the
following val; each key must have a val, so the total number of
arguments to hash must be even.

The hash procedure creates a table where keys are compared with equal?,
hasheq procedure creates a table where keys are compared with eq?, and
hasheqv procedure creates a table where keys are compared with eqv?.

The key to val mappings are added to the table in the order that they
appear in the argument list, so later mappings can hide earlier mappings
if the keys are equal.

                                        *make-hash*
(make-hash [assocs]) -> (and/c hash? hash-equal?) ~
  assocs : (listof pair?) = null ~ ~
(make-hasheqv [assocs]) -> (and/c hash? hash-eqv?)
  assocs : (listof pair?) = null ~ ~
(make-hasheq [assocs]) -> (and/c hash? hash-eq?)
  assocs : (listof pair?) = null ~ ~

Creates a mutable hash table that holds keys strongly.

The make-hash procedure creates a table where keys are compared with
equal?, make-hasheq procedure creates a table where keys are compared
with eq?, and make-hasheqv procedure creates a table where keys are
compared with eqv?.

The table is initialized with the content of assocs.  In each element of
assocs, the car is a key, and the cdr is the corresponding value. The
mappings are added to the table in the order that they appear in assocs,
so later mappings can hide earlier mappings.

See also make-custom-hash.

                                        *make-weak-hash*
(make-weak-hash [assocs]) -> (and/c hash? hash-equal? hash-weak?) ~
  assocs : (listof pair?) = null ~ ~
(make-weak-hasheqv [assocs]) -> (and/c hash? hash-eqv? hash-weak?)
  assocs : (listof pair?) = null ~ ~
(make-weak-hasheq [assocs]) -> (and/c hash? hash-eq? hash-weak?)
  assocs : (listof pair?) = null ~ ~

Like make-hash, make-hasheq, and make-hasheqv, but creates a mutable
hash table that holds keys weakly.

Beware that values in the table are retained normally. If a value in the
table refers back to its key, then the table will retain the value and
therefore the key; the mapping will never be removed from the table even
if the key becomes otherwise inaccessible. To avoid that problem,
instead of mapping the key to the value, map the key to an ephemeron
that pairs the key and value. Beware further, however, that an
ephemeron’s value might be cleared between retrieving an ephemeron and
extracting its value, depending on whether the key is otherwise
reachable. For eq?-based mappings, consider using the pattern
(ephemeron-value ephemeron #f key) to extract the value of ephemeron
while ensuring that key is retained until the value is extracted.

                                        *make-immutable-hash*
(make-immutable-hash [assocs]) ~
 -> (and/c hash? hash-equal? immutable?)
  assocs : (listof pair?) = null ~ ~
(make-immutable-hasheqv [assocs])
 -> (and/c hash? hash-eqv? immutable?)
  assocs : (listof pair?) = null ~ ~
(make-immutable-hasheq [assocs])
 -> (and/c hash? hash-eq? immutable?)
  assocs : (listof pair?) = null ~ ~

Like hash, hasheq, and hasheqv, but accepts the key–value mapping in
association-list form like make-hash, make-hasheq, and make-hasheqv.

                                        *hash-set!*
(hash-set! hash key v) -> void? ~
  hash : (and/c hash? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Maps key to v in hash, overwriting any existing mapping for key.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-set*!*
(hash-set*! hash key v ... ...) -> void? ~
  hash : (and/c hash? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Maps each key to each v in hash, overwriting any existing mapping for
each key. Mappings are added from the left, so later mappings overwrite
earlier mappings.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-set*
(hash-set hash key v) -> (and/c hash? immutable?) ~
  hash : (and/c hash? immutable?) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Functionally extends hash by mapping key to v, overwriting any existing
mapping for key, and returning the extended hash table.

See also the caveat concerning mutable keys above.

                                        *hash-set**
(hash-set* hash key v ... ...) -> (and/c hash? immutable?) ~
  hash : (and/c hash? immutable?) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Functionally extends hash by mapping each key to v, overwriting any
existing mapping for each key, and returning the extended hash table.
Mappings are added from the left, so later mappings overwrite earlier
mappings.

See also the caveat concerning mutable keys above.

                                        *hash-ref*
(hash-ref hash key [failure-result]) -> any ~
  hash : hash? ~ ~
  key : any/c ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda ()
                     (raise (make-exn:fail:contract ....))) ~ ~

Returns the value for key in hash. If no value is found for key, then
failure-result determines the result:

* If failure-result is a procedure, it is called (through a tail call)
  with no arguments to produce the result.

* Otherwise, failure-result is returned as the result.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-ref-key*
(hash-ref-key hash key [failure-result]) -> any ~
  hash : hash? ~ ~
  key : any/c ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda ()
                     (raise (make-exn:fail:contract ....))) ~ ~

Returns the key held by hash that is equivalent to key according to
hash’s key-comparison function. If no key is found, then failure-result
is used as in hash-ref to determine the result.

If hash is not an impersonator, then the returned key, assuming it is
found, will be eq?-equivalent to the one actually retained by hash:

Examples:

  > (define original-key "hello")
  > (define key-copy (string-copy original-key))
  > (equal? original-key key-copy)
  #t
  > (eq? original-key key-copy)
  #f
  > (define table (make-hash))
  > (hash-set! table original-key 'value)
  > (eq? (hash-ref-key table "hello") original-key)
  #t
  > (eq? (hash-ref-key table "hello") key-copy)
  #f

If a mutable hash is updated multiple times using keys that are not
eq?-equivalent but are equivalent according to the hash’s key-comparison
procedure, the hash retains the first one:

Examples:

  > (define original-key "hello")
  > (define key-copy (string-copy original-key))
  > (define table (make-hash))
  > (hash-set! table original-key 'one)
  > (hash-set! table key-copy 'two)
  > (eq? (hash-ref-key table "hello") original-key)
  #t
  > (eq? (hash-ref-key table "hello") key-copy)
  #f

Conversely, an immutable hash retains the key that was most-recently
used to update it:

Examples:

  > (define original-key "hello")
  > (define key-copy (string-copy original-key))
  > (define table0 (hash))
  > (define table1 (hash-set table0 original-key 'one))
  > (define table2 (hash-set table1 key-copy 'two))
  > (eq? (hash-ref-key table2 "hello") original-key)
  #f
  > (eq? (hash-ref-key table2 "hello") key-copy)
  #t

If hash is an impersonator, then the returned key will be determined as
described in the documentation to impersonate-hash.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

Added in version 7.4.0.3.

                                        *hash-ref!*
(hash-ref! hash key to-set) -> any ~
  hash : hash? ~ ~
  key : any/c ~ ~
  to-set : failure-result/c ~ ~

Returns the value for key in hash.  If no value is found for key, then
to-set determines the result as in hash-ref (i.e., it is either a thunk
that computes a value or a plain value), and this result is stored in
hash for the key.  (Note that if to-set is a thunk, it is not invoked in
tail position.)

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-has-key?*
(hash-has-key? hash key) -> boolean? ~
  hash : hash? ~ ~
  key : any/c ~ ~

Returns #t if hash contains a value for the given key, #f otherwise.

                                        *hash-update!*
(hash-update!  hash                  ~
               key                  
               updater              
              [failure-result]) -> void?
  hash : (and/c hash? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  updater : (any/c . -> . any/c) ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda ()
                     (raise (make-exn:fail:contract ....))) ~ ~

Composes hash-ref and hash-set! to update an existing mapping in hash,
where the optional failure-result argument is used as in hash-ref when
no mapping exists for key already. See the caveat above about concurrent
updates.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-update*
(hash-update hash key updater [failure-result]) ~
 -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?) ~ ~
  key : any/c ~ ~
  updater : (any/c . -> . any/c) ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda ()
                     (raise (make-exn:fail:contract ....))) ~ ~

Composes hash-ref and hash-set to functionally update an existing
mapping in hash, where the optional failure-result argument is used as
in hash-ref when no mapping exists for key already.

See also the caveat concerning mutable keys above.

                                        *hash-remove!*
(hash-remove! hash key) -> void? ~
  hash : (and/c hash? (not/c immutable?)) ~ ~
  key : any/c ~ ~

Removes any existing mapping for key in hash.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-remove*
(hash-remove hash key) -> (and/c hash? immutable?) ~
  hash : (and/c hash? immutable?) ~ ~
  key : any/c ~ ~

Functionally removes any existing mapping for key in hash, returning the
fresh hash table.

See also the caveat concerning mutable keys above.

                                        *hash-clear!*
(hash-clear! hash) -> void? ~
  hash : (and/c hash? (not/c immutable?)) ~ ~

Removes all mappings from hash.

If hash is not an impersonator, then all mappings are removed in
constant time. If hash is an impersonator, then each key is removed
one-by-one using hash-remove!.

See also the caveats concerning concurrent modification and the caveat
concerning mutable keys above.

                                        *hash-clear*
(hash-clear hash) -> (and/c hash? immutable?) ~
  hash : (and/c hash? immutable?) ~ ~

Functionally removes all mappings from hash.

If hash is not a chaperone, then clearing is equivalent to creating a
new hash table, and the operation is performed in constant time.  If
hash is a chaperone, then each key is removed one-by-one using
hash-remove.

                                        *hash-copy-clear*
(hash-copy-clear hash) -> hash? ~
  hash : hash? ~ ~

Produces an empty hash table with the same key-comparison procedure and
mutability of hash.

                                        *hash-map*
(hash-map hash proc [try-order?]) -> (listof any/c) ~
  hash : hash? ~ ~
  proc : (any/c any/c . -> . any/c) ~ ~
  try-order? : any/c = #f ~ ~

Applies the procedure proc to each element in hash in an unspecified
order, accumulating the results into a list. The procedure proc is
called each time with a key and its value, and the procedure’s
individual results appear in order in the result list.

If a hash table is extended with new keys (either through proc or by
another thread) while a hash-map or hash-for-each traversal is in
process, arbitrary key–value pairs can be dropped or duplicated in the
traversal. Key mappings can be deleted or remapped (by any thread) with
no adverse affects; the change does not affect a traversal if the key
has been seen already, otherwise the traversal skips a deleted key or
uses the remapped key’s new value.

See also the caveats concerning concurrent modification above.

If try-order? is true, then the order of keys and values passed to proc
is normalized under certain circumstances—including when every key is
one of the following and with the following order (earlier bullets
before later):

* booleans sorted #f before #t;

* characters sorted by char<?;

* real numbers sorted by <;

* symbols sorted with uninterned symbols before unreadable symbols
  before interned symbols, then sorted by symbol<?;

* keywords sorted by keyword<?;

* strings sorted by string<?;

* byte strings sorted by bytes<?;

* null;

* #<void>; and

* eof.

Changed in version 6.3: Added the try-order? argument. Changed in
version 7.1.0.7: Added guarantees for try-order?.

                                        *hash-keys*
(hash-keys hash) -> (listof any/c) ~
  hash : hash? ~ ~

Returns a list of the keys of hash in an unspecified order.

See hash-map for information about modifying hash during hash-keys.

See also the caveats concerning concurrent modification above.

                                        *hash-values*
(hash-values hash) -> (listof any/c) ~
  hash : hash? ~ ~

Returns a list of the values of hash in an unspecified order.

See hash-map for information about modifying hash during hash-values.

See also the caveats concerning concurrent modification above.

                                        *hash->list*
(hash->list hash) -> (listof (cons/c any/c any/c)) ~
  hash : hash? ~ ~

Returns a list of the key–value pairs of hash in an unspecified order.

See hash-map for information about modifying hash during hash->list.

See also the caveats concerning concurrent modification above.

                                        *hash-keys-subset?*
(hash-keys-subset? hash1 hash2) -> boolean? ~
  hash1 : hash? ~ ~
  hash2 : hash? ~ ~

Returns #t if the keys of hash1 are a subset of or the same as the keys
of hash2. The hash tables must both use the same key-comparison function
(equal?, eqv?, or eq?), otherwise the exn:fail:contract exception is
raised.

Using hash-keys-subset? on immutable hash tables can be much faster than
iterating through the keys of hash1 to make sure that each is in hash2.

Added in version 6.5.0.8.

                                        *hash-for-each*
(hash-for-each hash proc [try-order?]) -> void? ~
  hash : hash? ~ ~
  proc : (any/c any/c . -> . any) ~ ~
  try-order? : any/c = #f ~ ~

Applies proc to each element in hash (for the side-effects of proc) in
an unspecified order. The procedure proc is called each time with a key
and its value.

See hash-map for information about try-order? and about modifying hash
within proc.

See also the caveats concerning concurrent modification above.

Changed in version 6.3: Added the try-order? argument. Changed in
version 7.1.0.7: Added guarantees for try-order?.

                                        *hash-count*
(hash-count hash) -> exact-nonnegative-integer? ~
  hash : hash? ~ ~

Returns the number of keys mapped by hash. Unless hash retains keys
weakly, the result is computed in constant time and atomically. If hash
retains it keys weakly, a traversal is required to count the keys.

                                        *hash-empty?*
(hash-empty? hash) -> boolean? ~
  hash : hash? ~ ~

Equivalent to (zero? (hash-count hash)).

                                        *hash-iterate-first*
(hash-iterate-first hash) ~
 -> (or/c #f exact-nonnegative-integer?)
  hash : hash? ~ ~

Returns #f if hash contains no elements, otherwise it returns an integer
that is an index to the first element in the hash table; “first” refers
to an unspecified ordering of the table elements, and the index values
are not necessarily consecutive integers.

For a mutable hash, this index is guaranteed to refer to the first item
only as long as no items are added to or removed from hash. More
generally, an index is guaranteed to be a valid hash index for a given
hash table only as long it comes from hash-iterate-first or
hash-iterate-next, and only as long as the hash table is not modified.
In the case of a hash table with weakly held keys, the hash table can be
implicitly modified by the garbage collector (see [missing]) when it
discovers that the key is not reachable.

                                        *hash-iterate-next*
(hash-iterate-next hash pos) ~
 -> (or/c #f exact-nonnegative-integer?)
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~

Returns either an integer that is an index to the element in hash after
the element indexed by pos (which is not necessarily one more than pos)
or #f if pos refers to the last element in hash.

If pos is not a valid hash index of hash, then the result may be #f or
it may be the next later index that remains valid. The latter result is
guaranteed if a hash table has been modified only by the removal of
keys.

Changed in version 7.0.0.10: Handle an invalid index by returning #f
instead of raising exn:fail:contract.

                                        *hash-iterate-key*
(hash-iterate-key hash pos) -> any/c ~
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
(hash-iterate-key hash pos bad-index-v) -> any/c
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  bad-index-v : any/c ~ ~

Returns the key for the element in hash at index pos.

If pos is not a valid hash index for hash, the result is bad-index-v if
provided, otherwise the exn:fail:contract exception is raised.

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *hash-iterate-value*
(hash-iterate-value hash pos) -> any ~
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
(hash-iterate-value hash pos bad-index-v) -> any
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  bad-index-v : any/c ~ ~

Returns the value for the element in hash at index pos.

If pos is not a valid hash index for hash, the result is bad-index-v if
provided, otherwise the exn:fail:contract exception is raised.

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *hash-iterate-pair*
(hash-iterate-pair hash pos) -> (cons any/c any/c) ~
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
(hash-iterate-pair hash pos bad-index-v) -> (cons any/c any/c)
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  bad-index-v : any/c ~ ~

Returns a pair containing the key and value for the element in hash at
index pos.

If pos is not a valid hash index for hash, the result is (cons
bad-index-v bad-index-v) if bad-index-v is provided, otherwise the
exn:fail:contract exception is raised.

Added in version 6.4.0.5. Changed in version 7.0.0.10: Added the
optional bad-index-v argument.

                                        *hash-iterate-key+value*
(hash-iterate-key+value hash pos) -> any/c any/c ~
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
(hash-iterate-key+value hash             
                        pos              
                        bad-index-v) -> any/c any/c
  hash : hash? ~ ~
  pos : exact-nonnegative-integer? ~ ~
  bad-index-v : any/c ~ ~

Returns the key and value for the element in hash at index pos.

If pos is not a valid hash index for hash, the result is (values
bad-index-v bad-index-v) if bad-index-v is provided, otherwise the
exn:fail:contract exception is raised.

Added in version 6.4.0.5. Changed in version 7.0.0.10: Added the
optional bad-index-v argument.

                                        *hash-copy*
(hash-copy hash) -> (and/c hash? (not/c immutable?)) ~
  hash : hash? ~ ~

Returns a mutable hash table with the same mappings, same key-comparison
mode, and same key-holding strength as hash.

14.1. Additional Hash Table Functions

 (require racket/hash) package: base ~ ~

The bindings documented in this section are provided by the racket/hash
library, not racket/base or racket.

                                        *hash-union*
(hash-union  h0                           ~
             h ...                       
            [#:combine combine            ~ ~
             #:combine/key combine/key])  ~ ~
 -> (and/c hash? immutable?)
  h0 : (and/c hash? immutable?) ~ ~
  h : hash? ~ ~
  combine : (-> any/c any/c any/c) ~ ~
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c) ~ ~
              = (lambda (k a b) (combine a b))

Computes the union of h0 with each hash table h by functional update,
adding each element of each h to h0 in turn.  For each key k and value
v, if a mapping from k to some value v0 already exists, it is replaced
with a mapping from k to (combine/key k v0 v).

Examples:

  > (hash-union (make-immutable-hash '([1 . one]))
                (make-immutable-hash '([2 . two]))
                (make-immutable-hash '([3 . three])))
  '#hash((1 . one) (2 . two) (3 . three))
  > (hash-union (make-immutable-hash '([1    one uno]  [2    two dos]))
                (make-immutable-hash '([1    eins un]  [2    zwei deux]))
                #:combine/key (lambda (k v1 v2) (append v1 v2))) ~ ~
  '#hash((1 . (one uno eins un)) (2 . (two dos zwei deux)))

                                        *hash-union!*
(hash-union!  h0                               ~
              h ...                           
             [#:combine combine                ~ ~
              #:combine/key combine/key]) -> void? ~ ~
  h0 : (and/c hash? (not/c immutable?)) ~ ~
  h : hash? ~ ~
  combine : (-> any/c any/c any/c) ~ ~
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c) ~ ~
              = (lambda (k a b) (combine a b))

Computes the union of h0 with each hash table h by mutable update,
adding each element of each h to h0 in turn.  For each key k and value
v, if a mapping from k to some value v0 already exists, it is replaced
with a mapping from k to (combine/key k v0 v).

Examples:

  > (define h (make-hash))
  > h
  '#hash()
  >
  (hash-union! h (make-immutable-hash '([1    one uno]  [2    two dos])))
  > h
  '#hash((1 . (one uno)) (2 . (two dos)))
  > (hash-union! h
                 (make-immutable-hash '([1    eins un]  [2    zwei deux]))
                 #:combine/key (lambda (k v1 v2) (append v1 v2))) ~ ~
  > h
  '#hash((1 . (one uno eins un)) (2 . (two dos zwei deux)))

15. Sequences and Streams

Sequences and streams abstract over iteration of elements in a
collection. Sequences allow iteration with for macros or with sequence
operations such as sequence-map. Streams are functional sequences that
can be used either in a generic way or a stream-specific way. Generators
are closely related stateful objects that can be converted to a sequence
and vice-versa.

    15.1 Sequences
      15.1.1 Sequence Predicate and Constructors
      15.1.2 Sequence Conversion
      15.1.3 Additional Sequence Operations
        15.1.3.1 Additional Sequence Constructors
    15.2 Streams
    15.3 Generators

15.1. Sequences

+[missing] in [missing] introduces sequences.

A sequence encapsulates an ordered collection of values. The elements of
a sequence can be extracted with one of the for syntactic forms, with
the procedures returned by sequence-generate, or by converting the
sequence into a stream.

The sequence datatype overlaps with many other datatypes.  Among
built-in datatypes, the sequence datatype includes the following:

* exact nonnegative integers (see below)

* strings (see Strings)

* byte strings (see Byte Strings)

* lists (see Pairs and Lists)

* mutable lists (see Mutable Pairs and Lists)

* vectors (see Vectors)

* flvectors (see Flonum Vectors)

* fxvectors (see Fixnum Vectors)

* hash tables (see Hash Tables)

* dictionaries (see Dictionaries)

* sets (see Sets)

* input ports (see [missing])

* streams (see Streams)

An exact number k that is a non-negative integer acts as a sequence
similar to (in-range k), except that k by itself is not a stream.

Custom sequences can be defined using structure type properties.  The
easiest method to define a custom sequence is to use the gen:stream
generic interface. Streams are a suitable abstraction for data
structures that are directly iterable.  For example, a list is directly
iterable with first and rest. On the other hand, vectors are not
directly iterable: iteration has to go through an index. For data
structures that are not directly iterable, the iterator for the data
structure can be defined to be a stream (e.g., a structure containing
the index of a vector).

For example, unrolled linked lists (represented as a list of vectors)
themselves do not fit the stream abstraction, but have index-based
iterators that can be represented as streams:

Examples:

  > (struct unrolled-list-iterator (idx lst)
      #:methods gen:stream ~ ~
      [(define (stream-empty? iter)
         (define lst (unrolled-list-iterator-lst iter))
         (or (null? lst)
             (and (>= (unrolled-list-iterator-idx iter)
                      (vector-length (first lst)))
                  (null? (rest lst)))))
       (define (stream-first iter)
         (vector-ref (first (unrolled-list-iterator-lst iter))
                     (unrolled-list-iterator-idx iter)))
       (define (stream-rest iter)
         (define idx (unrolled-list-iterator-idx iter))
         (define lst (unrolled-list-iterator-lst iter))
         (if (>= idx (sub1 (vector-length (first lst))))
             (unrolled-list-iterator 0 (rest lst))
             (unrolled-list-iterator (add1 idx) lst)))])
  > (define (make-unrolled-list-iterator ul)
      (unrolled-list-iterator 0 (unrolled-list-lov ul)))
  > (struct unrolled-list (lov)
      #:property prop:sequence ~ ~
      make-unrolled-list-iterator)
  > (define ul1 (unrolled-list '(#(cracker biscuit) #(cookie scone))))
  > (for/list ([x ul1]) x)
  '(cracker biscuit cookie scone)

The prop:sequence property provides more flexibility in specifying
iteration, such as when a pre-processing step is needed to prepare the
data for iteration.  The make-do-sequence function creates a sequence
given a thunk that returns procedures to implement a sequence, and the
prop:sequence property can be associated with a structure type to
implement its implicit conversion to a sequence.

For most sequence types, extracting elements from a sequence has no
side-effect on the original sequence value; for example, extracting the
sequence of elements from a list does not change the list.  For other
sequence types, each extraction implies a side effect; for example,
extracting the sequence of bytes from a port causes the bytes to be read
from the port. A sequence’s state may either span all uses of the
sequence, as for a port, or it may be confined to each distinct time
that a sequence is initiated by a for form, sequence->stream,
sequence-generate, or sequence-generate*. Concretely, the thunk passed
to make-do-sequence is called to initiate the sequence each time the
sequence is used.

Individual elements of a sequence typically correspond to single values,
but an element may also correspond to multiple values.  For example, a
hash table generates two values—a key and its value—for each element in
the sequence.

15.1.1. Sequence Predicate and Constructors

                                        *sequence?*
(sequence? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v can be used as a sequence,   #f otherwise.

Examples:

  > (sequence? 42)
  #t
  > (sequence? '(a b c))
  #t
  > (sequence? "word")
  #t
  > (sequence? #\x)
  #f

                                        *in-range*
(in-range end) -> stream? ~
  end : real? ~ ~
(in-range start end [step]) -> stream?
  start : real? ~ ~
  end : real? ~ ~
  step : real? = 1 ~ ~

Returns a sequence (that is also a stream) whose elements are numbers.
The single-argument case (in-range end) is equivalent to (in-range 0 end
1).  The first number in the sequence is start, and each successive
element is generated by adding step to the previous element.  The
sequence stops before an element that would be greater or equal to end
if step is non-negative, or less or equal to end if step is negative.

An in-range application can provide better performance for number
iteration when it appears directly in a for clause.

Example: gaussian sum

  > (for/sum ([x (in-range 10)]) x)
  45

Example: sum of even numbers

  > (for/sum ([x (in-range 0 100 2)]) x)
  2450

When given zero as step, in-range returns an infinite sequence. It may
also return infinite sequences when step is a very small number, and
either step or the sequence elements are floating-point numbers.

                                        *in-naturals*
(in-naturals [start]) -> stream? ~
  start : exact-nonnegative-integer? = 0 ~ ~

Returns an infinite sequence (that is also a stream) of exact integers
starting with start, where each element is one more than the preceding
element.

An in-naturals application can provide better performance for integer
iteration when it appears directly in a for clause.

Example:

  > (for/list ([k (in-naturals)]
               [x (in-range 10)])
      (list k x))
  '((0 0) (1 1) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9))

                                        *in-list*
(in-list lst) -> stream? ~
  lst : list? ~ ~

Returns a sequence (that is also a stream) that is equivalent   to using
lst directly as a sequence.

See Pairs and Lists for information on using lists as sequences.

An in-list application can provide better performance for list iteration
when it appears directly in a for clause.

See for for information on the reachability of list elements during an
iteration.

Example:

  > (for/list ([x (in-list '(3 1 4))])
      `(,x ,(* x x)))
  '((3 9) (1 1) (4 16))

Changed in version 6.7.0.4: Improved element-reachability guarantee for
lists in for.

                                        *in-mlist*
(in-mlist mlst) -> sequence? ~
  mlst : mlist? ~ ~

Returns a sequence equivalent to mlst.

See Mutable Pairs and Lists for information on using mutable lists as
sequences.

An in-mlist application can provide better performance for mutable list
iteration when it appears directly in a for clause.

Example:

  > (for/list ([x (in-mlist (mcons "RACKET" (mcons "LANG" '())))])
      (string-length x))
  '(6 4)

                                        *in-vector*
(in-vector vec [start stop step]) -> sequence? ~
  vec : vector? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~

Returns a sequence equivalent to vec when no optional arguments are
supplied.

See Vectors for information on using vectors as sequences.

The optional arguments start, stop, and step are analogous to in-range,
except that a #f value for stop is equivalent to (vector-length vec).
That is, the first element in the sequence is (vector-ref vec start),
and each successive element is generated by adding step to index of the
previous element.  The sequence stops before an index that would be
greater or equal to end if step is non-negative, or less or equal to end
if step is negative.

If start is not a valid index, then the exn:fail:contract exception is
raised, except when start, stop, and (vector-length vec) are equal, in
which case the result is an empty sequence.

Examples:

  > (for ([x (in-vector (vector 1) 1)]) x)
  > (for ([x (in-vector (vector 1) 2)]) x)
  in-vector: starting index is out of range
    starting index: 2 ~ ~
    valid range: [0, 0] ~ ~
    vector: '#(1) ~ ~
  > (for ([x (in-vector (vector) 0 0)]) x)
  > (for ([x (in-vector (vector 1) 1 1)]) x)

If stop is not in [-1, (vector-length vec)], then the exn:fail:contract
exception is raised.

If start is less than stop and step is negative, then the
exn:fail:contract exception is raised.  Similarly, if start is more than
stop and step is positive, then the exn:fail:contract exception is
raised.

An in-vector application can provide better performance for vector
iteration when it appears directly in a for clause.

Examples:

  > (define (histogram vector-of-words)
      (define a-hash (make-hash))
      (for ([word (in-vector vector-of-words)])
        (hash-set! a-hash word (add1 (hash-ref a-hash word 0))))
      a-hash)
  > (histogram #("hello" "world" "hello" "sunshine"))
  '#hash(("hello" . 2) ("sunshine" . 1) ("world" . 1))

                                        *in-string*
(in-string str [start stop step]) -> sequence? ~
  str : string? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~

Returns a sequence equivalent to str when no optional arguments are
supplied.

See Strings for information on using strings as sequences.

The optional arguments start, stop, and step are as in in-vector.

An in-string application can provide better performance for string
iteration when it appears directly in a for clause.

Examples:

  > (define (line-count str)
      (for/sum ([ch (in-string str)])
        (if (char=? #\newline ch) 1 0)))
  > (line-count "this string\nhas\nthree \nnewlines")
  3

                                        *in-bytes*
(in-bytes bstr [start stop step]) -> sequence? ~
  bstr : bytes? ~ ~
  start : exact-nonnegative-integer? = 0 ~ ~
  stop : (or/c exact-integer? #f) = #f ~ ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~ ~

Returns a sequence equivalent to bstr when no optional arguments are
supplied.

See Byte Strings for information on using byte strings as sequences.

The optional arguments start, stop, and step are as in in-vector.

An in-bytes application can provide better performance for byte string
iteration when it appears directly in a for clause.

Examples:

  > (define (has-eof? bs)
      (for/or ([ch (in-bytes bs)])
        (= ch 0)))
  > (has-eof? #"this byte string has an \0embedded zero byte")
  #t
  > (has-eof? #"this byte string does not")
  #f

                                        *in-port*
(in-port [r in]) -> sequence? ~
  r : (input-port? . -> . any/c) = read ~ ~
  in : input-port? = (current-input-port) ~ ~

Returns a sequence whose elements are produced by calling r on in until
it produces eof.

                                        *in-input-port-bytes*
(in-input-port-bytes in) -> sequence? ~
  in : input-port? ~ ~

Returns a sequence equivalent to (in-port read-byte in).

                                        *in-input-port-chars*
(in-input-port-chars in) -> sequence? ~
  in : input-port? ~ ~

Returns a sequence whose elements are read as characters from in
(equivalent to (in-port read-char in)).

                                        *in-lines*
(in-lines [in mode]) -> sequence? ~
  in : input-port? = (current-input-port) ~ ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
       = 'any

Returns a sequence equivalent to (in-port (lambda (p) (read-line p
mode)) in).  Note that the default mode is 'any, whereas the default
mode of read-line is 'linefeed.

                                        *in-bytes-lines*
(in-bytes-lines [in mode]) -> sequence? ~
  in : input-port? = (current-input-port) ~ ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
       = 'any

Returns a sequence equivalent to (in-port (lambda (p) (read-bytes-line p
mode)) in).  Note that the default mode is 'any, whereas the default
mode of read-bytes-line is 'linefeed.

                                        *in-hash*
(in-hash hash) -> sequence? ~
  hash : hash? ~ ~
(in-hash hash bad-index-v) -> sequence?
  hash : hash? ~ ~
  bad-index-v : any/c ~ ~

Returns a sequence equivalent to hash, except when bad-index-v is
supplied.

If bad-index-v is supplied, then bad-index-v is returned as both the key
and the value in the case that the hash is modified concurrently so that
iteration does not have a valid hash index. Providing bad-index-v is
particularly useful when iterating through a hash table with weakly held
keys, since entries can be removed asynchronously (i.e., after in-hash
has committed to another iteration, but before it can access the entry
for the next iteration).

Examples:

  > (define table (hash 'a 1 'b 2))
  > (for ([(key value) (in-hash table)])
      (printf "key: ~a value: ~a\n" key value)) ~ ~
  key: a value: 1
  key: b value: 2

See Hash Tables for information on using hash tables as sequences.

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *in-hash-keys*
(in-hash-keys hash) -> sequence? ~
  hash : hash? ~ ~
(in-hash-keys hash bad-index-v) -> sequence?
  hash : hash? ~ ~
  bad-index-v : any/c ~ ~

Returns a sequence whose elements are the keys of hash, using
bad-index-v in the same way as in-hash.

Examples:

  > (define table (hash 'a 1 'b 2))
  > (for ([key (in-hash-keys table)])
      (printf "key: ~a\n" key)) ~ ~
  key: a
  key: b

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *in-hash-values*
(in-hash-values hash) -> sequence? ~
  hash : hash? ~ ~
(in-hash-values hash bad-index-v) -> sequence?
  hash : hash? ~ ~
  bad-index-v : any/c ~ ~

Returns a sequence whose elements are the values of hash, using
bad-index-v in the same way as in-hash.

Examples:

  > (define table (hash 'a 1 'b 2))
  > (for ([value (in-hash-values table)])
      (printf "value: ~a\n" value)) ~ ~
  value: 1
  value: 2

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *in-hash-pairs*
(in-hash-pairs hash) -> sequence? ~
  hash : hash? ~ ~
(in-hash-pairs hash bad-index-v) -> sequence?
  hash : hash? ~ ~
  bad-index-v : any/c ~ ~

Returns a sequence whose elements are pairs, each containing a key and
its value from hash (as opposed to using hash directly as a sequence to
get the key and value as separate values for each element).

The bad-index-v argument, if supplied, is used in the same way as by
in-hash. When an invalid index is encountered, the pair in the sequence
with have bad-index-v as both its car and cdr.

Examples:

  > (define table (hash 'a 1 'b 2))
  > (for ([key+value (in-hash-pairs table)])
      (printf "key and value: ~a\n" key+value)) ~ ~
  key and value: (a . 1)
  key and value: (b . 2)

Changed in version 7.0.0.10: Added the optional bad-index-v argument.

                                        *in-mutable-hash*
(in-mutable-hash hash) -> sequence? ~
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
(in-mutable-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
  bad-index-v : any/c ~ ~
(in-mutable-hash-keys hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
(in-mutable-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
  bad-index-v : any/c ~ ~
(in-mutable-hash-values hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
(in-mutable-hash-values hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
  bad-index-v : any/c ~ ~
(in-mutable-hash-pairs hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
(in-mutable-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) (not/c hash-weak?)) ~ ~
  bad-index-v : any/c ~ ~
(in-immutable-hash hash) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
(in-immutable-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
  bad-index-v : any/c ~ ~
(in-immutable-hash-keys hash) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
(in-immutable-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
  bad-index-v : any/c ~ ~
(in-immutable-hash-values hash) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
(in-immutable-hash-values hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
  bad-index-v : any/c ~ ~
(in-immutable-hash-pairs hash) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
(in-immutable-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?) ~ ~
  bad-index-v : any/c ~ ~
(in-weak-hash hash) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
(in-weak-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
  bad-index-v : any/c ~ ~
(in-weak-hash-keys hash) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
(in-weak-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
  bad-index-v : any/c ~ ~
(in-weak-hash-values hash) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
(in-weak-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
  bad-index-v : any/c ~ ~
(in-weak-hash-pairs hash) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
(in-weak-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?) ~ ~
  bad-index-v : any/c ~ ~

Sequence constructors for specific kinds of hash tables. These may
perform better than the analogous in-hash forms.

Added in version 6.4.0.6. Changed in version 7.0.0.10: Added the
optional bad-index-v argument.

                                        *in-directory*
(in-directory [dir use-dir?]) -> sequence? ~
  dir : (or/c #f path-string?) = #f ~ ~
  use-dir? : ((and/c path? complete-path?) . -> . any/c) ~ ~
           = (lambda (dir-path) #t)

Returns a sequence that produces all of the paths for files,
directories, and links within dir, except for the   contents of any
directory for which use-dir? returns   #f. If dir is not   #f, then
every produced path starts with dir as   its prefix.  If dir is #f, then
paths in and   relative to the current directory are produced.

An in-directory sequence traverses nested subdirectories   recursively
(filtered by use-dir?).   To generate a sequence that includes only the
immediate   content of a directory, use the result of directory-list as
a sequence.

The immediate content of each directory is reported as sorted by
path<?, and the content of a subdirectory is reported   before
subsequent paths within the directory.

Examples:

  > (current-directory (collection-path "info"))
  > (for/list ([f (in-directory)])
       f)
  '(#<path:main.rkt>
    #<path:compiled> ~ ~
    #<path:compiled/main_rkt.dep> ~ ~
    #<path:compiled/main_rkt.zo>) ~ ~
  > (for/list ([f (in-directory "compiled")])
      f)
  '(#<path:main_rkt.dep> #<path:main_rkt.zo>)
  > (for/list ([f (in-directory "compiled")])
      f)
  '(#<path:compiled/main_rkt.dep> #<path:compiled/main_rkt.zo>)
  > (for/list ([f (in-directory #f (lambda (p)
                                     (not (regexp-match? #rx"compiled" p))))])
       f)
  '(#<path:main.rkt> #<path:compiled>)

Changed in version 6.0.0.1: Added use-dir? argument. Changed in version
6.6.0.4: Added guarantee of sorted results.

                                        *in-producer*
(in-producer producer) -> sequence? ~
  producer : procedure? ~ ~
(in-producer producer stop arg ...) -> sequence?
  producer : procedure? ~ ~
  stop : any/c ~ ~
  arg : any/c ~ ~

Returns a sequence that contains values from sequential calls to
producer, which would usually use some state to do its work.

If a stop value is not given, the sequence goes on infinitely, and
therefore it common to use it with a finite sequence or using #:break
etc.  If a stop value is given, it is used to identify a value that
marks the end of the sequence (and the stop value is not included in the
sequence); stop can be a predicate that is applied to the results of
producer, or it can be a value that is tested against the result of with
eq?.  (The stop argument must be a predicate if the stop value is itself
a function or if producer returns multiple values.)

If additional args are specified, they are passed to every call to
producer.

Examples:

  > (define (counter)
      (define n 0)
      (lambda ([d 1]) (set! n (+ d n)) n))
  > (for/list ([x (in-producer (counter))] [y (in-range 4)]) x)
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter))] #:break (= x 5)) x) ~ ~
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter) 5)]) x)
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter) 5 1/2)]) x)
  '(1/2 1 3/2 2 5/2 3 7/2 4 9/2)
  > (for/list ([x (in-producer read eof (open-input-string "1 2 3"))]) x)
  '(1 2 3)

                                        *in-value*
(in-value v) -> sequence? ~
  v : any/c ~ ~

Returns a sequence that produces a single value: v.  This form is mostly
useful for let-like bindings in forms such as for*/list.

                                        *in-indexed*
(in-indexed seq) -> sequence? ~
  seq : sequence? ~ ~

Returns a sequence where each element has two values: the value produced
by seq, and a non-negative exact integer starting with 0.  The elements
of seq must be single-valued.

                                        *in-sequences*
(in-sequences seq ...) -> sequence? ~
  seq : sequence? ~ ~

Returns a sequence that is made of all input sequences, one after the
other. Each seq is initiated only after the preceding seq is exhausted.
If a single seq is provided, then seq is returned; otherwise, the
elements of each seq must all have the same number of values.

                                        *in-cycle*
(in-cycle seq ...) -> sequence? ~
  seq : sequence? ~ ~

Similar to in-sequences, but the sequences are repeated in an infinite
cycle, where each seq is initiated afresh in each iteration. Beware that
if no seqs are provided or if all seqs become empty, then the sequence
produced by in-cycle never returns when an element is demanded—or even
when the sequence is initiated, if all seqs are initially empty.

                                        *in-parallel*
(in-parallel seq ...) -> sequence? ~
  seq : sequence? ~ ~

Returns a sequence where each element has as many values as the number
of supplied seqs; the values, in order, are the values of each seq.  The
elements of each seq must be single-valued.

                                        *in-values-sequence*
(in-values-sequence seq) -> sequence? ~
  seq : sequence? ~ ~

Returns a sequence that is like seq, but it combines multiple values for
each element from seq as a list of elements.

                                        *in-values*-sequence*
(in-values*-sequence seq) -> sequence? ~
  seq : sequence? ~ ~

Returns a sequence that is like seq, but when an element of seq has
multiple values or a single list value, then the values are combined in
a list. In other words, in-values*-sequence is like in-values-sequence,
except that non-list, single-valued elements are not wrapped in a list.

                                        *stop-before*
(stop-before seq pred) -> sequence? ~
  seq : sequence? ~ ~
  pred : (any/c . -> . any) ~ ~

Returns a sequence that contains the elements of seq (which must be
single-valued), but only until the last element for which applying pred
to the element produces #t, after which the sequence ends.

                                        *stop-after*
(stop-after seq pred) -> sequence? ~
  seq : sequence? ~ ~
  pred : (any/c . -> . any) ~ ~

Returns a sequence that contains the elements of seq (which must be
single-valued), but only until the element (inclusive) for which
applying pred to the element produces #t, after which the sequence ends.

                                        *make-do-sequence*
(make-do-sequence thunk) -> sequence? ~
  thunk : (or/c (-> (values (any/c . -> . any) ~ ~
                            (any/c . -> . any/c)
                            any/c
                            (or/c (any/c . -> . any/c) #f)
                            (or/c (() () #:rest list? . ->* . any/c) #f) ~ ~
                            (or/c ((any/c) () #:rest list? . ->* . any/c) #f))) ~ ~
                (-> (values (any/c . -> . any)
                            (or/c (any/c . -> . any/c) #f)
                            (any/c . -> . any/c)
                            any/c
                            (or/c (any/c . -> . any/c) #f)
                            (or/c (() () #:rest list? . ->* . any/c) #f) ~ ~
                            (or/c ((any/c) () #:rest list? . ->* . any/c) #f)))) ~ ~

Returns a sequence whose elements are generated by the procedures   and
initial value returned by the thunk, which is called to   initiate the
sequence.  The initiated sequence is defined in   terms of a position,
which is initialized to the third   result of the thunk, and the
element, which may consist of   multiple values.

The thunk results define the generated elements as follows:

* The first result is a pos->element procedure that takes the current
  position and returns the value(s) for the current element.

* The optional second result is an early-next-pos procedure that is
  described further below. Alternatively, the optional second result can
  be #f, which is equivalent to the identity function.

* The third (or second) result is a next-pos procedure that takes the
  current position and returns the next position.

* The fourth (or third) result is the initial position.

* The fifth (or fourth) result is a continue-with-pos? function that
  takes the current position and returns a true result if the sequence
  includes the value(s) for the current position, and false if the
  sequence should end instead of including the value(s). Alternatively,
  the fifth (or fourth) result can be #f to indicate that the sequence
  should always include the current value(s). This function is checked
  on each position before pos->element is used.

* The sixth (or fifth) result is a continue-with-val? function that is
  like the fourth result, but it takes the current element value(s)
  instead of the current position.  Alternatively, the sixth (or fifth)
  result can be #f to indicate that the sequence should always include
  the value(s) at the current position.

* The seventh (or sixth) result is a continue-after-pos+val? procedure
  that takes both the current position and the current element value(s)
  and determines whether the sequence ends after the current element is
  already included in the sequence. Alternatively, the seventh (or
  sixth) result can be #f to indicate that the sequence can always
  continue after the current value(s).

The early-next-pos procedure, which is the optional second   result,
takes the current position and returns an updated position.   This
updated position is used for next-pos and   continue-after-pos+val?, but
not with   continue-with-pos? (which uses the original current
position). The intent of early-next-pos is to support a   sequence where
the position must be incremented to avoid keeping a   value reachable
while a loop processes the sequence value, so   early-next-pos is
applied just after   pos->element.

Each of the procedures listed above is called only once per   position.
Among the last three procedures, as soon as one of the   procedures
returns #f, the sequence ends, and none are   called again.  Typically,
one of the functions determines the end   condition, and #f is used in
place of the other two   functions.

Changed in version 6.7.0.4: Added support for the optional second
result.

prop:sequence : struct-type-property? ~ ~

Associates a procedure to a structure type that takes an instance of the
structure and returns a sequence.  If v is an instance of a structure
type with this property, then (sequence? v) produces #t.

Using a pre-existing sequence:

Examples:

  > (struct my-set (table)
      #:property prop:sequence ~ ~
      (lambda (s)
        (in-hash-keys (my-set-table s))))
  > (define (make-set . xs)
      (my-set (for/hash ([x (in-list xs)])
                (values x #t))))
  > (for/list ([c (make-set 'celeriac 'carrot 'potato)])
      c)
  '(celeriac potato carrot)

Using make-do-sequence:

Examples:

  > (define-struct train (car next)
      #:property prop:sequence ~ ~
      (lambda (t)
        (make-do-sequence
         (lambda ()
           (values train-car train-next t
                   (lambda (t) t)
                   (lambda (v) #t)
                   (lambda (t v) #t))))))
  > (for/list ([c (make-train 'engine
                              (make-train 'boxcar
                                          (make-train 'caboose
                                                      #f)))])
      c)
  '(engine boxcar caboose)

15.1.2. Sequence Conversion

                                        *sequence->stream*
(sequence->stream seq) -> stream? ~
  seq : sequence? ~ ~

Coverts a sequence to a stream, which supports the stream-first and
stream-rest operations. Creation of the stream eagerly initiates the
sequence, but the stream lazily draws elements from the sequence,
caching each element so that stream-first produces the same result each
time is applied to a stream.

If extracting an element from seq involves a side-effect, then the
effect is performed each time that either stream-first or stream-rest is
first used to access or skip an element.

                                        *sequence-generate*
(sequence-generate seq) -> (-> boolean?) (-> any) ~
  seq : sequence? ~ ~

Initiates a sequence and returns two thunks to extract elements from the
sequence.  The first returns #t if more values are available for the
sequence.  The second returns the next element (which may be multiple
values) from the sequence; if no more elements are available, the
exn:fail:contract exception is raised.

                                        *sequence-generate**
(sequence-generate* seq) ~
 -> (or/c list? #f)
    (-> (values (or/c list? #f) procedure?))
  seq : sequence? ~ ~

Like sequence-generate, but avoids state (aside from any inherent in the
sequence) by returning a list of values for the sequence’s first
element—or #f if the sequence is empty—and a thunk to continue with the
sequence; the result of the thunk is the same as the result of
sequence-generate*, but for the second element of the sequence, and so
on. If the thunk is called when the element result is #f (indicating no
further values in the sequence), the exn:fail:contract exception is
raised.

15.1.3. Additional Sequence Operations

 (require racket/sequence) package: base ~ ~

The bindings documented in this section are provided by the
racket/sequence and racket libraries, but not racket/base.

empty-sequence : sequence? ~ ~

A sequence with no elements.

                                        *sequence->list*
(sequence->list s) -> list? ~
  s : sequence? ~ ~

Returns a list whose elements are the elements of s, each of which must
be a single value.  If s is infinite, this function does not terminate.

                                        *sequence-length*
(sequence-length s) -> exact-nonnegative-integer? ~
  s : sequence? ~ ~

Returns the number of elements of s by extracting and discarding all of
them.  If s is infinite, this function does not terminate.

                                        *sequence-ref*
(sequence-ref s i) -> any ~
  s : sequence? ~ ~
  i : exact-nonnegative-integer? ~ ~

Returns the ith element of s (which may be multiple values).

                                        *sequence-tail*
(sequence-tail s i) -> sequence? ~
  s : sequence? ~ ~
  i : exact-nonnegative-integer? ~ ~

Returns a sequence equivalent to s, except that the first i elements are
omitted.

In case initiating s involves a side effect, the sequence s is not
initiated until the resulting sequence is initiated, at which point the
first i elements are extracted from the sequence.

                                        *sequence-append*
(sequence-append s ...) -> sequence? ~
  s : sequence? ~ ~

Returns a sequence that contains all elements of each sequence in the
order they appear in the original sequences.  The new sequence is
constructed lazily.

If all given ss are streams, the result is also a stream.

                                        *sequence-map*
(sequence-map f s) -> sequence? ~
  f : procedure? ~ ~
  s : sequence? ~ ~

Returns a sequence that contains f applied to each element of s.  The
new sequence is constructed lazily.

If s is a stream, then the result is also a stream.

                                        *sequence-andmap*
(sequence-andmap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~ ~
  s : sequence? ~ ~

Returns #t if f returns a true result on every element of s.  If s is
infinite and f never returns a false result, this function does not
terminate.

                                        *sequence-ormap*
(sequence-ormap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~ ~
  s : sequence? ~ ~

Returns #t if f returns a true result on some element of s.  If s is
infinite and f never returns a true result, this function does not
terminate.

                                        *sequence-for-each*
(sequence-for-each f s) -> void? ~
  f : (-> any/c ... any) ~ ~
  s : sequence? ~ ~

Applies f to each element of s.  If s is infinite, this function does
not terminate.

                                        *sequence-fold*
(sequence-fold f i s) -> any/c ~
  f : (-> any/c any/c ... any/c) ~ ~
  i : any/c ~ ~
  s : sequence? ~ ~

Folds f over each element of s with i as the initial accumulator.  If s
is infinite, this function does not terminate. The f function takes the
accumulator as its first argument and the next sequence element as its
second.

                                        *sequence-count*
(sequence-count f s) -> exact-nonnegative-integer? ~
  f : procedure? ~ ~
  s : sequence? ~ ~

Returns the number of elements in s for which f returns a true result.
If s is infinite, this function does not terminate.

                                        *sequence-filter*
(sequence-filter f s) -> sequence? ~
  f : (-> any/c ... boolean?) ~ ~
  s : sequence? ~ ~

Returns a sequence whose elements are the elements of s for which f
returns a true result.  Although the new sequence is constructed lazily,
if s has an infinite number of elements where f returns a false result
in between two elements where f returns a true result, then operations
on this sequence will not terminate during the infinite sub-sequence.

If s is a stream, then the result is also a stream.

                                        *sequence-add-between*
(sequence-add-between s e) -> sequence? ~
  s : sequence? ~ ~
  e : any/c ~ ~

Returns a sequence whose elements are the elements of s, but with e
between each pair of elements in s. The new sequence is constructed
lazily.

If s is a stream, then the result is also a stream.

Examples:

  > (let* ([all-reds (in-cycle '("red"))]
           [red-and-blues (sequence-add-between all-reds "blue")])
      (for/list ([n (in-range 10)]
                 [elt red-and-blues])
        elt))
  '("red" "blue" "red" "blue" "red" "blue" "red" "blue" "red" "blue")
  > (for ([text (sequence-add-between '("veni" "vidi" "duci") ", ")])
      (display text))
  veni, vidi, duci

                                        *sequence/c*
(sequence/c [#:min-count min-count]      ~ ~ ~
             elem/c ...)            -> contract?
  min-count : (or/c #f exact-nonnegative-integer?) = #f ~ ~
  elem/c : contract? ~ ~

Wraps a sequence, obligating it to produce elements with as many values
as there are elem/c contracts, and obligating each value to satisfy the
corresponding elem/c.  The result is not guaranteed to be the same kind
of sequence as the original value; for instance, a wrapped list is not
guaranteed to satisfy list?.

If min-count is a number, the stream is required to have at least that
many elements in it.

Examples:

  > (define/contract predicates
      (sequence/c (-> any/c boolean?))
      (in-list (list integer?
                     string->symbol)))
  > (for ([P predicates])
      (printf "~s\n" (P "cat")))
  #f
  predicates: broke its own contract
    promised: boolean? ~ ~
    produced: 'cat ~ ~
    in: an element of ~ ~
        (sequence/c (-> any/c boolean?))
    contract from: (definition predicates) ~ ~
    blaming: (definition predicates) ~ ~
     (assuming the contract is correct)
    at: eval:29.0 ~ ~
  > (define/contract numbers&strings
      (sequence/c number? string?)
      (in-dict (list (cons 1 "one")
                     (cons 2 "two")
                     (cons 3 'three))))
  > (for ([(N S) numbers&strings])
      (printf "~s: ~a\n" N S)) ~ ~
  1: one
  2: two
  numbers&strings: broke its own contract
    promised: string? ~ ~
    produced: 'three ~ ~
    in: an element of ~ ~
        (sequence/c number? string?)
    contract from: (definition numbers&strings) ~ ~
    blaming: (definition numbers&strings) ~ ~
     (assuming the contract is correct)
    at: eval:31.0 ~ ~
  > (define/contract a-sequence
      (sequence/c #:min-count 2 char?) ~ ~
      "x")
  > (for ([x a-sequence]
          [i (in-naturals)])
      (printf "~a is ~a\n" i x))
  0 is x
  a-sequence: broke its own contract
    promised: a sequence that contains at least 2 values ~ ~
    produced: "x" ~ ~
    in: (sequence/c #:min-count 2 char?) ~ ~
    contract from: (definition a-sequence) ~ ~
    blaming: (definition a-sequence) ~ ~
     (assuming the contract is correct)
    at: eval:33.0 ~ ~

15.1.3.1. Additional Sequence Constructors

                                        *in-syntax*
(in-syntax stx) -> sequence? ~
  stx : syntax? ~ ~

Produces a sequence whose elements are the successive subparts of   stx.
Equivalent to (stx->list lst).

An in-syntax application can provide better performance for syntax
iteration when it appears directly in a for clause.

Example:

  > (for/list ([x (in-syntax #'(1 2 3))])
      x)
  '(#<syntax:eval:35:0 1> #<syntax:eval:35:0 2> #<syntax:eval:35:0 3>)

Added in version 6.3 of package base.

                                        *in-slice*
(in-slice length seq) -> sequence? ~
  length : exact-positive-integer? ~ ~
  seq : sequence? ~ ~

Returns a sequence whose elements are lists with the first length
elements of seq, then the next length and so on.

Example:

  > (for/list ([e (in-slice 3 (in-range 8))]) e)
  '((0 1 2) (3 4 5) (6 7))

Added in version 6.3 of package base.

15.2. Streams

A stream is a kind of sequence that supports functional iteration via
stream-first and stream-rest.  The stream-cons form constructs a lazy
stream, but plain lists can be used as streams, and functions such as
in-range and in-naturals also create streams.

 (require racket/stream) package: base ~ ~

The bindings documented in this section are provided by the
racket/stream and racket libraries, but not racket/base.

                                        *stream?*
(stream? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v can be used as a stream, #f otherwise.

                                        *stream-empty?*
(stream-empty? s) -> boolean? ~
  s : stream? ~ ~

Returns #t if s has no elements, #f otherwise.

                                        *stream-first*
(stream-first s) -> any ~
  s : (and/c stream? (not/c stream-empty?)) ~ ~

Returns the value(s) of the first element in s.

                                        *stream-rest*
(stream-rest s) -> stream? ~
  s : (and/c stream? (not/c stream-empty?)) ~ ~

Returns a stream that is equivalent to s without its first element.

                                        *stream-cons*
(stream-cons first-expr rest-expr) ~

Produces a lazy stream for which stream-first forces the evaluation of
first-expr to produce the first element of the stream, and stream-rest
forces the evaluation of rest-expr to produce a stream for the rest of
the returned stream.

The first element of the stream as produced by first-expr must be a
single value. The rest-expr must produce a stream when it is evaluated,
otherwise the exn:fail:contract? exception is raised.

                                        *stream*
(stream expr ...) ~

A shorthand for nested stream-conses ending with empty-stream.

                                        *stream**
(stream* expr ... rest-expr) ~

A shorthand for nested stream-conses, but the rest-expr   must be a
stream, and it is used as the rest of the stream instead of
empty-stream. Similar to list* but for streams.

Added in version 6.3 of package base.

                                        *in-stream*
(in-stream s) -> sequence? ~
  s : stream? ~ ~

Returns a sequence that is equivalent to s.

An in-stream application can provide better performance for streams
iteration when it appears directly in a for clause.

See for for information on the reachability of stream elements during an
iteration.

Changed in version 6.7.0.4 of package base: Improved
element-reachability guarantee for streams in for.

empty-stream : stream? ~ ~

A stream with no elements.

                                        *stream->list*
(stream->list s) -> list? ~
  s : stream? ~ ~

Returns a list whose elements are the elements of s, each of which must
be a single value.  If s is infinite, this function does not terminate.

                                        *stream-length*
(stream-length s) -> exact-nonnegative-integer? ~
  s : stream? ~ ~

Returns the number of elements of s.  If s is infinite, this function
does not terminate.

In the case of lazy streams, this function forces evaluation only of the
sub-streams, and not the stream’s elements.

                                        *stream-ref*
(stream-ref s i) -> any ~
  s : stream? ~ ~
  i : exact-nonnegative-integer? ~ ~

Returns the ith element of s (which may be multiple values).

                                        *stream-tail*
(stream-tail s i) -> stream? ~
  s : stream? ~ ~
  i : exact-nonnegative-integer? ~ ~

Returns a stream equivalent to s, except that the first i elements are
omitted.

In case extracting elements from s involves a side effect, they will not
be extracted until the first element is extracted from the resulting
stream.

                                        *stream-take*
(stream-take s i) -> stream? ~
  s : stream? ~ ~
  i : exact-nonnegative-integer? ~ ~

Returns a stream of the first i elements of s.

                                        *stream-append*
(stream-append s ...) -> stream? ~
  s : stream? ~ ~

Returns a stream that contains all elements of each stream in the order
they appear in the original streams.  The new stream is constructed
lazily, while the last given stream is used in the tail of the result.

                                        *stream-map*
(stream-map f s) -> stream? ~
  f : procedure? ~ ~
  s : stream? ~ ~

Returns a stream that contains f applied to each element of s.  The new
stream is constructed lazily.

                                        *stream-andmap*
(stream-andmap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~ ~
  s : stream? ~ ~

Returns #t if f returns a true result on every element of s.  If s is
infinite and f never returns a false result, this function does not
terminate.

                                        *stream-ormap*
(stream-ormap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~ ~
  s : stream? ~ ~

Returns #t if f returns a true result on some element of s.  If s is
infinite and f never returns a true result, this function does not
terminate.

                                        *stream-for-each*
(stream-for-each f s) -> void? ~
  f : (-> any/c ... any) ~ ~
  s : stream? ~ ~

Applies f to each element of s.  If s is infinite, this function does
not terminate.

                                        *stream-fold*
(stream-fold f i s) -> any/c ~
  f : (-> any/c any/c ... any/c) ~ ~
  i : any/c ~ ~
  s : stream? ~ ~

Folds f over each element of s with i as the initial accumulator.  If s
is infinite, this function does not terminate. The f function takes the
accumulator as its first argument and the next stream element as its
second.

                                        *stream-count*
(stream-count f s) -> exact-nonnegative-integer? ~
  f : procedure? ~ ~
  s : stream? ~ ~

Returns the number of elements in s for which f returns a true result.
If s is infinite, this function does not terminate.

                                        *stream-filter*
(stream-filter f s) -> stream? ~
  f : (-> any/c ... boolean?) ~ ~
  s : stream? ~ ~

Returns a stream whose elements are the elements of s for which f
returns a true result.  Although the new stream is constructed lazily,
if s has an infinite number of elements where f returns a false result
in between two elements where f returns a true result, then operations
on this stream will not terminate during the infinite sub-stream.

                                        *stream-add-between*
(stream-add-between s e) -> stream? ~
  s : stream? ~ ~
  e : any/c ~ ~

Returns a stream whose elements are the elements of s, but with e
between each pair of elements in s.  The new stream is constructed
lazily.

                                        *for/stream*
(for/stream (for-clause ...) body-or-break ... body) ~
(for*/stream (for-clause ...) body-or-break ... body)

Iterates like for/list and for*/list, respectively, but the results are
lazily collected into a stream instead of a list.

Unlike most for forms, these forms are evaluated lazily, so each body
will not be evaluated until the resulting stream is forced. This allows
for/stream and for*/stream to iterate over infinite sequences, unlike
their finite counterparts.

Please note that these forms do not support returning multiple values.

Examples:

  > (for/stream ([i '(1 2 3)]) (* i i))
  #<stream>
  > (stream->list (for/stream ([i '(1 2 3)]) (* i i)))
  '(1 4 9)
  > (stream-ref (for/stream ([i '(1 2 3)]) (displayln i) (* i i)) 1)
  2
  4
  > (stream-ref (for/stream ([i (in-naturals)]) (* i i)) 25)
  625

Added in version 6.3.0.9 of package base.

gen:stream : any/c ~ ~

Associates three methods to a structure type to implement the generic
interface (see [missing]) for streams.

To supply method implementations, the #:methods keyword should be used
in a structure type definition. The following three methods should be
implemented:

* stream-empty? : accepts one argument

* stream-first : accepts one argument

* stream-rest : accepts one argument

Examples:

  > (define-struct list-stream (v)
      #:methods gen:stream ~ ~
      [(define (stream-empty? stream)
         (empty? (list-stream-v stream)))
       (define (stream-first stream)
         (first (list-stream-v stream)))
       (define (stream-rest stream)
         (list-stream (rest (list-stream-v stream))))])
  > (define l1 (list-stream '(1 2)))
  > (stream? l1)
  #t
  > (stream-first l1)
  1

prop:stream : struct-type-property? ~ ~

A structure type property used to define custom extensions to the stream
API. Using the prop:stream property is discouraged; use the gen:stream
generic interface instead. Accepts a vector of three procedures taking
the same arguments as the methods in gen:stream.

                                        *stream/c*
(stream/c c) -> contract? ~
  c : contract? ~ ~

Returns a contract that recognizes streams. All elements of the stream
must match c.

If the c argument is a flat contract or a chaperone contract, then the
result will be a chaperone contract. Otherwise, the result will be an
impersonator contract.

When an stream/c contract is applied to a stream, the result is not eq?
to the input. The result will be either a chaperone or impersonator of
the input depending on the type of contract.

Contracts on streams are evaluated lazily by necessity (since streams
may be infinite). Contract violations will not be raised until the value
in violation is retrieved from the stream. As an exception to this rule,
streams that are lists are checked immediately, as if c had been used
with listof.

If a contract is applied to a stream, and that stream is subsequently
used as the tail of another stream (as the second parameter to
stream-cons), the new elements will not be checked with the contract,
but the tail’s elements will still be enforced.

Added in version 6.1.1.8 of package base.

15.3. Generators

A generator is a procedure that returns a sequence of values,
incrementing the sequence each time that the generator is called. In
particular, the generator form implements a generator by evaluating a
body that calls yield to return values from the generator.

 (require racket/generator) package: base ~ ~

                                        *generator?*
(generator? v) -> boolean? ~
  v : any/c ~ ~

Return #t if v is a generator, #f otherwise.

                                        *generator*
(generator formals body ...+) ~

Creates a generator, where formals is like the formals of case-lambda
(i.e., the kw-formals of lambda restricted to non-optional and
non-keyword arguments).

For the first call to a generator, the arguments are bound to the
formals and evaluation of body starts. During the dynamic extent of
body, the generator can return immediately using the yield function. A
second call to the generator resumes at the yield call, producing the
arguments of the second call as the results of the yield, and so on. The
eventual results of body are supplied to an implicit final yield; after
that final yield, calling the generator again returns the same values,
but all such calls must provide 0 arguments to the generator.

Examples:

  > (define g (generator ()
                (let loop ([x '(a b c)])
                  (if (null? x)
                      0
                      (begin
                        (yield (car x))
                        (loop (cdr x)))))))
  > (g)
  'a
  > (g)
  'b
  > (g)
  'c
  > (g)
  0
  > (g)
  0

                                        *yield*
(yield v ...) -> any ~
  v : any/c ~ ~

Returns vs from a generator, saving the point of execution inside a
generator (i.e., within the dynamic extent of a generator body) to be
resumed by the next call to the generator. The results of yield are the
arguments that are provided to the next call of the generator.

When not in the dynamic extent of a generator, infinite-generator, or
in-generator body, yield raises exn:fail after evaluating its exprs.

Examples:

  > (define my-generator (generator () (yield 1) (yield 2 3 4)))
  > (my-generator)
  1
  > (my-generator)
  2
  3
  4

Examples:

  > (define pass-values-generator
      (generator ()
        (let* ([from-user (yield 2)]
               [from-user-again (yield (add1 from-user))])
          (yield from-user-again))))
  > (pass-values-generator)
  2
  > (pass-values-generator 5)
  6
  > (pass-values-generator 12)
  12

                                        *infinite-generator*
(infinite-generator body ...+) ~

Like generator, but repeats evaluation of the bodys when the last body
completes without implicitly yielding.

Examples:

  > (define welcome
      (infinite-generator
        (yield 'hello)
        (yield 'goodbye)))
  > (welcome)
  'hello
  > (welcome)
  'goodbye
  > (welcome)
  'hello
  > (welcome)
  'goodbye

                                        *in-generator*
(in-generator maybe-arity body ...+) ~
 
maybe-arity = 
            | #:arity arity-k ~ ~

Produces a sequence that encapsulates the generator formed by (generator
() body ...+). The values produced by the generator form the elements of
the sequence, except for the last value produced by the generator (i.e.,
the values produced by returning).

Example:

  > (for/list ([i (in-generator
                    (let loop ([x '(a b c)])
                      (when (not (null? x))
                        (yield (car x))
                        (loop (cdr x)))))])
      i)
  '(a b c)

If in-generator is used immediately with a for (or for/list, etc.)
binding’s right-hand side, then its result arity (i.e., the number of
values in each element of the sequence) can be inferred. Otherwise, if
the generator produces multiple values for each element, its arity
should be declared with an #:arity arity-k clause; the arity-k must be a
literal, exact, non-negative integer.

Examples:

  > (let ([g (in-generator
              (let loop ([n 3])
                (unless (zero? n) (yield n (add1 n)) (loop (sub1 n)))))])
      (let-values ([(not-empty? next) (sequence-generate g)])
        (let loop () (when (not-empty?) (next) (loop))) 'done))
  stop?: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 1 ~ ~
    given: 2 ~ ~
    arguments...: ~ ~
     3
     4
  > (let ([g (in-generator #:arity 2 ~ ~
              (let loop ([n 3])
                (unless (zero? n) (yield n (add1 n)) (loop (sub1 n)))))])
      (let-values ([(not-empty? next) (sequence-generate g)])
        (let loop () (when (not-empty?) (next) (loop))) 'done))
  'done

To use an existing generator as a sequence, use in-producer with a
stop-value known for the generator:

  > (define abc-generator (generator ()
                           (for ([x '(a b c)])
                              (yield x))))
  > (for/list ([i (in-producer abc-generator (void))])
      i)
  '(a b c)
  > (define my-stop-value (gensym))
  > (define my-generator (generator ()
                           (let loop ([x (list 'a (void) 'c)])
                             (if (null? x)
                                 my-stop-value
                                 (begin
                                   (yield (car x))
                                   (loop (cdr x)))))))
  > (for/list ([i (in-producer my-generator my-stop-value)])
      i)
  '(a #<void> c)

                                        *generator-state*
(generator-state g) -> symbol? ~
  g : generator? ~ ~

Returns a symbol that describes the state of the generator.

* 'fresh — The generator has been freshly created and has not been
  called yet.

* 'suspended — Control within the generator has been suspended due to a
  call to yield.  The generator can be called.

* 'running — The generator is currently executing.

* 'done — The generator has executed its entire body and will continue
  to produce the same result as from the last call.

Examples:

  > (define my-generator (generator () (yield 1) (yield 2)))
  > (generator-state my-generator)
  'fresh
  > (my-generator)
  1
  > (generator-state my-generator)
  'suspended
  > (my-generator)
  2
  > (generator-state my-generator)
  'suspended
  > (my-generator)
  > (generator-state my-generator)
  'done
  > (define introspective-generator (generator () ((yield 1))))
  > (introspective-generator)
  1
  > (introspective-generator
     (lambda () (generator-state introspective-generator)))
  'running
  > (generator-state introspective-generator)
  'done
  > (introspective-generator)
  'running

                                        *sequence->generator*
(sequence->generator s) -> (-> any) ~
  s : sequence? ~ ~

Converts a sequence to a generator. The generator returns the next
element of the sequence each time the generator is invoked, where each
element of the sequence must be a single value. When the sequence ends,
the generator returns #<void> as its final result.

                                        *sequence->repeated-generator*
(sequence->repeated-generator s) -> (-> any) ~
  s : sequence? ~ ~

Like sequence->generator, but when s has no further values, the
generator starts the sequence again (so that the generator never stops
producing values).

16. Dictionaries

A dictionary is an instance of a datatype that maps keys to values. The
following datatypes are all dictionaries:

* hash tables;

* vectors (using only exact integers as keys);

* lists of pairs as an association list using equal? to compare keys,
  which must be distinct; and

* structures whose types implement the gen:dict generic interface.

When list of pairs is used as association list but does not have
distinct keys (so it’s not an association list), operations like
dict-ref and dict-remove operate on the first instance of the key, while
operations like dict-map and dict-keys produce an element for every
instance of the key.

 (require racket/dict) package: base ~ ~

The bindings documented in this section are provided by the racket/dict
and racket libraries, but not racket/base.

16.1. Dictionary Predicates and Contracts

                                        *dict?*
(dict? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a dictionary, #f otherwise.

Beware that dict? is not a constant-time test on pairs, since checking
that v is an association list may require traversing the list.

Examples:

  > (dict? #hash((a . "apple")))
  #t
  > (dict? '#("apple" "banana"))
  #t
  > (dict? '("apple" "banana"))
  #f
  > (dict? '((a . "apple") (b . "banana")))
  #t

                                        *dict-implements?*
(dict-implements? d sym ...) -> boolean? ~
  d : dict? ~ ~
  sym : symbol? ~ ~

Returns #t if d implements all of the methods from gen:dict named by the
syms; returns #f otherwise. Fallback implementations do not affect the
result; d may support the given methods via fallback implementations yet
produce #f.

Examples:

  > (dict-implements? (hash 'a "apple") 'dict-set!)
  #f
  > (dict-implements? (make-hash '((a . "apple") (b .
  "banana"))) 'dict-set!)
  #t
  > (dict-implements? (make-hash '((b . "banana") (a .
  "apple"))) 'dict-remove!)
  #t
  > (dict-implements? (vector "apple" "banana") 'dict-set!)
  #t
  > (dict-implements? (vector 'a 'b) 'dict-remove!)
  #f
  > (dict-implements? (vector 'a "apple") 'dict-set! 'dict-remove!)
  #f

                                        *dict-implements/c*
(dict-implements/c sym ...) -> flat-contract? ~
  sym : symbol? ~ ~

Recognizes dictionaries that support all of the methods from gen:dict
named by the syms. Note that the generated contract is not similar to
hash/c, but closer to dict-implements?.

Examples:

  > (struct deformed-dict ()
      #:methods gen:dict []) ~ ~
  > (define/contract good-dict
      (dict-implements/c)
      (deformed-dict))
  > (define/contract bad-dict
      (dict-implements/c 'dict-ref)
      (deformed-dict))
  bad-dict: broke its own contract
    promised: (dict-implements/c dict-ref) ~ ~
    produced: #<deformed-dict> ~ ~
    in: (dict-implements/c dict-ref) ~ ~
    contract from: (definition bad-dict) ~ ~
    blaming: (definition bad-dict) ~ ~
     (assuming the contract is correct)
    at: eval:14.0 ~ ~

                                        *dict-mutable?*
(dict-mutable? d) -> boolean? ~
  d : dict? ~ ~

Returns #t if d is mutable via dict-set!, #f otherwise.

Equivalent to (dict-implements? d 'dict-set!).

Examples:

  > (dict-mutable? #hash((a . "apple")))
  #f
  > (dict-mutable? (make-hash))
  #t
  > (dict-mutable? '#("apple" "banana"))
  #f
  > (dict-mutable? (vector "apple" "banana"))
  #t
  > (dict-mutable? '((a . "apple") (b . "banana")))
  #f

                                        *dict-can-remove-keys?*
(dict-can-remove-keys? d) -> boolean? ~
  d : dict? ~ ~

Returns #t if d supports removing mappings via dict-remove! and/or
dict-remove, #f otherwise.

Equivalent to (or (dict-implements? d 'dict-remove!) (dict-implements? d
'dict-remove)).

Examples:

  > (dict-can-remove-keys? #hash((a . "apple")))
  #t
  > (dict-can-remove-keys? '#("apple" "banana"))
  #f
  > (dict-can-remove-keys? '((a . "apple") (b . "banana")))
  #t

                                        *dict-can-functional-set?*
(dict-can-functional-set? d) -> boolean? ~
  d : dict? ~ ~

Returns #t if d supports functional update via dict-set, #f otherwise.

Equivalent to (dict-implements? d 'dict-set).

Examples:

  > (dict-can-functional-set? #hash((a . "apple")))
  #t
  > (dict-can-functional-set? (make-hash))
  #f
  > (dict-can-functional-set? '#("apple" "banana"))
  #f
  > (dict-can-functional-set? '((a . "apple") (b . "banana")))
  #t

16.2. Generic Dictionary Interface

gen:dict

A generic interface (see [missing]) that supplies dictionary method
implementations for a structure type via the #:methods option of struct
definitions.  This interface can be used to implement any of the methods
documented as Primitive Dictionary Methods and Derived Dictionary
Methods.

Examples:

  > (struct alist (v)
      #:methods gen:dict ~ ~
      [(define (dict-ref dict key
                         [default (lambda () (error "key not
  found" key))])
         (cond [(assoc key (alist-v dict)) => cdr]
               [else (if (procedure? default) (default) default)]))
       (define (dict-set dict key val)
         (alist (cons (cons key val) (alist-v dict))))
       (define (dict-remove dict key)
         (define al (alist-v dict))
         (alist (remove* (filter (λ (p) (equal? (car p) key)) al) al)))
       (define (dict-count dict)
         (length (remove-duplicates (alist-v dict) #:key car)))]) ~ ~
  ; etc. other methods
  > (define d1 (alist '((1 . a) (2 . b))))
  > (dict? d1)
  #t
  > (dict-ref d1 1)
  'a
  > (dict-remove d1 1)
  #<alist>

prop:dict : struct-type-property? ~ ~

A structure type property used to define custom extensions to the
dictionary API. Using the prop:dict property is discouraged; use the
gen:dict generic interface instead. Accepts a vector of 10 method
implementations:

* dict-ref

* dict-set!, or #f if unsupported

* dict-set, or #f if unsupported

* dict-remove!, or #f if unsupported

* dict-remove, or #f if unsupported

* dict-count

* dict-iterate-first

* dict-iterate-next

* dict-iterate-key

* dict-iterate-value

16.2.1. Primitive Dictionary Methods

These methods of gen:dict have no fallback implementations; they are
only supported for dictionary types that directly implement them.

                                        *dict-ref*
(dict-ref dict key [failure-result]) -> any ~
  dict : dict? ~ ~
  key : any/c ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda () (raise (make-exn:fail ....))) ~ ~

Returns the value for key in dict. If no value is found for key, then
failure-result determines the result:

* If failure-result is a procedure, it is called (through a tail call)
  with no arguments to produce the result.

* Otherwise, failure-result is returned as the result.

Examples:

  > (dict-ref #hash((a . "apple") (b . "beer")) 'a)
  "apple"
  > (dict-ref #hash((a . "apple") (b . "beer")) 'c)
  hash-ref: no value found for key
    key: 'c ~ ~
  > (dict-ref #hash((a . "apple") (b . "beer")) 'c #f)
  #f
  > (dict-ref '((a . "apple") (b . "banana")) 'b)
  "banana"
  > (dict-ref #("apple" "banana") 1)
  "banana"
  > (dict-ref #("apple" "banana") 3 #f)
  #f
  > (dict-ref #("apple" "banana") -3 #f)
  dict-ref: contract violation
    expected: natural? ~ ~
    given: -3 ~ ~
    in: the k argument of ~ ~
        (->i
         ((d dict?) (k (d) (dict-key-contract d)))
         ((default any/c))
         any)
    contract from: <collects>/racket/dict.rkt ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: <collects>/racket/dict.rkt:181.2 ~ ~

                                        *dict-set!*
(dict-set! dict key v) -> void? ~
  dict : (and/c dict? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Maps key to v in dict, overwriting any existing mapping for key. The
update can fail with a exn:fail:contract exception if dict is not
mutable or if key is not an allowed key for the dictionary (e.g., not an
exact integer in the appropriate range when dict is a vector).

Examples:

  > (define h (make-hash))
  > (dict-set! h 'a "apple")
  > h
  '#hash((a . "apple"))
  > (define v (vector #f #f #f))
  > (dict-set! v 0 "apple")
  > v
  '#("apple" #f #f)

                                        *dict-set*
(dict-set dict key v) -> (and/c dict? immutable?) ~
  dict : (and/c dict? immutable?) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Functionally extends dict by mapping key to v, overwriting any existing
mapping for key, and returning an extended dictionary. The update can
fail with a exn:fail:contract exception if dict does not support
functional extension or if key is not an allowed key for the dictionary.

Examples:

  > (dict-set #hash() 'a "apple")
  '#hash((a . "apple"))
  > (dict-set #hash((a . "apple") (b . "beer")) 'b "banana")
  '#hash((a . "apple") (b . "banana"))
  > (dict-set '() 'a "apple")
  '((a . "apple"))
  > (dict-set '((a . "apple") (b . "beer")) 'b "banana")
  '((a . "apple") (b . "banana"))

                                        *dict-remove!*
(dict-remove! dict key) -> void? ~
  dict : (and/c dict? (not/c immutable?)) ~ ~
  key : any/c ~ ~

Removes any existing mapping for key in dict. The update can fail if
dict is not mutable or does not support removing keys (as is the case
for vectors, for example).

Examples:

  > (define h (make-hash))
  > (dict-set! h 'a "apple")
  > h
  '#hash((a . "apple"))
  > (dict-remove! h 'a)
  > h
  '#hash()

                                        *dict-remove*
(dict-remove dict key) -> (and/c dict? immutable?) ~
  dict : (and/c dict? immutable?) ~ ~
  key : any/c ~ ~

Functionally removes any existing mapping for key in dict, returning the
fresh dictionary.  The update can fail if dict does not support
functional update or does not support removing keys.

Examples:

  > (define h #hash())
  > (define h (dict-set h 'a "apple"))
  > h
  '#hash((a . "apple"))
  > (dict-remove h 'a)
  '#hash()
  > h
  '#hash((a . "apple"))
  > (dict-remove h 'z)
  '#hash((a . "apple"))
  > (dict-remove '((a . "apple") (b . "banana")) 'a)
  '((b . "banana"))

                                        *dict-iterate-first*
(dict-iterate-first dict) -> any/c ~
  dict : dict? ~ ~

Returns #f if dict contains no elements, otherwise it returns a non-#f
value that is an index to the first element in the dict table; “first”
refers to an unspecified ordering of the dictionary elements. For a
mutable dict, this index is guaranteed to refer to the first item only
as long as no mappings are added to or removed from dict.

Examples:

  > (dict-iterate-first #hash((a . "apple") (b . "banana")))
  0
  > (dict-iterate-first #hash())
  #f
  > (dict-iterate-first #("apple" "banana"))
  0
  > (dict-iterate-first '((a . "apple") (b . "banana")))
  #<assoc-iter>

                                        *dict-iterate-next*
(dict-iterate-next dict pos) -> any/c ~
  dict : dict? ~ ~
  pos : any/c ~ ~

Returns either a non-#f that is an index to the element in dict after
the element indexed by pos or #f if pos refers to the last element in
dict. If pos is not a valid index, then the exn:fail:contract exception
is raised. For a mutable dict, the result index is guaranteed to refer
to its item only as long as no items are added to or removed from dict.
The dict-iterate-next operation should take constant time.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (define i (dict-iterate-first h))
  > i
  0
  > (dict-iterate-next h i)
  1
  > (dict-iterate-next h (dict-iterate-next h i))
  #f

                                        *dict-iterate-key*
(dict-iterate-key dict pos) -> any ~
  dict : dict? ~ ~
  pos : any/c ~ ~

Returns the key for the element in dict at index pos. If pos is not a
valid index for dict, the exn:fail:contract exception is raised. The
dict-iterate-key operation should take constant time.

Examples:

  > (define h '((a . "apple") (b . "banana")))
  > (define i (dict-iterate-first h))
  > (dict-iterate-key h i)
  'a
  > (dict-iterate-key h (dict-iterate-next h i))
  'b

                                        *dict-iterate-value*
(dict-iterate-value dict pos) -> any ~
  dict : dict? ~ ~
  pos : any/c ~ ~

Returns the value for the element in dict at index pos. If pos is not a
valid index for dict, the exn:fail:contract exception is raised. The
dict-iterate-key operation should take constant time.

Examples:

  > (define h '((a . "apple") (b . "banana")))
  > (define i (dict-iterate-first h))
  > (dict-iterate-value h i)
  "apple"
  > (dict-iterate-value h (dict-iterate-next h i))
  "banana"

16.2.2. Derived Dictionary Methods

These methods of gen:dict have fallback implementations in terms of the
other methods; they may be supported even by dictionary types that do
not directly implement them.

                                        *dict-has-key?*
(dict-has-key? dict key) -> boolean? ~
  dict : dict? ~ ~
  key : any/c ~ ~

Returns #t if dict contains a value for the given key, #f otherwise.

Supported for any dict that implements dict-ref.

Examples:

  > (dict-has-key? #hash((a . "apple") (b . "beer")) 'a)
  #t
  > (dict-has-key? #hash((a . "apple") (b . "beer")) 'c)
  #f
  > (dict-has-key? '((a . "apple") (b . "banana")) 'b)
  #t
  > (dict-has-key? #("apple" "banana") 1)
  #t
  > (dict-has-key? #("apple" "banana") 3)
  #f
  > (dict-has-key? #("apple" "banana") -3)
  #f

                                        *dict-set*!*
(dict-set*! dict key v ... ...) -> void? ~
  dict : (and/c dict? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Maps each key to each v in dict, overwriting any existing mapping for
each key. The update can fail with a exn:fail:contract exception if dict
is not mutable or if any key is not an allowed key for the dictionary
(e.g., not an exact integer in the appropriate range when dict is a
vector). The update takes place from the left, so later mappings
overwrite earlier mappings.

Supported for any dict that implements dict-set!.

Examples:

  > (define h (make-hash))
  > (dict-set*! h 'a "apple" 'b "banana")
  > h
  '#hash((a . "apple") (b . "banana"))
  > (define v1 (vector #f #f #f))
  > (dict-set*! v1 0 "apple" 1 "banana")
  > v1
  '#("apple" "banana" #f)
  > (define v2 (vector #f #f #f))
  > (dict-set*! v2 0 "apple" 0 "banana")
  > v2
  '#("banana" #f #f)

                                        *dict-set**
(dict-set* dict key v ... ...) -> (and/c dict? immutable?) ~
  dict : (and/c dict? immutable?) ~ ~
  key : any/c ~ ~
  v : any/c ~ ~

Functionally extends dict by mapping each key to each v, overwriting any
existing mapping for each key, and returning an extended dictionary. The
update can fail with a exn:fail:contract exception if dict does not
support functional extension or if any key is not an allowed key for the
dictionary. The update takes place from the left, so later mappings
overwrite earlier mappings.

Supported for any dict that implements dict-set.

Examples:

  > (dict-set* #hash() 'a "apple" 'b "beer")
  '#hash((a . "apple") (b . "beer"))
  > (dict-set* #hash((a . "apple") (b . "beer")) 'b "banana" 'a "anchor")
  '#hash((a . "anchor") (b . "banana"))
  > (dict-set* '() 'a "apple" 'b "beer")
  '((a . "apple") (b . "beer"))
  > (dict-set* '((a . "apple") (b . "beer")) 'b "banana" 'a "anchor")
  '((a . "anchor") (b . "banana"))
  > (dict-set* '((a . "apple") (b . "beer")) 'b "banana" 'b "ballistic")
  '((a . "apple") (b . "ballistic"))

                                        *dict-ref!*
(dict-ref! dict key to-set) -> any ~
  dict : dict? ~ ~
  key : any/c ~ ~
  to-set : any/c ~ ~

Returns the value for key in dict. If no value is found for key, then
to-set determines the result as in dict-ref (i.e., it is either a thunk
that computes a value or a plain value), and this result is stored in
dict for the key.  (Note that if to-set is a thunk, it is not invoked in
tail position.)

Supported for any dict that implements dict-ref and dict-set!.

Examples:

  > (dict-ref! (make-hasheq '((a . "apple") (b . "beer"))) 'a #f)
  "apple"
  > (dict-ref! (make-hasheq '((a . "apple") (b . "beer"))) 'c 'cabbage)
  'cabbage
  > (define h (make-hasheq '((a . "apple") (b . "beer"))))
  > (dict-ref h 'c)
  hash-ref: no value found for key
    key: 'c ~ ~
  > (dict-ref! h 'c (λ () 'cabbage))
  'cabbage
  > (dict-ref h 'c)
  'cabbage

                                        *dict-update!*
(dict-update!  dict                  ~
               key                  
               updater              
              [failure-result]) -> void?
  dict : (and/c dict? (not/c immutable?)) ~ ~
  key : any/c ~ ~
  updater : (any/c . -> . any/c) ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda () (raise (make-exn:fail ....))) ~ ~

Composes dict-ref and dict-set! to update an existing mapping in dict,
where the optional failure-result argument is used as in dict-ref when
no mapping exists for key already.

Supported for any dict that implements dict-ref and dict-set!.

Examples:

  > (define h (make-hash))
  > (dict-update! h 'a add1)
  hash-update!: no value found for key: 'a
  > (dict-update! h 'a add1 0)
  > h
  '#hash((a . 1))
  > (define v (vector #f #f #f))
  > (dict-update! v 0 not)
  > v
  '#(#t #f #f)

                                        *dict-update*
(dict-update dict key updater [failure-result]) ~
 -> (and/c dict? immutable?)
  dict : dict? ~ ~
  key : any/c ~ ~
  updater : (any/c . -> . any/c) ~ ~
  failure-result : failure-result/c ~ ~
                 = (lambda () (raise (make-exn:fail ....))) ~ ~

Composes dict-ref and dict-set to functionally update an existing
mapping in dict, where the optional failure-result argument is used as
in dict-ref when no mapping exists for key already.

Supported for any dict that implements dict-ref and dict-set.

Examples:

  > (dict-update #hash() 'a add1)
  hash-update: no value found for key: 'a
  > (dict-update #hash() 'a add1 0)
  '#hash((a . 1))
  > (dict-update #hash((a . "apple") (b . "beer")) 'b string-length)
  '#hash((a . "apple") (b . 4))

                                        *dict-map*
(dict-map dict proc) -> (listof any/c) ~
  dict : dict? ~ ~
  proc : (any/c any/c . -> . any/c) ~ ~

Applies the procedure proc to each element in dict in an unspecified
order, accumulating the results into a list. The procedure proc is
called each time with a key and its value.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, dict-iterate-key, and dict-iterate-value.

Example:

  > (dict-map #hash((a . "apple") (b . "banana")) vector)
  '(#(a "apple") #(b "banana"))

                                        *dict-for-each*
(dict-for-each dict proc) -> void? ~
  dict : dict? ~ ~
  proc : (any/c any/c . -> . any) ~ ~

Applies proc to each element in dict (for the side-effects of proc) in
an unspecified order. The procedure proc is called each time with a key
and its value.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, dict-iterate-key, and dict-iterate-value.

Example:

  > (dict-for-each #hash((a . "apple") (b . "banana"))
                   (lambda (k v)
                     (printf "~a = ~s\n" k v)))
  a = "apple"
  b = "banana"

                                        *dict-empty?*
(dict-empty? dict) -> boolean? ~
  dict : dict? ~ ~

Reports whether dict is empty.

Supported for any dict that implements dict-iterate-first.

Examples:

  > (dict-empty? #hash((a . "apple") (b . "banana")))
  #f
  > (dict-empty? (vector))
  #t

                                        *dict-count*
(dict-count dict) -> exact-nonnegative-integer? ~
  dict : dict? ~ ~

Returns the number of keys mapped by dict, usually in constant time.

Supported for any dict that implements dict-iterate-first and
dict-iterate-next.

Examples:

  > (dict-count #hash((a . "apple") (b . "banana")))
  2
  > (dict-count #("apple" "banana"))
  2

                                        *dict-copy*
(dict-copy dict) -> dict? ~
  dict : dict? ~ ~

Produces a new, mutable dictionary of the same type as dict and with the
same key/value associations.

Supported for any dict that implements dict-clear, dict-set!,
dict-iterate-first, dict-iterate-next, dict-iterate-key, and
dict-iterate-value.

Examples:

  > (define original (vector "apple" "banana"))
  > (define copy (dict-copy original))
  > original
  '#("apple" "banana")
  > copy
  '#("apple" "banana")
  > (dict-set! copy 1 "carrot")
  > original
  '#("apple" "banana")
  > copy
  '#("apple" "carrot")

                                        *dict-clear*
(dict-clear dict) -> dict? ~
  dict : dict? ~ ~

Produces an empty dictionary of the same type as dict.  If dict is
mutable, the result must be a new dictionary.

Supported for any dict that supports dict-remove, dict-iterate-first,
dict-iterate-next, and dict-iterate-key.

Examples:

  > (dict-clear #hash((a . "apple") ("banana" . b)))
  '#hash()
  > (dict-clear '((1 . two) (three . "four")))
  '()

                                        *dict-clear!*
(dict-clear! dict) -> void? ~
  dict : dict? ~ ~

Removes all of the key/value associations in dict.

Supported for any dict that supports dict-remove!, dict-iterate-first,
and dict-iterate-key.

Examples:

  > (define table (make-hash))
  > (dict-set! table 'a "apple")
  > (dict-set! table "banana" 'b)
  > table
  '#hash((a . "apple") ("banana" . b))
  > (dict-clear! table)
  > table
  '#hash()

                                        *dict-keys*
(dict-keys dict) -> list? ~
  dict : dict? ~ ~

Returns a list of the keys from dict in an unspecified order.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, and dict-iterate-key.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (dict-keys h)
  '(a b)

                                        *dict-values*
(dict-values dict) -> list? ~
  dict : dict? ~ ~

Returns a list of the values from dict in an unspecified order.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, and dict-iterate-value.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (dict-values h)
  '("apple" "banana")

                                        *dict->list*
(dict->list dict) -> list? ~
  dict : dict? ~ ~

Returns a list of the associations from dict in an unspecified order.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, dict-iterate-key, and dict-iterate-value.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (dict->list h)
  '((a . "apple") (b . "banana"))

16.3. Dictionary Sequences

                                        *in-dict*
(in-dict dict) -> sequence? ~
  dict : dict? ~ ~

Returns a sequence whose each element is two values: a key and
corresponding value from dict.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, dict-iterate-key, and dict-iterate-value.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (for/list ([(k v) (in-dict h)])
      (format "~a = ~s" k v))
  '("a = \"apple\"" "b = \"banana\"")

                                        *in-dict-keys*
(in-dict-keys dict) -> sequence? ~
  dict : dict? ~ ~

Returns a sequence whose elements are the keys of dict.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, and dict-iterate-key.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (for/list ([k (in-dict-keys h)])
      k)
  '(a b)

                                        *in-dict-values*
(in-dict-values dict) -> sequence? ~
  dict : dict? ~ ~

Returns a sequence whose elements are the values of dict.

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, and dict-iterate-value.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (for/list ([v (in-dict-values h)])
      v)
  '("apple" "banana")

                                        *in-dict-pairs*
(in-dict-pairs dict) -> sequence? ~
  dict : dict? ~ ~

Returns a sequence whose elements are pairs, each containing a key and
its value from dict (as opposed to using in-dict, which gets the key and
value as separate values for each element).

Supported for any dict that implements dict-iterate-first,
dict-iterate-next, dict-iterate-key, and dict-iterate-value.

Examples:

  > (define h #hash((a . "apple") (b . "banana")))
  > (for/list ([p (in-dict-pairs h)])
      p)
  '((a . "apple") (b . "banana"))

16.4. Contracted Dictionaries

prop:dict/contract : struct-type-property? ~ ~

A structure type property for defining dictionaries with contracts. The
value associated with prop:dict/contract must be a list of two immutable
vectors:

  (list dict-vector
        (vector type-key-contract
                type-value-contract
                type-iter-contract
                instance-key-contract
                instance-value-contract
                instance-iter-contract))

The first vector must be a vector of 10 procedures which match the
gen:dict generic interface (in addition, it must be an immutable
vector). The second vector must contain six elements; each of the first
three is a contract for the dictionary type’s keys, values, and
positions, respectively. Each of the second three is either #f or a
procedure used to extract the contract from a dictionary instance.

                                        *dict-key-contract*
(dict-key-contract d) -> contract? ~
  d : dict? ~ ~
(dict-value-contract d) -> contract?
  d : dict? ~ ~
(dict-iter-contract d) -> contract?
  d : dict? ~ ~

Returns the contract that d imposes on its keys, values, or iterators,
respectively, if d implements the prop:dict/contract interface.

16.5. Custom Hash Tables

                                        *define-custom-hash-types*
(define-custom-hash-types name ~
                          optional-predicate
                          comparison-expr
                          optional-hash-functions)
 
     optional-predicate = 
                        | #:key? predicate-expr ~ ~
                           
optional-hash-functions = 
                        | hash1-expr
                        | hash1-expr hash2-expr

Creates a new dictionary type based on the given comparison
comparison-expr, hash functions hash1-expr and hash2-expr, and key
predicate predicate-expr; the interfaces for these functions are the
same as in make-custom-hash-types. The new dictionary type has three
variants: immutable, mutable with strongly-held keys, and mutable with
weakly-held keys.

Defines seven names:

* name? recognizes instances of the new type,

* immutable-name? recognizes immutable instances of the new type,

* mutable-name? recognizes mutable instances of the new type with
  strongly-held keys,

* weak-name? recognizes mutable instances of the new type with
  weakly-held keys,

* make-immutable-name constructs immutable instances of the new type,

* make-mutable-name constructs mutable instances of the new type with
  strongly-held keys, and

* make-weak-name constructs mutable instances of the new type with
  weakly-held keys.

The constructors all accept a dictionary as an optional argument,
providing initial key/value pairs.

Examples:

  > (define-custom-hash-types string-hash
                              #:key? string? ~ ~
                              string=?
                              string-length)
  > (define imm
      (make-immutable-string-hash
       '(("apple" . a) ("banana" . b))))
  > (define mut
      (make-mutable-string-hash
       '(("apple" . a) ("banana" . b))))
  > (dict? imm)
  #t
  > (dict? mut)
  #t
  > (string-hash? imm)
  #t
  > (string-hash? mut)
  #t
  > (immutable-string-hash? imm)
  #t
  > (immutable-string-hash? mut)
  #f
  > (dict-ref imm "apple")
  'a
  > (dict-ref mut "banana")
  'b
  > (dict-set! mut "banana" 'berry)
  > (dict-ref mut "banana")
  'berry
  > (equal? imm mut)
  #f
  > (equal? (dict-remove (dict-remove imm "apple") "banana")
            (make-immutable-string-hash))
  #t

                                        *make-custom-hash-types*
(make-custom-hash-types  eql?             ~
                        [hash1           
                         hash2           
                         #:key? key?      ~ ~
                         #:name name      ~ ~
                         #:for who]) -> (any/c . -> . boolean?) ~ ~
                                        (any/c . -> . boolean?)
                                        (any/c . -> . boolean?)
                                        (any/c . -> . boolean?)
                                        (->* [] [dict?] dict?)
                                        (->* [] [dict?] dict?)
                                        (->* [] [dict?] dict?)
  eql? : (or/c (any/c any/c . -> . any/c) ~ ~
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (const #true) ~ ~
  name : symbol? = 'custom-hash ~ ~
  who : symbol? = 'make-custom-hash-types ~ ~

Creates a new dictionary type based on the given comparison function
eql?, hash functions hash1 and hash2, and predicate key?.  The new
dictionary type has variants that are immutable, mutable with
strongly-held keys, and mutable with weakly-held keys.  The given name
is used when printing instances of the new dictionary type, and the
symbol who is used for reporting errors.

The comparison function eql? may accept 2 or 3 arguments.  If it accepts
2 arguments, it given two keys to compare them.  If it accepts 3
arguments and does not accept 2 arguments, it is also given a recursive
comparison function that handles data cycles when comparing sub-parts of
the keys.

The hash functions hash1 and hash2 may accept 1 or 2 arguments.  If
either hash function accepts 1 argument, it is applied to a key to
compute the corresponding hash value.  If either hash function accepts 2
arguments and does not accept 1 argument, it is also given a recursive
hash function that handles data cycles when computing hash values of
sub-parts of the keys.

The predicate key? must accept 1 argument and is used to recognize valid
keys for the new dictionary type.

Produces seven values:

* a predicate recognizing all instances of the new dictionary type,

* a predicate recognizing immutable instances,

* a predicate recognizing mutable instances,

* a predicate recognizing weak instances,

* a constructor for immutable instances,

* a constructor for mutable instances, and

* a constructor for weak instances.

See define-custom-hash-types for an example.

                                        *make-custom-hash*
(make-custom-hash  eql?               ~
                  [hash1             
                   hash2             
                   #:key? key?]) -> dict? ~ ~
  eql? : (or/c (any/c any/c . -> . any/c) ~ ~
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true) ~ ~
(make-weak-custom-hash  eql?              
                       [hash1             
                        hash2             
                        #:key? key?]) -> dict? ~ ~
  eql? : (or/c (any/c any/c . -> . any/c) ~ ~
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true) ~ ~
(make-immutable-custom-hash  eql?              
                            [hash1             
                             hash2             
                             #:key? key?]) -> dict? ~ ~
  eql? : (or/c (any/c any/c . -> . any/c) ~ ~
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true) ~ ~

Creates an instance of a new dictionary type, implemented  in terms of a
hash table where keys are compared with  eql?, hashed with hash1 and
hash2, and where the key predicate is  key?. See gen:equal+hash for
information  on suitable equality and hashing functions.

The make-custom-hash and make-weak-custom-hash functions create a
mutable dictionary that does not support functional update, while
make-immutable-custom-hash creates an immutable dictionary that supports
functional update. The dictionary created by make-weak-custom-hash
retains its keys weakly, like the result of make-weak-hash.

Dictionaries created by make-custom-hash and company are equal? when
they have the same mutability and key strength, the associated
procedures are equal?, and the key–value mappings are the same when keys
and values are compared with equal?.

See also define-custom-hash-types.

Examples:

  > (define h (make-custom-hash (lambda (a b)
                                  (string=? (format "~a" a)
                                            (format "~a" b)))
                                (lambda (a)
                                  (equal-hash-code
                                   (format "~a" a)))))
  > (dict-set! h 1 'one)
  > (dict-ref h "1")
  'one

17. Sets

A set represents a collection of distinct elements.  The following
datatypes are all sets:

* hash sets;

* lists using equal? to compare elements; and

* structures whose types implement the gen:set generic interface.

 (require racket/set) package: base ~ ~

The bindings documented in this section are provided by the racket/set
and racket libraries, but not racket/base.

17.1. Hash Sets

A hash set is a set whose elements are compared via equal?, eqv?, or eq?
and partitioned via equal-hash-code, eqv-hash-code, or eq-hash-code.  A
hash set is either immutable or mutable; mutable hash sets retain their
elements either strongly or weakly.

Like operations on immutable hash tables, “constant time” hash set
operations actually require O(log N) time for a set of size N.

A hash set can be used as a stream (see Streams) and thus as a
single-valued sequence (see Sequences). The elements of the set serve as
elements of the stream or sequence. If an element is added to or removed
from the hash set during iteration, then an iteration step may fail with
exn:fail:contract, or the iteration may skip or duplicate elements. See
also in-set.

Two hash sets are equal? when they use the same element-comparison
procedure (equal?, eqv?, or eq?), both hold elements strongly or weakly,
have the same mutability, and have equivalent elements. Immutable hash
sets support effectively constant-time access and update, just like
mutable hash sets; the constant on immutable operations is usually
larger, but the functional nature of immutable hash sets can pay off in
certain algorithms.

All hash sets implement set->stream, set-empty?, set-member?, set-count,
subset?, proper-subset?, set-map, set-for-each, set-copy,
set-copy-clear, set->list, and set-first.  Immutable hash sets in
addition implement set-add, set-remove, set-clear, set-union,
set-intersect, set-subtract, and set-symmetric-difference.  Mutable hash
sets in addition implement set-add!, set-remove!, set-clear!,
set-union!, set-intersect!, set-subtract!, and
set-symmetric-difference!.

Operations on sets that contain elements that are mutated are
unpredictable in much the same way that hash table operations are
unpredictable when keys are mutated.

                                        *set-equal?*
(set-equal? x) -> boolean? ~
  x : any/c ~ ~
(set-eqv? x) -> boolean?
  x : any/c ~ ~
(set-eq? x) -> boolean?
  x : any/c ~ ~

Returns #t if x is a hash set that compares elements with equal?, eqv?,
or eq?, respectively; returns #f otherwise.

                                        *set?*
(set? x) -> boolean? ~
  x : any/c ~ ~
(set-mutable? x) -> boolean?
  x : any/c ~ ~
(set-weak? x) -> boolean?
  x : any/c ~ ~

Returns #t if x is a hash set that is respectively immutable, mutable
with strongly-held keys, or mutable with weakly-held keys; returns #f
otherwise.

                                        *set*
(set v ...) -> (and/c generic-set? set-equal? set?) ~
  v : any/c ~ ~
(seteqv v ...) -> (and/c generic-set? set-eqv? set?)
  v : any/c ~ ~
(seteq v ...) -> (and/c generic-set? set-eq? set?)
  v : any/c ~ ~
(mutable-set v ...)
 -> (and/c generic-set? set-equal? set-mutable?)
  v : any/c ~ ~
(mutable-seteqv v ...)
 -> (and/c generic-set? set-eqv? set-mutable?)
  v : any/c ~ ~
(mutable-seteq v ...)
 -> (and/c generic-set? set-eq? set-mutable?)
  v : any/c ~ ~
(weak-set v ...) -> (and/c generic-set? set-equal? set-weak?)
  v : any/c ~ ~
(weak-seteqv v ...) -> (and/c generic-set? set-eqv? set-weak?)
  v : any/c ~ ~
(weak-seteq v ...) -> (and/c generic-set? set-eq? set-weak?)
  v : any/c ~ ~

Creates a hash set with the given vs as elements.  The elements are
added in the order that they appear as arguments, so in the case of sets
that use equal? or eqv?, an earlier element may be replaced by a later
element that is equal? or eqv? but not eq?.

                                        *list->set*
(list->set lst) -> (and/c generic-set? set-equal? set?) ~
  lst : list? ~ ~
(list->seteqv lst) -> (and/c generic-set? set-eqv? set?)
  lst : list? ~ ~
(list->seteq lst) -> (and/c generic-set? set-eq? set?)
  lst : list? ~ ~
(list->mutable-set lst)
 -> (and/c generic-set? set-equal? set-mutable?)
  lst : list? ~ ~
(list->mutable-seteqv lst)
 -> (and/c generic-set? set-eqv? set-mutable?)
  lst : list? ~ ~
(list->mutable-seteq lst)
 -> (and/c generic-set? set-eq? set-mutable?)
  lst : list? ~ ~
(list->weak-set lst)
 -> (and/c generic-set? set-equal? set-weak?)
  lst : list? ~ ~
(list->weak-seteqv lst)
 -> (and/c generic-set? set-eqv? set-weak?)
  lst : list? ~ ~
(list->weak-seteq lst) -> (and/c generic-set? set-eq? set-weak?)
  lst : list? ~ ~

Creates a hash set with the elements of the given lst as the elements of
the set.  Equivalent to (apply set lst), (apply seteqv lst), (apply
seteq lst), and so on, respectively.

                                        *for/set*
(for/set (for-clause ...) body ...+) ~
(for/seteq (for-clause ...) body ...+)
(for/seteqv (for-clause ...) body ...+)
(for*/set (for-clause ...) body ...+)
(for*/seteq (for-clause ...) body ...+)
(for*/seteqv (for-clause ...) body ...+)
(for/mutable-set (for-clause ...) body ...+)
(for/mutable-seteq (for-clause ...) body ...+)
(for/mutable-seteqv (for-clause ...) body ...+)
(for*/mutable-set (for-clause ...) body ...+)
(for*/mutable-seteq (for-clause ...) body ...+)
(for*/mutable-seteqv (for-clause ...) body ...+)
(for/weak-set (for-clause ...) body ...+)
(for/weak-seteq (for-clause ...) body ...+)
(for/weak-seteqv (for-clause ...) body ...+)
(for*/weak-set (for-clause ...) body ...+)
(for*/weak-seteq (for-clause ...) body ...+)
(for*/weak-seteqv (for-clause ...) body ...+)

Analogous to for/list and for*/list, but to construct a hash set instead
of a list.

                                        *in-immutable-set*
(in-immutable-set st) -> sequence? ~
  st : set? ~ ~
(in-mutable-set st) -> sequence?
  st : set-mutable? ~ ~
(in-weak-set st) -> sequence?
  st : set-weak? ~ ~

Explicitly converts a specific kind of hash set to a sequence for use
with for forms.

As with in-list and some other sequence constructors, in-immutable-set
performs better when it appears directly in a for clause.

These sequence constructors are compatible with [missing].

Added in version 6.4.0.7 of package base.

17.2. Set Predicates and Contracts

                                        *generic-set?*
(generic-set? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a set; returns #f otherwise.

Examples:

  > (generic-set? (list 1 2 3))
  #t
  > (generic-set? (set 1 2 3))
  #t
  > (generic-set? (mutable-seteq 1 2 3))
  #t
  > (generic-set? (vector 1 2 3))
  #f

                                        *set-implements?*
(set-implements? st sym ...) -> boolean? ~
  st : generic-set? ~ ~
  sym : symbol? ~ ~

Returns #t if st implements all of the methods from gen:set named by the
syms; returns #f otherwise. Fallback implementations do not affect the
result; st may support the given methods via fallback implementations
yet produce #f.

Examples:

  > (set-implements? (list 1 2 3) 'set-add)
  #t
  > (set-implements? (list 1 2 3) 'set-add!)
  #f
  > (set-implements? (set 1 2 3) 'set-add)
  #t
  > (set-implements? (set 1 2 3) 'set-add!)
  #t
  > (set-implements? (mutable-seteq 1 2 3) 'set-add)
  #t
  > (set-implements? (mutable-seteq 1 2 3) 'set-add!)
  #t
  > (set-implements? (weak-seteqv 1 2 3) 'set-remove 'set-remove!)
  #t

                                        *set-implements/c*
(set-implements/c sym ...) -> flat-contract? ~
  sym : symbol? ~ ~

Recognizes sets that support all of the methods from gen:set named by
the syms.

                                        *set/c*
(set/c  elem/c                           ~
       [#:cmp cmp                        ~ ~
        #:kind kind                      ~ ~
        #:lazy? lazy?                    ~ ~
        #:equal-key/c equal-key/c]) -> contract? ~ ~
  elem/c : chaperone-contract? ~ ~
  cmp : (or/c 'dont-care 'equal 'eqv 'eq) = 'dont-care ~ ~
  kind : (or/c 'dont-care 'immutable 'mutable 'weak 'mutable-or-weak) ~ ~
       = 'immutable
  lazy? : any/c = (not (and (equal? kind 'immutable) ~ ~
                            (flat-contract? elem/c)))
  equal-key/c : contract? = any/c ~ ~

Constructs a contract that recognizes sets whose elements match  elem/c.

If kind is 'immutable, 'mutable, or  'weak, the resulting contract
accepts only hash sets that  are respectively immutable, mutable with
strongly-held keys, or mutable with  weakly-held keys.  If kind is
'mutable-or-weak, the  resulting contract accepts any mutable hash sets,
regardless of  key-holding strength.

If cmp is 'equal, 'eqv, or 'eq, the  resulting contract accepts only
hash sets that compare elements  using equal?, eqv?, or eq?,
respectively.

If cmp is 'eqv or 'eq, then elem/c must  be a flat contract.

If cmp and kind are both 'dont-care, then the  resulting contract will
accept any kind of set, not just hash sets.

If lazy? is not #f, then the elements of the set are not checked
immediately by the contract and only the set itself is checked
(according to the cmp and kind arguments). If lazy? is #f, then the
elements are checked immediately by the contract. The lazy? argument is
ignored when the set contract accepts generic sets (i.e., when cmp and
kind are both 'dont-care); in that case, the value being checked in that
case is a list?, then the contract is not lazy otherwise the contract is
lazy.

If kind allows mutable sets (i.e., is 'dont-care, 'mutable, 'weak, or
'mutable-or-weak) and lazy? is #f, then the elements are checked both
immediately and when they are accessed from the set.

The equal-key/c contract is used when values are passed to the
comparison and hashing functions used internally.

The result contract will be a flat contract when elem/c and equal-key/c
are both flat contracts, lazy? is #f, and kind is 'immutable. The result
will be a chaperone contract when elem/c is a chaperone contract.

17.3. Generic Set Interface

gen:set

A generic interface (see [missing]) that supplies set method
implementations for a structure type via the #:methods option of struct
definitions.  This interface can be used to implement any of the methods
documented as Set Methods.

Examples:

  > (struct binary-set [integer]
      #:transparent ~ ~
      #:methods gen:set ~ ~
      [(define (set-member? st i)
         (bitwise-bit-set? (binary-set-integer st) i))
       (define (set-add st i)
         (binary-set (bitwise-ior (binary-set-integer st)
                                  (arithmetic-shift 1 i))))
       (define (set-remove st i)
         (binary-set (bitwise-and (binary-set-integer st)
                                  (bitwise-not (arithmetic-shift 1 i)))))])
  > (define bset (binary-set 5))
  > bset
  (binary-set 5)
  > (generic-set? bset)
  #t
  > (set-member? bset 0)
  #t
  > (set-member? bset 1)
  #f
  > (set-member? bset 2)
  #t
  > (set-add bset 4)
  (binary-set 21)
  > (set-remove bset 2)
  (binary-set 1)

17.3.1. Set Methods

The methods of gen:set can be classified into three categories, as
determined by their fallback implementations:

* methods with no fallbacks,

* methods whose fallbacks depend on other, non-fallback methods,

* and methods whose fallbacks can depend on either fallback or
  non-fallback methods.

As an example, implementing the following methods would guarantee that
all the methods in gen:set would at least have a fallback method:

* set-member?

* set-add

* set-add!

* set-remove

* set-remove!

* set-first

* set-empty?

* set-copy-clear

There may be other such subsets of methods that would guarantee at least
a fallback for every method.

                                        *set-member?*
(set-member? st v) -> boolean? ~
  st : generic-set? ~ ~
  v : any/c ~ ~

Returns #t if v is in st, #f otherwise. Has no fallback.

                                        *set-add*
(set-add st v) -> generic-set? ~
  st : generic-set? ~ ~
  v : any/c ~ ~

Produces a set that includes v plus all elements of st. This operation
runs in constant time for hash sets. Has no fallback.

                                        *set-add!*
(set-add! st v) -> void? ~
  st : generic-set? ~ ~
  v : any/c ~ ~

Adds the element v to st.  This operation runs in constant time for hash
sets. Has no fallback.

                                        *set-remove*
(set-remove st v) -> generic-set? ~
  st : generic-set? ~ ~
  v : any/c ~ ~

Produces a set that includes all elements of st except v. This operation
runs in constant time for hash sets. Has no fallback.

                                        *set-remove!*
(set-remove! st v) -> void? ~
  st : generic-set? ~ ~
  v : any/c ~ ~

Removes the element v from st.  This operation runs in constant time for
hash sets. Has no fallback.

                                        *set-empty?*
(set-empty? st) -> boolean? ~
  st : generic-set? ~ ~

Returns #t if st has no members; returns #f otherwise.

Supported for any st that implements set->stream or set-count.

                                        *set-count*
(set-count st) -> exact-nonnegative-integer? ~
  st : generic-set? ~ ~

Returns the number of elements in st.

Supported for any st that supports set->stream.

                                        *set-first*
(set-first st) -> any/c ~
  st : (and/c generic-set? (not/c set-empty?)) ~ ~

Produces an unspecified element of st. Multiple uses of set-first on st
produce the same result.

Supported for any st that implements set->stream.

                                        *set-rest*
(set-rest st) -> generic-set? ~
  st : (and/c generic-set? (not/c set-empty?)) ~ ~

Produces a set that includes all elements of st except (set-first st).

Supported for any st that implements set-remove and either set-first or
set->stream.

                                        *set->stream*
(set->stream st) -> stream? ~
  st : generic-set? ~ ~

Produces a stream containing the elements of st.

Supported for any st that implements:

* set->list

* in-set

* set-empty?, set-first, set-rest

* set-empty?, set-first, set-remove

* set-count, set-first, set-rest

* set-count, set-first, set-remove

                                        *set-copy*
(set-copy st) -> generic-set? ~
  st : generic-set? ~ ~

Produces a new, mutable set of the same type and with the same elements
as st.

Supported for any st that supports set->stream and implements
set-copy-clear and set-add!.

                                        *set-copy-clear*
(set-copy-clear st) -> (and/c generic-set? set-empty?) ~
  st : generic-set? ~ ~

Produces a new, empty set of the same type, mutability, and key strength
as st.

A difference between set-copy-clear and set-clear is that the latter
conceptually iterates set-remove on the given set, and so it preserves
any contract on the given set. The set-copy-clear function produces a
new set without any contracts.

The set-copy-clear function must call concrete set constructors and thus
has no generic fallback.

                                        *set-clear*
(set-clear st) -> (and/c generic-set? set-empty?) ~
  st : generic-set? ~ ~

Produces a set like st but with all elements removed.

Supported for any st that implements set-remove and supports
set->stream.

                                        *set-clear!*
(set-clear! st) -> void? ~
  st : generic-set? ~ ~

Removes all elements from st.

Supported for any st that implements set-remove! and either supports
set->stream or implements set-first and either set-count or set-empty?.

                                        *set-union*
(set-union st0 st ...) -> generic-set? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Produces a set of the same type as st0 that includes the elements from
st0 and all of the sts.

If st0 is a list, each st must also be a list.  This operation runs on
lists in time proportional to the total size of the sts times the size
of the result.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the total size of all of the sets except the
largest immutable set.

At least one set must be provided to set-union to determine the type of
the resulting set (list, hash set, etc.).  If there is a case where
set-union may be applied to zero arguments, instead pass an empty set of
the intended type as the first argument.

Supported for any st that implements  set-add and supports set->stream.

Examples:

  > (set-union (set))
  (set)
  > (set-union (seteq))
  (seteq)
  > (set-union (set 1 2) (set 2 3))
  (set 1 3 2)
  > (set-union (list 1 2) (list 2 3))
  '(3 1 2)
  > (set-union (set 1 2) (seteq 2 3))
  set-union: set arguments have incompatible equivalence
  predicates
    first set: (set 1 2) ~ ~
    incompatible set: (seteq 2 3) ~ ~
  ; Sets of different types cannot be unioned

                                        *set-union!*
(set-union! st0 st ...) -> void? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Adds the elements from all of the sts to st0.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the total size of the sts.

Supported for any st that implements set-add! and supports set->stream.

                                        *set-intersect*
(set-intersect st0 st ...) -> generic-set? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Produces a set of the same type as st0 that includes the elements from
st0 that are also contained by all of the sts.

If st0 is a list, each st must also be a list.  This operation runs on
lists in time proportional to the total size of the sts times the size
of st0.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of the smallest immutable set.

Supported for any st that implements either set-remove or both set-clear
and set-add, and supports set->stream.

                                        *set-intersect!*
(set-intersect! st0 st ...) -> void? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Removes every element from st0 that is not contained by all of the sts.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st0.

Supported for any st that implements set-remove! and supports
set->stream.

                                        *set-subtract*
(set-subtract st0 st ...) -> generic-set? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Produces a set of the same type as st0 that includes the elements from
st0 that are not contained by any of the sts.

If st0 is a list, each st must also be a list.  This operation runs on
lists in time proportional to the total size of the sts times the size
of st0.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st0.

Supported for any st that implements either set-remove or both set-clear
and set-add, and supports set->stream.

                                        *set-subtract!*
(set-subtract! st0 st ...) -> void? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Removes every element from st0 that is contained by any of the sts.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st0.

Supported for any st that implements set-remove! and supports
set->stream.

                                        *set-symmetric-difference*
(set-symmetric-difference st0 st ...) -> generic-set? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Produces a set of the same type as st0 that includes all of the elements
contained an odd number of times in st0 and the sts.

If st0 is a list, each st must also be a list.  This operation runs on
lists in time proportional to the total size of the sts times the size
of st0.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the total size of all of the sets except the
largest immutable set.

Supported for any st that implements set-remove or both set-clear and
set-add, and supports set->stream.

Example:

  > (set-symmetric-difference (set 1) (set 1 2) (set 1 2 3))
  (set 1 3)

                                        *set-symmetric-difference!*
(set-symmetric-difference! st0 st ...) -> void? ~
  st0 : generic-set? ~ ~
  st : generic-set? ~ ~

Adds and removes elements of st0 so that it includes all of the elements
contained an odd number of times in the sts and the original contents of
st0.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the total size of the sts.

Supported for any st that implements set-remove! and supports
set->stream.

                                        *set=?*
(set=? st st2) -> boolean? ~
  st : generic-set? ~ ~
  st2 : generic-set? ~ ~

Returns #t if st and st2 contain the same members; returns #f otherwise.

If st0 is a list, each st must also be a list.  This operation runs on
lists in time proportional to the size of st times the size of st2.

If st0 is a hash set, each st must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st plus the size of st2.

Supported for any st and st2 that both support subset?; also supported
for any if st2 that implements set=? regardless of st.

Examples:

  > (set=? (list 1 2) (list 2 1))
  #t
  > (set=? (set 1) (set 1 2 3))
  #f
  > (set=? (set 1 2 3) (set 1))
  #f
  > (set=? (set 1 2 3) (set 1 2 3))
  #t
  > (set=? (seteq 1 2) (mutable-seteq 2 1))
  #t
  > (set=? (seteq 1 2) (seteqv 1 2))
  set=?: set arguments have incompatible equivalence
  predicates
    first set: (seteq 1 2) ~ ~
    incompatible set: (seteqv 1 2) ~ ~
  ; Sets of different types cannot be compared

                                        *subset?*
(subset? st st2) -> boolean? ~
  st : generic-set? ~ ~
  st2 : generic-set? ~ ~

Returns #t if st2 contains every member of st; returns #f otherwise.

If st is a list, then st2 must also be a list.  This operation runs on
lists in time proportional to the size of st times the size of st2.

If st is a hash set, then st2 must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st.

Supported for any st that supports set->stream.

Examples:

  > (subset? (set 1) (set 1 2 3))
  #t
  > (subset? (set 1 2 3) (set 1))
  #f
  > (subset? (set 1 2 3) (set 1 2 3))
  #t

                                        *proper-subset?*
(proper-subset? st st2) -> boolean? ~
  st : generic-set? ~ ~
  st2 : generic-set? ~ ~

Returns #t if st2 contains every member of st and at least one
additional element; returns #f otherwise.

If st is a list, then st2 must also be a list.  This operation runs on
lists in time proportional to the size of st times the size of st2.

If st is a hash set, then st2 must also be a hash set that uses the same
comparison function (equal?, eqv?, or eq?).  The mutability and key
strength of the hash sets may differ.  This operation runs on hash sets
in time proportional to the size of st plus the size of st2.

Supported for any st and st2 that both support subset?.

Examples:

  > (proper-subset? (set 1) (set 1 2 3))
  #t
  > (proper-subset? (set 1 2 3) (set 1))
  #f
  > (proper-subset? (set 1 2 3) (set 1 2 3))
  #f

                                        *set->list*
(set->list st) -> list? ~
  st : generic-set? ~ ~

Produces a list containing the elements of st.

Supported for any st that supports set->stream.

                                        *set-map*
(set-map st proc) -> (listof any/c) ~
  st : generic-set? ~ ~
  proc : (any/c . -> . any/c) ~ ~

Applies the procedure proc to each element in st in an unspecified
order, accumulating the results into a list.

Supported for any st that supports set->stream.

                                        *set-for-each*
(set-for-each st proc) -> void? ~
  st : generic-set? ~ ~
  proc : (any/c . -> . any) ~ ~

Applies proc to each element in st (for the side-effects of proc) in an
unspecified order.

Supported for any st that supports set->stream.

                                        *in-set*
(in-set st) -> sequence? ~
  st : generic-set? ~ ~

Explicitly converts a set to a sequence for use with for and other
forms.

Supported for any st that supports set->stream.

                                        *impersonate-hash-set*
(impersonate-hash-set  st               ~
                       inject-proc     
                       add-proc        
                       shrink-proc     
                       extract-proc    
                      [clear-proc      
                       equal-key-proc] 
                       prop            
                       prop-val ...    
                       ...)            
 -> (and/c (or/c set-mutable? set-weak?) impersonator?)
  st : (or/c set-mutable? set-weak?) ~ ~
  inject-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  add-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  shrink-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  extract-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  clear-proc : (or/c #f (-> set? any)) = #f ~ ~
  equal-key-proc : (or/c #f (-> set? any/c any/c)) = #f ~ ~
  prop : impersonator-property? ~ ~
  prop-val : any/c ~ ~

Impersonates st, redirecting various set operations via the given
procedures.

The inject-proc procedure is called whenever an element is temporarily
put into the set for the purposes of comparing it with other elements
that may already be in the set. For example, when evaluating
(set-member? s e), e will be passed to the inject-proc before comparing
it with other elements of s.

The add-proc procedure is called when adding an element to a set, e.g.,
via set-add or set-add!. The result of the add-proc is stored in the
set.

The shrink-proc procedure is called when building a new set with one
fewer element. For example, when evaluating (set-remove s e) or
(set-remove! s e), an element is removed from a set, e.g., via
set-remove or set-remove!. The result of the shrink-proc is the element
actually removed from the set.

The extract-proc procedure is called when an element is pulled out of a
set, e.g., by set-first. The result of the extract-proc is the element
actually produced by from the set.

The clear-proc is called by set-clear and set-clear! and if it returns
(as opposed to escaping, perhaps via raising an exception), the clearing
operation is permitted. Its result is ignored. If clear-proc is #f, then
clearing is done element by element (via calls into the other supplied
procedures).

The equal-key-proc is called when an element’s hash code is needed of
when an element is supplied to the underlying equality in the set. The
result of equal-key-proc is used when computing the hash or comparing
for equality.

If any of the inject-proc, add-proc, shrink-proc, or extract-proc
arguments are  #f, then they all must be #f, the clear-proc and
equal-key-proc must also be #f, and there must be at least one property
supplied.

Pairs of prop and prop-val (the number of arguments to
impersonate-hash-set must be odd) add impersonator properties or
override impersonator property values of st.

                                        *chaperone-hash-set*
(chaperone-hash-set  st               ~
                     inject-proc     
                     add-proc        
                     shrink-proc     
                     extract-proc    
                    [clear-proc      
                     equal-key-proc] 
                     prop            
                     prop-val ...    
                     ...)            
 -> (and/c (or/c set? set-mutable? set-weak?) chaperone?)
  st : (or/c set? set-mutable? set-weak?) ~ ~
  inject-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  add-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  shrink-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  extract-proc : (or/c #f (-> set? any/c any/c)) ~ ~
  clear-proc : (or/c #f (-> set? any)) = #f ~ ~
  equal-key-proc : (or/c #f (-> set? any/c any/c)) = #f ~ ~
  prop : impersonator-property? ~ ~
  prop-val : any/c ~ ~

Chaperones st. Like impersonate-hash-set but with the constraints that
the results of the inject-proc, add-proc, shrink-proc, extract-proc, and
equal-key-proc must be chaperone-of? their second arguments. Also, the
input may be an immutable? set.

17.4. Custom Hash Sets

                                        *define-custom-set-types*
(define-custom-set-types name ~
                         optional-predicate
                         comparison-expr
                         optional-hash-functions)
 
     optional-predicate = 
                        | #:elem? predicate-expr ~ ~
                           
optional-hash-functions = 
                        | hash1-expr
                        | hash1-expr hash2-expr

Creates a new hash set type based on the given comparison
comparison-expr, hash functions hash1-expr and hash2-expr, and element
predicate predicate-expr; the interfaces for these functions are the
same as in make-custom-set-types.  The new set type has three variants:
immutable, mutable with strongly-held elements, and mutable with
weakly-held elements.

Defines seven names:

* name? recognizes instances of the new type,

* immutable-name? recognizes immutable instances of the new type,

* mutable-name? recognizes mutable instances of the new type with
  strongly-held elements,

* weak-name? recognizes mutable instances of the new type with
  weakly-held elements,

* make-immutable-name constructs immutable instances of the new type,

* make-mutable-name constructs mutable instances of the new type with
  strongly-held elements, and

* make-weak-name constructs mutable instances of the new type with
  weakly-held elements.

The constructors all accept a stream as an optional argument, providing
initial elements.

Examples:

  > (define-custom-set-types string-set
                             #:elem? string? ~ ~
                             string=?
                             string-length)
  > (define imm
      (make-immutable-string-set '("apple" "banana")))
  > (define mut
      (make-mutable-string-set '("apple" "banana")))
  > (generic-set? imm)
  #t
  > (generic-set? mut)
  #t
  > (set? imm)
  #t
  > (generic-set? imm)
  #t
  > (string-set? imm)
  #t
  > (string-set? mut)
  #t
  > (immutable-string-set? imm)
  #t
  > (immutable-string-set? mut)
  #f
  > (set-member? imm "apple")
  #t
  > (set-member? mut "banana")
  #t
  > (equal? imm mut)
  #f
  > (set=? imm mut)
  #t
  > (set-remove! mut "banana")
  > (set-member? mut "banana")
  #f
  > (equal? (set-remove (set-remove imm "apple") "banana")
            (make-immutable-string-set))
  #t

                                        *make-custom-set-types*
(make-custom-set-types  eql?           ~
                       [hash1         
                        hash2         
                        #:elem? elem?  ~ ~
                        #:name name    ~ ~
                        #:for who])    ~ ~
 -> (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (->* [] [stream?] generic-set?)
    (->* [] [stream?] generic-set?)
    (->* [] [stream?] generic-set?)
  eql? : (or/c (any/c any/c . -> . any/c) ~ ~
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?) ~ ~
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  elem? : (any/c . -> . boolean?) = (const #true) ~ ~
  name : symbol? = 'custom-set ~ ~
  who : symbol? = 'make-custom-set-types ~ ~

Creates a new set type based on the given comparison function eql?, hash
functions hash1 and hash2, and predicate elem?. The new set type has
variants that are immutable, mutable with strongly-held elements, and
mutable with weakly-held elements.  The given name is used when printing
instances of the new set type, and the symbol who is used for reporting
errors.

The comparison function eql? may accept 2 or 3 arguments.  If it accepts
2 arguments, it given two elements to compare them.  If it accepts 3
arguments and does not accept 2 arguments, it is also given a recursive
comparison function that handles data cycles when comparing sub-parts of
the elements.

The hash functions hash1 and hash2 may accept 1 or 2 arguments.  If
either hash function accepts 1 argument, it is applied to a element to
compute the corresponding hash value.  If either hash function accepts 2
arguments and does not accept 1 argument, it is also given a recursive
hash function that handles data cycles when computing hash values of
sub-parts of the elements.

The predicate elem? must accept 1 argument and is used to recognize
valid elements for the new set type.

Produces seven values:

* a predicate recognizing all instances of the new set type,

* a predicate recognizing weak instances,

* a predicate recognizing mutable instances,

* a predicate recognizing immutable instances,

* a constructor for weak instances,

* a constructor for mutable instances, and

* a constructor for immutable instances.

See define-custom-set-types for an example.

18. Procedures

                                        *procedure?*
(procedure? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a procedure, #f otherwise.

                                        *apply*
(apply proc v ... lst #:<kw> kw-arg ...) -> any ~ ~ ~
  proc : procedure? ~ ~
  v : any/c ~ ~
  lst : list? ~ ~
  kw-arg : any/c ~ ~

+[missing] in [missing] introduces apply.

Applies proc using the content of (list* v ... lst) as the (by-position)
arguments. The #:<kw> kw-arg sequence is also supplied as keyword
arguments to proc, where #:<kw> stands for any keyword.

The given proc must accept as many arguments as the number of vs plus
length of lst, it must accept the supplied keyword arguments, and it
must not require any other keyword arguments; otherwise, the
exn:fail:contract exception is raised. The given proc is called in tail
position with respect to the apply call.

Examples:

  > (apply + '(1 2 3))
  6
  > (apply + 1 2 '(3))
  6
  > (apply + '())
  0
  > (apply sort (list (list '(2) '(1)) <) #:key car) ~ ~
  '((1) (2))

                                        *compose*
(compose proc ...) -> procedure? ~
  proc : procedure? ~ ~
(compose1 proc ...) -> procedure?
  proc : procedure? ~ ~

Returns a procedure that composes the given functions, applying the last
proc first and the first proc last.  The compose function allows the
given functions to consume and produce any number of values, as long as
each function produces as many values as the preceding function
consumes, while compose1 restricts the internal value passing to a
single value.  In both cases, the input arity of the last function and
the output arity of the first are unrestricted, and they become the
corresponding arity of the resulting composition (including keyword
arguments for the input side).

When no proc arguments are given, the result is values.  When exactly
one is given, it is returned.

Examples:

  > ((compose1 - sqrt) 10)
  -3.1622776601683795
  > ((compose1 sqrt -) 10)
  0+3.1622776601683795i
  > ((compose list split-path) (bytes->path #"/a" 'unix))
  '(#<path:/> #<path:a> #f)

Note that in many cases, compose1 is preferred.  For example, using
compose with two library functions may lead to problems when one
function is extended to return two values, and the preceding one has an
optional input with different semantics.  In addition, compose1 may
create faster compositions.

                                        *procedure-rename*
(procedure-rename proc name) -> procedure? ~
  proc : procedure? ~ ~
  name : symbol? ~ ~

Returns a procedure that is like proc, except that its name as returned
by object-name (and as printed for debugging) is name.

The given name is used for printing an error message if the resulting
procedure is applied to the wrong number of arguments.  In addition, if
proc is an accessor or mutator produced by struct,
make-struct-field-accessor, or make-struct-field-mutator, the resulting
procedure also uses name when its (first) argument has the wrong type.
More typically, however, name is not used for reporting errors, since
the procedure name is typically hard-wired into an internal check.

                                        *procedure->method*
(procedure->method proc) -> procedure? ~
  proc : procedure? ~ ~

Returns a procedure that is like proc except that, when applied to the
wrong number of arguments, the resulting error hides the first argument
as if the procedure had been compiled with the 'method-arity-error
syntax property.

                                        *procedure-closure-contents-eq?*
(procedure-closure-contents-eq? proc1       ~
                                proc2) -> boolean?
  proc1 : procedure? ~ ~
  proc2 : procedure? ~ ~

Compares the contents of the closures of proc1 and proc2 for equality by
comparing closure elements pointwise using eq?

18.1. Keywords and Arity

                                        *keyword-apply*
(keyword-apply proc                    ~
               kw-lst                 
               kw-val-lst             
               v ...                  
               lst                    
               #:<kw> kw-arg ...) -> any ~ ~
  proc : procedure? ~ ~
  kw-lst : (listof keyword?) ~ ~
  kw-val-lst : list? ~ ~
  v : any/c ~ ~
  lst : list? ~ ~
  kw-arg : any/c ~ ~

+[missing] in [missing] introduces keyword-apply.

Like apply, but kw-lst and kw-val-lst supply by-keyword arguments in
addition to the by-position arguments of the vs and lst, and in addition
to the directly supplied keyword arguments in the #:<kw> kw-arg
sequence, where #:<kw> stands for any keyword.

The given kw-lst must be sorted using keyword<?.  No keyword can appear
twice in kw-lst or in both kw-list and as a #:<kw>, otherwise, the
exn:fail:contract exception is raised. The given kw-val-lst must have
the same length as kw-lst, otherwise, the exn:fail:contract exception is
raised. The given proc must accept all of the keywords in kw-lst plus
the #:<kw>s, it must not require any other keywords, and it must accept
as many by-position arguments as supplied via the vs and lst; otherwise,
the exn:fail:contract exception is raised.

Examples:

  (define (f x #:y y #:z [z 10]) ~ ~
    (list x y z))
   
  > (keyword-apply f '(#:y) '(2) '(1)) ~ ~
  '(1 2 10)
  > (keyword-apply f '(#:y #:z) '(2 3) '(1)) ~ ~
  '(1 2 3)
  > (keyword-apply f #:z 7 '(#:y) '(2) '(1)) ~ ~
  '(1 2 7)

                                        *procedure-arity*
(procedure-arity proc) -> normalized-arity? ~
  proc : procedure? ~ ~

Returns information about the number of by-position arguments accepted
by proc. See also procedure-arity?, normalized-arity?, and
procedure-arity-mask.

                                        *procedure-arity?*
(procedure-arity? v) -> boolean? ~
  v : any/c ~ ~

A valid arity a is one of the following:

* An exact non-negative integer, which means that the procedure accepts
  a arguments, only.

* A arity-at-least instance, which means that the procedure accepts
  (arity-at-least-value a) or more arguments.

* A list containing integers and arity-at-least instances, which means
  that the procedure accepts any number of arguments that can match one
  of the elements of a.

The result of procedure-arity is always normalized in the sense of
normalized-arity?.

Examples:

  > (procedure-arity cons)
  2
  > (procedure-arity list)
  (arity-at-least 0)
  > (arity-at-least? (procedure-arity list))
  #t
  > (arity-at-least-value (procedure-arity list))
  0
  > (arity-at-least-value (procedure-arity (lambda (x . y) x)))
  1
  > (procedure-arity (case-lambda [(x) 0] [(x y) 1]))
  '(1 2)

                                        *procedure-arity-mask*
(procedure-arity-mask proc) -> exact-integer? ~
  proc : procedure? ~ ~

Returns the same information as procedure-arity, but encoded
differently. The arity is encoded as an exact integer mask where
(bitwise-bit-set? mask n) returns true if proc accepts n arguments.

The mask encoding of an arity is often easier to test and manipulate,
and procedure-arity-mask is sometimes faster than procedure-arity while
always being at least as fast.

Added in version 7.0.0.11.

                                        *procedure-arity-includes?*
(procedure-arity-includes? proc k [kws-ok?]) -> boolean? ~
  proc : procedure? ~ ~
  k : exact-nonnegative-integer? ~ ~
  kws-ok? : any/c = #f ~ ~

Returns #t if the procedure can accept k by-position arguments, #f
otherwise.  If kws-ok? is #f, the result is #t only if proc has no
required keyword arguments.

Examples:

  > (procedure-arity-includes? cons 2)
  #t
  > (procedure-arity-includes? display 3)
  #f
  > (procedure-arity-includes? (lambda (x #:y y) x) 1) ~ ~
  #f
  > (procedure-arity-includes? (lambda (x #:y y) x) 1 #t) ~ ~
  #t

                                        *procedure-reduce-arity*
(procedure-reduce-arity proc arity [name]) -> procedure? ~
  proc : procedure? ~ ~
  arity : procedure-arity? ~ ~
  name : (or/c symbol? #f) = #f ~ ~

Returns a procedure that is the same as proc (including the same name
returned by object-name), but that accepts only arguments consistent
with arity. In particular, when procedure-arity is applied to the
generated procedure, it returns a value that is equal? to the normalized
form of arity.

If the arity specification allows arguments that are not in
(procedure-arity proc), the exn:fail:contract exception is raised.  If
proc accepts keyword argument, either the keyword arguments must be all
optional (and they are not accepted in by the arity-reduced procedure)
or arity must be the empty list (which makes a procedure that cannot be
called); otherwise, the exn:fail:contract exception is raised.

If name is not #f, then object-name of the result procedure produces
name. Otherwise, object-name of the result procedure produces the same
result as for proc.

Examples:

  > (define my+ (procedure-reduce-arity + 2))
  > (my+ 1 2)
  3
  > (my+ 1 2 3)
  +: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 2 ~ ~
    given: 3 ~ ~
    arguments...: ~ ~
     1
     2
     3
  > (define also-my+ (procedure-reduce-arity + 2 'also-my+))
  > (also-my+ 1 2 3)
  also-my+: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 2 ~ ~
    given: 3 ~ ~
    arguments...: ~ ~
     1
     2
     3

Changed in version 7.0.0.11: Added the optional name argument.

                                        *procedure-reduce-arity-mask*
(procedure-reduce-arity-mask proc mask [name]) -> procedure? ~
  proc : procedure? ~ ~
  mask : exact-integer? ~ ~
  name : (or/c symbol? #f) = #f ~ ~

The same as procedure-reduce-arity, but using the representation of
arity described with procedure-arity-mask.

The mask encoding of an arity is often easier to test and manipulate,
and procedure-reduce-arity-mask is sometimes faster than
procedure-reduce-arity while always being at least as fast.

Added in version 7.0.0.11.

                                        *procedure-keywords*
(procedure-keywords proc) -> (listof keyword?) ~
                             (or/c (listof keyword?) #f)
  proc : procedure? ~ ~

Returns information about the keyword arguments required and accepted by
a procedure. The first result is a list of distinct keywords (sorted by
keyword<?) that are required when applying proc. The second result is a
list of distinct accepted keywords (sorted by keyword<?), or #f to mean
that any keyword is accepted. When the second result is a list, every
element in the first list is also in the second list.

Examples:

  > (procedure-keywords +)
  '()
  '()
  > (procedure-keywords (lambda (#:tag t #:mode m) t)) ~ ~
  '(#:mode #:tag)
  '(#:mode #:tag)
  > (procedure-keywords (lambda (#:tag t #:mode [m #f]) t)) ~ ~
  '(#:tag)
  '(#:mode #:tag)

                                        *procedure-result-arity*
(procedure-result-arity proc) -> (or/c #f procedure-arity?) ~
  proc : procedure? ~ ~

Returns the arity of the result of the procedure proc or #f if the
number of results are not known, perhaps due to shortcomings in the
implementation of procedure-result-arity or because proc’s behavior is
not sufficiently simple.

Examples:

  > (procedure-result-arity car)
  1
  > (procedure-result-arity values)
  (arity-at-least 0)
  > (procedure-result-arity
     (λ (x)
       (apply
        values
        (let loop ()
          (cond
            [(zero? (random 10)) '()]
            [else (cons 1 (loop))])))))
  #f

Added in version 6.4.0.3.

                                        *make-keyword-procedure*
(make-keyword-procedure proc [plain-proc]) -> procedure? ~
  proc : (((listof keyword?) list?) () #:rest list? . ->* . any) ~ ~
  plain-proc : procedure? ~ ~
             = (lambda args (apply proc null null args))

Returns a procedure that accepts all keyword arguments (without
requiring any keyword arguments).

When the procedure returned by make-keyword-procedure is called with
keyword arguments, then proc is called; the first argument is a list of
distinct keywords sorted by keyword<?, the second argument is a parallel
list containing a value for each keyword, and the remaining arguments
are the by-position arguments.

When the procedure returned by make-keyword-procedure is called without
keyword arguments, then plain-proc is called—possibly more efficiently
than dispatching through proc. Normally, plain-proc should have the same
behavior as calling proc with empty lists as the first two arguments,
but that correspondence is in no way enforced.

The result of procedure-arity and object-name on the new procedure is
the same as for plain-proc. See also procedure-reduce-keyword-arity and
procedure-rename.

Examples:

  (define show
    (make-keyword-procedure (lambda (kws kw-args . rest)
                              (list kws kw-args rest))))
   
  > (show 1)
  '(() () (1))
  > (show #:init 0 1 2 3 #:extra 4) ~ ~
  '((#:extra #:init) (4 0) (1 2 3))
   
  (define show2
    (make-keyword-procedure (lambda (kws kw-args . rest)
                              (list kws kw-args rest))
                            (lambda args
                              (list->vector args))))
   
  > (show2 1)
  '#(1)
  > (show2 #:init 0 1 2 3 #:extra 4) ~ ~
  '((#:extra #:init) (4 0) (1 2 3))

                                        *procedure-reduce-keyword-arity*
(procedure-reduce-keyword-arity proc              ~
                                arity            
                                required-kws     
                                allowed-kws) -> procedure?
  proc : procedure? ~ ~
  arity : procedure-arity? ~ ~
  required-kws : (listof keyword?) ~ ~
  allowed-kws : (or/c (listof keyword?) ~ ~
                      #f)

Like procedure-reduce-arity, but constrains the keyword arguments
according to required-kws and allowed-kws, which must be sorted using
keyword<? and contain no duplicates. If allowed-kws is #f, then the
resulting procedure still accepts any keyword, otherwise the keywords in
required-kws must be a subset of those in allowed-kws. The original proc
must require no more keywords than the ones listed in required-kws, and
it must allow at least the keywords in allowed-kws (or it must allow all
keywords if allowed-kws is #f).

Examples:

  (define orig-show
    (make-keyword-procedure (lambda (kws kw-args . rest)
                              (list kws kw-args rest))))
  (define show (procedure-reduce-keyword-arity
                orig-show 3 '(#:init) '(#:extra #:init))) ~ ~
   
  > (show #:init 0 1 2 3 #:extra 4) ~ ~
  '((#:extra #:init) (4 0) (1 2 3))
  > (show 1)
  unknown: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 3 plus an argument with keyword #:init plus an ~ ~
  optional argument with keyword #:extra
    given: 1 ~ ~
    arguments...: ~ ~
     1
  > (show #:init 0 1 2 3 #:extra 4 #:more 7) ~ ~
  application: procedure does not expect an argument with
  given keyword
    procedure: unknown ~ ~
    given keyword: #:more ~ ~
    arguments...: ~ ~
     1
     2
     3
     #:extra 4 ~ ~
     #:init 0 ~ ~
     #:more 7 ~ ~

                                        *procedure-reduce-keyword-arity-mask*
(procedure-reduce-keyword-arity-mask proc              ~
                                     mask             
                                     required-kws     
                                     allowed-kws) -> procedure?
  proc : procedure? ~ ~
  mask : exact-integer? ~ ~
  required-kws : (listof keyword?) ~ ~
  allowed-kws : (or/c (listof keyword?) ~ ~
                       #f)

The same as procedure-reduce-keyword-arity, but using the representation
of arity described with procedure-arity-mask.

Added in version 7.0.0.11.

                                        *struct*
(struct arity-at-least (value) ~
    #:extra-constructor-name make-arity-at-least) ~ ~
  value : exact-nonnegative-integer? ~ ~

A structure type used for the result of procedure-arity. See also
procedure-arity?.

prop:procedure : struct-type-property? ~ ~

A structure type property to identify structure types whose instances
can be applied as procedures. In particular, when procedure? is applied
to the instance, the result will be #t, and when an instance is used in
the function position of an application expression, a procedure is
extracted from the instance and used to complete the procedure call.

If the prop:procedure property value is an exact non-negative integer,
it designates a field within the structure that should contain a
procedure. The integer must be between 0 (inclusive) and the number of
non-automatic fields in the structure type (exclusive, not counting
supertype fields). The designated field must also be specified as
immutable, so that after an instance of the structure is created, its
procedure cannot be changed. (Otherwise, the arity and name of the
instance could change, and such mutations are generally not allowed for
procedures.) When the instance is used as the procedure in an
application expression, the value of the designated field in the
instance is used to complete the procedure call. (This procedure can be
another structure that acts as a procedure; the immutability of
procedure fields disallows cycles in the procedure graph, so that the
procedure call will eventually continue with a non-structure procedure.)
That procedure receives all of the arguments from the application
expression. The procedure’s name (see object-name), arity (see
procedure-arity), and keyword protocol (see procedure-keywords) are also
used for the name, arity, and keyword protocol of the structure. If the
value in the designated field is not a procedure, then the instance
behaves like (case-lambda) (i.e., a procedure which does not accept any
number of arguments). See also procedure-extract-target.

Providing an integer proc-spec argument to make-struct-type is the same
as both supplying the value with the prop:procedure property and
designating the field as immutable (so that a property binding or
immutable designation is redundant and disallowed).

Examples:

  > (struct annotated-proc (base note)
      #:property prop:procedure ~ ~
                 (struct-field-index base))
  > (define plus1 (annotated-proc
                    (lambda (x) (+ x 1))
                    "adds 1 to its argument"))
  > (procedure? plus1)
  #t
  > (annotated-proc? plus1)
  #t
  > (plus1 10)
  11
  > (annotated-proc-note plus1)
  "adds 1 to its argument"

When the prop:procedure value is a procedure, it should accept at least
one non-keyword argument. When an instance of the structure is used in
an application expression, the property-value procedure is called with
the instance as the first argument. The remaining arguments to the
property-value procedure are the arguments from the application
expression (including keyword arguments). Thus, if the application
expression provides five non-keyword arguments, the property-value
procedure is called with six non-keyword arguments. The name of the
instance (see object-name) and its keyword protocol (see
procedure-keywords) are unaffected by the property-value procedure, but
the instance’s arity is determined by subtracting one from every
possible non-keyword argument count of the property-value procedure. If
the property-value procedure cannot accept at least one argument, then
the instance behaves like (case-lambda).

Providing a procedure proc-spec argument to make-struct-type is the same
as supplying the value with the prop:procedure property (so that a
specific property binding is disallowed).

Examples:

  > (struct fish (weight color)
      #:mutable ~ ~
      #:property ~ ~
      prop:procedure ~ ~
      (lambda (f n)
        (let ([w (fish-weight f)])
          (set-fish-weight! f (+ n w)))))
  > (define wanda (fish 12 'red))
  > (fish? wanda)
  #t
  > (procedure? wanda)
  #t
  > (fish-weight wanda)
  12
  > (for-each wanda '(1 2 3))
  > (fish-weight wanda)
  18

If the value supplied for the prop:procedure property is not an exact
non-negative integer or a procedure, the exn:fail:contract exception is
raised.

                                        *procedure-struct-type?*
(procedure-struct-type? type) -> boolean? ~
  type : struct-type? ~ ~

Returns #t if instances of the structure type represented by type are
procedures (according to procedure?), #f otherwise.

                                        *procedure-extract-target*
(procedure-extract-target proc) -> (or/c #f procedure?) ~
  proc : procedure? ~ ~

If proc is an instance of a structure type with property prop:procedure,
and if the property value indicates a field of the structure, and if the
field value is a procedure, then procedure-extract-target returns the
field value. Otherwise, the result is #f.

When a prop:procedure property value is a procedure, the procedure is
not returned by procedure-extract-target. Such a procedure is different
from one accessed through a structure field, because it consumes an
extra argument, which is always the structure that was applied as a
procedure. Keeping the procedure private ensures that is it always
called with a suitable first argument.

prop:arity-string : struct-type-property? ~ ~

A structure type property that is used for reporting arity-mismatch
errors when a structure type with the prop:procedure property is applied
to the wrong number of arguments. The value of the prop:arity-string
property must be a procedure that takes a single argument, which is the
misapplied structure, and returns a string. The result string is used
after the word “expects,” and it is followed in the error message by the
number of actual arguments.

Arity-mismatch reporting automatically uses procedure-extract-target
when the prop:arity-string property is not associated with a procedure
structure type.

Examples:

  > (struct evens (proc)
      #:property prop:procedure (struct-field-index proc) ~ ~
      #:property prop:arity-string ~ ~
      (lambda (p)
        "an even number of arguments"))
  > (define pairs
      (evens
       (case-lambda
        [() null]
        [(a b . more)
         (cons (cons a b)
               (apply pairs more))])))
  > (pairs 1 2 3 4)
  '((1 . 2) (3 . 4))
  > (pairs 5)
  #<procedure>: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: an even number of arguments ~ ~
    given: 1 ~ ~
    arguments...: ~ ~
     5

prop:checked-procedure : struct-type-property? ~ ~

A structure type property that is used with
checked-procedure-check-and-extract, which is a hook to allow the
compiler to improve the performance of keyword arguments. The property
can only be attached to a structure type without a supertype and with at
least two fields.

                                        *checked-procedure-check-and-extract*
(checked-procedure-check-and-extract type      ~
                                     v        
                                     proc     
                                     v1       
                                     v2)  -> any/c
  type : struct-type? ~ ~
  v : any/c ~ ~
  proc : (any/c any/c any/c . -> . any/c) ~ ~
  v1 : any/c ~ ~
  v2 : any/c ~ ~

Extracts a value from v if it is an instance of type, which must have
the property prop:checked-procedure. If v is such an instance, then the
first field of v is extracted and applied to v1 and v2; if the result is
a true value, the result is the value of the second field of v.

If v is not an instance of type, or if the first field of v applied to
v1 and v2 produces #f, then proc is applied to v, v1, and v2, and its
result is returned by checked-procedure-check-and-extract.

                                        *procedure-specialize*
(procedure-specialize proc) -> procedure? ~
  proc : procedure? ~ ~

Returns proc or its equivalent, but provides a hint to the run-time
system that it should spend extra time and memory to specialize the
implementation of proc.

The hint is currently used when proc is the value of a lambda or
case-lambda form that references variables bound outside of the lambda
or case-lambda, and when proc has not been previously applied.

Added in version 6.3.0.10.

18.2. Reflecting on Primitives

A primitive procedure is a built-in procedure that is implemented in
low-level language. Not all procedures of racket/base are primitives,
but many are. The distinction is mainly useful to other low-level code.

                                        *primitive?*
(primitive? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a primitive procedure, #f otherwise.

                                        *primitive-closure?*
(primitive-closure? v) -> boolean ~
  v : any/c ~ ~

Returns #t if v is internally implemented as a primitive closure rather
than a simple primitive procedure, #f otherwise.

                                        *primitive-result-arity*
(primitive-result-arity prim) -> procedure-arity? ~
  prim : primitive? ~ ~

Returns the arity of the result of the primitive procedure prim (as
opposed to the procedure’s input arity as returned by procedure-arity).
For most primitives, this procedure returns 1, since most primitives
return a single value when applied.

18.3. Additional Higher-Order Functions

 (require racket/function) package: base ~ ~

The bindings documented in this section are provided by the
racket/function and racket libraries, but not racket/base.

                                        *identity*
(identity v) -> any/c ~
  v : any/c ~ ~

Returns v.

                                        *const*
(const v) -> procedure? ~
  v : any ~ ~

Returns a procedure that accepts any arguments (including keyword
arguments) and returns v.

Examples:

  > ((const 'foo) 1 2 3)
  'foo
  > ((const 'foo))
  'foo

                                        *thunk*
(thunk  body ...+) ~
(thunk* body ...+)

The thunk form creates a nullary function that evaluates the given body.
The thunk* form is similar, except that the resulting function accepts
any arguments (including keyword arguments).

Examples:

  (define th1 (thunk (define x 1) (printf "~a\n" x)))
   
  > (th1)
  1
  > (th1 'x)
  th1: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 0 ~ ~
    given: 1 ~ ~
    arguments...: ~ ~
     'x
  > (th1 #:y 'z) ~ ~
  application: procedure does not accept keyword arguments
    procedure: th1 ~ ~
    arguments...: ~ ~
     #:y 'z ~ ~
   
  (define th2 (thunk* (define x 1) (printf "~a\n" x)))
   
  > (th2)
  1
  > (th2 'x)
  1
  > (th2 #:y 'z) ~ ~
  1

                                        *negate*
(negate proc) -> procedure? ~
  proc : procedure? ~ ~

Returns a procedure that is just like proc, except that it returns the
not of proc’s result.

Examples:

  > (filter (negate symbol?) '(1 a 2 b 3 c))
  '(1 2 3)
  > (map (negate =) '(1 2 3) '(1 1 1))
  '(#f #t #t)

((conjoin f ...) x ...) -> any
  f : procedure? ~ ~
  x : any/c ~ ~

Combines calls to each function with and.  Equivalent to (and (f x ...)
...)

Examples:

  (define f (conjoin exact? integer?))
   
  > (f 1)
  #t
  > (f 1.0)
  #f
  > (f 1/2)
  #f
  > (f 0.5)
  #f
  > ((conjoin (λ (x) (values 1 2))) 0)
  1
  2

((disjoin f ...) x ...) -> any
  f : procedure? ~ ~
  x : any/c ~ ~

Combines calls to each function with or.  Equivalent to (or (f x ...)
...)

Examples:

  (define f (disjoin exact? integer?))
   
  > (f 1)
  #t
  > (f 1.0)
  #t
  > (f 1/2)
  #t
  > (f 0.5)
  #f
  > ((disjoin (λ (x) (values 1 2))) 0)
  1
  2

                                        *curry*
(curry proc) -> procedure? ~
  proc : procedure? ~ ~
(curry proc v ...+) -> any/c
  proc : procedure? ~ ~
  v : any/c ~ ~

Returns a procedure that is a curried version of proc. When the
resulting procedure is first applied, unless it is given the maximum
number of arguments that it can accept, the result is a procedure to
accept additional arguments.

Examples:

  > ((curry list) 1 2)
  #<procedure:curried:list>
  > ((curry cons) 1)
  #<procedure:curried:cons>
  > ((curry cons) 1 2)
  '(1 . 2)

After the first application of the result of curry, each further
application accumulates arguments until an acceptable number of
arguments have been accumulated, at which point the original proc is
called.

Examples:

  > (((curry list) 1 2) 3)
  '(1 2 3)
  > (((curry list) 1) 3)
  '(1 3)
  > ((((curry foldl) +) 0) '(1 2 3))
  6
  > (define foo (curry (lambda (x y z) (list x y z))))
  > (foo 1 2 3)
  '(1 2 3)
  > (((((foo) 1) 2)) 3)
  '(1 2 3)

A function call (curry proc v ...) is equivalent to ((curry proc) v
...). In other words, curry itself is curried.

Examples:

  > (map ((curry +) 10) '(1 2 3))
  '(11 12 13)
  > (map (curry + 10) '(1 2 3))
  '(11 12 13)
  > (map (compose (curry * 2) (curry + 10)) '(1 2 3))
  '(22 24 26)

The curry function also supports functions with keyword arguments:
keyword arguments will be accumulated in the same way as positional
arguments until all required keyword arguments have been supplied.

Examples:

  (define (f #:a a #:b b #:c c) ~ ~
    (list a b c))
   
  > ((((curry f) #:a 1) #:b 2) #:c 3) ~ ~
  '(1 2 3)
  > ((((curry f) #:b 1) #:c 2) #:a 3) ~ ~
  '(3 1 2)
  > ((curry f #:a 1 #:c 2) #:b 3) ~ ~
  '(1 3 2)

Changed in version 7.0.0.7 of package base: Added support for keyword
arguments.

                                        *curryr*
(curryr proc) -> procedure? ~
  proc : procedure? ~ ~
(curryr proc v ...+) -> any/c
  proc : procedure? ~ ~
  v : any/c ~ ~

Like curry, except that the arguments are collected in the opposite
direction: the first step collects the rightmost group of arguments, and
following steps add arguments to the left of these.

Example:

  > (map (curryr list 'foo) '(1 2 3))
  '((1 foo) (2 foo) (3 foo))

                                        *normalized-arity?*
(normalized-arity? arity) -> boolean? ~
  arity : any/c ~ ~

A normalized arity has one of the following forms:

* the empty list;

* an exact non-negative integer;

* an arity-at-least instance;

* a list of two or more strictly increasing, exact non-negative
  integers; or

* a list of one or more strictly increasing, exact non-negative integers
  followed by a single arity-at-least instance whose value is greater
  than the preceding integer by at least 2.

Every normalized arity is a valid procedure arity and satisfies
procedure-arity?.  Any two normalized arity values that are arity=? must
also be equal?.

Examples:

  > (normalized-arity? (arity-at-least 1))
  #t
  > (normalized-arity? (list (arity-at-least 1)))
  #f
  > (normalized-arity? (list 0 (arity-at-least 2)))
  #t
  > (normalized-arity? (list (arity-at-least 2) 0))
  #f
  > (normalized-arity? (list 0 2 (arity-at-least 3)))
  #f

                                        *normalize-arity*
(normalize-arity arity) ~
 -> (and/c normalized-arity? (lambda (x) (arity=? x arity)))
  arity : procedure-arity? ~ ~

Produces a normalized form of arity.  See also normalized-arity? and
arity=?.

Examples:

  > (normalize-arity 1)
  1
  > (normalize-arity (list 1))
  1
  > (normalize-arity (arity-at-least 2))
  (arity-at-least 2)
  > (normalize-arity (list (arity-at-least 2)))
  (arity-at-least 2)
  > (normalize-arity (list 1 (arity-at-least 2)))
  (arity-at-least 1)
  > (normalize-arity (list (arity-at-least 2) 1))
  (arity-at-least 1)
  > (normalize-arity (list (arity-at-least 2) 3))
  (arity-at-least 2)
  > (normalize-arity (list 3 (arity-at-least 2)))
  (arity-at-least 2)
  > (normalize-arity (list (arity-at-least 6) 0 2 (arity-at-least 4)))
  (list 0 2 (arity-at-least 4))

                                        *arity=?*
(arity=? a b) -> boolean? ~
  a : procedure-arity? ~ ~
  b : procedure-arity? ~ ~

Returns #true if procedures with arity a and b accept the same numbers
of arguments, and #false otherwise. Equivalent to both (and
(arity-includes? a b) (arity-includes? b a)) and (equal?
(normalize-arity a) (normalize-arity b)).

Examples:

  > (arity=? 1 1)
  #t
  > (arity=? (list 1) 1)
  #t
  > (arity=? 1 (list 1))
  #t
  > (arity=? 1 (arity-at-least 1))
  #f
  > (arity=? (arity-at-least 1) 1)
  #f
  > (arity=? (arity-at-least 1) (list 1 (arity-at-least 2)))
  #t
  > (arity=? (list 1 (arity-at-least 2)) (arity-at-least 1))
  #t
  > (arity=? (arity-at-least 1) (list 1 (arity-at-least 3)))
  #f
  > (arity=? (list 1 (arity-at-least 3)) (arity-at-least 1))
  #f
  > (arity=? (list 0 1 2 (arity-at-least 3)) (list (arity-at-least 0)))
  #t
  > (arity=? (list (arity-at-least 0)) (list 0 1 2 (arity-at-least 3)))
  #t
  > (arity=? (list 0 2 (arity-at-least 3)) (list (arity-at-least 0)))
  #f
  > (arity=? (list (arity-at-least 0)) (list 0 2 (arity-at-least 3)))
  #f

                                        *arity-includes?*
(arity-includes? a b) -> boolean? ~
  a : procedure-arity? ~ ~
  b : procedure-arity? ~ ~

Returns #true if procedures with arity a accept any number of arguments
that procedures with arity b accept.

Examples:

  > (arity-includes? 1 1)
  #t
  > (arity-includes? (list 1) 1)
  #t
  > (arity-includes? 1 (list 1))
  #t
  > (arity-includes? 1 (arity-at-least 1))
  #f
  > (arity-includes? (arity-at-least 1) 1)
  #t
  > (arity-includes? (arity-at-least 1) (list 1 (arity-at-least 2)))
  #t
  > (arity-includes? (list 1 (arity-at-least 2)) (arity-at-least 1))
  #t
  > (arity-includes? (arity-at-least 1) (list 1 (arity-at-least 3)))
  #t
  > (arity-includes? (list 1 (arity-at-least 3)) (arity-at-least 1))
  #f
  >
  (arity-includes? (list 0 1 2 (arity-at-least 3)) (list (arity-at-least 0)))
  #t
  >
  (arity-includes? (list (arity-at-least 0)) (list 0 1 2 (arity-at-least 3)))
  #t
  >
  (arity-includes? (list 0 2 (arity-at-least 3)) (list (arity-at-least 0)))
  #f
  >
  (arity-includes? (list (arity-at-least 0)) (list 0 2 (arity-at-least 3)))
  #t

19. Void

The constant #<void> is returned by most forms and procedures that have
a side-effect and no useful result.

The #<void> value is always eq? to itself.

                                        *void?*
(void? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is the constant #<void>, #f otherwise.

                                        *void*
(void v ...) -> void? ~
  v : any/c ~ ~

Returns the constant #<void>. Each v argument is ignored.

20. Undefined

 (require racket/undefined) package: base ~ ~

The bindings documented in this section are provided by the
racket/undefined library, not racket/base or racket.

The constant undefined can be used as a placeholder value for a value to
be installed later, especially for cases where premature access of the
value is either difficult or impossible to detect or prevent.

The undefined value is always eq? to itself.

Added in version 6.0.0.6 of package base.

undefined : any/c ~ ~

The “undefined” constant.
