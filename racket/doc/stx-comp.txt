Syntax Object Bindings

                                        *bound-identifier=?*
(bound-identifier=? a-id b-id [phase-level]) -> boolean? ~
  a-id : syntax? ~ ~
  b-id : syntax? ~ ~
  phase-level : (or/c exact-integer? #f) ~ ~
              = (syntax-local-phase-level)

Returns #t if the identifier a-id would bind b-id (or vice versa) if the
identifiers were substituted in a suitable expression context at the
phase level indicated by phase-level, #f otherwise. A #f value for
phase-level corresponds to the label phase level.

Examples:

  > (define-syntax (check stx)
      (syntax-case stx ()
        [(_ x y)
         (if (bound-identifier=? #'x #'y)
             #'(let ([y 'wrong]) (let ([x 'binds]) y))
             #'(let ([y 'no-binds]) (let ([x 'wrong]) y)))]))
  > (check a a)
  'binds
  > (check a b)
  'no-binds
  > (define-syntax-rule (check-a x) (check a x))
  > (check-a a)
  'no-binds

                                        *free-identifier=?*
(free-identifier=?  a-id                 ~
                    b-id                
                   [a-phase-level       
                    b-phase-level]) -> boolean?
  a-id : identifier? ~ ~
  b-id : identifier? ~ ~
  a-phase-level : (or/c exact-integer? #f) ~ ~
                = (syntax-local-phase-level)
  b-phase-level : (or/c exact-integer? #f) = a-phase-level ~ ~

Returns #t if a-id and b-id access the same local binding, module
binding, or top-level binding—perhaps via rename transformers—at the
phase levels indicated by a-phase-level and b-phase-level, respectively.
A #f value for a-phase-level or b-phase-level corresponds to the label
phase level.

“Same module binding” means that the identifiers refer to the same
original definition site, and not necessarily to the same require or
provide site. Due to renaming in require and provide, or due to a
transformer binding to a rename transformer, the identifiers may return
distinct results with syntax-e.

Examples:

  > (define-syntax (check stx)
      (syntax-case stx ()
        [(_ x)
         (if (free-identifier=? #'car #'x)
             #'(list 'same: x) ~ ~
             #'(list 'different: x))])) ~ ~
  > (check car)
  '(same: #<procedure:car>)
  > (check mcar)
  '(different: #<procedure:mcar>)
  > (let ([car list])
      (check car))
  '(different: #<procedure:list>)
  > (require (rename-in racket/base [car kar]))
  > (check kar)
  '(same: #<procedure:car>)

                                        *free-transformer-identifier=?*
(free-transformer-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~ ~
  b-id : identifier? ~ ~

Same as (free-identifier=? a-id b-id (add1 (syntax-local-phase-level))).

                                        *free-template-identifier=?*
(free-template-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~ ~
  b-id : identifier? ~ ~

Same as (free-identifier=? a-id b-id (sub1 (syntax-local-phase-level))).

                                        *free-label-identifier=?*
(free-label-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~ ~
  b-id : identifier? ~ ~

Same as (free-identifier=? a-id b-id #f).

                                        *check-duplicate-identifier*
(check-duplicate-identifier ids) -> (or/c identifier? #f) ~
  ids : (listof identifier?) ~ ~

Compares each identifier in ids with every other identifier in the list
with bound-identifier=?. If any comparison returns #t, one of the
duplicate identifiers is returned (the first one in ids that is a
duplicate), otherwise the result is #f.

                                        *identifier-binding*
(identifier-binding  id-stx               ~
                    [phase-level         
                     top-level-symbol?]) 
 -> (or/c 'lexical
          #f
          (list/c module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f))
          (list/c symbol?))
  id-stx : identifier? ~ ~
  phase-level : (or/c exact-integer? #f) ~ ~
              = (syntax-local-phase-level)
  top-level-symbol? : any/c = #f ~ ~

Returns one of three (if top-level-symbol? is #f) or four (if
top-level-symbol? is true) kinds of values, depending on the binding of
id-stx at the phase level indicated by phase-level (where a #f value for
phase-level corresponds to the label phase level):

* The result is 'lexical if id-stx has a local binding.

* The result is a list of seven items when id-stx has a module binding:
  (list source-mod source-id nominal-source-mod nominal-source-id
  source-phase import-phase nominal-export-phase).

  * source-mod is a module path index (see [missing]) that indicates the
    defining module.

  * source-id is a symbol for the identifier’s name at its definition
    site in the source module. This can be different from the local name
    returned by syntax->datum for several reasons: the identifier is
    renamed on import, it is renamed on export, or it is implicitly
    renamed because the identifier (or its import) was generated by a
    macro invocation.

  * nominal-source-mod is a module path index (see [missing]) that
    indicates the module required into the context of id-stx to provide
    its binding. It can be different from source-mod due to a re-export
    in nominal-source-mod of some imported identifier.  If the same
    binding is imported in multiple ways, an arbitrary representative is
    chosen.

  * nominal-source-id is a symbol for the identifier’s name as exported
    by nominal-source-mod. It can be different from source-id due to a
    renaming provide, even if source-mod and nominal-source-mod are the
    same.

  * source-phase is an exact non-negative integer representing the
    source phase. For example, it is 1 if the source definition is
    for-syntax.

  * import-phase is 0 if the binding import of nominal-source-mode is a
    plain require, 1 if it is from a for-syntax import, etc.

  * nominal-export-phase is the phase level of the export from
    nominal-source-mod.

* The result is (list source-id) if id-stx has a top-level binding and
  top-level-symbol? is true.

* The result is #f if id-stx has a top-level binding and
  top-level-symbol? is #f or if id-stx is unbound. An unbound identifier
  is typically treated the same as an identifier whose top-level binding
  is a variable.

If id-stx is bound to a rename-transformer, the result from
identifier-binding is for the identifier in the transformer, so that
identifier-binding is consistent with free-identifier=?.

Changed in version 6.6.0.4: Added the top-level-symbol? argument to
report information on top-level bindings.

                                        *identifier-transformer-binding*
(identifier-transformer-binding  id-stx            ~
                                [rt-phase-level]) 
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~ ~
  rt-phase-level : (or/c exact-integer? #f) ~ ~
                 = (syntax-local-phase-level)

Same as (identifier-binding id-stx (and rt-phase-level (add1
rt-phase-level))).

                                        *identifier-template-binding*
(identifier-template-binding id-stx) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~ ~

Same as (identifier-binding id-stx (sub1 (syntax-local-phase-level))).

                                        *identifier-label-binding*
(identifier-label-binding id-stx) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~ ~

Same as (identifier-binding id-stx #f).

                                        *identifier-binding-symbol*
(identifier-binding-symbol  id-stx             ~
                           [phase-level]) -> symbol?
  id-stx : identifier? ~ ~
  phase-level : (or/c exact-integer? #f) ~ ~
              = (syntax-local-phase-level)

Like identifier-binding, but produces a symbol that corresponds to the
binding. The symbol result is the same for any identifiers that are
free-identifier=?, but the result may also be the same for identifiers
that are not free-identifier=? (i.e., different symbols imply different
bindings, but the same symbol does not imply the same binding).

When identifier-binding would produce a list, then the second element of
that list is the result that identifier-binding-symbol produces.
