Sequences and Streams

Sequences and streams abstract over iteration of elements in a
collection. Sequences allow iteration with for macros or with sequence
operations such as sequence-map. Streams are functional sequences that
can be used either in a generic way or a stream-specific way. Generators
are closely related stateful objects that can be converted to a sequence
and vice-versa.

    1 Sequences
      1.1 Sequence Predicate and Constructors
      1.2 Sequence Conversion
      1.3 Sequence Combinations & Contract

    2 Streams

    3 Generators

1. Sequences

+[missing] in [missing] introduces sequences.

A sequence encapsulates an ordered collection of values. The elements of
a sequence can be extracted with one of the for syntactic forms, with
the procedures returned by sequence-generate, or by converting the
sequence into a stream.

The sequence datatype overlaps with many other datatypes.  Among
built-in datatypes, the sequence datatype includes the following:

* exact nonnegative integers (see below)

* strings (see [missing])

* byte strings (see [missing])

* lists (see [missing])

* mutable lists (see [missing])

* vectors (see [missing])

* flvectors (see [missing])

* fxvectors (see [missing])

* hash tables (see [missing])

* dictionaries (see [missing])

* sets (see [missing])

* input ports (see [missing])

* streams (see Streams)

An exact number k that is a non-negative integer acts as a sequence
similar to (in-range k), except that k by itself is not a stream.

Custom sequences can be defined using structure type properties.  The
easiest method to define a custom sequence is to use the gen:stream
generic interface. Streams are a suitable abstraction for data
structures that are directly iterable.  For example, a list is directly
iterable with first and rest. On the other hand, vectors are not
directly iterable: iteration has to go through an index. For data
structures that are not directly iterable, the iterator for the data
structure can be defined to be a stream (e.g., a structure containing
the index of a vector).

For example, unrolled linked lists (represented as a list of vectors)
themselves do not fit the stream abstraction, but have index-based
iterators that can be represented as streams:

Examples:
  > (struct unrolled-list-iterator (idx lst)
      #:methods gen:stream ~
      [(define (stream-empty? iter)
         (define lst (unrolled-list-iterator-lst iter))
         (or (null? lst)
             (and (>= (unrolled-list-iterator-idx iter)
                      (vector-length (first lst)))
                  (null? (rest lst)))))
       (define (stream-first iter)
         (vector-ref (first (unrolled-list-iterator-lst iter))
                     (unrolled-list-iterator-idx iter)))
       (define (stream-rest iter)
         (define idx (unrolled-list-iterator-idx iter))
         (define lst (unrolled-list-iterator-lst iter))
         (if (>= idx (sub1 (vector-length (first lst))))
             (unrolled-list-iterator 0 (rest lst))
             (unrolled-list-iterator (add1 idx) lst)))])

  > (define (make-unrolled-list-iterator ul)
      (unrolled-list-iterator 0 (unrolled-list-lov ul)))

  > (struct unrolled-list (lov)
      #:property prop:sequence ~
      make-unrolled-list-iterator)

  > (define ul1 (unrolled-list '(#(cracker biscuit) #(cookie scone))))

  > (for/list ([x ul1]) x)
  '(cracker biscuit cookie scone)

The prop:sequence property provides more flexibility in specifying
iteration, such as when a pre-processing step is needed to prepare the
data for iteration.  The make-do-sequence function creates a sequence
given a thunk that returns procedures to implement a sequence, and the
prop:sequence property can be associated with a structure type to
implement its implicit conversion to a sequence.

For most sequence types, extracting elements from a sequence has no
side-effect on the original sequence value; for example, extracting the
sequence of elements from a list does not change the list.  For other
sequence types, each extraction implies a side effect; for example,
extracting the sequence of bytes from a port causes the bytes to be read
from the port. A sequence’s state may either span all uses of the
sequence, as for a port, or it may be confined to each distinct time
that a sequence is initiated by a for form, sequence->stream,
sequence-generate, or sequence-generate*. Concretely, the thunk passed
to make-do-sequence is called to initiate the sequence each time the
sequence is used.

Individual elements of a sequence typically correspond to single values,
but an element may also correspond to multiple values.  For example, a
hash table generates two values—a key and its value—for each element in
the sequence.

1.1. Sequence Predicate and Constructors

                                        *sequence?*
(sequence? v) -> boolean? ~
  v : any/c ~

Returns #t if v can be used as a sequence,   #f otherwise.

  > (sequence? 42)
  #t
  > (sequence? '(a b c))
  #t
  > (sequence? "word")
  #t
  > (sequence? #\x)
  #f

                                        *in-range*
(in-range end) -> stream? ~
  end : number? ~
(in-range start end [step]) -> stream?
  start : number? ~
  end : number? ~
  step : number? = 1 ~

Returns a sequence (that is also a stream) whose elements are numbers.
The single-argument case (in-range end) is equivalent to (in-range 0 end
1).  The first number in the sequence is start, and each successive
element is generated by adding step to the previous element.  The
sequence stops before an element that would be greater or equal to end
if step is non-negative, or less or equal to end if step is negative.

An in-range application can provide better performance for number
iteration when it appears directly in a for clause.

Example: gaussian sum

  > (for/sum ([x (in-range 10)]) x)
  45

Example: sum of even numbers

  > (for/sum ([x (in-range 0 100 2)]) x)
  2450

                                        *in-naturals*
(in-naturals [start]) -> stream? ~
  start : exact-nonnegative-integer? = 0 ~

Returns an infinite sequence (that is also a stream) of exact integers
starting with start, where each element is one more than the preceding
element.

An in-naturals application can provide better performance for integer
iteration when it appears directly in a for clause.

  > (for/list ([k (in-naturals)]
               [x (in-range 10)])
      (list k x))
  '((0 0) (1 1) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9))

                                        *in-list*
(in-list lst) -> stream? ~
  lst : list? ~

Returns a sequence (that is also a stream) that is equivalent to using
lst directly as a sequence.

See [missing] for information on using lists as sequences.

An in-list application can provide better performance for list iteration
when it appears directly in a for clause.

  > (for/list ([x (in-list '(3 1 4))])
      `(,x ,(* x x)))
  '((3 9) (1 1) (4 16))

                                        *in-mlist*
(in-mlist mlst) -> sequence? ~
  mlst : mlist? ~

Returns a sequence equivalent to mlst.

See [missing] for information on using mutable lists as sequences.

An in-mlist application can provide better performance for mutable list
iteration when it appears directly in a for clause.

  > (for/list ([x (in-mlist (mcons "RACKET" (mcons "LANG" '())))])
      (string-length x))
  '(6 4)

                                        *in-vector*
(in-vector vec [start stop step]) -> sequence? ~
  vec : vector? ~
  start : exact-nonnegative-integer? = 0 ~
  stop : (or/c exact-integer? #f) = #f ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~

Returns a sequence equivalent to vec when no optional arguments are
supplied.

See [missing] for information on using vectors as sequences.

The optional arguments start, stop, and step are analogous to in-range,
except that a #f value for stop is equivalent to (vector-length vec).
That is, the first element in the sequence is (vector-ref vec start),
and each successive element is generated by adding step to index of the
previous element.  The sequence stops before an index that would be
greater or equal to end if step is non-negative, or less or equal to end
if step is negative.

If start is not a valid index, or stop is not in [-1, (vector-length
vec)] then the exn:fail:contract exception is raised.  If start is less
than stop and step is negative, then the exn:fail:contract:mismatch
exception is raised.  Similarly, if start is more than stop and step is
positive, then the exn:fail:contract:mismatch exception is raised.

An in-vector application can provide better performance for vector
iteration when it appears directly in a for clause.

  > (define (histogram vector-of-words)
      (define a-hash (make-hash))
      (for ([word (in-vector vector-of-words)])
        (hash-set! a-hash word (add1 (hash-ref a-hash word 0))))
      a-hash)

  > (histogram #("hello" "world" "hello" "sunshine"))
  '#hash(("sunshine" . 1) ("world" . 1) ("hello" . 2))

                                        *in-string*
(in-string str [start stop step]) -> sequence? ~
  str : string? ~
  start : exact-nonnegative-integer? = 0 ~
  stop : (or/c exact-integer? #f) = #f ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~

Returns a sequence equivalent to str when no optional arguments are
supplied.

See [missing] for information on using strings as sequences.

The optional arguments start, stop, and step are as in in-vector.

An in-string application can provide better performance for string
iteration when it appears directly in a for clause.

  > (define (line-count str)
      (for/sum ([ch (in-string str)])
        (if (char=? #\newline ch) 1 0)))

  > (line-count "this string\nhas\nthree \nnewlines")
  3

                                        *in-bytes*
(in-bytes bstr [start stop step]) -> sequence? ~
  bstr : bytes? ~
  start : exact-nonnegative-integer? = 0 ~
  stop : (or/c exact-integer? #f) = #f ~
  step : (and/c exact-integer? (not/c zero?)) = 1 ~

Returns a sequence equivalent to bstr when no optional arguments are
supplied.

See [missing] for information on using byte strings as sequences.

The optional arguments start, stop, and step are as in in-vector.

An in-bytes application can provide better performance for byte string
iteration when it appears directly in a for clause.

  > (define (has-eof? bs)
      (for/or ([ch (in-bytes bs)])
        (= ch 0)))

  > (has-eof? #"this byte string has an \0embedded zero byte")
  #t
  > (has-eof? #"this byte string does not")
  #f

                                        *in-port*
(in-port [r in]) -> sequence? ~
  r : (input-port? . -> . any/c) = read ~
  in : input-port? = (current-input-port) ~

Returns a sequence whose elements are produced by calling r on in until
it produces eof.

                                        *in-input-port-bytes*
(in-input-port-bytes in) -> sequence? ~
  in : input-port? ~

Returns a sequence equivalent to (in-port read-byte in).

                                        *in-input-port-chars*
(in-input-port-chars in) -> sequence? ~
  in : input-port? ~

Returns a sequence whose elements are read as characters from in
(equivalent to (in-port read-char in)).

                                        *in-lines*
(in-lines [in mode]) -> sequence? ~
  in : input-port? = (current-input-port) ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
       = 'any

Returns a sequence equivalent to (in-port (lambda (p) (read-line p
mode)) in).  Note that the default mode is 'any, whereas the default
mode of read-line is 'linefeed.

                                        *in-bytes-lines*
(in-bytes-lines [in mode]) -> sequence? ~
  in : input-port? = (current-input-port) ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
       = 'any

Returns a sequence equivalent to (in-port (lambda (p) (read-bytes-line p
mode)) in).  Note that the default mode is 'any, whereas the default
mode of read-bytes-line is 'linefeed.

                                        *in-hash*
(in-hash hash) -> sequence? ~
  hash : hash? ~

Returns a sequence equivalent to hash.

Examples:
  > (define table (hash 'a 1 'b 2))

  > (for ([(key value) (in-hash table)])
      (printf "key: ~a value: ~a\n" key value)) ~
  key: b value: 2
  key: a value: 1


See [missing] for information on using hash tables as sequences.

                                        *in-hash-keys*
(in-hash-keys hash) -> sequence? ~
  hash : hash? ~

Returns a sequence whose elements are the keys of hash.

Examples:
  > (define table (hash 'a 1 'b 2))

  > (for ([key (in-hash-keys table)])
      (printf "key: ~a\n" key)) ~
  key: b
  key: a


                                        *in-hash-values*
(in-hash-values hash) -> sequence? ~
  hash : hash? ~

Returns a sequence whose elements are the values of hash.

Examples:
  > (define table (hash 'a 1 'b 2))

  > (for ([value (in-hash-values table)])
      (printf "value: ~a\n" value)) ~
  value: 2
  value: 1


                                        *in-hash-pairs*
(in-hash-pairs hash) -> sequence? ~
  hash : hash? ~

Returns a sequence whose elements are pairs, each containing a key and
its value from hash (as opposed to using hash directly as a sequence to
get the key and value as separate values for each element).

Examples:
  > (define table (hash 'a 1 'b 2))

  > (for ([key+value (in-hash-pairs table)])
      (printf "key and value: ~a\n" key+value)) ~
  key and value: (b . 2)
  key and value: (a . 1)


                                        *in-directory*
(in-directory [dir use-dir?]) -> sequence? ~
  dir : (or/c #f path-string?) = #f ~
  use-dir? : ((and/c path? complete-path?) . -> . any/c) ~
           = (lambda (dir-path) #t)

Returns a sequence that produces all of the paths for files,
directories, and links within dir, except for the   contents of any
directory for which use-dir? returns   #f. If dir is not   #f, then
every produced path starts with dir as   its prefix.  If dir is #f, then
paths in and   relative to the current directory are produced.

An in-directory sequence traverses nested subdirectories   recursively
(filtered by use-dir?).   To generate a sequence that includes only the
immediate   content of a directory, use the result of directory-list as
a sequence.

Changed in version 6.0.0.1: Added use-dir? argument.

                                        *in-producer*
(in-producer producer) -> sequence? ~
  producer : procedure? ~
(in-producer producer stop arg ...) -> sequence?
  producer : procedure? ~
  stop : any/c ~
  arg : any/c ~

Returns a sequence that contains values from sequential calls to
producer, which would usually use some state to do its work.

If a stop value is not given, the sequence goes on infinitely, and
therefore it common to use it with a finite sequence or using #:break
etc.  If a stop value is given, it is used to identify a value that
marks the end of the sequence (and the stop value is not included in the
sequence); stop can be a predicate that is applied to the results of
producer, or it can be a value that is tested against the result of with
eq?.  (The stop argument must be a predicate if the stop value is itself
a function or if producer returns multiple values.)

If additional args are specified, they are passed to every call to
producer.

Examples:
  > (define (counter)
      (define n 0)
      (lambda ([d 1]) (set! n (+ d n)) n))

  > (for/list ([x (in-producer (counter))] [y (in-range 4)]) x)
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter))] #:break (= x 5)) x) ~
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter) 5)]) x)
  '(1 2 3 4)
  > (for/list ([x (in-producer (counter) 5 1/2)]) x)
  '(1/2 1 3/2 2 5/2 3 7/2 4 9/2)
  > (for/list ([x (in-producer read eof (open-input-string "1 2 3"))]) x)
  '(1 2 3)

                                        *in-value*
(in-value v) -> sequence? ~
  v : any/c ~

Returns a sequence that produces a single value: v.  This form is mostly
useful for let-like bindings in forms such as for*/list.

                                        *in-indexed*
(in-indexed seq) -> sequence? ~
  seq : sequence? ~

Returns a sequence where each element has two values: the value produced
by seq, and a non-negative exact integer starting with 0.  The elements
of seq must be single-valued.

                                        *in-sequences*
(in-sequences seq ...) -> sequence? ~
  seq : sequence? ~

Returns a sequence that is made of all input sequences, one after the
other. Each seq is initiated only after the preceding seq is exhausted.
If a single seq is provided, then seq is returned; otherwise, the
elements of each seq must all have the same number of values.

                                        *in-cycle*
(in-cycle seq ...) -> sequence? ~
  seq : sequence? ~

Similar to in-sequences, but the sequences are repeated in an infinite
cycle, where each seq is initiated afresh in each iteration. Beware that
if no seqs are provided or if all seqs become empty, then the sequence
produced by in-cycle never returns when an element is demanded—or even
when the sequence is initiated, if all seqs are initially empty.

                                        *in-parallel*
(in-parallel seq ...) -> sequence? ~
  seq : sequence? ~

Returns a sequence where each element has as many values as the number
of supplied seqs; the values, in order, are the values of each seq.  The
elements of each seq must be single-valued.

                                        *in-values-sequence*
(in-values-sequence seq) -> sequence? ~
  seq : sequence? ~

Returns a sequence that is like seq, but it combines multiple values for
each element from seq as a list of elements.

                                        *in-values*-sequence*
(in-values*-sequence seq) -> sequence? ~
  seq : sequence? ~

Returns a sequence that is like seq, but when an element of seq has
multiple values or a single list value, then the values are combined in
a list. In other words, in-values*-sequence is like in-values-sequence,
except that non-list, single-valued elements are not wrapped in a list.

                                        *stop-before*
(stop-before seq pred) -> sequence? ~
  seq : sequence? ~
  pred : (any/c . -> . any) ~

Returns a sequence that contains the elements of seq (which must be
single-valued), but only until the last element for which applying pred
to the element produces #t, after which the sequence ends.

                                        *stop-after*
(stop-after seq pred) -> sequence? ~
  seq : sequence? ~
  pred : (any/c . -> . any) ~

Returns a sequence that contains the elements of seq (which must be
single-valued), but only until the element (inclusive) for which
applying pred to the element produces #t, after which the sequence ends.

                                        *make-do-sequence*
(make-do-sequence thunk) -> sequence? ~
  thunk : (-> (values (any/c . -> . any) ~
                      (any/c . -> . any/c)
                      any/c
                      (or/c (any/c . -> . any/c) #f)
                      (or/c (() () #:rest list? . ->* . any/c) #f) ~
                      (or/c ((any/c) () #:rest list? . ->* . any/c) #f))) ~

Returns a sequence whose elements are generated by the procedures and
initial value returned by the thunk, which is called to initiate the
sequence.  The initiated sequence is defined in terms of a position,
which is initialized to the third result of the thunk, and the element,
which may consist of multiple values.

The thunk results define the generated elements as follows:

* The first result is a pos->element procedure that takes the current
  position and returns the value(s) for the current element.

* The second result is a next-pos procedure that takes the current
  position and returns the next position.

* The third result is the initial position.

* The fourth result is a continue-with-pos? function that takes the
  current position and returns a true result if the sequence includes
  the value(s) for the current position, and false if the sequence
  should end instead of including the value(s). Alternatively, the
  fourth result can be #f to indicate that the sequence should always
  include the current value(s).

* The fifth result is a continue-with-val? function that is like the
  fourth result, but it takes the current element value(s) instead of
  the current position.  Alternatively, the fifth result can be #f to
  indicate that the sequence should always include the value(s) at the
  current position.

* The sixth result is a continue-after-pos+val? procedure that takes
  both the current position and the current element value(s) and
  determines whether the sequence ends after the current element is
  already included in the sequence. Alternatively, the sixth result can
  be #f to indicate that the sequence can always continue after the
  current value(s).

Each of the procedures listed above is called only once per position.
Among the last three procedures, as soon as one of the procedures
returns #f, the sequence ends, and none are called again.  Typically,
one of the functions determines the end condition, and #f is used in
place of the other two functions.

prop:sequence : struct-type-property? ~

Associates a procedure to a structure type that takes an instance of the
structure and returns a sequence.  If v is an instance of a structure
type with this property, then (sequence? v) produces #t.

Using a pre-existing sequence:

Examples:
  > (struct my-set (table)
      #:property prop:sequence ~
      (lambda (s)
        (in-hash-keys (my-set-table s))))

  > (define (make-set . xs)
      (my-set (for/hash ([x (in-list xs)])
                (values x #t))))

  > (for/list ([c (make-set 'celeriac 'carrot 'potato)])
      c)
  '(celeriac carrot potato)

Using make-do-sequence:

Examples:
  > (define-struct train (car next)
      #:property prop:sequence ~
      (lambda (t)
        (make-do-sequence
         (lambda ()
           (values train-car train-next t
                   (lambda (t) t)
                   (lambda (v) #t)
                   (lambda (t v) #t))))))

  > (for/list ([c (make-train 'engine
                              (make-train 'boxcar
                                          (make-train 'caboose
                                                      #f)))])
      c)
  '(engine boxcar caboose)

1.2. Sequence Conversion

                                        *sequence->stream*
(sequence->stream seq) -> stream? ~
  seq : sequence? ~

Coverts a sequence to a stream, which supports the stream-first and
stream-rest operations. Creation of the stream eagerly initiates the
sequence, but the stream lazily draws elements from the sequence,
caching each element so that stream-first produces the same result each
time is applied to a stream.

If extracting an element from seq involves a side-effect, then the
effect is performed each time that either stream-first or stream-rest is
first used to access or skip an element.

                                        *sequence-generate*
(sequence-generate seq) -> (-> boolean?) (-> any) ~
  seq : sequence? ~

Initiates a sequence and returns two thunks to extract elements from the
sequence.  The first returns #t if more values are available for the
sequence.  The second returns the next element (which may be multiple
values) from the sequence; if no more elements are available, the
exn:fail:contract exception is raised.

                                        *sequence-generate**
(sequence-generate* seq) ~
 -> (or/c list? #f)
    (-> (values (or/c list? #f) procedure?))
  seq : sequence? ~

Like sequence-generate, but avoids state (aside from any inherent in the
sequence) by returning a list of values for the sequence’s first
element—or #f if the sequence is empty—and a thunk to continue with the
sequence; the result of the thunk is the same as the result of
sequence-generate*, but for the second element of the sequence, and so
on. If the thunk is called when the element result is #f (indicating no
further values in the sequence), the exn:fail:contract exception is
raised.

1.3. Sequence Combinations & Contract

 (require racket/sequence) package: base ~

The bindings documented in this section are provided by the
racket/sequence and racket libraries, but not racket/base.

empty-sequence : sequence? ~

A sequence with no elements.

                                        *sequence->list*
(sequence->list s) -> list? ~
  s : sequence? ~

Returns a list whose elements are the elements of s, each of which must
be a single value.  If s is infinite, this function does not terminate.

                                        *sequence-length*
(sequence-length s) -> exact-nonnegative-integer? ~
  s : sequence? ~

Returns the number of elements of s by extracting and discarding all of
them.  If s is infinite, this function does not terminate.

                                        *sequence-ref*
(sequence-ref s i) -> any ~
  s : sequence? ~
  i : exact-nonnegative-integer? ~

Returns the ith element of s (which may be multiple values).

                                        *sequence-tail*
(sequence-tail s i) -> sequence? ~
  s : sequence? ~
  i : exact-nonnegative-integer? ~

Returns a sequence equivalent to s, except that the first i elements are
omitted.

In case initiating s involves a side effect, the sequence s is not
initiated until the resulting sequence is initiated, at which point the
first i elements are extracted from the sequence.

                                        *sequence-append*
(sequence-append s ...) -> sequence? ~
  s : sequence? ~

Returns a sequence that contains all elements of each sequence in the
order they appear in the original sequences.  The new sequence is
constructed lazily.

If all given ss are streams, the result is also a stream.

                                        *sequence-map*
(sequence-map f s) -> sequence? ~
  f : procedure? ~
  s : sequence? ~

Returns a sequence that contains f applied to each element of s.  The
new sequence is constructed lazily.

If s is a stream, then the result is also a stream.

                                        *sequence-andmap*
(sequence-andmap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~
  s : sequence? ~

Returns #t if f returns a true result on every element of s.  If s is
infinite and f never returns a false result, this function does not
terminate.

                                        *sequence-ormap*
(sequence-ormap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~
  s : sequence? ~

Returns #t if f returns a true result on some element of s.  If s is
infinite and f never returns a true result, this function does not
terminate.

                                        *sequence-for-each*
(sequence-for-each f s) -> void? ~
  f : (-> any/c ... any) ~
  s : sequence? ~

Applies f to each element of s.  If s is infinite, this function does
not terminate.

                                        *sequence-fold*
(sequence-fold f i s) -> any/c ~
  f : (-> any/c any/c ... any/c) ~
  i : any/c ~
  s : sequence? ~

Folds f over each element of s with i as the initial accumulator.  If s
is infinite, this function does not terminate. The f function takes the
accumulator as its first argument and the next sequence element as its
second.

                                        *sequence-count*
(sequence-count f s) -> exact-nonnegative-integer? ~
  f : procedure? ~
  s : sequence? ~

Returns the number of elements in s for which f returns a true result.
If s is infinite, this function does not terminate.

                                        *sequence-filter*
(sequence-filter f s) -> sequence? ~
  f : (-> any/c ... boolean?) ~
  s : sequence? ~

Returns a sequence whose elements are the elements of s for which f
returns a true result.  Although the new sequence is constructed lazily,
if s has an infinite number of elements where f returns a false result
in between two elements where f returns a true result, then operations
on this sequence will not terminate during the infinite sub-sequence.

If s is a stream, then the result is also a stream.

                                        *sequence-add-between*
(sequence-add-between s e) -> sequence? ~
  s : sequence? ~
  e : any/c ~

Returns a sequence whose elements are the elements of s, but with e
between each pair of elements in s. The new sequence is constructed
lazily.

If s is a stream, then the result is also a stream.

Examples:
  > (let* ([all-reds (in-cycle '("red"))]
           [red-and-blues (sequence-add-between all-reds "blue")])
      (for/list ([n (in-range 10)]
                 [elt red-and-blues])
        elt))
  '("red" "blue" "red" "blue" "red" "blue" "red" "blue" "red" "blue")
  > (for ([text (sequence-add-between '("veni" "vidi" "duci") ", ")])
      (display text))
  veni, vidi, duci


                                        *sequence/c*
(sequence/c [#:min-count min-count]      ~ ~
             elem/c ...)            -> contract?
  min-count : (or/c #f exact-nonnegative-integer?) = #f ~
  elem/c : contract? ~

Wraps a sequence, obligating it to produce as many values as there are
elem/c contracts, and obligating each value to satisfy the corresponding
elem/c.  The result is not guaranteed to be the same kind of sequence as
the original value; for instance, a wrapped list is not guaranteed to
satisfy list?.

If min-count is a number, the stream is required to have at least that
many elements in it.

Examples:
  > (define/contract predicates
      (sequence/c (-> any/c boolean?))
      (in-list (list integer?
                     string->symbol)))
  sequence/c: undefined;
   cannot reference undefined identifier
  > (for ([P predicates])
      (printf "~s\n" (P "cat")))
  predicates: undefined;
   cannot reference undefined identifier
  > (define/contract numbers&strings
      (sequence/c number? string?)
      (in-dict (list (cons 1 "one")
                     (cons 2 "two")
                     (cons 3 'three))))
  in-dict: undefined;
   cannot reference undefined identifier
  > (for ([(N S) numbers&strings])
      (printf "~s: ~a\n" N S)) ~
  numbers&strings: undefined;
   cannot reference undefined identifier
  > (define/contract a-sequence
      (sequence/c #:min-count 2 char?) ~
      "x")
  sequence/c: undefined;
   cannot reference undefined identifier
  > (for ([x a-sequence]
          [i (in-naturals)])
      (printf "~a is ~a\n" i x))
  a-sequence: undefined;
   cannot reference undefined identifier

2. Streams

A stream is a kind of sequence that supports functional iteration via
stream-first and stream-rest.  The stream-cons form constructs a lazy
stream, but plain lists can be used as streams, and functions such as
in-range and in-naturals also create streams.

 (require racket/stream) package: base ~

The bindings documented in this section are provided by the
racket/stream and racket libraries, but not racket/base.

                                        *stream?*
(stream? v) -> boolean? ~
  v : any/c ~

Returns #t if v can be used as a stream, #f otherwise.

                                        *stream-empty?*
(stream-empty? s) -> boolean? ~
  s : stream? ~

Returns #t if s has no elements, #f otherwise.

                                        *stream-first*
(stream-first s) -> any ~
  s : (and/c stream? (not/c stream-empty?)) ~

Returns the value(s) of the first element in s.

                                        *stream-rest*
(stream-rest s) -> stream? ~
  s : (and/c stream? (not/c stream-empty?)) ~

Returns a stream that is equivalent to s without its first element.

                                        *stream-cons*
(stream-cons first-expr rest-expr) ~

Produces a lazy stream for which stream-first forces the evaluation of
first-expr to produce the first element of the stream, and stream-rest
forces the evaluation of rest-expr to produce a stream for the rest of
the returned stream.

The first element of the stream as produced by first-expr must be a
single value. The rest-expr must produce a stream when it is evaluated,
otherwise the exn:fail:contract? exception is raised.

                                        *stream*
(stream expr ...) ~

A shorthand for nested stream-conses ending with empty-stream.

                                        *stream**
(stream* expr ...) ~

A shorthand for nested stream-conses, but the final expr must be a
stream, and it is used as the rest of the stream instead of
empty-stream. Similar to list* but for streams.

                                        *in-stream*
(in-stream s) -> sequence? ~
  s : stream? ~

Returns a sequence that is equivalent to s.

An in-stream application can provide better performance for streams
iteration when it appears directly in a for clause.

empty-stream : stream? ~

A stream with no elements.

                                        *stream->list*
(stream->list s) -> list? ~
  s : stream? ~

Returns a list whose elements are the elements of s, each of which must
be a single value.  If s is infinite, this function does not terminate.

                                        *stream-length*
(stream-length s) -> exact-nonnegative-integer? ~
  s : stream? ~

Returns the number of elements of s.  If s is infinite, this function
does not terminate.

In the case of lazy streams, this function forces evaluation only of the
sub-streams, and not the stream’s elements.

                                        *stream-ref*
(stream-ref s i) -> any ~
  s : stream? ~
  i : exact-nonnegative-integer? ~

Returns the ith element of s (which may be multiple values).

                                        *stream-tail*
(stream-tail s i) -> stream? ~
  s : stream? ~
  i : exact-nonnegative-integer? ~

Returns a stream equivalent to s, except that the first i elements are
omitted.

In case extracting elements from s involves a side effect, they will not
be extracted until the first element is extracted from the resulting
stream.

                                        *stream-append*
(stream-append s ...) -> stream? ~
  s : stream? ~

Returns a stream that contains all elements of each stream in the order
they appear in the original streams.  The new stream is constructed
lazily, while the last given stream is used in the tail of the result.

                                        *stream-map*
(stream-map f s) -> stream? ~
  f : procedure? ~
  s : stream? ~

Returns a stream that contains f applied to each element of s.  The new
stream is constructed lazily.

                                        *stream-andmap*
(stream-andmap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~
  s : stream? ~

Returns #t if f returns a true result on every element of s.  If s is
infinite and f never returns a false result, this function does not
terminate.

                                        *stream-ormap*
(stream-ormap f s) -> boolean? ~
  f : (-> any/c ... boolean?) ~
  s : stream? ~

Returns #t if f returns a true result on some element of s.  If s is
infinite and f never returns a true result, this function does not
terminate.

                                        *stream-for-each*
(stream-for-each f s) -> void? ~
  f : (-> any/c ... any) ~
  s : stream? ~

Applies f to each element of s.  If s is infinite, this function does
not terminate.

                                        *stream-fold*
(stream-fold f i s) -> any/c ~
  f : (-> any/c any/c ... any/c) ~
  i : any/c ~
  s : stream? ~

Folds f over each element of s with i as the initial accumulator.  If s
is infinite, this function does not terminate.

                                        *stream-count*
(stream-count f s) -> exact-nonnegative-integer? ~
  f : procedure? ~
  s : stream? ~

Returns the number of elements in s for which f returns a true result.
If s is infinite, this function does not terminate.

                                        *stream-filter*
(stream-filter f s) -> stream? ~
  f : (-> any/c ... boolean?) ~
  s : stream? ~

Returns a stream whose elements are the elements of s for which f
returns a true result.  Although the new stream is constructed lazily,
if s has an infinite number of elements where f returns a false result
in between two elements where f returns a true result, then operations
on this stream will not terminate during the infinite sub-stream.

                                        *stream-add-between*
(stream-add-between s e) -> stream? ~
  s : stream? ~
  e : any/c ~

Returns a stream whose elements are the elements of s, but with e
between each pair of elements in s.  The new stream is constructed
lazily.

gen:stream : any/c ~

Associates three methods to a structure type to implement the generic
interface (see [missing]) for streams.

To supply method implementations, the #:methods keyword should be used
in a structure type definition. The following three methods should be
implemented:

* stream-empty? : accepts one argument

* stream-first : accepts one argument

* stream-rest : accepts one argument

Examples:
  > (define-struct list-stream (v)
      #:methods gen:stream ~
      [(define (stream-empty? stream)
         (empty? (list-stream-v stream)))
       (define (stream-first stream)
         (first (list-stream-v stream)))
       (define (stream-rest stream)
         (rest (list-stream-v stream)))])

  > (define l1 (list-stream '(1 2)))

  > (stream? l1)
  #t
  > (stream-first l1)
  1

prop:stream : struct-type-property? ~

A deprecated structure type property used to define custom extensions to
the stream API. Use gen:stream instead. Accepts a vector of three
procedures taking the same arguments as the methods in gen:stream.

                                        *stream/c*
(stream/c c) -> contract? ~
  c : contract? ~

Returns a contract that recognizes streams. All elements of the stream
must match c.

If the c argument is a flat contract or a chaperone contract, then the
result will be a chaperone contract. Otherwise, the result will be an
impersonator contract.

When an stream/c contract is applied to an asynchronous channel, the
result is not eq? to the input. The result will be either a chaperone or
impersonator of the input depending on the type of contract.

Contracts on streams are evaluated lazily by necessity (since streams
may be infinite). Contract violations will not be raised until the value
in violation is retrieved from the stream. As an exception to this rule,
streams that are lists are checked immediately, as if c had been used
with listof.

If a contract is applied to a stream, and that stream is subsequently
used as the tail of another stream (as the second parameter to
stream-cons), the new elements will not be checked with the contract,
but the tail’s elements will still be enforced.

Added in version 6.1.1.8 of package base.

3. Generators

A generator is a procedure that returns a sequence of values,
incrementing the sequence each time that the generator is called. In
particular, the generator form implements a generator by evaluating a
body that calls yield to return values from the generator.

 (require racket/generator) package: base ~

                                        *generator?*
(generator? v) -> boolean? ~
  v : any/c ~

Return #t if v is a generator, #f otherwise.

                                        *generator*
(generator formals body ...+) ~

Creates a generator, where formals is like the formals of case-lambda
(i.e., the kw-formals of lambda restricted to non-optional and
non-keyword arguments).

For the first call to a generator, the arguments are bound to the
formals and evaluation of body starts. During the dynamic extent of
body, the generator can return immediately using the yield function. A
second call to the generator resumes at the yield call, producing the
arguments of the second call as the results of the yield, and so on. The
eventual results of body are supplied to an implicit final yield; after
that final yield, calling the generator again returns the same values,
but all such calls must provide 0 arguments to the generator.

Examples:
  > (define g (generator ()
                (let loop ([x '(a b c)])
                  (if (null? x)
                      0
                      (begin
                        (yield (car x))
                        (loop (cdr x)))))))

  > (g)
  'a
  > (g)
  'b
  > (g)
  'c
  > (g)
  0
  > (g)
  0

                                        *yield*
(yield v ...) -> any ~
  v : any/c ~

Returns vs from a generator, saving the point of execution inside a
generator (i.e., within the dynamic extent of a generator body) to be
resumed by the next call to the generator. The results of yield are the
arguments that are provided to the next call of the generator.

When not in the dynamic extent of a generator, infinite-generator, or
in-generator body, yield raises exn:fail after evaluating its exprs.

Examples:
  > (define my-generator (generator () (yield 1) (yield 2 3 4)))

  > (my-generator)
  1
  > (my-generator)
  2
  3
  4

Examples:
  > (define pass-values-generator
      (generator ()
        (let* ([from-user (yield 2)]
               [from-user-again (yield (add1 from-user))])
          (yield from-user-again))))

  > (pass-values-generator)
  2
  > (pass-values-generator 5)
  6
  > (pass-values-generator 12)
  12

                                        *infinite-generator*
(infinite-generator body ...+) ~

Like generator, but repeats evaluation of the bodys when the last body
completes without implicitly yielding.

Examples:
  > (define welcome
      (infinite-generator
        (yield 'hello)
        (yield 'goodbye)))

  > (welcome)
  'hello
  > (welcome)
  'goodbye
  > (welcome)
  'hello
  > (welcome)
  'goodbye

                                        *in-generator*
(in-generator maybe-arity body ...+) ~
 
maybe-arity = 
            | #:arity arity-k ~

Produces a sequence that encapsulates the generator formed by (generator
() body ...+). The values produced by the generator form the elements of
the sequence, except for the last value produced by the generator (i.e.,
the values produced by returning).

Example:
  > (for/list ([i (in-generator
                    (let loop ([x '(a b c)])
                      (when (not (null? x))
                        (yield (car x))
                        (loop (cdr x)))))])
      i)
  '(a b c)

If in-generator is used immediately with a for (or for/list, etc.)
binding’s right-hand side, then its result arity (i.e., the number of
values in each element of the sequence) can be inferred. Otherwise, if
the generator produces multiple values for each element, its arity
should be declared with an #:arity arity-k clause; the arity-k must be a
literal, exact, non-negative integer.

Examples:
  > (let ([g (in-generator
              (let loop ([n 3])
                (unless (zero? n) (yield n (add1 n)) (loop (sub1 n)))))])
      (let-values ([(not-empty? next) (sequence-generate g)])
        (let loop () (when (not-empty?) (next) (loop))) 'done))
  stop?: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 1 ~
    given: 2 ~
    arguments...: ~
     3
     4
  > (let ([g (in-generator #:arity 2 ~
              (let loop ([n 3])
                (unless (zero? n) (yield n (add1 n)) (loop (sub1 n)))))])
      (let-values ([(not-empty? next) (sequence-generate g)])
        (let loop () (when (not-empty?) (next) (loop))) 'done))
  'done

To use an existing generator as a sequence, use in-producer with a
stop-value known for the generator:

  > (define abc-generator (generator ()
                           (for ([x '(a b c)])
                              (yield x))))

  > (for/list ([i (in-producer abc-generator (void))])
      i)
  '(a b c)
  > (define my-stop-value (gensym))

  > (define my-generator (generator ()
                           (let loop ([x (list 'a (void) 'c)])
                             (if (null? x)
                                 my-stop-value
                                 (begin
                                   (yield (car x))
                                   (loop (cdr x)))))))

  > (for/list ([i (in-producer my-generator my-stop-value)])
      i)
  '(a #<void> c)

                                        *generator-state*
(generator-state g) -> symbol? ~
  g : generator? ~

Returns a symbol that describes the state of the generator.

* 'fresh — The generator has been freshly created and has not been
  called yet.

* 'suspended — Control within the generator has been suspended due to a
  call to yield.  The generator can be called.

* 'running — The generator is currently executing.

* 'done — The generator has executed its entire body and will continue
  to produce the same result as from the last call.

Examples:
  > (define my-generator (generator () (yield 1) (yield 2)))

  > (generator-state my-generator)
  'fresh
  > (my-generator)
  1
  > (generator-state my-generator)
  'suspended
  > (my-generator)
  2
  > (generator-state my-generator)
  'suspended
  > (my-generator)

  > (generator-state my-generator)
  'done
  > (define introspective-generator (generator () ((yield 1))))

  > (introspective-generator)
  1
  > (introspective-generator
     (lambda () (generator-state introspective-generator)))
  'running
  > (generator-state introspective-generator)
  'done
  > (introspective-generator)
  'running

                                        *sequence->generator*
(sequence->generator s) -> (-> any) ~
  s : sequence? ~

Converts a sequence to a generator. The generator returns the next
element of the sequence each time the generator is invoked, where each
element of the sequence must be a single value. When the sequence ends,
the generator returns #<void> as its final result.

                                        *sequence->repeated-generator*
(sequence->repeated-generator s) -> (-> any) ~
  s : sequence? ~

Like sequence->generator, but when s has no further values, the
generator starts the sequence again (so that the generator never stops
producing values).
