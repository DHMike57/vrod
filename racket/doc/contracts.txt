Contracts

+[missing] in [missing] introduces contracts.

The contract system guards one part of a program from another.
Programmers specify the behavior of a module’s exports via (provide
(contract-out ....)), and the contract system enforces those
constraints.

 (require racket/contract) package: base ~ ~

The bindings documented in this section are provided by the
racket/contract and racket libraries, but not racket/base.

Contracts come in two forms: those constructed by the various operations
listed in this section of the manual, and various ordinary Racket values
that double as contracts, including

* symbols, booleans, keywords, and null, which are treated as contracts
  that recognize themselves, using eq?,

* strings, byte strings, characters, +nan.0, and +nan.0, which are
  treated as contracts that recognize themselves using equal?,

* numbers (except +nan.0 and        +nan.0), which are treated as
  contracts that recognize themselves using =,

* regular expressions, which are treated as contracts  that recognize
  byte strings and strings that  match the regular expression, and

* predicates: any procedure of arity 1 is treated as a predicate. During
  contract checking, it is applied to the values that appear and should
  return #f to indicate that the contract failed, and anything else to
  indicate it passed.

Contract combinators are functions such as -> and listof that take
contracts and produce other contracts.

Contracts in Racket are subdivided into three different categories:

* Flat contracts can be fully checked immediately for  a given value.
  These kinds of contracts are essentially  predicate functions. Using
  flat-contract-predicate,  you can extract the predicate from an
  arbitrary flat contract; some  flat contracts can be applied like
  functions, in which case  they accept a single argument and return #t
  or  #f to indicate if the given value would be accepted  by the
  contract. All of the flat contracts returned by functions  in this
  library can be used directly as predicates, but ordinary  Racket
  values that double as flat contracts (e.g., numbers or symbols)
  cannot.

  The function flat-contract? recognizes a flat contract.

* Chaperone contracts may wrap a value in such  a way that it signals
  contract violations later, as the value  is used, but are guaranteed
  to not otherwise change behavior.  For example, a function contract
  wraps a function value and  later checks inputs and outputs; any
  properties that the  function value had before being wrapped by the
  contract are  preserved by the contract wrapper.

  All flat contracts may be used where chaperone contracts are expected
  (but not vice-versa). The function chaperone-contract?  recognizes a
  chaperone contract.

* Impersonator contracts may wrap values and do  not provide any
  guarantees. Impersonator contracts  may hide properties of values, or
  even make them completely  opaque (e.g, new-∀/c).

  All contracts may be used where impersonator contracts are expected.
  The function impersonator-contract? recognizes an  impersonator
  contract.

For more about this hierarchy, see the section “[missing]” as well as a
research paper [Strickland12] on chaperones, impersonators, and how they
can be used to implement contracts.

Changed in version 6.1.1.8 of package base: Changed +nan.0 and +nan.0 to
be equal?-based contracts.

    1 Data-structure Contracts

    2 Function Contracts

    3 Parametric Contracts

    4 Lazy Data-structure Contracts

    5 Structure Type Property Contracts

    6 Attaching Contracts to Values
      6.1 Nested Contract Boundaries
      6.2 Low-level Contract Boundaries

    7 Building New Contract Combinators
      7.1 Blame Objects
      7.2 Contracts as structs
      7.3 Obligation Information in Check Syntax
      7.4 Utilities for Building New Combinators

    8 Contract Utilities

    9 racket/contract/base

    10 Collapsible Contracts

    11 Legacy Contracts

    12 Random generation

1. Data-structure Contracts

                                        *flat-contract-with-explanation*
(flat-contract-with-explanation  get-explanation  ~
                                [#:name name])    ~ ~
 -> flat-contract?
  get-explanation : (-> any/c (or/c boolean? (-> blame? any))) ~ ~
  name : any/c = (object-name get-explanation) ~ ~

Provides a way to use flat contracts that, when a contract fails,
provide more information about the failure.

If get-explanation returns a boolean, then that boolean value is
treated as the predicate in a flat contract. If it returns  a procedure,
then it is treated similarly to returning #f,  except the result
procedure is called to actually signal the contract  violation.

The name argument is used as the name of the contract; it defaults  to
the name of the get-explanation function.

  (flat-contract-with-explanation
   (λ (val)
     (cond
       [(even? val) #t]
       [else
        (λ (blame)
          (define more-information ...do-some-complex-computation-here...)
          (raise-blame-error blame val
                             '(expected: "an even number" given: "~e" ~ ~
                                         "and, here is more help: ~s") ~ ~
                             val more-information))])))

                                        *flat-named-contract*
(flat-named-contract  name               ~
                      flat-contract     
                     [generator])   -> flat-contract?
  name : any/c ~ ~
  flat-contract : flat-contract? ~ ~
  generator : (or/c #f (-> contract (-> int? any))) = #f ~ ~

Produces a flat contract like flat-contract, but with the name name.

For example,

  (define/contract i
    (flat-named-contract
     'odd-integer
     (lambda (x) (and (integer? x) (odd? x))))
    2)

The generator argument adds a generator for the flat-named-contract. See
contract-random-generate for more information.

any/c : flat-contract? ~ ~

A flat contract that accepts any value.

When using this contract as the result portion of a function contract,
consider using any instead; using any leads to better memory
performance, but it also allows multiple results.

none/c : flat-contract? ~ ~

A flat contract that accepts no values.

                                        *or/c*
(or/c contract ...) -> contract? ~
  contract : contract? ~ ~

Takes any number of contracts and returns a contract that accepts any
value that any one of the contracts accepts individually.

The or/c result tests any value by applying the contracts in order, from
left to right, with the exception that it always moves the non-flat
contracts (if any) to the end, checking them last. Thus, a contract such
as (or/c (not/c real?) positive?) is guaranteed to only invoke the
positive? predicate on real numbers.

If all of the arguments are procedures or flat contracts, the result is
a flat contract. If only one of the arguments is a higher-order
contract, the result is a contract that just checks the flat contracts
and, if they don’t pass, applies the higher-order contract.

If there are multiple higher-order contracts, or/c uses
contract-first-order-passes? to distinguish between them. More
precisely, when an or/c is checked, it first checks all of the flat
contracts. If none of them pass, it calls contract-first-order-passes?
with each of the higher-order contracts. If only one returns true, or/c
uses that contract. If none of them return true, it signals a contract
violation. If more than one returns true, it also signals a contract
violation. For example, this contract

  (or/c (-> number? number?)
        (-> string? string? string?))

does not accept a function like this one: (lambda args ...) since it
cannot tell which of the two arrow contracts should be used with the
function.

If all of its arguments are list-contract?s, then or/c returns a
list-contract?.

                                        *first-or/c*
(first-or/c contract ...) -> contract? ~
  contract : contract? ~ ~

Takes any number of contracts and returns a contract that accepts any
value that any one of the contracts accepts individually.

The first-or/c result tests any value by applying the contracts in order
from left to right. Thus, a contract such as (first-or/c (not/c real?)
positive?) is guaranteed to only invoke the positive? predicate on real
numbers.

If all of the arguments are procedures or flat contracts, the result is
a flat contract and similarly if all of the arguments are chaperone
contracts the result is too. Otherwise, the result is an impersonator
contract.

If there are multiple higher-order contracts, first-or/c uses
contract-first-order-passes? to distinguish between them. More
precisely, when an first-or/c is checked, it checks the first order
passes of the first contract against the value. If it succeeds, then it
uses only that contract. If it fails, then it moves to the second
contract, continuing until it finds one of the contracts where the first
order check succeeds. If none of them do, a contract violation is
signaled.

For example, this contract

  (first-or/c (-> number? number?)
         (-> string? string? string?))

accepts the function (λ args 0), applying the (-> number? number?)
contract to the function because it comes first, even though (-> string?
string? string?) also applies.

If all of its arguments are list-contract?s, then first-or/c returns a
list-contract?.

                                        *and/c*
(and/c contract ...) -> contract? ~
  contract : contract? ~ ~

Takes any number of contracts and returns a contract that accepts any
value that satisfies all of the contracts simultaneously.

If all of the arguments are procedures or flat contracts, the result is
a flat contract.

The contract produced by and/c tests any value by applying the contracts
in order, from left to right.

This means that and/c can be used to guard predicates that are not total
in contracts. For example, this contract is well-behaved, correctly
blaming the definition of whoops-not-a-number for not being a number:

Example:

  > (define/contract whoops-not-a-number
      (and/c real? even?)
      "four")
  whoops-not-a-number: broke its own contract
    promised: real? ~ ~
    produced: "four" ~ ~
    in: an and/c case of ~ ~
        (and/c real? even?)
    contract from: ~ ~
        (definition whoops-not-a-number)
    blaming: (definition whoops-not-a-number) ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

but if the arguments to and/c are reversed, then the contract itself
raises  an error:

Example:

  > (define/contract whoops-not-a-number
      (and/c even? real?)
      "four")
  even?: contract violation
    expected: integer ~ ~
    given: "four" ~ ~

If more than one of the contracts are not flat contracts,  then the
order in which the higher-order parts of the contract are tested  can be
counter-intuitive. As an example, consider this function that  uses
and/c in a higher-order manner with contracts that  always succeed, but
that print when they are called, in order for us  to see the order in
which they are called.

Examples:

  > (define ((show-me n) x)
      (printf "show-me ~a\n" n)
      #t)
  > (define/contract identity-with-complex-printing-contract
      (and/c (-> (show-me 4) (show-me 5))
             (-> (show-me 3) (show-me 6))
             (-> (show-me 2) (show-me 7))
             (-> (show-me 1) (show-me 8)))
      (λ (x) x))
  > (identity-with-complex-printing-contract 101)
  show-me 1
  show-me 2
  show-me 3
  show-me 4
  show-me 5
  show-me 6
  show-me 7
  show-me 8
  101

The checking order is just like the usual ordering when a contract  is
double-wrapped. The contract that is first put on has its domain checked
second but its range checked first and we see a similar pattern here in
this example, because and/c simply applies the contracts in order.

                                        *not/c*
(not/c flat-contract) -> flat-contract? ~
  flat-contract : flat-contract? ~ ~

Accepts a flat contract or a predicate and returns a flat contract that
checks the inverse of the argument.

                                        *=/c*
(=/c z) -> flat-contract?
  z : real? ~ ~

Returns a flat contract that requires the input to be a number and = to
z.

                                        *</c*
(</c n) -> flat-contract?
  n : real? ~ ~

Returns a flat contract that requires the input to be a number and <
than n.

                                        *>/c*
(>/c n) -> flat-contract?
  n : real? ~ ~

Like </c, but for >.

                                        *<=/c*
(<=/c n) -> flat-contract?
  n : real? ~ ~

Like </c, but for <=.

                                        *>=/c*
(>=/c n) -> flat-contract?
  n : real? ~ ~

Like </c, but for >=.

                                        *between/c*
(between/c n m) -> flat-contract? ~
  n : real? ~ ~
  m : real? ~ ~

Returns a flat contract that requires the input to be a real number
between n and m or equal to one of them.

                                        *real-in*
(real-in n m) -> flat-contract? ~
  n : real? ~ ~
  m : real? ~ ~

An alias for between/c.

                                        *integer-in*
(integer-in j k) -> flat-contract? ~
  j : (or/c exact-integer? #f) ~ ~
  k : (or/c exact-integer? #f) ~ ~

Returns a flat contract that requires the input to be an exact integer
between j and k, inclusive. If either j or k is #f, then the range is
unbounded on that end.

Examples:

  > (define/contract two-digit-number
      (integer-in 10 99)
      23)
  > (define/contract not-a-two-digit-number
      (integer-in 10 99)
      124)
  not-a-two-digit-number: broke its own contract
    promised: (integer-in 10 99) ~ ~
    produced: 124 ~ ~
    in: (integer-in 10 99) ~ ~
    contract from: ~ ~
        (definition not-a-two-digit-number)
    blaming: (definition not-a-two-digit-number) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~
  > (define/contract negative-number
      (integer-in #f -1)
      -4)
  > (define/contract not-a-negative-number
      (integer-in #f -1)
      4)
  not-a-negative-number: broke its own contract
    promised: (integer-in #f -1) ~ ~
    produced: 4 ~ ~
    in: (integer-in #f -1) ~ ~
    contract from: ~ ~
        (definition not-a-negative-number)
    blaming: (definition not-a-negative-number) ~ ~
     (assuming the contract is correct)
    at: eval:5.0 ~ ~

Changed in version 6.8.0.2 of package base: Allow j and k to be #f

                                        *char-in*
(char-in a b) -> flat-contract? ~
  a : char? ~ ~
  b : char? ~ ~

Returns a flat contract that requires the input to be a character whose
code point number is between the code point numbers of a and b,
inclusive.

natural-number/c : flat-contract? ~ ~

A flat contract that requires the input to be an exact non-negative
integer.

                                        *string-len/c*
(string-len/c len) -> flat-contract? ~
  len : real? ~ ~

Returns a flat contract that recognizes strings that have fewer than len
characters.

false/c : flat-contract? ~ ~

An alias for #f for backwards compatibility.

printable/c : flat-contract? ~ ~

A flat contract that recognizes values that can be written out and read
back in with write and read.

                                        *one-of/c*
(one-of/c v ...+) -> flat-contract? ~
  v : any/c ~ ~

Accepts any number of atomic values and returns a flat contract that
recognizes those values, using eqv?  as the comparison predicate.  For
the purposes of one-of/c, atomic values are defined to be: characters,
symbols, booleans, null, keywords, numbers, #<void>, and #<undefined>.

This is a backwards compatibility contract constructor. If neither
#<void> nor #<undefined> are arguments, it simply passes its arguments
to or/c.

                                        *symbols*
(symbols sym ...+) -> flat-contract? ~
  sym : symbol? ~ ~

Accepts any number of symbols and returns a flat contract that
recognizes those symbols.

This is a backwards compatibility constructor; it merely passes its
arguments to or/c.

                                        *vectorof*
(vectorof  c                          ~
          [#:immutable immutable      ~ ~
           #:flat? flat?              ~ ~
           #:eager eager])       -> contract? ~ ~
  c : contract? ~ ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~ ~
  flat? : boolean? = #f ~ ~
  eager : (or/c #t #f exact-nonnegative-integer?) = #t ~ ~

Returns a contract that recognizes vectors. The elements of the vector
must match c.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the c argument must also be a flat contract.  Such flat
contracts will be unsound if applied to mutable vectors, as they will
not check future operations on the vector.

If the immutable argument is #t and the c argument is a flat contract
and the eager argument is #t, the result will be a flat contract.  If
the c argument is a chaperone contract, then the result will be a
chaperone contract.

If the eager argument is #t, then immutable vectors are checked eagerly
when c is a flat contract. If the eager argument is a number n, then
immutable vectors are checked eagerly when c is a flat contract and the
length of the vector is less than or equal to n.

When a higher-order vectorof contract is applied to a vector, the result
is not eq? to the input.  The result will be a copy for immutable
vectors and a chaperone or impersonator of the input for mutable
vectors, unless the c argument is a flat contract and the vector is
immutable, in which case the result is the original vector.

Changed in version 6.3.0.5 of package base: Changed flat vector
contracts to not copy immutable vectors. Changed in version 6.7.0.3:
Added the #:eager option.

                                        *vector-immutableof*
(vector-immutableof c) -> contract? ~
  c : contract? ~ ~

Returns the same contract as (vectorof c #:immutable #t). This form
exists for backwards compatibility.

                                        *vector/c*
(vector/c  c                          ~
           ...                       
          [#:immutable immutable      ~ ~
           #:flat? flat?])       -> contract? ~ ~
  c : contract? ~ ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~ ~
  flat? : boolean? = #f ~ ~

Returns a contract that recognizes vectors whose lengths match the
number of contracts given. Each element of the vector must match its
corresponding contract.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the c arguments must also be flat contracts.  Such flat
contracts will be unsound if applied to mutable vectors, as they will
not check future operations on the vector.

If the immutable argument is #t and the c arguments are flat contracts,
the result will be a flat contract.  If the c arguments are chaperone
contracts, then the result will be a chaperone contract.

When a higher-order vector/c contract is applied to a vector, the result
is not eq? to the input.  The result will be a copy for immutable
vectors and a chaperone or impersonator of the input for mutable
vectors.

                                        *vector-immutable/c*
(vector-immutable/c c ...) -> contract? ~
  c : contract? ~ ~

Returns the same contract as (vector/c c ... #:immutable #t). This form
exists for reasons of backwards compatibility.

                                        *box/c*
(box/c  in-c                       ~
       [c                         
        #:immutable immutable      ~ ~
        #:flat? flat?])       -> contract? ~ ~
  in-c : contract? ~ ~
  c : contract? = in-c ~ ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~ ~
  flat? : boolean? = #f ~ ~

Returns a contract that recognizes boxes. The content of the box must
match c, and mutations on mutable boxes must match in-c.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the out argument must also be a flat contract.  Such flat
contracts will be unsound if applied to mutable boxes, as they will not
check future operations on the box.

If the immutable argument is #t and the c argument is a flat contract,
the result will be a flat contract.  If the c argument is a chaperone
contract, then the result will be a chaperone contract.

When a higher-order box/c contract is applied to a box, the result is
not eq? to the input.  The result will be a copy for immutable boxes and
either a chaperone or impersonator of the input for mutable boxes.

                                        *box-immutable/c*
(box-immutable/c c) -> contract? ~
  c : contract? ~ ~

Returns the same contract as (box/c c #:immutable #t). This form exists
for reasons of backwards compatibility.

                                        *listof*
(listof c) -> list-contract? ~
  c : contract? ~ ~

Returns a contract that recognizes a list whose every element matches
the contract c. Beware that when this contract is applied to a value,
the result is not necessarily eq? to the input.

Examples:

  > (define/contract some-numbers
      (listof number?)
      (list 1 2 3))
  > (define/contract just-one-number
      (listof number?)
      11)
  just-one-number: broke its own contract
    promised: list? ~ ~
    produced: 11 ~ ~
    in: (listof number?) ~ ~
    contract from: (definition just-one-number) ~ ~
    blaming: (definition just-one-number) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *non-empty-listof*
(non-empty-listof c) -> list-contract? ~
  c : contract? ~ ~

Returns a contract that recognizes non-empty lists whose elements match
the contract c. Beware that when this contract is applied to a value,
the result is not necessarily eq? to the input.

Examples:

  > (define/contract some-numbers
      (non-empty-listof number?)
      (list 1 2 3))
  > (define/contract not-enough-numbers
      (non-empty-listof number?)
      (list))
  not-enough-numbers: broke its own contract
    promised: "(and/c list? pair?)" ~ ~
    produced: '() ~ ~
    in: (non-empty-listof number?) ~ ~
    contract from: ~ ~
        (definition not-enough-numbers)
    blaming: (definition not-enough-numbers) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *list*of*
(list*of ele-c [last-c]) -> contract? ~
  ele-c : contract? ~ ~
  last-c : contract? = ele-c ~ ~

Returns a contract that recognizes improper lists whose elements match
the contract ele-c and whose last position matches last-c. If an
improper list is created with cons, then its car position is expected to
match ele-c and its cdr position is expected to be (list*of ele-c
list-c). Otherwise, it is expected to match last-c. Beware that when
this contract is applied to a value, the result is not necessarily eq?
to the input.

Examples:

  > (define/contract improper-numbers
      (list*of number?)
      (cons 1 (cons 2 3)))
  > (define/contract not-improper-numbers
      (list*of number?)
      (list 1 2 3))
  not-improper-numbers: broke its own contract
    promised: number? ~ ~
    produced: '() ~ ~
    in: an element of ~ ~
        (list*of number?)
    contract from: ~ ~
        (definition not-improper-numbers)
    blaming: (definition not-improper-numbers) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

Added in version 6.1.1.1 of package base. Changed in version 6.4.0.4:
Added the last-c argument.

                                        *cons/c*
(cons/c car-c cdr-c) -> contract? ~
  car-c : contract? ~ ~
  cdr-c : contract? ~ ~

Produces a contract that recognizes pairs whose first and second
elements match car-c and cdr-c, respectively. Beware that when this
contract is applied to a value, the result is not necessarily eq? to the
input.

If the cdr-c contract is a list-contract?, then cons/c returns a
list-contract?.

Examples:

  > (define/contract a-pair-of-numbers
      (cons/c number? number?)
      (cons 1 2))
  > (define/contract not-a-pair-of-numbers
      (cons/c number? number?)
      (cons #f #t))
  not-a-pair-of-numbers: broke its own contract
    promised: number? ~ ~
    produced: #f ~ ~
    in: the car of ~ ~
        (cons/c number? number?)
    contract from: ~ ~
        (definition not-a-pair-of-numbers)
    blaming: (definition not-a-pair-of-numbers) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

Changed in version 6.0.1.13 of package base: Added the list-contract?
propagating behavior.

                                        *cons/dc*
(cons/dc [car-id contract-expr] [cdr-id (car-id) contract-expr] cons/dc-option) ~
(cons/dc [car-id (cdr-id) contract-expr] [cdr-id contract-expr] cons/dc-option)
 
cons/dc-option = 
               | #:flat ~ ~
               | #:chaperone ~ ~
               | #:impersonator ~ ~

Produces a contract that recognizes pairs whose first and second
elements match the expressions after car-id and cdr-id, respectively.

In the first case, the contract on the cdr-id portion of the contract
may depend on the value in the car-id portion of the pair and in the
second case, the reverse is true.

Examples:

  > (define/contract an-ordered-pair-of-reals
      (cons/dc [hd real?] [tl (hd) (>=/c hd)])
      (cons 1 2))
  > (define/contract not-an-ordered-pair-of-reals
      (cons/dc [hd real?] [tl (hd) (>=/c hd)])
      (cons 2 1))
  not-an-ordered-pair-of-reals: broke its own contract
    promised: (>=/c 2) ~ ~
    produced: 1 ~ ~
    in: the cdr of ~ ~
        (cons/dc (hd real?) (tl (hd) (>=/c hd)))
    contract from: ~ ~
        (definition not-an-ordered-pair-of-reals)
    blaming: (definition not-an-ordered-pair-of-reals) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

Added in version 6.1.1.6 of package base.

                                        *list/c*
(list/c c ...) -> list-contract? ~
  c : contract? ~ ~

Produces a contract for a list. The number of elements in the list must
match the number of arguments supplied to list/c, and each element of
the list must match the corresponding contract. Beware that when this
contract is applied to a value, the result is not necessarily eq? to the
input.

                                        **list/c*
(*list/c prefix suffix ...) -> list-contract?
  prefix : contract? ~ ~
  suffix : contract? ~ ~

Produces a contract for a list. The number of elements in the list must
be at least as long as the number of suffix contracts and the tail of
the list must match those contracts, one for each element. The beginning
portion of the list can be arbitrarily long, and each element must match
prefix.

Beware that when this contract is applied to a value, the result is not
necessarily eq? to the input.

Examples:

  > (define/contract a-list-of-numbers-ending-with-two-integers
      (*list/c number? integer? integer?)
      (list 1/2 4/5 0+1i -11 322))
  > (define/contract not-enough-integers-at-the-end
      (*list/c number? integer? integer? integer?)
      (list 1/2 4/5 1/2 321 322))
  not-enough-integers-at-the-end: broke its own contract
    promised: integer? ~ ~
    produced: 1/2 ~ ~
    in: the 3rd to the last element of ~ ~
        (*list/c number? integer? integer? integer?)
    contract from: ~ ~
        (definition not-enough-integers-at-the-end)
    blaming: (definition not-enough-integers-at-the-end) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *syntax/c*
(syntax/c c) -> flat-contract? ~
  c : flat-contract? ~ ~

Produces a flat contract that recognizes syntax objects whose syntax-e
content matches c.

                                        *struct/c*
(struct/c struct-id contract-expr ...) ~

Produces a contract that recognizes instances of the structure type
named by struct-id, and whose field values match the contracts produced
by the contract-exprs.

Contracts for immutable fields must be either flat or chaperone
contracts. Contracts for mutable fields may be impersonator contracts.
If all fields are immutable and the contract-exprs evaluate to flat
contracts, a flat contract is produced.  If all the contract-exprs are
chaperone contracts, a chaperone contract is produced.  Otherwise, an
impersonator contract is produced.

                                        *struct/dc*
(struct/dc struct-id field-spec ... maybe-inv) ~
 
         field-spec = [field-name maybe-lazy contract-expr]
                    | [field-name (dep-field-name ...)
                                  maybe-lazy
                                  maybe-contract-type
                                  maybe-dep-state
                                  contract-expr]
                       
         field-name = field-id
                    | (#:selector selector-id) ~ ~
                    | (field-id #:parent struct-id) ~ ~
                       
         maybe-lazy = 
                    | #:lazy ~ ~
                       
maybe-contract-type = 
                    | #:flat ~ ~
                    | #:chaperone ~ ~
                    | #:impersonator ~ ~
                       
    maybe-dep-state = 
                    | #:depends-on-state ~ ~
                       
          maybe-inv = 
                    | #:inv (dep-field-name ...) invariant-expr ~ ~

Produces a contract that recognizes instances of the structure type
named by struct-id, and whose field values match the contracts produced
by the field-specs.

If the field-spec lists the names of other fields, then the contract
depends on values in those fields, and the contract-expr expression is
evaluated each time a selector is applied, building a new contract for
the fields based on the values of the dep-field-name fields (the
dep-field-name syntax is the same as the field-name syntax). If the
field is a dependent field and no contract-type annotation appears, then
it is assumed that the contract is a chaperone, but not always a flat
contract (and thus the entire struct/dc contract is not a flat
contract). If this is not the case, and the contract is always flat then
the field must be annotated with the #:flat, or the field must be
annotated with #:impersonator (in which case, it must be a mutable
field).

A field-name is either an identifier naming a field in the first case,
an identifier naming a selector in the second case indicated by the
#:selector keyword, or a field id for a struct that is a parent of
struct-id, indicated by the #:parent keyword.

If the #:lazy keyword appears, then the contract on the field is checked
lazily (only when a selector is applied); #:lazy contracts cannot be put
on mutable fields.

If a dependent contract depends on some mutable state, then use the
#:depends-on-state keyword argument (if a field’s dependent contract
depends on a mutable field, this keyword is automatically inferred). The
presence of this keyword means that the contract expression is evaluated
each time the corresponding field is accessed (or mutated, if it is a
mutable field). Otherwise, the contract expression for a dependent field
contract is evaluated when the contract is applied to a value.

If the #:inv clause appears, then the invariant expression is evaluated
(and must return a non-#f value) when the contract is applied to a
struct.

Contracts for immutable fields must be either flat or chaperone
contracts. Contracts for mutable fields may be impersonator contracts.
If all fields are immutable and the contract-exprs evaluate to flat
contracts, a flat contract is produced.  If all the contract-exprs are
chaperone contracts, a chaperone contract is produced.  Otherwise, an
impersonator contract is produced.

As an example, the function bst/c below returns a contract for binary
search trees whose values are all between lo and hi. The lazy
annotations ensure that this contract does not change the running time
of operations that do not inspect the entire tree.

Examples:

  > (struct bt (val left right))
  > (define (bst/c lo hi)
      (or/c #f
            (struct/dc bt
                       [val (between/c lo hi)]
                       [left (val) #:lazy (bst/c lo val)] ~ ~
                       [right (val) #:lazy (bst/c val hi)]))) ~ ~
  > (define/contract not-really-a-bst
      (bst/c -inf.0 +inf.0)
      (bt 5
          (bt 4
              (bt 2 #f #f)
              (bt 6 #f #f))
          #f))
  > (bt-right not-really-a-bst)
  #f
  > (bt-val (bt-left (bt-left not-really-a-bst)))
  2
  > (bt-right (bt-left not-really-a-bst))
  not-really-a-bst: broke its own contract
    promised: (between/c 4 5) ~ ~
    produced: 6 ~ ~
    in: the val field of ~ ~
        a part of the or/c of
        the right field of
        a part of the or/c of
        the left field of
        a part of the or/c of
        (or/c
         #f
         (struct/dc
          bt
          (val (between/c -inf.0 +inf.0))
          (left (val) #:lazy ...) ~ ~
          (right (val) #:lazy ...))) ~ ~
    contract from: (definition not-really-a-bst) ~ ~
    blaming: (definition not-really-a-bst) ~ ~
     (assuming the contract is correct)
    at: eval:4.0 ~ ~

Changed in version 6.0.1.6 of package base: Added #:inv.

                                        *parameter/c*
(parameter/c in [out]) -> contract? ~
  in : contract? ~ ~
  out : contract? = in ~ ~

Produces a contract on parameters whose values must match out. When the
value in the contracted parameter is set, it must match in.

Examples:

  > (define/contract current-snack
      (parameter/c string?)
      (make-parameter "potato-chip"))
  > (define baked/c
      (flat-named-contract 'baked/c (λ (s) (regexp-match #rx"baked" s))))
  > (define/contract current-dinner
      (parameter/c string? baked/c)
      (make-parameter "turkey" (λ (s) (string-append "roasted " s))))
  > (current-snack 'not-a-snack)
  current-snack: contract violation
    expected: string? ~ ~
    given: 'not-a-snack ~ ~
    in: the parameter of ~ ~
        (parameter/c string?)
    contract from: (definition current-snack) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~
  > (parameterize ([current-dinner "tofurkey"])
      (current-dinner))
  current-dinner: broke its own contract
    promised: baked/c ~ ~
    produced: "roasted tofurkey" ~ ~
    in: the parameter of ~ ~
        (parameter/c string? baked/c)
    contract from: (definition current-dinner) ~ ~
    blaming: (definition current-dinner) ~ ~
     (assuming the contract is correct)
    at: eval:4.0 ~ ~

                                        *procedure-arity-includes/c*
(procedure-arity-includes/c n) -> flat-contract? ~
  n : exact-nonnegative-integer? ~ ~

Produces a contract for procedures that accept n argument (i.e,. the
procedure? contract is implied).

                                        *hash/c*
(hash/c  key                        ~
         val                       
        [#:immutable immutable      ~ ~
         #:flat? flat?])       -> contract? ~ ~
  key : chaperone-contract? ~ ~
  val : contract? ~ ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~ ~
  flat? : boolean? = #f ~ ~

Produces a contract that recognizes hash tables with keys and values as
specified by the key and val arguments.

Examples:

  > (define/contract good-hash
      (hash/c integer? boolean?)
      (hash 1 #t
            2 #f
            3 #t))
  > (define/contract bad-hash
      (hash/c integer? boolean?)
      (hash 1 "elephant"
            2 "monkey"
            3 "manatee"))
  bad-hash: broke its own contract
    promised: boolean? ~ ~
    produced: "elephant" ~ ~
    in: the values of ~ ~
        (hash/c integer? boolean?)
    contract from: (definition bad-hash) ~ ~
    blaming: (definition bad-hash) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

There are a number of technicalities that control how hash/c contracts
behave.

* If the flat? argument is #t, then the resulting contract is  a flat
  contract, and the key and val arguments must also be  flat contracts.

  Examples:

    > (flat-contract? (hash/c integer? boolean?))
    #f
    > (flat-contract? (hash/c integer? boolean? #:flat? #t)) ~ ~
    #t
    > (hash/c integer? (-> integer? integer?) #:flat? #t) ~ ~
    hash/c: contract violation
      expected: flat-contract? ~ ~
      given: (-> integer? integer?) ~ ~

  Such flat contracts will be unsound if applied to mutable hash tables,
  as they will not check future mutations to the hash table.

  Examples:

    > (define original-h (make-hasheq))
    > (define/contract ctc-h
        (hash/c integer? boolean? #:flat? #t) ~ ~
        original-h)
    > (hash-set! original-h 1 "not a boolean")
    > (hash-ref ctc-h 1)
    "not a boolean"

* If the immutable argument is #t and the key and val arguments are
  flat-contract?s, the result will be a flat-contract?.

  Example:

    > (flat-contract? (hash/c integer? boolean? #:immutable #t)) ~ ~
    #t

  If either the domain or the range is a chaperone-contract?, then the
  result will be a chaperone-contract?.

  Examples:

    > (flat-contract? (hash/c (-> integer? integer?) boolean?
                              #:immutable #t)) ~ ~
    #f
    > (chaperone-contract? (hash/c (-> integer? integer?) boolean?
                                   #:immutable #t)) ~ ~
    #t

* If the key argument is a chaperone-contract? but not a flat-contract?,
  then the resulting contract can be applied only to equal?-based hash
  tables.

  Example:

    > (define/contract h
        (hash/c (-> integer? integer?) any/c)
        (make-hasheq))
    h: broke its own contract;
     promised equal?-based hash table due to higher-order domain
    contract
      produced: '#hasheq() ~ ~
      in: (hash/c (-> integer? integer?) any/c) ~ ~
      contract from: (definition h) ~ ~
      blaming: (definition h) ~ ~
       (assuming the contract is correct)
      at: eval:2.0 ~ ~

  Also, when such a hash/c contract is applied to a hash table, the
  result is not eq? to the input. The result of applying the contract
  will be a copy for immutable hash tables, and either a chaperone or
  impersonator of the original hash table for mutable hash tables.

                                        *hash/dc*
(hash/dc [key-id key-contract-expr] [value-id (key-id) value-contract-expr] ~
         hash/dc-option)
 
hash/dc-option = 
               | #:immutable immutable?-expr hash/dc-option ~ ~
               | #:kind kind-expr hash/dc-option ~ ~

Creates a contract for hash? tables with keys matching key-contract-expr
and where the contract on the values can depend on the key itself, since
key-id will be bound to the corresponding key before evaluating the
values-contract-expr.

If immutable?-expr is #t, then only immutable? hashes are accepted. If
it is #f then immutable? hashes are always rejected. It defaults to
'dont-care, in which case both mutable and immutable hashes are
accepted.

If kind-expr evaluates to 'flat, then key-contract-expr and
value-contract-expr are expected to evaluate to flat-contract?s. If it
is 'chaperone, then they are expected to be chaperone-contract?s, and it
may also be 'impersonator, in which case they may be any contract?s. The
default is 'chaperone.

Examples:

  > (define/contract h
      (hash/dc [k real?] [v (k) (>=/c k)])
      (hash 1 3
            2 4))
  > (define/contract h
      (hash/dc [k real?] [v (k) (>=/c k)])
      (hash 3 1
            4 2))
  h: broke its own contract
    promised: (>=/c 3) ~ ~
    produced: 1 ~ ~
    in: the values of ~ ~
        (hash/dc (k real?) (v (k) (>=/c k)))
    contract from: (definition h) ~ ~
    blaming: (definition h) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *channel/c*
(channel/c val) -> contract? ~
  val : contract? ~ ~

Produces a contract that recognizes channels that communicate values as
specified by the val argument.

If the val argument is a chaperone contract, then the resulting contract
is a chaperone contract. Otherwise, the resulting contract is an
impersonator contract. When a channel contract is applied to a channel,
the resulting channel is not eq? to the input.

Examples:

  > (define/contract chan
      (channel/c string?)
      (make-channel))
  > (thread (λ () (channel-get chan)))
  #<thread>
  > (channel-put chan 'not-a-string)
  chan: contract violation
    expected: string? ~ ~
    given: 'not-a-string ~ ~
    in: (channel/c string?) ~ ~
    contract from: (definition chan) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

                                        *prompt-tag/c*
(prompt-tag/c contract ... maybe-call/cc) ~
 
maybe-call/cc = 
              | #:call/cc contract ~ ~
              | #:call/cc (values contract ...) ~ ~
 
  contract : contract? ~ ~

Takes any number of contracts and returns a contract that recognizes
continuation prompt tags and will check any aborts or prompt handlers
that use the contracted prompt tag.

Each contract will check the corresponding value passed to an
abort-current-continuation and handled by the handler of a call to
call-with-continuation-prompt.

If all of the contracts are chaperone contracts, the resulting contract
will also be a chaperone contract. Otherwise, the contract is an
impersonator contract.

If maybe-call/cc is provided, then the provided contracts are used to
check the return values from a continuation captured with
call-with-current-continuation.

Examples:

  > (define/contract tag
      (prompt-tag/c (-> number? string?))
      (make-continuation-prompt-tag))
  > (call-with-continuation-prompt
      (lambda ()
        (number->string
          (call-with-composable-continuation
            (lambda (k)
              (abort-current-continuation tag k)))))
      tag
      (lambda (k) (k "not a number")))
  tag: contract violation
    expected: number? ~ ~
    given: "not a number" ~ ~
    in: the 1st argument of ~ ~
        (prompt-tag/c
         (-> number? string?)
         #:call/cc) ~ ~
    contract from: (definition tag) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

                                        *continuation-mark-key/c*
(continuation-mark-key/c contract) -> contract? ~
  contract : contract? ~ ~

Takes a single contract and returns a contract that recognizes
continuation marks and will check any mappings of marks to values or any
accesses of the mark value.

If the argument contract is a chaperone contract, the resulting contract
will also be a chaperone contract. Otherwise, the contract is an
impersonator contract.

Examples:

  > (define/contract mark-key
      (continuation-mark-key/c (-> symbol? (listof symbol?)))
      (make-continuation-mark-key))
  > (with-continuation-mark
      mark-key
      (lambda (s) (append s '(truffle fudge ganache)))
      (let ([mark-value (continuation-mark-set-first
                         (current-continuation-marks) mark-key)])
        (mark-value "chocolate-bar")))
  mark-key: contract violation
    expected: symbol? ~ ~
    given: "chocolate-bar" ~ ~
    in: the 1st argument of ~ ~
        (continuation-mark-key/c
         (-> symbol? (listof symbol?)))
    contract from: (definition mark-key) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

                                        *evt/c*
(evt/c contract ...) -> chaperone-contract? ~
  contract : chaperone-contract? ~ ~

Returns a contract that recognizes synchronizable events whose
synchronization results are checked by the given contracts.

The resulting contract is always a chaperone contract and its arguments
must all be chaperone contracts.

Examples:

  > (define/contract my-evt
      (evt/c evt?)
      always-evt)
  > (define/contract failing-evt
      (evt/c number? number?)
      (alarm-evt (+ (current-inexact-milliseconds) 50)))
  > (sync my-evt)
  #<always-evt>
  > (sync failing-evt)
  failing-evt: broke its own contract
    promised: event that produces 2 values ~ ~
    produced: event that produces 1 values ~ ~
    in: (evt/c number? number?) ~ ~
    contract from: (definition failing-evt) ~ ~
    blaming: (definition failing-evt) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *flat-rec-contract*
(flat-rec-contract id flat-contract-expr ...) ~

Constructs a recursive flat contract. A flat-contract-expr can refer to
id to refer recursively to the generated contract.

For example, the contract

  (flat-rec-contract sexp
    (cons/c sexp sexp)
    number?
    symbol?)

is a flat contract that checks for (a limited form of) S-expressions. It
says that a sexp is either two sexps combined with cons, or a number, or
a symbol.

Note that if the contract is applied to a circular value, contract
checking will not terminate.

                                        *flat-murec-contract*
(flat-murec-contract ([id flat-contract-expr ...] ...) body ...+) ~

A generalization of flat-rec-contract for defining several mutually
recursive flat contracts simultaneously. Each id is visible in the
entire flat-murec-contract form, and the result of the final body is the
result of the entire form.

any

Represents a contract that is always satisfied. In particular, it can
accept multiple values.  It can only be used in a result position of
contracts like ->. Using any elsewhere is a syntax error.

                                        *promise/c*
(promise/c c) -> contract? ~
  c : contract? ~ ~

Constructs a contract on a promise. The contract does not force the
promise, but when the promise is forced, the contract checks that the
result value meets the contract c.

                                        *flat-contract*
(flat-contract predicate) -> flat-contract? ~
  predicate : (-> any/c any/c) ~ ~

Constructs a flat contract from predicate. A value satisfies the
contract if the predicate returns a true value.

This function is a holdover from before predicates could be used
directly as flat contracts. It exists today for backwards compatibility.

                                        *flat-contract-predicate*
(flat-contract-predicate v) -> (-> any/c any/c) ~
  v : flat-contract? ~ ~

Extracts the predicate from a flat contract.

This function is a holdover from before flat contracts could be used
directly as predicates. It exists today for backwards compatibility.

                                        *property/c*
(property/c accessor ctc [#:name name]) -> flat-contract? ~ ~ ~
  accessor : (-> any/c any/c) ~ ~
  ctc : flat-contract? ~ ~
  name : any/c = (object-name accessor) ~ ~

Constructs a flat contract that checks that the first-order property
accessed by accessor satisfies ctc. The resulting contract is equivalent
to

  (lambda (v) (ctc (accessor v)))

except that more information is included in error messages produced by
violations of the contract. The name argument is used to describe the
property being checked in error messages.

Examples:

  > (define/contract (sum-triple lst)
      (-> (and/c (listof number?)
                 (property/c length (=/c 3)))
          number?)
      (+ (first lst) (second lst) (third lst)))
  > (sum-triple '(1 2 3))
  6
  > (sum-triple '(1 2))
  sum-triple: contract violation
    expected: (=/c 3) ~ ~
    given: 2 ~ ~
    in: the length of ~ ~
        an and/c case of
        the 1st argument of
        (->
         (and/c
          (listof number?)
          (property/c length (=/c 3)))
         number?)
    contract from: (function sum-triple) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

Added in version 7.3.0.11 of package base.

                                        *suggest/c*
(suggest/c c field message) -> contract? ~
  c : contract? ~ ~
  field : string? ~ ~
  message : string? ~ ~

Returns a contract that behaves like c, except that it adds an extra
line to the error message on a contract violation.

The field and message strings are added following the guidelines in
[missing].

Examples:

  > (define allow-calls? #f)
  > (define/contract (f)
      (suggest/c (->* () #:pre allow-calls? any) ~ ~
                 "suggestion" "maybe you should set! allow-calls? to #t")
      5)
  > (f)
  f: contract violation
    #:pre condition ~ ~
    suggestion: maybe you should set! allow-calls? to #t ~ ~
    in: (->* () #:pre ... any) ~ ~
    contract from: (function f) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

2. Function Contracts

A function contract wraps a procedure to delay checks for its arguments
and results. There are three primary function contract combinators that
have increasing amounts of expressiveness and increasing additional
overheads. The first -> is the cheapest. It generates wrapper functions
that can call the original function directly. Contracts built with ->*
require packaging up arguments as lists in the wrapper function and then
using either keyword-apply or apply. Finally, ->i is the most expensive
(along with ->d), because it requires delaying the evaluation of the
contract expressions for the domain and range until the function itself
is called or returns.

The case-> contract is a specialized contract, designed to match
case-lambda and unconstrained-domain-> allows range checking without
requiring that the domain have any particular shape (see below for an
example use).

                                        *->*
(-> dom ... range)
(-> dom ... ellipsis dom-expr ... range)
 
     dom = dom-expr
         | keyword dom-expr
            
   range = range-expr
         | (values range-expr ...)
         | any
            
ellipsis = ...

Produces a contract for a function that accepts the argument specified
by the dom-expr contracts and returns either a fixed number of results
or completely unspecified results (the latter when any is specified).

Each dom-expr is a contract on an argument to a function, and each
range-expr is a contract on a result of the function.

If the domain contain ... then the function accepts as many arguments as
the rest of the contracts in the domain portion specify, as well as
arbitrarily many more that match the contract just before the ....
Otherwise, the contract accepts exactly the argument specified.

Using a -> between two whitespace-delimited .s is the same as putting
the -> right after the enclosing opening parenthesis. See [missing] or
[missing] for more information.

For example,

  (integer? boolean? . -> . integer?)

produces a contract on functions of two arguments. The first argument
must be an integer, and the second argument must be a boolean. The
function must produce an integer.

Examples:

  > (define/contract (maybe-invert i b)
      (-> integer? boolean? integer?)
      (if b (- i) i))
  > (maybe-invert 1 #t)
  -1
  > (maybe-invert #f 1)
  maybe-invert: contract violation
    expected: integer? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> integer? boolean? integer?)
    contract from: (function maybe-invert) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

A domain specification may include a keyword. If so, the function must
accept corresponding (mandatory) keyword arguments, and the values for
the keyword arguments must match the corresponding contracts. For
example:

  (integer? #:invert? boolean? . -> . integer?) ~ ~

is a contract on a function that accepts a by-position argument that is
an integer and an #:invert? argument that is a boolean.

Examples:

  > (define/contract (maybe-invert i #:invert? b) ~ ~
      (-> integer? #:invert? boolean? integer?) ~ ~
      (if b (- i) i))
  > (maybe-invert 1 #:invert? #t) ~ ~
  -1
  > (maybe-invert 1 #f)
  maybe-invert: arity mismatch;
   the expected number of arguments does not match the given
  number
    expected: 1 plus an argument with keyword #:invert? ~ ~
    given: 2 ~ ~
    arguments...: ~ ~
     1
     #f

As an example that uses an ..., this contract:

  (integer? string? ... integer? . -> . any)

on a function insists that the first and last arguments to the function
must be integers (and there must be at least two arguments) and any
other arguments must be strings.

Examples:

  > (define/contract (string-length/between? lower-bound s1 . more-args)
      (-> integer? string? ... integer? boolean?)
    
      (define all-but-first-arg-backwards (reverse (cons s1 more-args)))
      (define upper-bound (first all-but-first-arg-backwards))
      (define strings (rest all-but-first-arg-backwards))
      (define strings-length
        (for/sum ([str (in-list strings)])
          (string-length str)))
      (<= lower-bound strings-length upper-bound))
  > (string-length/between? 4 "farmer" "john" 40)
  #t
  > (string-length/between? 4 "farmer" 'john 40)
  string-length/between?: contract violation
    expected: string? ~ ~
    given: 'john ~ ~
    in: the repeated argument of ~ ~
        (-> integer? string? ... integer? boolean?)
    contract from: ~ ~
        (function string-length/between?)
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~
  > (string-length/between? 4 "farmer" "john" "fourty")
  string-length/between?: contract violation
    expected: integer? ~ ~
    given: "fourty" ~ ~
    in: the last argument of ~ ~
        (-> integer? string? ... integer? boolean?)
    contract from: ~ ~
        (function string-length/between?)
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

If any is used as the last sub-form for ->, no contract checking is
performed on the result of the function, and thus any number of values
is legal (even different numbers on different invocations of the
function).

Examples:

  > (define/contract (multiple-xs n x)
      (-> natural? any/c any)
      (apply
       values
       (for/list ([_ (in-range n)])
         n)))
  > (multiple-xs 4 "four")
  4
  4
  4
  4

If (values range-expr ...) is used as the last sub-form of ->, the
function must produce a result for each contract, and each value must
match its respective contract.

Examples:

  > (define/contract (multiple-xs n x)
      (-> natural? any/c (values any/c any/c any/c))
      (apply
       values
       (for/list ([_ (in-range n)])
         n)))
  > (multiple-xs 3 "three")
  3
  3
  3
  > (multiple-xs 4 "four")
  multiple-xs: broke its own contract;
   expected 3 values, returned 4 values
    in: the range of ~ ~
        (->
         natural?
         any/c
         (values any/c any/c any/c))
    contract from: (function multiple-xs) ~ ~
    blaming: (function multiple-xs) ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

Changed in version 6.4.0.5 of package base: Added support for ellipses

                                        *->**
(->* (mandatory-dom ...) optional-doms rest pre range post)
 
mandatory-dom = dom-expr
              | keyword dom-expr
                 
optional-doms = 
              | (optional-dom ...)
                 
 optional-dom = dom-expr
              | keyword dom-expr
                 
         rest = 
              | #:rest rest-expr ~ ~
                 
          pre = 
              | #:pre pre-cond-expr ~ ~
              | #:pre/desc pre-cond-expr ~ ~
                 
        range = range-expr
              | (values range-expr ...)
              | any
                 
         post = 
              | #:post post-cond-expr ~ ~
              | #:post/desc post-cond-expr ~ ~

The ->* contract combinator produces contracts for functions that accept
optional arguments (either keyword or positional) and/or arbitrarily
many arguments. The first clause of a ->* contract describes the
mandatory arguments, and is similar to the argument description of a ->
contract. The second clause describes the optional arguments. The range
of description can either be any or a sequence of contracts, indicating
that the function must return multiple values.

If present, the rest-expr contract governs the arguments in the rest
parameter. Note that the rest-expr contract governs only the arguments
in the rest parameter, not those in mandatory arguments. For example,
this contract:

  (->* () #:rest (cons/c integer? (listof integer?)) any) ~ ~

does not match the function

  (λ (x . rest) x)

because the contract insists that the function accept zero arguments
(because there are no mandatory arguments listed in the contract). The
->* contract does not know that the contract on the rest argument is
going to end up disallowing empty argument lists.

The pre-cond-expr and post-cond-expr expressions are checked as the
function is called and returns, respectively, and allow checking of the
environment without an explicit connection to an argument (or a result).
If the #:pre or #:post keywords are used, then a #f result is treated as
a failure and any other result is treated as success. If the #:pre/desc
or #:post/desc keyword is used, the result of the expression must be
either a boolean, a string, or a list of strings, where #t means success
and any of the other results mean failure. If the result is a string or
a list of strings, the strings are expected to have at exactly one space
after each newline and multiple are used as lines in the error message;
the contract itself adds single space of indentation to each of the
strings in that case. The formatting requirements are not checked but
they match the recommendations in [missing].

As an example, the contract

  (->* () (boolean? #:x integer?) #:rest (listof symbol?) symbol?) ~ ~

matches functions that optionally accept a boolean, an integer keyword
argument #:x and arbitrarily more symbols, and that return a symbol.

                                        *->i*
(->i maybe-chaperone
     (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
(->i maybe-chaperone
     (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
 
        maybe-chaperone = #:chaperone ~ ~
                        | 
                           
mandatory-dependent-dom = id+ctc
                        | keyword id+ctc
                           
 optional-dependent-dom = id+ctc
                        | keyword id+ctc
                           
         dependent-rest = 
                        | #:rest id+ctc ~ ~
                           
          pre-condition = 
                        | #:pre (id ...) ~ ~
                          boolean-expr pre-condition
                        | #:pre/desc (id ...) ~ ~
                          expr pre-condition
                        | #:pre/name (id ...) ~ ~
                          string boolean-expr pre-condition
                           
        dependent-range = any
                        | id+ctc
                        | un+ctc
                        | (values id+ctc ...)
                        | (values un+ctc ...)
                           
         post-condition = 
                        | #:post (id ...) ~ ~
                          boolean-expr post-condition
                        | #:post/desc (id ...) ~ ~
                          expr post-condition
                        | #:post/name (id ...) ~ ~
                          string boolean-expr post-condition
                           
                 id+ctc = [id contract-expr]
                        | [id (id ...) contract-expr]
                           
                 un+ctc = [_ contract-expr]
                        | [_ (id ...) contract-expr]

The ->i contract combinator differs from the ->* combinator in that each
argument and result is named and these names can be used in the
subcontracts and in the pre-/post-condition clauses. In other words, ->i
expresses dependencies among arguments and results.

The optional first keyword argument to ->i indicates if the result
contract will be a chaperone. If it is #:chaperone, all of the contract
for the arguments and results must be chaperone contracts and the result
of ->i will be a chaperone contract. If it is not present, then the
result contract will not be a chaperone contract.

The first sub-form of a ->i contract covers the mandatory and the second
sub-form covers the optional arguments. Following that is an optional
rest-args contract, and an optional pre-condition. The pre-condition is
introduced with the #:pre keyword followed by the list of names on which
it depends. If the #:pre/name keyword is used, the string supplied is
used as part of the error message; similarly with #:post/name. If
#:pre/desc or #:post/desc is used, the the result of the expression is
treated the same way as ->*.

The dependent-range non-terminal specifies the possible result
contracts. If it is any, then any value is allowed. Otherwise, the
result contract pairs a name and a contract or a multiple values return
with names and contracts. In the last two cases, the range contract may
be optionally followed by a post-condition; the post-condition
expression is not allowed if the range contract is any. Like the
pre-condition, the post-condition must specify the variables on which it
depends.

Consider this sample contract:

  (->i ([x number?]
        [y (x) (>=/c x)])
       [result (x y) (and/c number? (>=/c (+ x y)))])

It specifies a function of two arguments, both numbers. The contract on
the second argument (y) demands that it is greater than the first
argument. The result contract promises a number that is greater than the
sum of the two arguments. While the dependency specification for y
signals that the argument contract depends on the value of the first
argument, the dependency sequence for result indicates that the contract
depends on both argument values. In general, an empty sequence is
(nearly) equivalent to not adding a sequence at all except that the
former is more expensive than the latter. Since the contract for x does
not depend on anything else, it does not come with any dependency
sequence, not even ().

This example is like the previous one, except the x and y arguments are
now optional keyword arguments, instead of mandatory, by-position
arguments:

  (->i ()
       (#:x [x number?] ~ ~
        #:y [y (x) (>=/c x)]) ~ ~
       [result (x y)
        (and/c number?
               (if (and (number? x) (number? y))
                   (>=/c (+ x y))
                   any/c))])

The conditional in the range that tests x and y is necessary to cover
the situation where x or y are not supplied by the calling context
(meaning they might be bound to the-unsupplied-arg).

The contract expressions are not always evaluated in order. First, if
there is no dependency for a given contract expression, the contract
expression is evaluated at the time that the ->i expression is evaluated
rather than the time when the function is called or returns.  These
dependency-free contract expressions are evaluated in the order in which
they are listed. Second, the dependent contract sub-expressions are
evaluated when the contracted function is called or returns in some
order that satisfies the dependencies. That is, if a contract for an
argument depends on the value of some other contract, the former is
evaluated first (so that the argument, with its contract checked, is
available for the other).  When there is no dependency between two
arguments (or the result and an argument), then the contract that
appears earlier in the source text is evaluated first.

If all of the identifier positions of a range contract with  a
dependency are _s (underscores), then the range  contract expressions
are evaluated when the function is  called instead of when it returns.
Otherwise, dependent  range expressions are evaluated when the function
returns.

If there are optional arguments that are not supplied, then  the
corresponding variables will be bound to a special value  called
the-unsupplied-arg value. For example, in  this contract:

  (->i ([x (y) (if (unsupplied-arg? y)
                   real?
                   (>=/c y))])
       ([y real?])
       any)

the contract on x depends on y, but  y might not be supplied at the call
site. In that  case, the value of y in the contract on  x is
the-unsupplied-arg  and the ->i contract must check for it and tailor
the contract on x to  account for y not being supplied.

When the contract expressions for unsupplied arguments are dependent,
and the argument is not supplied at the call site, the contract
expressions are not evaluated at all. For example, in this contract, y’s
contract expression is evaluated only when y is supplied:

  (->i ()
       ([x real?]
        [y (x) (>=/c x)])
       any)

In contrast, x’s expression is always evaluated (indeed, it is evaluated
when the ->i expression is evaluated because it does not have any
dependencies).

                                        *->d*
(->d (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
(->d (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
 
mandatory-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
 optional-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
         dependent-rest = 
                        | #:rest id rest-expr ~ ~
                           
          pre-condition = 
                        | #:pre boolean-expr ~ ~
                        | #:pre-cond boolean-expr ~ ~
                           
        dependent-range = any
                        | [_ range-expr]
                        | (values [_ range-expr] ...)
                        | [id range-expr]
                        | (values [id range-expr] ...)
                           
         post-condition = 
                        | #:post-cond boolean-expr ~ ~

This contract is here for backwards compatibility; any new code should
use ->i instead.

This contract is similar to ->i, but is “lax”, meaning that it does not
enforce contracts internally. For example, using this contract

  (->d ([f (-> integer? integer?)])
       #:pre ~ ~
       (zero? (f #f))
       any)

will allow f to be called with #f, trigger whatever bad behavior the
author of f was trying to prohibit by insisting that f’s contract accept
only integers.

The #:pre-cond and #:post-cond keywords are aliases for #:pre and #:post
and are provided for backwards compatibility.

                                        *case->*
(case-> (-> dom-expr ... rest range) ...) ~
 
 rest = 
      | #:rest rest-expr ~ ~
         
range = range-expr
      | (values range-expr ...)
      | any

This contract form is designed to match case-lambda. Each argument to
case-> is a contract that governs a clause in the case-lambda. If the
#:rest keyword is present, the corresponding clause must accept an
arbitrary number of arguments. The range specification is just like that
for -> and ->*.

For example, this contract matches a function with two cases, one that
accepts an integer, returning void, and one that accepts no arguments
and returns an integer.

  (case-> (-> integer? void?)
          (-> integer?))

Such a contract could be used to guard a function that controls access
to a single shared integer.

                                        *dynamic->**
(dynamic->*                                                             ~
            [#:mandatory-domain-contracts mandatory-domain-contracts    ~ ~
             #:optional-domain-contracts optional-domain-contracts      ~ ~
             #:mandatory-keywords mandatory-keywords                    ~ ~
             #:mandatory-keyword-contracts mandatory-keyword-contracts  ~ ~
             #:optional-keywords optional-keywords                      ~ ~
             #:optional-keyword-contracts optional-keyword-contracts    ~ ~
             #:rest-contract rest-contract]                             ~ ~
             #:range-contracts range-contracts)                         ~ ~
 -> contract?
  mandatory-domain-contracts : (listof contract?) = '() ~ ~
  optional-domain-contracts : (listof contract?) = '() ~ ~
  mandatory-keywords : (listof keyword?) = '() ~ ~
  mandatory-keyword-contracts : (listof contract?) = '() ~ ~
  optional-keywords : (listof keyword?) = '() ~ ~
  optional-keyword-contracts : (listof contract?) = '() ~ ~
  rest-contract : (or/c #f contract?) = #f ~ ~
  range-contracts : (or/c #f (listof contract?)) ~ ~

Like ->*, except the number of arguments and results can be computed at
runtime, instead of being fixed at compile-time. Passing #f as the
#:range-contracts argument produces a contract like one where any is
used with -> or ->*.

For many uses, dynamic->*’s result is slower than ->* (or ->), but for
some it has comparable speed. The name of the contract returned by
dynamic->* uses the -> or ->* syntax.

                                        *unconstrained-domain->*
(unconstrained-domain-> range-expr ...) ~

Constructs a contract that accepts a function, but makes no constraint
on the function’s domain. The range-exprs determine the number of
results and the contract for each result.

Generally, this contract must be combined with another contract to
ensure that the domain is actually known to be able to safely call the
function itself.

For example, the contract

  (provide
   (contract-out
    [f (->d ([size natural-number/c]
             [proc (and/c (unconstrained-domain-> number?)
                          (lambda (p)
                            (procedure-arity-includes? p size)))])
            ()
            [_ number?])]))

says that the function f accepts a natural number and a function. The
domain of the function that f accepts must include a case for size
arguments, meaning that f can safely supply size arguments to its input.

For example, the following is a definition of f that cannot be blamed
using the above contract:

  (define (f i g)
    (apply g (build-list i add1)))

predicate/c : contract? ~ ~

Use this contract to indicate that some function is a predicate. It is
semantically equivalent to (-> any/c boolean?).

This contract also includes an optimization so that functions returning
#t from struct-predicate-procedure? are just returned directly, without
being wrapped. This contract is used by provide/contract’s struct
sub-form so that struct predicates end up not being wrapped.

the-unsupplied-arg : unsupplied-arg? ~ ~

Used by ->i (and ->d) to bind optional arguments that are not supplied
by a call site.

                                        *unsupplied-arg?*
(unsupplied-arg? v) -> boolean? ~
  v : any/c ~ ~

A predicate to determine whether v is the-unsupplied-arg.

3. Parametric Contracts

 (require racket/contract/parametric) package: base ~ ~

The most convenient way to use parametric contract is to use
contract-out’s #:exists keyword. The racket/contract/parametric provides
a few more, general-purpose parametric contracts.

                                        *parametric->/c*
(parametric->/c (x ...) c) ~

Creates a contract for parametric polymorphic functions.  Each function
is protected by c, where each x is bound in c and refers to a
polymorphic type that is instantiated each time the function is applied.

At each application of a function, the parametric->/c contract
constructs a new opaque wrapper for each x; values flowing into the
polymorphic function (i.e. values protected by some x in negative
position with respect to parametric->/c) are wrapped in the
corresponding opaque wrapper.  Values flowing out of the polymorphic
function (i.e. values protected by some x in positive position with
respect to parametric->/c) are checked for the appropriate wrapper.  If
they have it, they are unwrapped; if they do not, a contract violation
is signaled.

Examples:

  > (define swap-ctc (parametric->/c [A B] (-> A B (values B A))))
  > (define/contract (good-swap a b)
      swap-ctc
      (values b a))
  > (good-swap 1 2)
  2
  1
  > (define/contract (bad-swap a b)
      swap-ctc
      (values a b))
  > (bad-swap 1 2)
  bad-swap: broke its own contract
    promised: B ~ ~
    produced: #<A> ~ ~
    in: the range of ~ ~
        (parametric->/c (A B) (-> A B (values B A)))
    contract from: (function bad-swap) ~ ~
    blaming: (function bad-swap) ~ ~
     (assuming the contract is correct)
    at: eval:5.0 ~ ~
  > (define/contract (copy-first a b)
      swap-ctc
      (values a a))
  > (let ((v 'same-symbol)) (copy-first v v))
  copy-first: broke its own contract
    promised: B ~ ~
    produced: #<A> ~ ~
    in: the range of ~ ~
        (parametric->/c (A B) (-> A B (values B A)))
    contract from: (function copy-first) ~ ~
    blaming: (function copy-first) ~ ~
     (assuming the contract is correct)
    at: eval:7.0 ~ ~
  > (define/contract (inspect-first a b)
      swap-ctc
      (if (integer? a)
        (+ a b)
        (raise-user-error "an opaque wrapped value is not an integer")))
  > (inspect-first 1 2)
  an opaque wrapped value is not an integer

                                        *new-*
(new-∀/c [name]) -> contract? ~
  name : (or/c symbol? #f) = #f ~ ~

Constructs a new universal contract.

Universal contracts accept all values when in negative positions (e.g.,
function inputs) and wrap them in an opaque struct, hiding the precise
value. In positive positions (e.g. function returns), a universal
contract accepts only values that were previously accepted in negative
positions (by checking for the wrappers).

The name is used to identify the contract in error messages and defaults
to a name based on the lexical context of new-∀/c.

For example, this contract:

  (let ([a (new-∀/c 'a)])
    (-> a a))

describes the identity function (or a non-terminating function). That
is, the first use of the a appears in a negative position and thus
inputs to that function are wrapped with an opaque struct. Then, when
the function returns, it is checked to determine whether the result is
wrapped, since the second a appears in a positive position.

The new-∀/c contract constructor is dual to new-∃/c.

                                        *new-*
(new-∃/c [name]) -> contract? ~
  name : (or/c symbol? #f) = #f ~ ~

Constructs a new existential contract.

Existential contracts accept all values when in positive positions
(e.g., function returns) and wrap them in an opaque struct, hiding the
precise value. In negative positions (e.g. function inputs), they
accepts only values that were previously accepted in positive positions
(by checking for the wrappers).

The name is used to identify the contract in error messages and defaults
to a name based on the lexical context of new-∀/c.

For example, this contract:

  (let ([a (new-∃/c 'a)])
    (-> (-> a a)
        any/c))

describes a function that accepts the identity function (or a
non-terminating function) and returns an arbitrary value. That is, the
first use of the a appears in a positive position and thus inputs to
that function are wrapped with an opaque struct. Then, when the function
returns, it is checked to see if the result is wrapped, since the second
a appears in a negative position.

The new-∃/c construct constructor is dual to new-∀/c.

4. Lazy Data-structure Contracts

                                        *contract-struct*
(contract-struct id (field-id ...)) ~

  NOTE: This library is deprecated; use struct, instead. Lazy struct
  contracts no longer require a separate struct declaration; instead
  struct/dc and struct/c work directly with struct and define-struct.

Like struct, but with two differences: they do not define field
mutators, and they define two contract constructors: id/c and id/dc. The
first is a procedure that accepts as many arguments as there are fields
and returns a contract for struct values whose fields match the
arguments. The second is a syntactic form that also produces contracts
on the structs, but the contracts on later fields may depend on the
values of earlier fields.

The generated contract combinators are lazy: they only verify the
contract holds for the portion of some data structure that is actually
inspected. More precisely, a lazy data structure contract is not checked
until a selector extracts a field of a struct.

                                        *id/dc*
(id/dc field-spec ...) ~
 
field-spec = [field-id contract-expr]
           | [field-id (field-id ...) contract-expr]
In each field-spec case, the first field-id specifies which field the
contract applies to; the fields must be specified in the same order as
the original contract-struct. The first case is for when the contract on
the field does not depend on the value of any other field. The second
case is for when the contract on the field does depend on some other
fields, and the parenthesized field-ids indicate which fields it depends
on; these dependencies can only be to earlier fields.

                                        *define-contract-struct*
(define-contract-struct id (field-id ...)) ~

  NOTE: This library is deprecated; use struct, instead. Lazy struct
  contracts no longer require a separate struct declaration; instead
  struct/dc and struct/c work directly with struct and define-struct.

Like contract-struct, but where the constructor’s name is make-id, much
like define-struct.

5. Structure Type Property Contracts

                                        *struct-type-property/c*
(struct-type-property/c value-contract) -> contract? ~
  value-contract : contract? ~ ~

Produces a contract for a structure type property. When the contract is
applied to a struct type property, it produces a wrapped struct type
property that applies value-contract to the value associated with the
property when it used to create a new struct type (via struct,
make-struct-type, etc).

The struct type property’s accessor function is not affected; if it is
exported, it must be protected separately.

As an example, consider the following module. It creates a structure
type property, prop, whose value should be a function mapping a
structure instance to a numeric predicate. The module also exports
app-prop, which extracts the predicate from a structure instance and
applies it to a given value.

  > (module propmod racket
      (require racket/contract)
      (define-values (prop prop? prop-ref)
        (make-struct-type-property 'prop))
      (define (app-prop x v)
        (((prop-ref x) x) v))
      (provide/contract
       [prop? (-> any/c boolean?)]
       [prop (struct-type-property/c
              (-> prop? (-> integer? boolean?)))]
       [app-prop (-> prop? integer? boolean?)])
      (provide prop-ref))

The structmod module creates a structure type named s with a single
field; the value of prop is a function that extracts the field value
from an instance. Thus the field ought to be an integer predicate, but
notice that structmod places no contract on s enforcing that constraint.

  > (module structmod racket
      (require 'propmod)
      (struct s (f) #:property prop (lambda (s) (s-f s))) ~ ~
      (provide (struct-out s)))
  > (require 'propmod 'structmod)

First we create an s instance with an integer predicate, so the
constraint on prop is in fact satisfied. The first call to app-prop is
correct; the second simply violates the contract of app-prop.

  > (define s1 (s even?))
  > (app-prop s1 5)
  #f
  > (app-prop s1 'apple)
  app-prop: contract violation
    expected: integer? ~ ~
    given: 'apple ~ ~
    in: the 2nd argument of ~ ~
        (-> prop? integer? boolean?)
    contract from: propmod ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

We are able to create s instances with values other than integer
predicates, but applying app-prop on them blames structmod, because the
function associated with prop—that is, (lambda (s) (s-f s))—does not
always produce a value satisfying (-> integer? boolean?).

  > (define s2 (s "not a fun"))
  > (app-prop s2 5)
  prop: contract violation
    expected: a procedure ~ ~
    given: "not a fun" ~ ~
    in: the range of ~ ~
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~ ~
    blaming: structmod ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~
  > (define s3 (s list))
  > (app-prop s3 5)
  prop: contract violation
    expected: boolean? ~ ~
    given: '(5) ~ ~
    in: the range of ~ ~
        the range of
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~ ~
    blaming: structmod ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

The fix would be to propagate the obligation inherited from prop to s:

  (provide (contract-out
             [struct s ([f (-> integer? boolean?)])]))

Finally, if we directly apply the property accessor, prop-ref, and then
misuse the resulting function, the propmod module is blamed:

  > ((prop-ref s3) 'apple)
  prop: broke its own contract
    promised: prop? ~ ~
    produced: 'apple ~ ~
    in: the 1st argument of ~ ~
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~ ~
    blaming: propmod ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

The propmod module has an obligation to ensure a function associated
with prop is applied only to values satisfying prop?. By directly
providing prop-ref, it enables that constraint to be violated (and thus
it is blamed), even though the bad application actually occurs
elsewhere.

Generally there is no need to provide a structure type property accessor
at all; it is typically only used by other functions within the module.
But if it must be provided, it should be protected thus:

  (provide (contract-out
             [prop-ref (-> prop? (-> prop? (-> integer? boolean?)))]))

6. Attaching Contracts to Values

                                        *contract-out*
(contract-out unprotected-submodule contract-out-item ...) ~
 
unprotected-submodule = 
                      | #:unprotected-submodule submodule-name ~ ~
                         
    contract-out-item = (struct id/ignored ((id contract-expr) ...)
                          struct-option)
                      | (rename orig-id id contract-expr)
                      | (id contract-expr)
                      | #:∃ poly-variables ~ ~
                      | #:exists poly-variables ~ ~
                      | #:∀ poly-variables ~ ~
                      | #:forall poly-variables ~ ~
                         
       poly-variables = id
                      | (id ...)
                         
           id/ignored = id
                      | (id ignored-id)
                         
        struct-option = 
                      | #:omit-constructor ~ ~

A provide-spec for use in provide (currently only for the same phase
level as the provide form; for example, contract-out cannot be nested
within for-syntax). Each id is provided from the module. In addition,
clients of the module must live up to the contract specified by
contract-expr for each export.

The contract-out form treats modules as units of blame. The module that
defines the provided variable is expected to meet the positive
(co-variant) positions of the contract. Each module that imports the
provided variable must obey the negative (contra-variant) positions of
the contract. Each contract-expr in a contract-out form is effectively
moved to the end of the enclosing module, so a contract-expr can refer
to variables that are defined later in the same module.

Only uses of the contracted variable outside the module are checked.
Inside the module, no contract checking occurs.

The rename form of contract-out exports the first variable (the internal
name) with the name specified by the second variable (the external
name).

The struct form of contract-out provides a structure-type definition id,
and each field has a contract that dictates the contents of the fields.
Unlike a struct definition, however, all of the fields (and their
contracts) must be listed. The contract on the fields that the
sub-struct shares with its parent are only used in the contract for the
sub-struct’s constructor, and the selector or mutators for the
super-struct are not provided. The exported structure-type name always
doubles as a constructor, even if the original structure-type name does
not act as a constructor. If the #:omit-constructor option is present,
the constructor is not provided. The second form of id/ignored, which
has both id and ignored-id, is deprecated and allowed in the grammar
only for backward compatability, where ignored-id is ignored. The first
form should be used instead.

Note that if the struct is created with serializable-struct or
define-serializable-struct, contract-out does not protect struct
instances that are created via deserialize. Consider using
struct-guard/c instead.

The #:∃, #:exists, #:∀, and #:forall clauses define new abstract
contracts. The variables are bound in the remainder of the contract-out
form to new contracts that hide the values they accept and ensure that
the exported functions are treated parametrically. See new-∃/c and
new-∀/c for details on how the clauses hide the values.

If #:unprotected-submodule appears, the identifier that follows it is
used as the name of a submodule that contract-out generates. The
submodule exports all of the names in the contract-out, but without
contracts.

The implementation of contract-out uses syntax-property to attach
properties to the code it generates that records the syntax of the
contracts in the fully expanded program. Specifically, the symbol
'provide/contract-original-contract is bound to vectors of two elements,
the exported identifier and a syntax object for the expression that
produces the contract controlling the export.

Changed in version 7.3.0.3 of package base: Added
#:unprotected-submodule. Changed in version 7.7.0.9: Started ignoring
ignored-id.

                                        *recontract-out*
(recontract-out id ...) ~

A provide-spec for use in provide (currently,   just like contract-out,
only for   the same phase level as the provide form).

It re-exports id, but with positive blame associated to the module
containing recontract-out instead of the location of the original site
of id.

This can be useful when a public module wants to export an identifier
from a private module but where any contract violations should be
reported in terms of the public module instead of the private one.

Examples:

  > (module private-implementation racket/base
      (require racket/contract)
      (define (recip x) (/ 1 x))
      (define (non-zero? x) (not (= x 0)))
      (provide/contract [recip (-> (and/c real? non-zero?)
                                   (between/c -1 1))]))
  > (module public racket/base
      (require racket/contract
               'private-implementation)
      (provide (recontract-out recip)))
  > (require 'public)
  > (recip +nan.0)
  recip: broke its own contract
    promised: (between/c -1 1) ~ ~
    produced: +nan.0 ~ ~
    in: the range of ~ ~
        (->
         (and/c real? non-zero?)
         (between/c -1 1))
    contract from: public ~ ~
    blaming: public ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

Replacing the use of recontract-out with just recip would result in a
contract violation blaming the private module.

                                        *provide/contract*
(provide/contract unprotected-submodule contract-out-item ...) ~

A legacy shorthand for (provide (contract-out unprotected-submodule
contract-out-item ...)), except that a contract-expr within
provide/contract is evaluated at the position of the provide/contract
form instead of at the end of the enclosing module.

                                        *struct-guard/c*
(struct-guard/c contract-expr ...) ~

Returns a procedure suitable to be passed as the #:guard argument to
struct, serializable-struct (and related forms). The guard procedure
ensures that each contract protects the corresponding field values, as
long as the struct is not mutated. Mutations are not protected.

Examples:

  > (struct snake (weight hungry?)
      #:guard (struct-guard/c real? boolean?)) ~ ~
  > (snake 1.5 "yep")
  snake, field 2: contract violation
    expected: boolean? ~ ~
    given: "yep" ~ ~
    in: boolean? ~ ~
    contract from: top-level ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

6.1. Nested Contract Boundaries

 (require racket/contract/region) package: base ~ ~

                                        *with-contract*
(with-contract blame-id (wc-export ...) free-var-list ... body ...+) ~
(with-contract blame-id results-spec free-var-list ... body ...+)
 
    wc-export = (id contract-expr)
                 
  result-spec = #:result contract-expr ~ ~
              | #:results (contract-expr ...) ~ ~
                 
free-var-list = 
              | #:freevar id contract-expr ~ ~
              | #:freevars ([id contract-expr] ...) ~ ~

Generates a local contract boundary.

The first with-contract form cannot appear in expression position. All
names defined within the first with-contract form are visible
externally, but those names listed in the wc-export list are protected
with the corresponding contract.  The body of the form allows
definition/expression interleaving if its context does.

The second with-contract form must appear in expression position. The
final body expression should return the same number of values as the
number of contracts listed in the result-spec, and each returned value
is contracted with its respective contract.  The sequence of body forms
is treated as for let.

The blame-id is used for the positive positions of contracts paired with
exported ids.  Contracts broken within the with-contract body will use
the blame-id for their negative position.

If a free-var-list is given, then any uses of the free variables inside
the body will be protected with contracts that blame the context of the
with-contract form for the positive positions and the with-contract form
for the negative ones.

                                        *define/contract*
(define/contract id contract-expr free-var-list init-value-expr) ~
(define/contract (head args) contract-expr free-var-list body ...+)

Works like define, except that the contract contract-expr is attached to
the bound value.  For the definition of head and args, see define. For
the definition of free-var-list, see with-contract.

Examples:

  > (define/contract distance (>=/c 0) 43.52)
  > (define/contract (furlongs->feet fr)
      (-> real? real?)
      (* 660 fr))
  ; a contract violation expected here: ~ ~
  > (furlongs->feet "not a furlong")
  furlongs->feet: contract violation
    expected: real? ~ ~
    given: "not a furlong" ~ ~
    in: the 1st argument of ~ ~
        (-> real? real?)
    contract from: (function furlongs->feet) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

The define/contract form treats the individual definition as a contract
region. The definition itself is responsible for positive (co-variant)
positions of the contract, and references to id outside of the
definition must meet the negative positions of the contract. Since the
contract boundary is between the definition and the surrounding context,
references to id inside the define/contract form are not checked.

Examples:

  ; an unsual predicate that prints when called
  > (define (printing-int? x)
      (displayln "I was called")
      (exact-integer? x))
  > (define/contract (fact n)
      (-> printing-int? printing-int?)
      (if (zero? n)
          1
          (* n (fact (sub1 n)))))
  > (fact 5) ; only prints twice, not for each recursive call
  I was called
  I was called
  120

If a free-var-list is given, then any uses of the free variables inside
the body will be protected with contracts that blame the context of the
define/contract form for the positive positions and the define/contract
form for the negative ones.

Examples:

  > (define (integer->binary-string n)
      (number->string n 2))
  > (define/contract (numbers->strings lst)
      (-> (listof number?) (listof string?))
      #:freevar integer->binary-string (-> exact-integer? string?) ~ ~
      ; mistake, lst might contain inexact numbers
      (map integer->binary-string lst))
  > (numbers->strings '(4.0 3.3 5.8))
  integer->binary-string: contract violation
    expected: exact-integer? ~ ~
    given: 4.0 ~ ~
    in: the 1st argument of ~ ~
        (-> exact-integer? string?)
    contract from: top-level ~ ~
    blaming: (function numbers->strings) ~ ~
     (assuming the contract is correct)
    at: eval:3.0 ~ ~

                                        *struct/contract*
(struct/contract struct-id ([field contract-expr] ...) ~
                        struct-option ...)
(struct/contract struct-id super-struct-id
                        ([field contract-expr] ...)
                        struct-option ...)

Works like struct, except that the arguments to the constructor,
accessors, and mutators are protected by contracts.  For the definitions
of field and struct-option, see struct.

The struct/contract form only allows a subset of the struct-option
keywords: #:mutable, #:transparent, #:auto-value,
#:omit-define-syntaxes, #:property and #:omit-define-values.

Examples:

  > (struct/contract fruit ([seeds number?]))
  > (fruit 60)
  #<fruit>
  > (fruit #f)
  fruit: contract violation
    expected: number? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> number? symbol? any)
    contract from: (struct fruit) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
  > (struct/contract apple fruit ([type string?]))
  > (apple 14 "golden delicious")
  #<apple>
  > (apple 5 30)
  apple: contract violation
    expected: string? ~ ~
    given: 30 ~ ~
    in: the 2nd argument of ~ ~
        (-> any/c string? symbol? any)
    contract from: (struct apple) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
  > (apple #f "granny smith")
  fruit: contract violation
    expected: number? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> number? symbol? any)
    contract from: (struct fruit) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)

                                        *define-struct/contract*
(define-struct/contract struct-id ([field contract-expr] ...) ~
                        struct-option ...)
(define-struct/contract (struct-id super-struct-id)
                        ([field contract-expr] ...)
                        struct-option ...)

Works like struct/contract, except that the syntax for supplying a
super-struct-id is different, and a constructor-id that has a make-
prefix on struct-id is implicitly supplied.  For the definitions of
field and struct-option, see define-struct.

The define-struct/contract form only allows a subset of the
struct-option keywords: #:mutable, #:transparent, #:auto-value,
#:omit-define-syntaxes, #:property and #:omit-define-values.

Examples:

  > (define-struct/contract fish ([color number?]))
  > (make-fish 5)
  #<fish>
  > (make-fish #f)
  make-fish: contract violation
    expected: number? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> number? symbol? any)
    contract from: (struct fish) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
  > (define-struct/contract (salmon fish) ([ocean symbol?]))
  > (make-salmon 5 'atlantic)
  #<salmon>
  > (make-salmon 5 #f)
  make-salmon: contract violation
    expected: symbol? ~ ~
    given: #f ~ ~
    in: the 2nd argument of ~ ~
        (-> any/c symbol? symbol? any)
    contract from: (struct salmon) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
  > (make-salmon #f 'pacific)
  make-fish: contract violation
    expected: number? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> number? symbol? any)
    contract from: (struct fish) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)

                                        *invariant-assertion*
(invariant-assertion invariant-expr expr) ~

Establishes an invariant of expr, determined by invariant-expr.

Unlike the specification of a contract, an invariant-assertion does not
establish a boundary between two parties. Instead, it simply attaches a
logical assertion to the value. Because the form uses contract machinery
to check the assertion, the surrounding module is treated as the party
to be blamed for any violations of the assertion.

This means, for example, that the assertion is checked on recursive
calls, when an invariant is used on the right-hand side of a definition:

Examples:

  > (define furlongss->feets
      (invariant-assertion
       (-> (listof real?) (listof real?))
       (λ (l)
         (cond
           [(empty? l) empty]
           [else
            (if (= 327 (car l))
                (furlongss->feets (list "wha?"))
                (cons (furlongs->feet (first l))
                      (furlongss->feets (rest l))))]))))
  > (furlongss->feets (list 1 2 3))
  '(660 1320 1980)
  > (furlongss->feets (list 1 327 3))
  furlongss->feets: assertion violation
    expected: real? ~ ~
    given: "wha?" ~ ~
    in: an element of ~ ~
        the 1st argument of
        (-> (listof real?) (listof real?))
    contract from: invariant-assertion ~ ~
    at: eval:5.0 ~ ~

Added in version 6.0.1.11 of package base.

current-contract-region

Bound by define-syntax-parameter, this contains information about the
current contract region, used by the above forms to determine the
candidates for blame assignment.

6.2. Low-level Contract Boundaries

                                        *define-module-boundary-contract*
(define-module-boundary-contract id ~
  orig-id
  contract-expr
  pos-blame-party
  source-loc
  name-for-blame
  context-limit)
 
pos-blame-party = 
                | #:pos-source pos-source-expr ~ ~
                   
     source-loc = 
                | #:srcloc srcloc-expr ~ ~
                   
 name-for-blame = 
                | #:name-for-blame blame-id ~ ~
                   
  context-limit = 
                | #:context-limit limit-expr ~ ~

Defines id to be orig-id, but with the contract contract-expr.

The identifier id is defined as a macro transformer that consults the
context of its use to determine the name for negative blame assignment
(using the entire module where a reference appears as the negative
party).

The positive party defaults to the module containing the use of
define-module-boundary-contract, but can be specified explicitly via the
#:pos-source keyword.

The source location used in the blame error messages for the location of
the place where the contract was put on the value defaults to the source
location of the use of define-module-boundary-contract, but can be
specified via the #:srcloc argument, in which case it can be any of the
things that the third argument to datum->syntax can be.

The name used in the error messages will be orig-id, unless
#:name-for-blame is supplied, in which case the identifier following it
is used as the name in the error messages.

If #:context-limit is supplied, it behaves the same as it does when
supplied to contract.

Examples:

  > (module server racket/base
      (require racket/contract/base)
      (define (f x) #f)
      (define-module-boundary-contract g f (-> integer? integer?))
      (provide g))
  > (module client racket/base
      (require 'server)
      (define (clients-fault) (g #f))
      (define (servers-fault) (g 1))
      (provide servers-fault clients-fault))
  > (require 'client)
  > (clients-fault)
  g: contract violation
    expected: integer? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        (-> integer? integer?)
    contract from: 'server ~ ~
    blaming: client ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~
  > (servers-fault)
  g: broke its own contract
    promised: integer? ~ ~
    produced: #f ~ ~
    in: the range of ~ ~
        (-> integer? integer?)
    contract from: 'server ~ ~
    blaming: (quote server) ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

Changed in version 6.7.0.4 of package base: Added the #:name-for-blame
argument. Changed in version 6.90.0.29: Added the #:context-limit
argument.

                                        *contract*
(contract contract-expr to-protect-expr ~
          positive-blame-expr negative-blame-expr)
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr
          #:context-limit limit-expr) ~ ~
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr
          value-name-expr source-location-expr)

The primitive mechanism for attaching a contract to a value. The purpose
of contract is as a target for the expansion of some higher-level
contract specifying form.

The contract expression adds the contract specified by contract-expr to
the value produced by to-protect-expr. The result of a contract
expression is the result of the to-protect-expr expression, but with the
contract specified by contract-expr enforced on to-protect-expr.

The values of positive-blame-expr and negative-blame-expr indicate how
to assign blame for positive and negative positions of the contract
specified by contract-expr.  They may be any value, and are formatted as
by display for purposes of contract violation error messages.

If specified, value-name-expr indicates a name for the protected value
to be used in error messages.  If not supplied, or if value-name-expr
produces #f, no name is printed.  Otherwise, it is also formatted as by
display. More precisely, the value-name-expr ends up in the blame-name
field of the blame record, which is used as the first portion of the
error message.

Examples:

  > (contract integer? #f 'pos 'neg 'timothy #f)
  timothy: broke its own contract
    promised: integer? ~ ~
    produced: #f ~ ~
    in: integer? ~ ~
    contract from: pos ~ ~
    blaming: pos ~ ~
     (assuming the contract is correct)
  > (contract integer? #f 'pos 'neg #f #f)
  broke its own contract
    promised: integer? ~ ~
    produced: #f ~ ~
    in: integer? ~ ~
    contract from: pos ~ ~
    blaming: pos ~ ~
     (assuming the contract is correct)

If specified, source-location-expr indicates the source location
reported by contract violations.  The expression must produce a srcloc
structure, syntax object, #f, or a list or vector in the format accepted
by the third argument to datum->syntax.

If #:context-limit is supplied, the following expression  must evaluate
to either #f or a natural number. If  the expression evaluates to an
natural number, the number of  layers of context information is limited
to at most that  many. For example, if the number is 0, no context
information is recorded and the error messages do not contain  the
section that starts with in:.

7. Building New Contract Combinators

 (require racket/contract/combinator) package: base ~ ~

                                        *make-contract*
(make-contract                                                               ~
               [#:name name                                                  ~ ~
                #:first-order first-order                                    ~ ~
                #:late-neg-projection late-neg-proj                          ~ ~
                #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                #:val-first-projection val-first-proj                        ~ ~
                #:projection proj                                            ~ ~
                #:stronger stronger                                          ~ ~
                #:equivalent equivalent                                      ~ ~
                #:list-contract? is-list-contract?])                         ~ ~
 -> contract?
  name : any/c = 'anonymous-contract ~ ~
  first-order : (-> any/c any/c) = (λ (x) #t) ~ ~
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~ ~
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~ ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  is-list-contract? : boolean? = #f ~ ~
(make-chaperone-contract                                                              
                         [#:name name                                                  ~ ~
                          #:first-order first-order                                    ~ ~
                          #:late-neg-projection late-neg-proj                          ~ ~
                          #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                          #:val-first-projection val-first-proj                        ~ ~
                          #:projection proj                                            ~ ~
                          #:stronger stronger                                          ~ ~
                          #:equivalent equivalent                                      ~ ~
                          #:list-contract? is-list-contract?])                         ~ ~
 -> chaperone-contract?
  name : any/c = 'anonymous-chaperone-contract ~ ~
  first-order : (-> any/c any/c) = (λ (x) #t) ~ ~
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~ ~
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~ ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  is-list-contract? : boolean? = #f ~ ~
(make-flat-contract                                                              
                    [#:name name                                                  ~ ~
                     #:first-order first-order                                    ~ ~
                     #:late-neg-projection late-neg-proj                          ~ ~
                     #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                     #:val-first-projection val-first-proj                        ~ ~
                     #:projection proj                                            ~ ~
                     #:stronger stronger                                          ~ ~
                     #:equivalent equivalent                                      ~ ~
                     #:list-contract? is-list-contract?])                         ~ ~
 -> flat-contract?
  name : any/c = 'anonymous-flat-contract ~ ~
  first-order : (-> any/c any/c) = (λ (x) #t) ~ ~
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~ ~
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~ ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  is-list-contract? : boolean? = #f ~ ~

These functions build simple higher-order contracts, chaperone
contracts, and flat contracts, respectively.  They all take the same set
of three optional arguments: a name, a first-order predicate, and a
blame-tracking projection. For make-flat-contract, see also
flat-contract-with-explanation.

The name argument is any value to be rendered using display to describe
the contract when a violation occurs.  The default name for simple
higher-order contracts is anonymous-contract, for chaperone contracts is
anonymous-chaperone-contract, and for flat contracts is
anonymous-flat-contract.

The first-order predicate first-order is used to determine which values
the contract applies to.  This test is used by
contract-first-order-passes?, and indirectly by or/c and first-or/c to
determine which higher-order contract to wrap a value with when there
are multiple higher-order contracts to choose from. The default value
accepts any value, but it must match the behavior of the projection
argument (see below for how). The predicate should be influenced by the
value of (contract-first-order-okay-to-give-up?) (see it’s documentation
for more explanation).

The late-neg-proj argument defines the behavior of applying  the
contract via a late neg projection. If it is supplied, this  argument
accepts a blame object that is missing one party (see also
blame-missing-party?).  Then it must return a function that accepts
both the value that is getting the contract and the name of the missing
blame  party, in that order. The result must either be the value
(perhaps suitably  wrapped with a chaperone or impersonator to enforce
the  contract), or signal a contract violation using raise-blame-error.
The default is #f.

The collapsible-late-neg-proj argument takes the place of the
late-neg-proj argument for contracts that support collapsing.  If it is
supplied, this argument accepts a blame object that is  missing one
party. It must return two values. The first value must be  a function
that accepts both the value that is getting the contract and  the name
of the missing blame party, in that order. The second value should  be a
collapsible representation of the contract.

The projection proj and val-first-proj are older mechanisms for
defining the behavior of applying the contract.  The proj argument is a
curried function of two arguments: the first application accepts a blame
object, and the second accepts a value to protect with the contract.
The projection must either produce the value, suitably wrapped to
enforce any higher-order aspects of the contract, or signal a contract
violation using raise-blame-error.  The default projection produces an
error when the first-order test fails, and produces the value unchanged
otherwise. The val-first-proj is like late-neg-proj, except with an
extra layer of currying.

At least one of the late-neg-proj, proj,  val-first-proj, or first-order
must be non-#f.

The projection arguments (late-neg-proj, proj, and  val-first-proj) must
be in sync with the first-order argument.  In particular, if the
first-order argument returns #f for some value,  then the projections
must raise a blame error for that value and if the  first-order argument
returns #t for some value, then the projection must  not signal any
blame for this value, unless there are higher-order interactions  later.
In other words, for flat contracts, the first-order and  projection
arguments must check the same predicate. For convenience, the  the
default projection uses the first-order argument, signalling an error
when it returns #f and never signalling one otherwise.

Projections for chaperone contracts must produce a value that passes
chaperone-of? when compared with the original, uncontracted value.
Projections for flat contracts must fail precisely when first-order
does, and must produce the input value unchanged otherwise.  Applying a
flat contract may result in either an application of the predicate, or
the projection, or both; therefore, the two must be consistent.  The
existence of a separate projection only serves to provide more specific
error messages.  Most flat contracts do not need to supply an explicit
projection.

The stronger argument is used to implement contract-stronger?. The first
argument is always the contract itself and the second argument is
whatever was passed as the second argument to contract-stronger?. If no
stronger argument is supplied, then a default that compares its
arguments with equal? is used for flat contracts and chaperone
contracts. For impersonator contracts constructed with make-contract
that do not supply the stronger argument, contract-stronger? returns #f.

Similarly, the equivalent argument is used to implement
contract-equivalent?. If it isn’t supplied or #false is supplied, then
equal? is used for chaperone and flat contracts, and (λ (x y) #f) is
used otherwise.

The is-list-contract? argument is used by the list-contract? predicate
to determine if this is a contract that accepts only list? values.

Examples:

  > (define int/c
      (make-flat-contract #:name 'int/c #:first-order integer?)) ~ ~
  > (contract int/c 1 'positive 'negative)
  1
  > (contract int/c "not one" 'positive 'negative)
  eval:4:0: broke its own contract
    promised: int/c ~ ~
    produced: "not one" ~ ~
    in: int/c ~ ~
    contract from: positive ~ ~
    blaming: positive ~ ~
     (assuming the contract is correct)
  > (int/c 1)
  #t
  > (int/c "not one")
  #f
  > (define int->int/c
      (make-contract
       #:name 'int->int/c ~ ~
       #:first-order ~ ~
       (λ (x) (and (procedure? x) (procedure-arity-includes? x 1)))
       #:projection ~ ~
       (λ (b)
         (let ([domain ((contract-projection int/c) (blame-swap b))]
               [range ((contract-projection int/c) b)])
           (λ (f)
             (if (and (procedure? f) (procedure-arity-includes? f 1))
               (λ (x) (range (f (domain x))))
               (raise-blame-error
                b f
                '(expected "a function of one argument" given: "~e") ~ ~
                f)))))))
  > (contract int->int/c "not fun" 'positive 'negative)
  eval:8:0: broke its own contract;
   promised a function of one argument
    produced: "not fun" ~ ~
    in: int->int/c ~ ~
    contract from: positive ~ ~
    blaming: positive ~ ~
     (assuming the contract is correct)
  > (define halve
      (contract int->int/c (λ (x) (/ x 2)) 'positive 'negative))
  > (halve 2)
  1
  > (halve 1/2)
  halve: contract violation
    expected: int/c ~ ~
    given: 1/2 ~ ~
    in: int->int/c ~ ~
    contract from: positive ~ ~
    blaming: negative ~ ~
     (assuming the contract is correct)
  > (halve 1)
  halve: broke its own contract
    promised: int/c ~ ~
    produced: 1/2 ~ ~
    in: int->int/c ~ ~
    contract from: positive ~ ~
    blaming: positive ~ ~
     (assuming the contract is correct)

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
argument. Changed in version 6.90.0.30: Added the #:equivalent argument.
Changed in version 7.1.0.10: Added the #:collapsible-late-neg-projection
argument.

                                        *build-compound-type-name*
(build-compound-type-name c/s ...) -> any ~
  c/s : any/c ~ ~

Produces an S-expression to be used as a name for a contract. The
arguments should be either contracts or symbols. It wraps parentheses
around its arguments and extracts the names from any contracts it is
supplied with.

                                        *coerce-contract*
(coerce-contract id v) -> contract? ~
  id : symbol? ~ ~
  v : any/c ~ ~

Converts a regular Racket value into an instance of a contract struct,
converting it according to the description of contracts.

If v is not one of the coercible values, coerce-contract signals an
error, using the first argument in the error message.

                                        *coerce-contracts*
(coerce-contracts id vs) -> (listof contract?) ~
  id : symbol? ~ ~
  vs : (listof any/c) ~ ~

Coerces all of the arguments in vs into contracts (via
coerce-contract/f) and signals an error if any of them are not
contracts.  The error messages assume that the function named by id got
vs as its entire argument list.

                                        *coerce-chaperone-contract*
(coerce-chaperone-contract id v) -> chaperone-contract? ~
  id : symbol? ~ ~
  v : any/c ~ ~

Like coerce-contract, but requires the result to be a chaperone
contract, not an arbitrary contract.

                                        *coerce-chaperone-contracts*
(coerce-chaperone-contracts id vs) ~
 -> (listof chaperone-contract?)
  id : symbol? ~ ~
  vs : (listof any/c) ~ ~

Like coerce-contracts, but requires the results to be chaperone
contracts, not arbitrary contracts.

                                        *coerce-flat-contract*
(coerce-flat-contract id v) -> flat-contract? ~
  id : symbol? ~ ~
  v : any/c ~ ~

Like coerce-contract, but requires the result to be a flat contract, not
an arbitrary contract.

                                        *coerce-flat-contracts*
(coerce-flat-contracts id v) -> (listof flat-contract?) ~
  id : symbol? ~ ~
  v : (listof any/c) ~ ~

Like coerce-contracts, but requires the results to be flat contracts,
not arbitrary contracts.

                                        *coerce-contract/f*
(coerce-contract/f v) -> (or/c contract? #f) ~
  v : any/c ~ ~

Like coerce-contract, but returns #f if the value cannot be coerced to a
contract.

                                        *get/build-val-first-projection*
(get/build-val-first-projection c) ~
 -> (-> blame? (-> any/c (-> any/c any/c)))
  c : contract? ~ ~

Returns the val-first projection for c.

See make-contract for more details.

Added in version 6.1.1.5 of package base.

                                        *get/build-late-neg-projection*
(get/build-late-neg-projection c) ~
 -> (-> blame? (-> any/c any/c any/c))
  c : contract? ~ ~

Returns the late-neg projection for c.

If c does not have a late-neg contract, then this function uses the
original projection for it and logs a warning to the 'racket/contract
logger.

See make-contract for more details.

Added in version 6.2.900.11 of package base.

                                        *skip-projection-wrapper?*
(skip-projection-wrapper?) -> boolean? ~
(skip-projection-wrapper? wrap?) -> void?
  wrap? : boolean? ~ ~
 = #f

The functions make-chaperone-contract and
build-chaperone-contract-property wrap their arguments to ensure that
the result of the projections are chaperones of the input. This layer of
wrapping can, in some cases, introduce unwanted overhead into contract
checking. If this parameter’s value is #t during the dynamic extent of
the call to either of those functions, the wrapping (and thus the
checks) are skipped.

                                        *with-contract-continuation-mark*
(with-contract-continuation-mark blame body ...) ~
(with-contract-continuation-mark blame+neg-party body ...)

Inserts a continuation mark that informs the contract profiler (see the
contract profiling documentation) that contract checking is happening.
For the costs from checking your new combinator to be included, you
should wrap any deferred, higher-order checks with this form.
First-order checks are recognized automatically and do not require this
form.

If your combinator’s projections operate on complete blame objects
(i.e., no missing blame parties), the blame object should be the first
argument to this form. Otherwise (e.g., in the case of late-neg
projections), a pair of the blame object and the missing party should be
used instead.

Added in version 6.4.0.4 of package base.

                                        *contract-pos/neg-doubling*
(contract-pos/neg-doubling e1 e2) ~

Some contract combinators need to build projections for subcontracts
with both regular and blame-swaped versions of the blame that they are
given in order to check both access and mutations (e.g., vector/c and
vectorof). In the case that such combinators are nested deeply inside
each other, there is a potential for an exponential explosion of nested
projections being built.

To avoid that explosion, wrap each of the calls to the blame-accepting
portion of the combinator in contract-pos/neg-doubling. It returns three
values. The first is a boolean, indicating how to interpret the other
two results. If the boolean is #t, then the other two results are the
values of e1 and e2 and we are not too deep in the nesting. If the
boolean is #f, then we have passed a threshold and it is not safe to
evaluate e1 and e2 yet, as we are in danger of running into the
exponential slowdown. In that case, the last two results are thunks
that, when invoked, compute the values of e1 and e2.

As an example, vectorof uses contract-pos/neg-doubling wrapping its two
calls to the blame-accepting part of the projection for its subcontract.
When it receives a #f as that first boolean, it does not invoke the
thunks right away, but waits until the interposition procedure that it
attaches to the chaperoned vector is called. Then it invokes them (and
caches the result). This delays the construction of the projections
until they are actually needed, avoiding the exponential blowup.

Added in version 6.90.0.27 of package base.

7.1. Blame Objects

This section describes blame objects and operations on them.

                                        *blame?*
(blame? v) -> boolean? ~
  v : any/c ~ ~

This predicate recognizes blame objects.

                                        *raise-blame-error*
(raise-blame-error b                                  ~
                   #:missing-party missing-party      ~ ~
                   v                                 
                   fmt                               
                   v-fmt ...)                    -> none/c
  b : blame? ~ ~
  missing-party : #f ~ ~
  v : any/c ~ ~
  fmt : (or/c string? ~ ~
              (listof (or/c string?
                            'given 'given: ~ ~
                            'expected 'expected:))) ~ ~
  v-fmt : any/c ~ ~

Signals a contract violation.  The first argument, b, records the
current blame information, including positive and negative parties, the
name of the contract, the name of the value, and the source location of
the contract application. The #:missing-party argument supplies one of
the blame parties. It should be non-#f when the b object was created
without supplying a negative party. See blame-add-missing-party and the
description of the late-neg-proj argument of make-contract.

The second positional argument, v, is the value that failed to satisfy
the contract.

The remaining arguments are a format string, fmt, and its arguments,
v-fmt ..., specifying an error message specific to the precise
violation.

If fmt is a list, then the elements are concatenated together (with
spaces added, unless there are already spaces at the ends of the
strings), after first replacing symbols with either their string
counterparts, or replacing 'given with "produced" and 'expected with
"promised", depending on whether or not the b argument has been swapped
or not (see blame-swap).

If fmt contains the symbols 'given: or 'expected:, they are replaced
like 'given and 'expected are, but the replacements are prefixed with
the string "\n  " to conform to the error message guidelines in
[missing].

                                        *blame-add-context*
(blame-add-context  blame                      ~
                    context                   
                   [#:important important      ~ ~
                    #:swap? swap?])       -> blame? ~ ~
  blame : blame? ~ ~
  context : (or/c string? #f) ~ ~
  important : (or/c string? #f) = #f ~ ~
  swap? : boolean? = #f ~ ~

Adds some context information to blame error messages   that explicates
which portion of the contract failed   (and that gets rendered by
raise-blame-error).

The context argument describes one layer of the   portion of the
contract, typically of the form "the 1st argument of"   (in the case of
a function contract)   or "a conjunct of" (in the case of an and/c
contract).

For example, consider this contract violation:

  > (define/contract f
      (list/c (-> integer? integer?))
      (list (λ (x) x)))
  > ((car f) #f)
  f: contract violation
    expected: integer? ~ ~
    given: #f ~ ~
    in: the 1st argument of ~ ~
        the 1st element of
        (list/c (-> integer? integer?))
    contract from: (definition f) ~ ~
    blaming: top-level ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~

It shows that the portion of the contract being violated is the first
occurrence of integer?, because the -> and the list/c combinators each
internally called blame-add-context to add the two lines following “in”
in the error message.

The important argument is used to build the beginning part of the
contract violation. The last important argument that gets added to a
blame object is used. The class/c contract adds an important argument,
as does the -> contract (when -> knows the name of the function getting
the contract).

The swap? argument has the effect of calling blame-swap while adding the
layer of context, but without creating an extra blame object.

Passing #f as the context string argument is no longer relevant. For
backwards compatibility, blame-add-context returns b when context is #f.

Changed in version 6.90.0.29 of package base: The context argument being
#f is no longer relevant.

                                        *blame-context*
(blame-context blame) -> (listof string?) ~
  blame : blame? ~ ~

Returns the context information that would be supplied in an error
message, if blame is passed to raise-blame-error.

                                        *blame-positive*
(blame-positive b) -> any/c ~
  b : blame? ~ ~
(blame-negative b) -> any/c
  b : blame? ~ ~

These functions produce printable descriptions of the current positive
and negative parties of a blame object.

                                        *blame-contract*
(blame-contract b) -> any/c ~
  b : blame? ~ ~

This function produces a description of the contract associated with a
blame object (the result of contract-name).

                                        *blame-value*
(blame-value b) -> any/c ~
  b : blame? ~ ~

This function produces the name of the value to which the contract was
applied, or #f if no name was provided.

                                        *blame-source*
(blame-source b) -> srcloc? ~
  b : blame? ~ ~

This function produces the source location associated with a contract.
If no source location was provided, all fields of the structure will
contain #f.

                                        *blame-swap*
(blame-swap b) -> blame? ~
  b : blame? ~ ~

This function swaps the positive and negative parties of a blame object.
(See also blame-add-context.)

                                        *blame-original?*
(blame-original? b) -> boolean? ~
  b : blame? ~ ~
(blame-swapped? b) -> boolean?
  b : blame? ~ ~

These functions report whether the current blame of a given blame object
is the same as in the original contract invocation (possibly of a
compound contract containing the current one), or swapped, respectively.
Each is the negation of the other; both are provided for convenience and
clarity.

                                        *blame-replace-negative*
(blame-replace-negative b neg) -> blame? ~
  b : blame? ~ ~
  neg : any/c ~ ~

Produces a blame? object just like b except            that it uses neg
instead of the negative            position b has.

                                        *blame-update*
(blame-update b pos neg) -> blame? ~
  b : blame? ~ ~
  pos : any/c ~ ~
  neg : any/c ~ ~

Produces a blame? object just like b except            that it adds pos
and neg to the positive            and negative parties of b
respectively.

                                        *blame-missing-party?*
(blame-missing-party? b) -> boolean? ~
  b : blame? ~ ~

Returns #t when b does not have both parties.

                                        *blame-add-missing-party*
(blame-add-missing-party b missing-party) ~
 -> (and/c blame? (not/c blame-missing-party?))
  b : (and/c blame? blame-missing-party?) ~ ~
  missing-party : any/c ~ ~

Produces a new blame object like b, except that the missing party is
replaced with missing-party.

                                        *struct*
(struct exn:fail:contract:blame exn:fail:contract (object) ~ ~ ~
    #:extra-constructor-name make-exn:fail:contract:blame) ~ ~
  object : blame? ~ ~

This exception is raised to signal a contract error. The object field
contains a blame object associated with a contract violation.

                                        *current-blame-format*
(current-blame-format) -> (-> blame? any/c string? string?) ~
(current-blame-format proc) -> void?
  proc : (-> blame? any/c string? string?) ~ ~

A parameter that is used when constructing a contract violation error.
Its value is procedure that accepts three arguments:

* the blame object for the violation,

* the value that the contract applies to, and

* a message indicating the kind of violation.

The procedure then returns a string that is put into the contract error
message. Note that the value is often already included in the message
that indicates the violation.

Examples:

  > (define (show-blame-error blame value message)
      (string-append
       "Contract Violation!\n"
       (format "Guilty Party: ~a\n" (blame-positive blame)) ~ ~
       (format "Innocent Party: ~a\n" (blame-negative blame)) ~ ~
       (format "Contracted Value Name: ~a\n" (blame-value blame)) ~ ~
       (format "Contract Location: ~s\n" (blame-source blame)) ~ ~
       (format "Contract Name: ~a\n" (blame-contract blame)) ~ ~
       (format "Offending Value: ~s\n" value) ~ ~
       (format "Offense: ~a\n" message))) ~ ~
  > (current-blame-format show-blame-error)
  > (define/contract (f x)
      (-> integer? integer?)
      (/ x 2))
  > (f 2)
  1
  > (f 1)
  Contract Violation!
  Guilty Party: (function f)
  Innocent Party: top-level
  Contracted Value Name: f
  Contract Location: #(struct:srcloc eval 4 0 4 1)
  Contract Name: (-> integer? integer?)
  Offending Value: 1/2
  Offense: promised: integer?
    produced: 1/2 ~ ~

  > (f 1/2)
  Contract Violation!
  Guilty Party: top-level
  Innocent Party: (function f)
  Contracted Value Name: f
  Contract Location: #(struct:srcloc eval 4 0 4 1)
  Contract Name: (-> integer? integer?)
  Offending Value: 1/2
  Offense: expected: integer?
    given: 1/2 ~ ~


7.2. Contracts as structs

The property prop:contract allows arbitrary structures to act as
contracts.  The property prop:chaperone-contract allows arbitrary
structures to act as chaperone contracts; prop:chaperone-contract
inherits prop:contract, so chaperone contract structures may also act as
general contracts.  The property prop:flat-contract allows arbitrary
structures to act as flat contracts; prop:flat-contract inherits both
prop:chaperone-contract and prop:procedure, so flat contract structures
may also act as chaperone contracts, as general contracts, and as
predicate procedures.

prop:contract : struct-type-property? ~ ~
prop:chaperone-contract : struct-type-property? ~ ~
prop:flat-contract : struct-type-property? ~ ~

These properties declare structures to be contracts or flat contracts,
respectively.  The value for prop:contract must be a contract property
constructed by build-contract-property; likewise, the value for
prop:chaperone-contract must be a chaperone contract property
constructed by build-chaperone-contract-property and the value for
prop:flat-contract must be a flat contract property constructed by
build-flat-contract-property.

prop:contracted : struct-type-property? ~ ~
impersonator-prop:contracted : impersonator-property? ~ ~

These properties attach a contract value to the protected structure,
chaperone, or impersonator value.  The function has-contract? returns #t
for values that have one of these properties, and value-contract
extracts the value from the property (which is expected to be the
contract on the value).

prop:blame : struct-type-property? ~ ~
impersonator-prop:blame : impersonator-property? ~ ~

These properties attach a blame information to the protected structure,
chaperone, or impersonator value.  The function has-blame? returns #t
for values that have one of these properties, and value-blame extracts
the value from the property.

The value is expected to be the blame record for the contract on the
value or a cons-pair of a blame record with a missing party and the
missing party. The value-blame function reassembles the arguments of the
pair into a complete blame record using blame-add-missing-party. If the
value has one of the properties, but the value is not a blame object or
a pair whose car position is a blame object, then has-blame? returns #f
but value-blame returns #f.

                                        *build-flat-contract-property*
(build-flat-contract-property                                                               ~
                              [#:name get-name                                              ~ ~
                               #:first-order get-first-order                                ~ ~
                               #:late-neg-projection late-neg-proj                          ~ ~
                               #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                               #:val-first-projection val-first-proj                        ~ ~
                               #:projection get-projection                                  ~ ~
                               #:stronger stronger                                          ~ ~
                               #:equivalent equivalent                                      ~ ~
                               #:generate generate                                          ~ ~
                               #:list-contract? is-list-contract?])                         ~ ~
 -> flat-contract-property?
  get-name : (-> contract? any/c) ~ ~
           = (λ (c) 'anonymous-flat-contract)
  get-first-order : (-> contract? (-> any/c boolean?)) ~ ~
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c)))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~ ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~ ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  generate : (->i ([c contract?]) ~ ~
                  [generator
                   (c)
                   (-> (and/c positive? real?)
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~ ~
(build-chaperone-contract-property                                                              
                                   [#:name get-name                                              ~ ~
                                    #:first-order get-first-order                                ~ ~
                                    #:late-neg-projection late-neg-proj                          ~ ~
                                    #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                                    #:val-first-projection val-first-proj                        ~ ~
                                    #:projection get-projection                                  ~ ~
                                    #:stronger stronger                                          ~ ~
                                    #:equivalent equivalent                                      ~ ~
                                    #:generate generate                                          ~ ~
                                    #:exercise exercise                                          ~ ~
                                    #:list-contract? is-list-contract?])                         ~ ~
 -> chaperone-contract-property?
  get-name : (-> contract? any/c) ~ ~
           = (λ (c) 'anonymous-chaperone-contract)
  get-first-order : (-> contract? (-> any/c boolean?)) ~ ~
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c)))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~ ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~ ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  generate : (->i ([c contract?]) ~ ~
                  [generator
                   (c)
                   (-> (and/c positive? real?)
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?]) ~ ~
                  [result
                   (c)
                   (-> (and/c positive? real?)
                       (values
                        (-> c void?)
                        (listof contract?)))])
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~ ~
(build-contract-property                                                              
                         [#:name get-name                                              ~ ~
                          #:first-order get-first-order                                ~ ~
                          #:late-neg-projection late-neg-proj                          ~ ~
                          #:collapsible-late-neg-projection collapsible-late-neg-proj  ~ ~
                          #:val-first-projection val-first-proj                        ~ ~
                          #:projection get-projection                                  ~ ~
                          #:stronger stronger                                          ~ ~
                          #:equivalent equivalent                                      ~ ~
                          #:generate generate                                          ~ ~
                          #:exercise exercise                                          ~ ~
                          #:list-contract? is-list-contract?])                         ~ ~
 -> contract-property?
  get-name : (-> contract? any/c) = (λ (c) 'anonymous-contract) ~ ~
  get-first-order : (-> contract? (-> any/c boolean?)) ~ ~
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c)))) ~ ~
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))) ~ ~
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~ ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~ ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~ ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~ ~
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f ~ ~
  generate : (->i ([c contract?]) ~ ~
                  [generator
                   (c)
                   (-> (and/c positive? real?)
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?]) ~ ~
                  [result
                   (c)
                   (-> (and/c positive? real?)
                       (values
                        (-> c void?)
                        (listof contract?)))])
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~ ~

These functions build the arguments for prop:contract,
prop:chaperone-contract, and prop:flat-contract, respectively.

A contract property specifies the behavior of a structure when used as a
contract.  It is specified in terms of seven properties:

* get-name which produces a description to write as part of a contract
  violation;

* get-first-order, which produces a first-order predicate to be used by
  contract-first-order-passes?;

* late-neg-proj, which produces a blame-tracking projection defining the
  behavior of the contract (The get-projection and val-first-proj
  arguments also specify the projection, but using a different
  signature. They are here for backwards compatibility.);

* collapsible-late-neg-proj, similar to late-neg-proj which produces a
  blame-tracking projection defining the behavior of the contract, this
  function additionally specifies the collapsible behavior of the
  contract;

* stronger, a predicate that determines whether this contract (passed in
  the first argument) is stronger than some other contract (passed in
  the second argument) and whose default always returns #f;

* equivalent, a predicate that determines whether this contract (passed
  in the first argument) is equivalent to some other contract (passed in
  the second argument); the default for flat and chaperone contracts is
  equal? and for impersonator contracts returns #f;

* generate, which returns a thunk that generates random values matching
  the contract (using contract-random-generate-fail) to indicate
  failure) or #f to indicate that random generation for this contract
  isn’t supported;

* exercise, which returns a function that exercises values matching the
  contract (e.g., if it is a function contract, it may call the
  function) and a list of contracts whose values will be generated by
  this process;

* and is-list-contract?, which is used by flat-contract? to determine if
  this contract accepts only list?s.

At least one of the late-neg-proj, collapsible-late-neg-proj,
get-projection, val-first-proj, or get-first-order must be non-#f.

These accessors are passed as (optional) keyword arguments to
build-contract-property, and are applied to instances of the appropriate
structure type by the contract system.  Their results are used
analogously to the arguments of make-contract.

A chaperone contract property specifies the behavior of a structure when
used as a chaperone contract.  It is specified using
build-chaperone-contract-property, and accepts exactly the same set of
arguments as build-contract-property.  The only difference is that the
projection accessor must return a value that passes chaperone-of? when
compared with the original, uncontracted value.

A flat contract property specifies the behavior of a structure when used
as a flat contract.  It is specified using build-flat-contract-property,
and accepts similar arguments as build-contract-property.  The
differences are:

* the projection accessor is expected not to wrap its argument in a
  higher-order fashion, analogous to the constraint on projections in
  make-flat-contract;

* the #:exercise keyword argument is omitted because it is not relevant
  for flat contracts.

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
argument. Changed in version 6.1.1.4: Allow generate to return
contract-random-generate-fail. Changed in version 6.90.0.30: Added the
#:equivalent argument. Changed in version 7.1.0.10: Added the
#:collapsible-late-neg-projection argument.

                                        *contract-property?*
(contract-property? v) -> boolean? ~
  v : any/c ~ ~
(chaperone-contract-property? v) -> boolean?
  v : any/c ~ ~
(flat-contract-property? v) -> boolean?
  v : any/c ~ ~

These predicates detect whether a value is a contract property,
chaperone contract property, or a flat contract property, respectively.

7.3. Obligation Information in Check Syntax

Check Syntax in DrRacket shows obligation information for contracts
according to syntax-propertys that the contract combinators leave in the
expanded form of the program. These properties indicate where contracts
appear in the source and where the positive and negative positions of
the contracts appear.

To make Check Syntax show obligation information for your new contract
combinators, use the following properties (some helper macros and
functions are below):

*

  'racket/contract:contract : (vector/c symbol? (listof syntax?) (listof syntax?)) ~ ~

  This property should be attached to the result of a transformer
  that implements a contract combinator. It signals to Check Syntax
  that this is where a contract begins.

  The first element in the                vector should be a unique (in
  the sense of eq?) value                that Check Syntax can use a tag
  to match up this contract with                its subpieces (specified
  by the two following syntax properties).

  The second and third elements of the vector are syntax objects
  from pieces of the contract, and Check Syntax will color them.
  The first list should contain subparts that are the responsibility
  of parties (typically modules) that provide implementations of the
  contract.                The second list should contain subparts that
  are the                responsibility of clients.

  For example, in (->* () #:pre #t any/c #:post #t),                the
  ->* and the #:post should be in the first                list and
  #:pre in the second list.

*

  'racket/contract:negative-position : symbol? ~ ~

  This property should be attached to sub-expressions of  a contract
  combinator that are expected to be other contracts.  The value of the
  property should be the key (the first element from  the vector for the
  'racket/contract:contract property)  indicating which contract this
  is.

  This property should be used when the expression’s value is a contract
  that clients are responsible for.

*

  'racket/contract:positive-position : symbol? ~ ~

  This form is just like 'racket/contract:negative-position,  except
  that it should be used when the expression’s value is  a contract that
  the original party should be responsible for.

*

  'racket/contract:contract-on-boundary : symbol? ~ ~

  The presence of this property tells Check Syntax that it  should start
  coloring from this point. It expects the expression  to be a contract
  (and, thus, to have the 'racket/contract:contract property);  this
  property indicates that this contract is on a (module) boundary.

  (The value of the property is not used.)

*

  'racket/contract:internal-contract : symbol? ~ ~

  Like 'racket/contract:contract-on-boundary, the presence  of this
  property triggers coloring, but this is meant for use  when the party
  (module) containing the contract (regardless of whether  or not this
  module exports anything matching the contract)  can be blamed for
  violating the contract. This comes into play  for ->i contracts, since
  the contract itself has  access to values under contract via the
  dependency.

                                        *define/final-prop*
(define/final-prop header body ...) ~
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)

The same as (define header body ...), except that uses of
main-id in the header are annotated             with the
'racket/contract:contract property             (as above).

                                        *define/subexpression-pos-prop*
(define/subexpression-pos-prop header body ...) ~
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)

The same as (define header body ...), except that uses of
main-id in the header are annotated             with the
'racket/contract:contract property             (as above) and arguments
are annotated with the             'racket/contract:positive-position
property.

7.4. Utilities for Building New Combinators

                                        *contract-stronger?*
(contract-stronger? c1 c2) -> boolean? ~
  c1 : contract? ~ ~
  c2 : contract? ~ ~

Returns #t if the contract c1 accepts either fewer   or the same set of
values that c2 does.

Chaperone contracts and flat contracts that are the same   (i.e., where
c1 is equal? to c2) are   considered to always be stronger than each
other.

This function is conservative, so it may return #f when   c1 does, in
fact, accept fewer values.

Examples:

  > (contract-stronger? integer? integer?)
  #t
  > (contract-stronger? (between/c 25 75) (between/c 0 100))
  #t
  > (contract-stronger? (between/c 0 100) (between/c 25 75))
  #f
  > (contract-stronger? (between/c -10 0) (between/c 0 10))
  #f
  > (contract-stronger? (λ (x) (and (real? x) (<= x 0)))
                        (λ (x) (and (real? x) (<= x 100))))
  #f

                                        *contract-equivalent?*
(contract-equivalent? c1 c2) -> boolean? ~
  c1 : contract? ~ ~
  c2 : contract? ~ ~

Returns #t if the contract c1 accepts the same   set of values that c2
does.

Chaperone contracts and flat contracts that are the same   (i.e., where
c1 is equal? to c2) are   considered to always be equivalent to each
other.

This function is conservative, so it may return #f when   c1 does, in
fact, accept the same set of values that c2 does.

Examples:

  > (contract-equivalent? integer? integer?)
  #t
  > (contract-equivalent? (non-empty-listof integer?)
                          (cons/c integer? (listof integer?)))
  #t
  >
  (contract-equivalent? (λ (x) (and (real? x) (and (number? x) (>= (sqr x) 0))))
                          (λ (x) (and (real? x) (real? x))))
  #f

Added in version 6.90.0.30 of package base.

                                        *contract-first-order-passes?*
(contract-first-order-passes? contract v) -> boolean? ~
  contract : contract? ~ ~
  v : any/c ~ ~

Returns a boolean indicating whether the first-order tests of contract
pass for v.

If it returns #f, the contract is guaranteed not to hold for that value;
if it returns #t, the contract may or may not hold. If the contract is a
first-order contract, a result of #t guarantees that the contract holds.

See also contract-first-order-okay-to-give-up? and
contract-first-order-try-less-hard.

                                        *contract-first-order*
(contract-first-order c) -> (-> any/c boolean?) ~
  c : contract? ~ ~

Produces the first-order test used by or/c to match values to
higher-order contracts.

8. Contract Utilities

                                        *contract?*
(contract? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if its argument is a contract (i.e., constructed with one of
the combinators described in this section or a value that can be used as
a contract) and #f otherwise.

                                        *chaperone-contract?*
(chaperone-contract? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if its argument is a chaperone contract, i.e., one that
guarantees that it returns a value which passes chaperone-of? when
compared to the original, uncontracted value.

                                        *impersonator-contract?*
(impersonator-contract? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if its argument is an impersonator contract, i.e., a contract
that is neither a chaperone contract nor a flat contract.

                                        *flat-contract?*
(flat-contract? v) -> boolean? ~
  v : any/c ~ ~

Returns #t when its argument is a contract that can be checked
immediately (unlike, say, a function contract).

For example, flat-contract constructs flat contracts from predicates,
and symbols, booleans, numbers, and other ordinary Racket values (that
are defined as contracts) are also flat contracts.

                                        *list-contract?*
(list-contract? v) -> boolean? ~
  v : any/c ~ ~

Recognizes certain contract? values that accept list?s.

A list contract is one that insists that its argument is a list?,
meaning that the value cannot be cyclic and must either be the empty
list or a pair constructed with cons and another list.

Added in version 6.0.1.13 of package base.

                                        *contract-name*
(contract-name c) -> any/c ~
  c : contract? ~ ~

Produces the name used to describe the contract in error messages.

                                        *value-contract*
(value-contract v) -> (or/c contract? #f) ~
  v : has-contract? ~ ~

Returns the contract attached to v, if recorded. Otherwise it returns
#f.

To support value-contract and value-contract in your own contract
combinators, use prop:contracted or impersonator-prop:contracted.

                                        *has-contract?*
(has-contract? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a value that has a recorded contract attached to it.

                                        *value-blame*
(value-blame v) -> (or/c blame? #f) ~
  v : has-blame? ~ ~

Returns the blame object for the contract attached to v, if recorded.
Otherwise it returns #f.

To support value-contract and value-blame in your own contract
combinators, use prop:blame or impersonator-prop:blame.

Added in version 6.0.1.12 of package base.

                                        *has-blame?*
(has-blame? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a value that has a contract with blame information
attached to it.

Added in version 6.0.1.12 of package base.

                                        *contract-late-neg-projection*
(contract-late-neg-projection c) ~
 -> (-> blame? (-> any/c (or/c #f any/c) any/c))
  c : contract? ~ ~

Produces the projection defining a contract’s behavior.

The first argument, blame? object encapsulates information about the
contract checking, mostly used to create a meaningful error message if a
contract violation is detected. The resulting function’s first argument
is the value that should have the contract and its second argument is a
missing party for the blame object, to be passed to
raise-contract-error.

If possible, use this function instead of contract-val-first-projection
or contract-projection.

                                        *contract-projection*
(contract-projection c) -> (-> blame? (-> any/c any/c)) ~
  c : contract? ~ ~

Produces a projection defining a contract’s behavior. This projection is
a curried function of two arguments: the first application accepts a
blame object, and the second accepts a value to protect with the
contract.

If possible, use contract-late-neg-projection instead.

                                        *contract-val-first-projection*
(contract-val-first-projection c) ~
 -> (-> blame? (-> any/c (-> any/c any/c)))
  c : contract? ~ ~

Produces a projection defining a contract’s behavior. This projection is
similar to the result of contract-late-neg-projection except with an
extra layer of currying.

If possible, use contract-late-neg-projection instead.

                                        *make-none/c*
(make-none/c sexp-name) -> contract? ~
  sexp-name : any/c ~ ~

Makes a contract that accepts no values, and reports the name sexp-name
when signaling a contract violation.

                                        *recursive-contract*
(recursive-contract contract-expr recursive-contract-option ...) ~
(recursive-contract contract-expr type recursive-contract-option ...)
 
recursive-contract-option = #:list-contract? ~ ~
                          | #:extra-delay ~ ~
                             
                     type = #:impersonator ~ ~
                          | #:chaperone ~ ~
                          | #:flat ~ ~

Delays the evaluation of its argument until the contract is checked,
making recursive contracts possible. If type is not given, an
impersonator contract is created.

If the recursive-contract-option #:list-contract? is given, then the
result is a list-contract? and the contract-expr must evaluate to a
list-contract?.

If the recursive-contract-option #:extra-delay is given, then the
contract-expr expression is evaluated only when the first value to be
checked against the contract is supplied to the contract. Without it,
the contract-expr is evaluated earlier. This option is supported only
when type is #:flat.

Examples:

  > (define even-length-list/c
      (or/c null?
            (cons/c any/c
                    (cons/c any/c
                            (recursive-contract even-length-list/c #:flat))))) ~ ~
  > (even-length-list/c '(A B))
  #t
  > (even-length-list/c '(1 2 3))
  #f

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
option. Changed in version 6.7.0.3: Added the #:extra-delay option.

                                        *opt/c*
(opt/c contract-expr maybe-name) ~
 
maybe-name = 
           | #:error-name id ~ ~

This optimizes its argument contract expression by traversing its syntax
and, for known contract combinators, fuses them into a single contract
combinator that avoids as much allocation overhead as possible. The
result is a contract that should behave identically to its argument,
except faster.

If the #:error-name argument is present, and contract-expr evaluates to
a non-contract expression, then opt/c raises an error using id as the
name of the primitive, instead of using the name opt/c.

Examples:

  > (define/contract (f x)
      (opt/c '(not-a-contract))
      x)
  opt/c: contract violation
    expected: contract? ~ ~
    given: '(not-a-contract) ~ ~
  > (define/contract (f x)
      (opt/c '(not-a-contract) #:error-name define/contract) ~ ~
      x)
  define/contract: contract violation
    expected: contract? ~ ~
    given: '(not-a-contract) ~ ~

                                        *define-opt/c*
(define-opt/c (id id ...) expr) ~

This defines a recursive contract and simultaneously optimizes it. As
long as the defined function terminates, define-opt/c behaves just as if
the -opt/c were not present, defining a function on contracts (except
that the body expression must return a contract). But, it also optimizes
that contract definition, avoiding extra allocation, much like opt/c
does.

For example,

  (define-contract-struct bt (val left right))
   
  (define-opt/c (bst-between/c lo hi)
    (or/c null?
          (bt/c [val (real-in lo hi)]
                [left (val) (bst-between/c lo val)]
                [right (val) (bst-between/c val hi)])))
   
  (define bst/c (bst-between/c -inf.0 +inf.0))

defines the bst/c contract that checks the binary search tree invariant.
Removing the -opt/c also makes a binary search tree contract, but one
that is (approximately) 20 times slower.

Note that in some cases, a call to a function defined by define-opt/c
may terminate, even if the corresponding define-based function would not
terminate. This is a shortcoming in define-opt/c that we hope to
understand and fix at some point, but have no concrete plans currently.

contract-continuation-mark-key : continuation-mark-key? ~ ~

Key used by continuation marks that are present during contract
checking. The value of these marks are the blame objects that correspond
to the contract currently being checked.

Added in version 6.4.0.4 of package base.

                                        *contract-custom-write-property-proc*
(contract-custom-write-property-proc c          ~
                                     p         
                                     mode) -> void?
  c : contract? ~ ~
  p : output-port? ~ ~
  mode : (or/c #f #t 0 1) ~ ~

Prints c to p using the contract’s name.

Added in version 6.1.1.5 of package base.

                                        *rename-contract*
(rename-contract contract name) -> contract? ~
  contract : contract? ~ ~
  name : any/c ~ ~

Produces a contract that acts like contract but with the name name.

The resulting contract is a flat contract if contract is a flat
contract.

Added in version 6.3 of package base.

                                        *contract-first-order-okay-to-give-up?*
(contract-first-order-okay-to-give-up?) ~

This form returns a boolean that controls the result of first-order
contact checks. More specifically, if it returns #t, then a first-order
check may return #t even when the entire first-order checks have not
happened. If it returns #f then the first order checks must continue
until a definitive answer is returned.

This will only return #t in the dynamic extent of or/c or first-or/c’s
checking to determine which branch to use.

Added in version 6.3.0.9 of package base.

                                        *contract-first-order-try-less-hard*
(contract-first-order-try-less-hard e) ~

Encourages first-order checks that happen in the dynamic-extent of e to
be more likely to give up. That is, makes it more likely that
contract-first-order-okay-to-give-up? might return #t.

If not in the dynamic-extent of or/c’s or first-or/c’s checking to
determine the branch, then this form has no effect.

Added in version 6.3.0.9 of package base.

                                        *if/c*
(if/c predicate then-contract else-contract) -> contract? ~
  predicate : (-> any/c any/c) ~ ~
  then-contract : contract? ~ ~
  else-contract : contract? ~ ~

Produces a contract that, when applied to a value, first tests the value
with predicate; if predicate returns true, the then-contract is applied;
otherwise, the else-contract is applied. The resulting contract is a
flat contract if both then-contract and else-contract are flat
contracts.

For example, the following contract enforces that if a value is a
procedure, it is a thunk; otherwise it can be any (non-procedure) value:

  (if/c procedure? (-> any) any/c)

Note that the following contract is not equivalent:

  (or/c (-> any) any/c) ; wrong!

The last contract is the same as any/c because or/c tries flat contracts
before higher-order contracts.

Added in version 6.3 of package base.

failure-result/c : contract? ~ ~

A contract that describes the failure result arguments of procedures
such as hash-ref.

Equivalent to (if/c procedure? (-> any) any/c).

Added in version 6.3 of package base.

9. racket/contract/base

 (require racket/contract/base) package: base ~ ~

The racket/contract/base module provides a subset of the exports of
racket/contract module. In particular, it contains everything in the

* Data-structure Contracts

* Function Contracts

* Attaching Contracts to Values and

* Contract Utilities sections.

Unfortunately, using racket/contract/base does not yield a significantly
smaller memory footprint than racket/contract, but it can still be
useful to add contracts to libraries that racket/contract uses to
implement some of the more sophisticated parts of the contract system.

10. Collapsible Contracts

 (require racket/contract/collapsible) package: base ~ ~

Added in version 7.1.0.10 of package base.

Collapsible contracts are an optimization in the contract system
designed to avoid a particular pathological build up of contract
wrappers on higher-order values. The vectorof, vector/c, and -> contract
combinators support collapsing for vector contracts and function
contracts for functions returning a single value.

Intuitively, a collapsible contract is a tree structure. The tree nodes
represent higher-order contracts  (e.g., ->) and the tree leaves
represent sequences of flat contracts. Two trees can collapse into one
tree via the merge procedure,  which removes unnecessary flat contracts
from the leaves.

For more information on the motivation and design of collapsible
contracts,  see [Feltey18]. For the theoretical foundations, see
[Greenberg15].

Warning: the features described in this section are experimental and may
not be sufficient to implement new collapsible contracts. Implementing
new collapsible contracts requires the use of unsafe chaperones and
impersonators which are only supported for vector and procedure values.
This documentation exists primarily to allow future maintenance of the
racket/contract/collapsible library. End Warning

                                        *get/build-collapsible-late-neg-projection*
(get/build-collapsible-late-neg-projection c) ~
 -> (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))
  c : contract? ~ ~

Returns the collapsible-late-neg projection for c.

If c does not have a collapsible-late-neg projection, then this function
uses the original projection for it and constructs a leaf as its
collapsible representation.

collapsible-contract-continuation-mark-key
 : continuation-mark-key? ~ ~

Key used by continuation marks that are present during collapsible
contract checking. The value of these marks are #t if the current
contract is collapsible.

                                        *with-collapsible-contract-continuation-mark*
(with-collapsible-contract-continuation-mark body ...) ~

Inserts a continuation mark that informs the contract profiler that the
current contract is collapsible.

prop:collapsible-contract : struct-type-property? ~ ~

Structures implementing this property are usable as collapsible
contracts. The value associated with this property should be constructed
by calling build-collapsible-contract-property.

                                        *collapsible-contract?*
(collapsible-contract? v) -> boolean? ~
  v : any/c ~ ~

A predicate recognizing structures with the prop:collapsible-contract
property.

                                        *merge*
(merge new-cc new-neg old-cc old-neg) -> collapsible-contract? ~
  new-cc : collapsible-contract? ~ ~
  new-neg : any/c ~ ~
  old-cc : collapsible-contract? ~ ~
  old-neg : any/c ~ ~

Combine two collapsible contracts into a single collapsible contract.
The new-neg and old-neg arguments are expected to be blame parties
similar to those passed to a late neg projection.

                                        *collapsible-guard*
(collapsible-guard cc val neg-party) -> any/c ~
  cc : collapsible-contract? ~ ~
  val : any/c ~ ~
  neg-party : any/c ~ ~

Similar to a late neg projection, this function guards the value val
with the collapsible contract cc.

                                        *collapsible-contract-property?*
(collapsible-contract-property? v) -> boolean? ~
  v : any/c ~ ~

This predicate indicates that a value can be used as the property for
prop:collapsible-contract.

                                        *build-collapsible-contract-property*
(build-collapsible-contract-property                                           ~
                                     [#:try-merge try-merge                    ~ ~
                                      #:collapsible-guard collapsible-guard])  ~ ~
 -> collapsible-contract-property?
  try-merge : (or/c #f                                    = #f ~ ~
                    (-> collapsible-contract?
                        any/c
                        collapsible-contract?
                        any/c
                        (or/c #f collapsible-contract?)))
  collapsible-guard : (-> collapsible-contract? any/c any/c any/c) ~ ~
                    = (λ (cc v neg)
                        (error
                         "internal error: contract does not support `collapsible-guard`" cc)) ~ ~

Constructs a collapsible contract property from a merging function and a
guard. The try-merge argument is similar to merge, but may return #f
instead of a collapsible contract and may be specialized to a particular
collapsible contract. The collapsible-guard argument should be
specialized to the particular collapsible contract being implemented.

                                        *struct*
(struct collapsible-ho/c (latest-blame missing-party latest-ctc)) ~
  latest-blame : blame? ~ ~
  missing-party : any/c ~ ~
  latest-ctc : contract? ~ ~

A common parent structure for collapsible contracts for higher-order
values. The latest-blame field holds the blame object for the most
recent contract attached. Similarly, the missing-party field holds the
latest missing party passed to the contract. The latest-contract field
stores the most recent contract attached to the value.

                                        *struct*
(struct collapsible-leaf/c (proj-list ~
                            contract-list
                            blame-list
                            missing-party-list))
  proj-list : (listof (-> any/c any/c any/c)) ~ ~
  contract-list : (listof contract?) ~ ~
  blame-list : (listof blame?) ~ ~
  missing-party-list : (listof any/c) ~ ~

A structure representing the leaf nodes of a collapsible contract. The
proj-list field holds a list of partially applied late neg projections.
The contract-list, blame-list, and missing-party-list fields hold a list
of contracts, blame objects, and blame missing parties respectively.

impersonator-prop:collapsible : impersonator-property? ~ ~
(has-impersonator-prop:collapsible? v) -> boolean?
  v : any/c ~ ~
(get-impersonator-prop:collapsible v) -> collapsible-property?
  v : any/c ~ ~

An impersonator property (and its accessors) that should be attached to
chaperoned or impersonated values that are guarded with a collapsible
contract.

                                        *struct*
(struct collapsible-property (c-c neg-party ref)) ~
  c-c : collapsible-contract? ~ ~
  neg-party : any/c ~ ~
  ref : (or/c #f impersonator?) ~ ~

The parent struct of properties that should be attached to chaperones or
impersonators of values protected with a collapsible contract. The c-c
field stores the collapsible contract that is or will in the future be
attached to the the value. The neg-party field stores the latest missing
blame party passed to the contract on the value. The ref field is
mutable and stores a reference to the chaperone or impersonator to which
this property is attached. This is necessary to determine whether an
unknown chaperone has been attached to a value after it has been
protected by a collapsible contract.

                                        *struct*
(struct collapsible-count-property collapsible-property (count ~
                                                         prev))
  count : natural-number/c ~ ~
  prev : (or/c collapsible-count-property? any/c) ~ ~

This property is associated with the impersonator-prop:collapsible
property before the value completely enters the collapsible mode. These
properties keep track of the number of contracts on a value in the count
field, and hold a reference to the previous count property in the prev
field or the original value without a contract. This allows the contract
system to traverse the chain of attached contracts and merge them into a
single collapsible contract to protect the original value.

                                        *struct*
(struct collapsible-wrapper-property collapsible-property ~
        (checking-wrapper)
  checking-wrapper : impersonator? ~ ~

This property is used when a value is guarded by a collapsible contract.
The checking-wrapper field holds a chaperone or impersonator that
dispatches to the collapsible contract stored in this property to
perform any necessary contract checks. When the value receives another
contract and merging happens, the checking wrapper will remain the same
even though the specific collapsible contract attached to the value may
change.

11. Legacy Contracts

                                        *make-proj-contract*
(make-proj-contract name proj first-order) -> contract? ~
  name : any/c ~ ~
  proj : (or/c (-> any/c ~ ~
                   any/c
                   (list/c any/c any/c)
                   contact?
                   (-> any/c any/c))
               (-> any/c
                   any/c
                   (list/c any/c any/c)
                   contact?
                   boolean?
                   (-> any/c any/c)))
  first-order : (-> any/c boolean?) ~ ~

Builds a contract using an old interface.

Modulo errors, it is equivalent to:

  (make-contract
   #:name name ~ ~
   #:first-order first-order ~ ~
   #:projection ~ ~
   (cond
     [(procedure-arity-includes? proj 5)
      (lambda (blame)
        (proj (blame-positive blame)
              (blame-negative blame)
              (list (blame-source blame) (blame-value blame))
              (blame-contract blame)
              (not (blame-swapped? blame))))]
     [(procedure-arity-includes? proj 4)
      (lambda (blame)
        (proj (blame-positive blame)
              (blame-negative blame)
              (list (blame-source blame) (blame-value blame))
              (blame-contract blame)))]))

                                        *raise-contract-error*
(raise-contract-error val           ~
                      src          
                      pos          
                      name         
                      fmt          
                      arg ...) -> any/c
  val : any/c ~ ~
  src : any/c ~ ~
  pos : any/c ~ ~
  name : any/c ~ ~
  fmt : string? ~ ~
  arg : any/c ~ ~

Calls raise-blame-error after building a blame struct from the val, src,
pos, and name arguments. The fmt string and following arguments are
passed to format and used as the string in the error message.

                                        *contract-proc*
(contract-proc c) ~
 -> (->* (symbol? symbol? (or/c syntax? (list/c any/c any/c)))
         (boolean?)
         (-> any/c any))
  c : contract? ~ ~

Constructs an old-style projection from a contract.

The resulting function accepts the information that is in a blame struct
and returns a projection function that checks the contract.

12. Random generation

                                        *contract-random-generate*
(contract-random-generate ctc [fuel fail]) -> any/c ~
  ctc : contract? ~ ~
  fuel : 5 = exact-nonnegative-integer? ~ ~
  fail : (or/c #f (-> any) (-> boolean? any)) = #f ~ ~

Attempts to randomly generate a value which will match the contract. The
fuel argument limits how hard the generator tries to generate a value
matching the contract and is a rough limit of the size of the resulting
value.

The generator may fail to generate a value, either because some
contracts do not have corresponding generators (for example, not all
predicates have generators) or because there is not enough fuel. In
either case, the function fail is invoked. If fail accepts an argument,
it is called with #t when there is no generator for ctc and called with
#f when there is a generator, but the generator ended up returning
contract-random-generate-fail.

Example:

  > (for/list ([i (in-range 10)])
      (contract-random-generate (or/c integer? #f)))
  '(#f #f #f -2147483647.0 #f #f #f #f -159 103)

Changed in version 6.1.1.5 of package base: Allow fail to accept a
boolean.

                                        *contract-exercise*
(contract-exercise [#:fuel fuel               ~ ~ ~
                    #:shuffle? shuffle?]      ~ ~
                    val ...+)            -> void?
  fuel : exact-nonnegative-integer? = 10 ~ ~
  shuffle? : any/c = #f ~ ~
  val : any/c ~ ~

Attempts to get the vals to break their contracts (if any).

Uses value-contract to determine if any of the vals have a  contract
and, for those that do, uses information about the contract’s shape  to
poke and prod at the value. For example, if the value is function, it
will  use the contract to tell it what arguments to supply to the value.

The argument fuel determines how hard contract-exercise  tries to break
the values. It controls both the number of exercise iterations  and the
size of the intermediate values generated during the exercises.

The argument shuffle? controls whether contract-exercise  randomizes the
exercise order or not. If shuffle? is not #f,  contract-exercise would
shuffle the order of the contracts in each  exercise iteration.

Examples:

  > (define/contract (returns-false x)
      (-> integer? integer?)
      ; does not obey its contract
      #f)
  > (contract-exercise returns-false)
  returns-false: broke its own contract
    promised: integer? ~ ~
    produced: #f ~ ~
    in: the range of ~ ~
        (-> integer? integer?)
    contract from: (function returns-false) ~ ~
    blaming: (function returns-false) ~ ~
     (assuming the contract is correct)
    at: eval:2.0 ~ ~
  > (define/contract (calls-its-argument-with-eleven f)
      (-> (-> integer? integer?) boolean?)
      ; f returns an integer, but
      ; we're supposed to return a boolean
      (f 11))
  > (contract-exercise calls-its-argument-with-eleven)
  calls-its-argument-with-eleven: broke its own contract
    promised: boolean? ~ ~
    produced: -1321552655.0 ~ ~
    in: the range of ~ ~
        (-> (-> integer? integer?) boolean?)
    contract from: ~ ~
        (function calls-its-argument-with-eleven)
    blaming: (function calls-its-argument-with-eleven) ~ ~
     (assuming the contract is correct)
    at: eval:4.0 ~ ~

Changed in version 7.0.0.18 of package base: Added the shuffle? optional
argument.

                                        *contract-random-generate/choose*
(contract-random-generate/choose c fuel) -> (or/c #f (-> c)) ~
  c : contract? ~ ~
  fuel : exact-nonnegative-integer? ~ ~

This function is like contract-random-generate, but it is intended to
be used with combinators that generate values based on sub-contracts
they have. It must be called when contract-random-generate   (and
contract-exercise) creates the generators.   To be more precise,
contract-random-generate/choose is available   only for the generate and
exercise arguments in   build-contract-property,
build-chaperone-contract-property   or build-flat-contract-property and
only during the dynamic   extent of the call to generate (and exercise).
That is, after it receives the c and fuel arguments   and before it
returns the thunk (or the exerciser).

contract-random-generate/choose will never fail,   but it might escape
back to an enclosing   call or to the original call to
contract-random-generate.

It chooses one of several possible generation strategies, and thus it
may not   actually use the generator associated with c, but might
instead   use a stashed value that matches c that it knows about via
contract-random-generate-stash.

Added in version 6.1.1.5 of package base.

contract-random-generate-fail : contract-random-generate-fail? ~ ~

An atomic value that is used to indicate that a generator   failed to
generate a value.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-fail?*
(contract-random-generate-fail? v) -> boolean? ~
  v : any/c ~ ~

A predicate to recognize contract-random-generate-fail.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-env?*
(contract-random-generate-env? v) -> boolean? ~
  v : any/c ~ ~

Recognizes contract generation environments.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-stash*
(contract-random-generate-stash env c v) -> void? ~
  env : contract-random-generate-env? ~ ~
  c : contract? ~ ~
  v : c ~ ~

This should be called with values that the program under   test supplies
during contract generation. For example, when   (-> (-> integer?
integer?) integer?) is generated,   it may call its argument function.
That argument function may   return an integer and, if so, that integer
should be saved by   calling contract-random-generate-stash, so it can
be used by other integer generators.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-get-current-environment*
(contract-random-generate-get-current-environment) ~
 -> contract-random-generate-env?

Returns the environment currently being for generation. This function
can be called only during the dynamic extent of contract generation.
It is intended to be grabbed during the construction of a contract
generator and then used with contract-random-generate-stash   while
generation is happening.

Added in version 6.1.1.5 of package base.
