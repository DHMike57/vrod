Contracts

+[missing] in [missing] introduces contracts.

The contract system guards one part of a program from another.
Programmers specify the behavior of a module’s exports via (provide
(contract-out ....)), and the contract system enforces those
constraints.

 (require racket/contract) package: base ~

The bindings documented in this section are provided by the
racket/contract and racket libraries, but not racket/base.

Contracts come in two forms: those constructed by the various operations
listed in this section of the manual, and various ordinary Racket values
that double as contracts, including

* symbols, booleans, characters, keywords, and null, which are treated
  as contracts that recognize themselves, using eq?,

* strings, byte strings, +nan.0, and        +nan.f, which are treated as
  contracts that recognize themselves using equal?,

* numbers (except +nan.0 and        +nan.f), which are treated as
  contracts that recognize themselves using =,

* regular expressions, which are treated as contracts  that recognize
  byte strings and strings that  match the regular expression, and

* predicates: any procedure of arity 1 is treated as a predicate. During
  contract checking, it is applied to the values that appear and should
  return #f to indicate that the contract failed, and anything else to
  indicate it passed.

Contract combinators are functions such as -> and listof that take
contracts and produce other contracts.

Contracts in Racket are subdivided into three different categories:

* Flat contracts can be fully checked immediately for  a given value.
  These kinds of contracts are essentially  predicate functions. Using
  flat-contract-predicate,  you can extract the predicate from an
  arbitrary flat contract; some  flat contracts can be applied like
  functions, in which case  they accept a single argument and return #t
  or  #f to indicate if the given value would be accepted  by the
  contract. All of the flat contracts returned by functions  in this
  library can be used directly as predicates, but ordinary  Racket
  values that double as flat contracts (e.g., numbers or symbols)
  cannot.

  The function flat-contract? recognizes a flat contract.

* Chaperone contracts are not always immediately  checkable, but are
  guaranteed to not change any properties  of any values that they
  check. That is, they may wrap  a value in such a way that it signals
  contract violations  later, as the value is used (e.g., a function
  contract  checks the inputs and outputs to the function only when  the
  function is called and returned), but any properties  that the value
  had before being wrapped by the contract  are preserved by the
  contract wrapper.

  All flat contracts are also chaperone contracts (but  not vice-versa).

* Impersonator contracts do not provide any  guarantees about values
  they check. Impersonator contracts  may hide properties of values, or
  even make them completely  opaque (e.g, new-∀/c).

  All contracts are impersonator contracts.

For more about this hierarchy, see chaperones and a research paper on
chaperones, impersonators, and how they can be used to implement
contracts [Strickland12].

Changed in version 6.1.1.8 of package base: Changed +nan.0 and +nan.f to
be equal?-based contracts.

    1 Data-structure Contracts

    2 Function Contracts

    3 Parametric Contracts

    4 Lazy Data-structure Contracts

    5 Structure Type Property Contracts

    6 Attaching Contracts to Values
      6.1 Nested Contract Boundaries
      6.2 Low-level Contract Boundaries

    7 Building New Contract Combinators
      7.1 Blame Objects
      7.2 Contracts as structs
      7.3 Obligation Information in Check Syntax
      7.4 Utilities for Building New Combinators

    8 Contract Utilities

    9 racket/contract/base

    10 Legacy Contracts

    11 Random generation

1. Data-structure Contracts

                                        *flat-named-contract*
(flat-named-contract  name               ~
                      flat-contract     
                     [generator])   -> flat-contract?
  name : any/c ~
  flat-contract : flat-contract? ~
  generator : (or/c #f (-> contract (-> int? any))) = #f ~

Produces a contract like flat-contract, but with the name name.

For example,

  (define/contract i
    (flat-named-contract
     'odd-integer
     (lambda (x) (and (integer? x) (odd? x))))
    2)

The generator argument adds a generator for the flat-named-contract. See
contract-generate for more information.

any/c : flat-contract? ~

A flat contract that accepts any value.

When using this contract as the result portion of a function contract,
consider using any instead; using any leads to better memory
performance, but it also allows multiple results.

none/c : flat-contract? ~

A flat contract that accepts no values.

                                        *or/c*
(or/c contract ...) -> contract? ~
  contract : contract? ~

Takes any number of contracts and returns a contract that accepts any
value that any one of the contracts accepts individually.

The or/c result tests any value by applying the contracts in order, from
left to right, with the exception that it always moves the non-flat
contracts (if any) to the end, checking them last. Thus, a contract such
as (or/c (not/c real?) positive?) is guaranteed to only invoke the
positive? predicate on real numbers.

If all of the arguments are procedures or flat contracts, the result is
a flat contract. If only one of the arguments is a higher-order
contract, the result is a contract that just checks the flat contracts
and, if they don’t pass, applies the higher-order contract.

If there are multiple higher-order contracts, or/c uses
contract-first-order-passes? to distinguish between them. More
precisely, when an or/c is checked, it first checks all of the flat
contracts. If none of them pass, it calls contract-first-order-passes?
with each of the higher-order contracts. If only one returns true, or/c
uses that contract. If none of them return true, it signals a contract
violation. If more than one returns true, it also signals a contract
violation. For example, this contract

  (or/c (-> number? number?)
        (-> string? string? string?))

does not accept a function like this one: (lambda args ...) since it
cannot tell which of the two arrow contracts should be used with the
function.

If all of its arguments are list-contract?s, then or/c returns a
list-contract?.

                                        *and/c*
(and/c contract ...) -> contract? ~
  contract : contract? ~

Takes any number of contracts and returns a contract that accepts any
value that satisfies all of the contracts simultaneously.

If all of the arguments are procedures or flat contracts, the result is
a flat contract.

The contract produced by and/c tests any value by applying the contracts
in order, from left to right.

                                        *not/c*
(not/c flat-contract) -> flat-contract? ~
  flat-contract : flat-contract? ~

Accepts a flat contracts or a predicate and returns a flat contract that
checks the inverse of the argument.

(=/c z) -> flat-contract?
  z : real? ~

Returns a flat contract that requires the input to be a number and = to
z.

                                        *</c*
(</c n) -> flat-contract?
  n : real? ~

Returns a flat contract that requires the input to be a number and <
than n.

                                        *>/c*
(>/c n) -> flat-contract?
  n : real? ~

Like </c, but for >.

                                        *<*
(<=/c n) -> flat-contract?
  n : real? ~

Like </c, but for <=.

                                        *>*
(>=/c n) -> flat-contract?
  n : real? ~

Like </c, but for >=.

                                        *between/c*
(between/c n m) -> flat-contract? ~
  n : real? ~
  m : real? ~

Returns a flat contract that requires the input to be a real number
between n and m or equal to one of them.

                                        *real-in*
(real-in n m) -> flat-contract? ~
  n : real? ~
  m : real? ~

An alias for between/c.

                                        *integer-in*
(integer-in j k) -> flat-contract? ~
  j : exact-integer? ~
  k : exact-integer? ~

Returns a flat contract that requires the input to be an exact integer
between j and k, inclusive.

                                        *char-in*
(char-in a b) -> flat-contract? ~
  a : char? ~
  b : char? ~

Returns a flat contract that requires the input to be a character whose
code point number is between the code point numbers of a and b,
inclusive.

natural-number/c : flat-contract? ~

A flat contract that requires the input to be an exact non-negative
integer.

                                        *string-len/c*
(string-len/c len) -> flat-contract? ~
  len : real? ~

Returns a flat contract that recognizes strings that have fewer than len
characters.

false/c : flat-contract? ~

An alias #f for backwards compatibility.

printable/c : flat-contract? ~

A flat contract that recognizes values that can be written out and read
back in with write and read.

                                        *one-of/c*
(one-of/c v ...+) -> flat-contract? ~
  v : any/c ~

Accepts any number of atomic values and returns a flat contract that
recognizes those values, using eqv?  as the comparison predicate.  For
the purposes of one-of/c, atomic values are defined to be: characters,
symbols, booleans, null, keywords, numbers, #<void>, and #<undefined>.

This is a backwards compatibility contract constructor. If neither
#<void> nor #<undefined> are arguments, it simply passes its arguments
to or/c.

                                        *symbols*
(symbols sym ...+) -> flat-contract? ~
  sym : symbol? ~

Accepts any number of symbols and returns a flat contract that
recognizes those symbols.

This is a backwards compatibility constructor; it merely passes its
arguments to or/c.

                                        *vectorof*
(vectorof  c                          ~
          [#:immutable immutable      ~
           #:flat? flat?])       -> contract? ~
  c : contract? ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~
  flat? : boolean? = #f ~

Returns a contract that recognizes vectors. The elements of the vector
must match c.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the c argument must also be a flat contract.  Such flat
contracts will be unsound if applied to mutable vectors, as they will
not check future operations on the vector.

If the immutable argument is #t and the c argument is a flat contract,
the result will be a flat contract.  If the c argument is a chaperone
contract, then the result will be a chaperone contract.

When a higher-order vectorof contract is applied to a vector, the result
is not eq? to the input.  The result will be a copy for immutable
vectors and a chaperone or impersonator of the input for mutable
vectors.

                                        *vector-immutableof*
(vector-immutableof c) -> contract? ~
  c : contract? ~

Returns the same contract as (vectorof c #:immutable #t). This form
exists for backwards compatibility.

                                        *vector/c*
(vector/c  c                          ~
           ...                       
          [#:immutable immutable      ~
           #:flat? flat?])       -> contract? ~
  c : contract? ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~
  flat? : boolean? = #f ~

Returns a contract that recognizes vectors whose lengths match the
number of contracts given. Each element of the vector must match its
corresponding contract.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the c arguments must also be flat contracts.  Such flat
contracts will be unsound if applied to mutable vectors, as they will
not check future operations on the vector.

If the immutable argument is #t and the c arguments are flat contracts,
the result will be a flat contract.  If the c arguments are chaperone
contracts, then the result will be a chaperone contract.

When a higher-order vector/c contract is applied to a vector, the result
is not eq? to the input.  The result will be a copy for immutable
vectors and a chaperone or impersonator of the input for mutable
vectors.

                                        *vector-immutable/c*
(vector-immutable/c c ...) -> contract? ~
  c : contract? ~

Returns the same contract as (vector/c c ... #:immutable #t). This form
exists for reasons of backwards compatibility.

                                        *box/c*
(box/c  c                          ~
       [#:immutable immutable      ~
        #:flat? flat?])       -> contract? ~
  c : contract? ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~
  flat? : boolean? = #f ~

Returns a contract that recognizes boxes. The content of the box must
match c.

If the flat? argument is #t, then the resulting contract is a flat
contract, and the c argument must also be a flat contract.  Such flat
contracts will be unsound if applied to mutable boxes, as they will not
check future operations on the box.

If the immutable argument is #t and the c argument is a flat contract,
the result will be a flat contract.  If the c argument is a chaperone
contract, then the result will be a chaperone contract.

When a higher-order box/c contract is applied to a box, the result is
not eq? to the input.  The result will be a copy for immutable boxes and
either a chaperone or impersonator of the input for mutable boxes.

                                        *box-immutable/c*
(box-immutable/c c) -> contract? ~
  c : contract? ~

Returns the same contract as (box/c c #:immutable #t). This form exists
for reasons of backwards compatibility.

                                        *listof*
(listof c) -> list-contract? ~
  c : contract? ~

Returns a contract that recognizes a list whose every element matches
the contract c. Beware that when this contract is applied to a value,
the result is not necessarily eq? to the input.

Examples:
  > (define/contract some-numbers
      (listof number?)
      (list 1 2 3))

  > (define/contract just-one-number
      (listof number?)
      11)
  just-one-number: broke its contract
    promised: "list?" ~
    produced: 11 ~
    in: (listof number?) ~
    contract from: (definition just-one-number) ~
    blaming: (definition just-one-number) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

                                        *non-empty-listof*
(non-empty-listof c) -> list-contract? ~
  c : contract? ~

Returns a contract that recognizes non-empty lists whose elements match
the contract c. Beware that when this contract is applied to a value,
the result is not necessarily eq? to the input.

Examples:
  > (define/contract some-numbers
      (non-empty-listof number?)
      (list 1 2 3))

  > (define/contract not-enough-numbers
      (non-empty-listof number?)
      (list))
  not-enough-numbers: broke its contract
    promised: "(and/c list? pair?)" ~
    produced: '() ~
    in: (non-empty-listof number?) ~
    contract from: ~
        (definition not-enough-numbers)
    blaming: (definition not-enough-numbers) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

                                        *list*of*
(list*of c) -> contract? ~
  c : contract? ~

Returns a contract that recognizes improper lists whose elements match
the contract c. If an improper list is created with cons, then its car
position is expected to match c and its cdr position is expected to be
(list*of c). Otherwise, it is expected to match c. Beware that when this
contract is applied to a value, the result is not necessarily eq? to the
input.

Examples:
  > (define/contract improper-numbers
      (list*of number?)
      (cons 1 (cons 2 3)))
  list*of: undefined;
   cannot reference undefined identifier
  > (define/contract not-improper-numbers
      (list*of number?)
      (list 1 2 3))
  list*of: undefined;
   cannot reference undefined identifier

Added in version 6.1.1.1 of package base.

                                        *cons/c*
(cons/c car-c cdr-c) -> contract? ~
  car-c : contract? ~
  cdr-c : contract? ~

Produces a contract that recognizes pairs whose first and second
elements match car-c and cdr-c, respectively. Beware that when this
contract is applied to a value, the result is not necessarily eq? to the
input.

If the cdr-c contract is a list-contract?, then cons/c returns a
list-contract?.

Examples:
  > (define/contract a-pair-of-numbers
      (cons/c number? number?)
      (cons 1 2))

  > (define/contract not-a-pair-of-numbers
      (cons/c number? number?)
      (cons #f #t))
  not-a-pair-of-numbers: broke its contract
    promised: number? ~
    produced: #f ~
    in: the car of ~
        (cons/c number? number?)
    contract from: ~
        (definition not-a-pair-of-numbers)
    blaming: (definition not-a-pair-of-numbers) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

Changed in version 6.0.1.13 of package base: Added the list-contract?
propagating behavior.

                                        *cons/dc*
(cons/dc [car-id contract-expr] [cdr-id (car-id) contract-expr] cons/dc-option) ~
(cons/dc [car-id (cdr-id) contract-expr] [cdr-id contract-expr] cons/dc-option)
 
cons/dc-option = 
               | #:flat ~
               | #:chaperone ~
               | #:impersonator ~

Produces a contract that recognizes pairs whose first and second
elements match the expressions after car-id and cdr-id, respectively.

In the first case, the contract on the cdr-id portion of the contract
may depend on the value in the car-id portion of the pair and in the
second case, the reverse is true.

Examples:
  > (define/contract an-ordered-pair-of-reals
      (cons/dc [hd real?] [tl (hd) (>=/c hd)])
      (cons 1 2))
  cons/dc: undefined;
   cannot reference undefined identifier
  > (define/contract not-an-ordered-pair-of-reals
      (cons/dc [hd real?] [tl (hd) (>=/c hd)])
      (cons 2 1))
  cons/dc: undefined;
   cannot reference undefined identifier

Added in version 6.1.1.6 of package base.

                                        *list/c*
(list/c c ...) -> list-contract? ~
  c : contract? ~

Produces a contract for a list. The number of elements in the list must
match the number of arguments supplied to list/c, and each element of
the list must match the corresponding contract. Beware that when this
contract is applied to a value, the result is not necessarily eq? to the
input.

                                        *syntax/c*
(syntax/c c) -> flat-contract? ~
  c : flat-contract? ~

Produces a flat contract that recognizes syntax objects whose syntax-e
content matches c.

                                        *struct/c*
(struct/c struct-id contract-expr ...) ~

Produces a contract that recognizes instances of the structure type
named by struct-id, and whose field values match the contracts produced
by the contract-exprs.

Contracts for immutable fields must be either flat or chaperone
contracts. Contracts for mutable fields may be impersonator contracts.
If all fields are immutable and the contract-exprs evaluate to flat
contracts, a flat contract is produced.  If all the contract-exprs are
chaperone contracts, a chaperone contract is produced.  Otherwise, an
impersonator contract is produced.

                                        *struct/dc*
(struct/dc struct-id field-spec ... maybe-inv) ~
 
         field-spec = [field-name maybe-lazy contract-expr]
                    | [field-name (dep-field-name ...)
                                  maybe-lazy
                                  maybe-contract-type
                                  maybe-dep-state
                                  contract-expr]
                       
         field-name = field-id
                    | (#:selector selector-id) ~
                    | (field-id #:parent struct-id) ~
                       
         maybe-lazy = 
                    | #:lazy ~
                       
maybe-contract-type = 
                    | #:flat ~
                    | #:chaperone ~
                    | #:impersonator ~
                       
    maybe-dep-state = 
                    | #:depends-on-state ~
                       
          maybe-inv = 
                    | #:inv (dep-field-name ...) invariant-expr ~

Produces a contract that recognizes instances of the structure type
named by struct-id, and whose field values match the contracts produced
by the field-specs.

If the field-spec lists the names of other fields, then the contract
depends on values in those fields, and the contract-expr expression is
evaluated each time a selector is applied, building a new contract for
the fields based on the values of the dep-field-name fields (the
dep-field-name syntax is the same as the field-name syntax). If the
field is a dependent field and no contract-type annotation appears, then
it is assumed that the contract is a chaperone, but not always a flat
contract (and thus the entire struct/dc contract is not a flat
contract). If this is not the case, and the contract is always flat then
the field must be annotated with the #:flat, or the field must be
annotated with #:impersonator (in which case, it must be a mutable
field).

A field-name is either an identifier naming a field in the first case,
an identifier naming a selector in the second case indicated by the
#:selector keyword, or a field id for a struct that is a parent of
struct-id, indicated by the #:parent keyword.

If the #:lazy keyword appears, then the contract on the field is check
lazily (only when a selector is applied); #:lazy contracts cannot be put
on mutable fields.

If a dependent contract depends on some mutable state, then use the
#:depends-on-state keyword argument (if a field’s dependent contract
depends on a mutable field, this keyword is automatically inferred). The
presence of this keyword means that the contract expression is evaluated
each time the corresponding field is accessed (or mutated, if it is a
mutable field). Otherwise, the contract expression for a dependent field
contract is evaluated when the contract is applied to a value.

If the #:inv clause appears, then the invariant expression is evaluated
(and must return a non-#f value) when the contract is applied to a
struct.

Contracts for immutable fields must be either flat or chaperone
contracts. Contracts for mutable fields may be impersonator contracts.
If all fields are immutable and the contract-exprs evaluate to flat
contracts, a flat contract is produced.  If all the contract-exprs are
chaperone contracts, a chaperone contract is produced.  Otherwise, an
impersonator contract is produced.

As an example, the function bst/c below returns a contract for binary
search trees whose values are all between lo and hi. The lazy
annotations ensure that this contract does not change the running time
of operations that do not inspect the entire tree.

  (struct bt (val left right))
  (define (bst/c lo hi)
    (or/c #f
          (struct/dc bt
                     [val (between/c lo hi)]
                     [left (val) #:lazy (bst lo val)] ~
                     [right (val) #:lazy (bst val hi)]))) ~

Changed in version 6.0.1.6 of package base: Added #:inv.

                                        *parameter/c*
(parameter/c in [out]) -> contract? ~
  in : contract? ~
  out : contract? = in ~

Produces a contract on parameters whose values must match out. When the
value in the contracted parameter is set, it must match in.

Examples:
  > (define/contract current-snack
      (parameter/c string?)
      (make-parameter "potato-chip"))

  > (define baked/c
      (flat-named-contract 'baked/c (λ (s) (regexp-match #rx"baked" s))))

  > (define/contract current-dinner
      (parameter/c string? baked/c)
      (make-parameter "turkey" (λ (s) (string-append "roasted " s))))

  > (current-snack 'not-a-snack)
  current-snack: contract violation
    expected: string? ~
    given: 'not-a-snack ~
    in: the parameter of ~
        (parameter/c string?)
    contract from: (definition current-snack) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~
  > (parameterize ([current-dinner "tofurkey"])
      (current-dinner))
  current-dinner: broke its contract
    promised: baked/c ~
    produced: "roasted tofurkey" ~
    in: the parameter of ~
        (parameter/c string? baked/c)
    contract from: (definition current-dinner) ~
    blaming: (definition current-dinner) ~
     (assuming the contract is correct)
    at: eval:4.0 ~

                                        *procedure-arity-includes/c*
(procedure-arity-includes/c n) -> flat-contract? ~
  n : exact-nonnegative-integer? ~

Produces a contract for procedures that accept n argument (i.e,. the
procedure? contract is implied).

                                        *hash/c*
(hash/c  key                        ~
         val                       
        [#:immutable immutable      ~
         #:flat? flat?])       -> contract? ~
  key : chaperone-contract? ~
  val : contract? ~
  immutable : (or/c #t #f 'dont-care) = 'dont-care ~
  flat? : boolean? = #f ~

Produces a contract that recognizes hash tables with keys and values as
specified by the key and val arguments.

Examples:
  > (define/contract good-hash
      (hash/c integer? boolean?)
      (hash 1 #t
            2 #f
            3 #t))

  > (define/contract bad-hash
      (hash/c integer? boolean?)
      (hash 1 "elephant"
            2 "monkey"
            3 "manatee"))
  bad-hash: broke its contract
    promised: boolean? ~
    produced: "elephant" ~
    in: the values of ~
        (hash/c integer? boolean?)
    contract from: (definition bad-hash) ~
    blaming: (definition bad-hash) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

There are a number of technicalities that control how hash/c contracts
behave.

* If the flat? argument is #t, then the resulting contract is  a flat
  contract, and the key and val arguments must also be flat  contracts.

  Examples:
    > (flat-contract? (hash/c integer? boolean?))
    #f
    > (flat-contract? (hash/c integer? boolean? #:flat? #t)) ~
    #t
    > (hash/c integer? (-> integer? integer?) #:flat? #t) ~
    hash/c: contract violation
      expected: flat-contract? ~
      given: #<chaperone-contract: (-> integer? integer?)> ~

  Such flat contracts will be unsound if applied to mutable hash tables,
  as they will not check future mutations to the hash table.

  Examples:
    > (define original-h (make-hasheq))

    > (define/contract ctc-h
        (hash/c integer? boolean? #:flat? #t) ~
        original-h)

    > (hash-set! original-h 1 "not a boolean")

    > (hash-ref ctc-h 1)
    "not a boolean"

* If the immutable argument is #t and the key and val arguments are
  flat-contract?s, the result will be a flat-contract?.

  Example:
    > (flat-contract? (hash/c integer? boolean? #:immutable #t)) ~
    #t

  If either the domain or the range is a chaperone-contract?, then the
  result will be a chaperone-contract?.

  Examples:
    > (flat-contract? (hash/c (-> integer? integer?) boolean?
                              #:immutable #t)) ~
    #f
    > (chaperone-contract? (hash/c (-> integer? integer?) boolean?
                                   #:immutable #t)) ~
    #t

* If the key argument is a chaperone-contract? but not a flat-contract?,
  then the resulting contract can be applied only to equal?-based hash
  tables.

  Example:
    > (define/contract h
        (hash/c (-> integer? integer?) any/c)
        (make-hasheq))
    h: broke its contract
      promised equal?-based hash table due to higher-order
    domain contract
      produced: '#hasheq() ~
      in: (hash/c (-> integer? integer?) any/c) ~
      contract from: (definition h) ~
      blaming: (definition h) ~
       (assuming the contract is correct)
      at: eval:2.0 ~

  Also, when such a hash/c contract is applied to a hash table, the
  result is not eq? to the input. The result of applying the contract
  will be a copy for immutable hash tables, and either a chaperone or
  impersonator of the original hash table for mutable hash tables.

                                        *hash/dc*
(hash/dc [key-id key-contract-expr] [value-id (key-id) value-contract-expr] ~
         hash/dc-option)
 
hash/dc-option = 
               | #:immutable immutable?-expr hash/dc-option ~
               | #:kind kind-expr hash/dc-option ~

Creates a contract for hash? tables with keys matching key-contract-expr
and where the contract on the values can depend on the key itself, since
key-id will be bound to the corresponding key before evaluating the
values-contract-expr.

If immutable?-expr is #t, then only immutable? hashes are accepted. If
it is #f then immutable? hashes are always rejected. It defaults to
'dont-care, in which case both mutable and immutable hashes are
accepted.

If kind-expr evaluates to 'flat, then key-contract-expr and
value-contract-expr are expected to evaluate to flat-contract?s. If it
is 'chaperone, then they are expected to be chaperone-contract?s, and it
may also be 'impersonator, in which case they may be any contract?s. The
default is 'chaperone.

Examples:
  > (define/contract h
      (hash/dc [k real?] [v (k) (>=/c k)])
      (hash 1 3
            2 4))
  hash/dc: undefined;
   cannot reference undefined identifier
  > (define/contract h
      (hash/dc [k real?] [v (k) (>=/c k)])
      (hash 3 1
            4 2))
  hash/dc: undefined;
   cannot reference undefined identifier

                                        *channel/c*
(channel/c val) -> contract? ~
  val : contract? ~

Produces a contract that recognizes channels that communicate values as
specified by the val argument.

If the val argument is a chaperone contract, then the resulting contract
is a chaperone contract. Otherwise, the resulting contract is an
impersonator contract. When a channel contract is applied to a channel,
the resulting channel is not eq? to the input.

Examples:
  > (define/contract chan
      (channel/c string?)
      (make-channel))

  > (thread (λ () (channel-get chan)))
  #<thread>
  > (channel-put chan 'not-a-string)
  chan: contract violation
    expected: string? ~
    given: 'not-a-string ~
    in: (channel/c string?) ~
    contract from: (definition chan) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~

                                        *prompt-tag/c*
(prompt-tag/c contract ... maybe-call/cc) ~
 
maybe-call/cc = 
              | #:call/cc contract ~
              | #:call/cc (values contract ...) ~
 
  contract : contract? ~

Takes any number of contracts and returns a contract that recognizes
continuation prompt tags and will check any aborts or prompt handlers
that use the contracted prompt tag.

Each contract will check the corresponding value passed to an
abort-current-continuation and handled by the handler of a call to
call-with-continuation-prompt.

If all of the contracts are chaperone contracts, the resulting contract
will also be a chaperone contract. Otherwise, the contract is an
impersonator contract.

If maybe-call/cc is provided, then the provided contracts are used to
check the return values from a continuation captured with
call-with-current-continuation.

Examples:
  > (define/contract tag
      (prompt-tag/c (-> number? string?))
      (make-continuation-prompt-tag))

  > (call-with-continuation-prompt
      (lambda ()
        (number->string
          (call-with-composable-continuation
            (lambda (k)
              (abort-current-continuation tag k)))))
      tag
      (lambda (k) (k "not a number")))
  tag: contract violation
    expected: number? ~
    given: "not a number" ~
    in: the 1st argument of ~
        (prompt-tag/c
         (-> number? string?)
         #:call/cc) ~
    contract from: (definition tag) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~

                                        *continuation-mark-key/c*
(continuation-mark-key/c contract) -> contract? ~
  contract : contract? ~

Takes a single contract and returns a contract that recognizes
continuation marks and will check any mappings of marks to values or any
accesses of the mark value.

If the argument contract is a chaperone contract, the resulting contract
will also be a chaperone contract. Otherwise, the contract is an
impersonator contract.

Examples:
  > (define/contract mark-key
      (continuation-mark-key/c (-> symbol? (listof symbol?)))
      (make-continuation-mark-key))

  > (with-continuation-mark
      mark-key
      (lambda (s) (append s '(truffle fudge ganache)))
      (let ([mark-value (continuation-mark-set-first
                         (current-continuation-marks) mark-key)])
        (mark-value "chocolate-bar")))
  mark-key: contract violation
    expected: symbol? ~
    given: "chocolate-bar" ~
    in: the 1st argument of ~
        (continuation-mark-key/c
         (-> symbol? (listof symbol?)))
    contract from: (definition mark-key) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~

                                        *evt/c*
(evt/c contract ...) -> chaperone-contract? ~
  contract : chaperone-contract? ~

Returns a contract that recognizes synchronizable events whose
synchronization results are checked by the given contracts.

The resulting contract is always a chaperone contract and its arguments
must all be chaperone contracts.

Examples:
  > (define/contract my-evt
      (evt/c evt?)
      always-evt)

  > (define/contract failing-evt
      (evt/c number? number?)
      (alarm-evt (+ (current-inexact-milliseconds) 50)))

  > (sync my-evt)
  #<always-evt>
  > (sync failing-evt)
  failing-evt: broke its contract
    promised: event that produces 2 values ~
    produced: event that produces 1 values ~
    in: (evt/c number? number?) ~
    contract from: (definition failing-evt) ~
    blaming: (definition failing-evt) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

                                        *flat-rec-contract*
(flat-rec-contract id flat-contract-expr ...) ~

Constructs a recursive flat contract. A flat-contract-expr can refer to
id to refer recursively to the generated contract.

For example, the contract

  (flat-rec-contract sexp
    (cons/c sexp sexp)
    number?
    symbol?)

is a flat contract that checks for (a limited form of) S-expressions. It
says that a sexp is either two sexps combined with cons, or a number, or
a symbol.

Note that if the contract is applied to a circular value, contract
checking will not terminate.

                                        *flat-murec-contract*
(flat-murec-contract ([id flat-contract-expr ...] ...) body ...+) ~

A generalization of flat-rec-contract for defining several mutually
recursive flat contracts simultaneously. Each id is visible in the
entire flat-murec-contract form, and the result of the final body is the
result of the entire form.

any

Represents a contract that is always satisfied. In particular, it can
accept multiple values.  It can only be used in a result position of
contracts like ->. Using any elsewhere is a syntax error.

                                        *promise/c*
(promise/c c) -> contract? ~
  c : contract? ~

Constructs a contract on a promise. The contract does not force the
promise, but when the promise is forced, the contract checks that the
result value meets the contract c.

                                        *flat-contract*
(flat-contract predicate) -> flat-contract? ~
  predicate : (-> any/c any/c) ~

Constructs a flat contract from predicate. A value satisfies the
contract if the predicate returns a true value.

This function is a holdover from before predicates could be used
directly as flat contracts. It exists today for backwards compatibility.

                                        *flat-contract-predicate*
(flat-contract-predicate v) -> (-> any/c any/c) ~
  v : flat-contract? ~

Extracts the predicate from a flat contract.

This function is a holdover from before flat contracts could be used
directly as predicates. It exists today for backwards compatibility.

2. Function Contracts

A function contract wraps a procedure to delay checks for its arguments
and results. There are three primary function contract combinators that
have increasing amounts of expressiveness and increasing additional
overheads. The first -> is the cheapest. It generates wrapper functions
that can call the original function directly. Contracts built with ->*
require packaging up arguments as lists in the wrapper function and then
using either keyword-apply or apply. Finally, ->i is the most expensive
(along with ->d), because it requires delaying the evaluation of the
contract expressions for the domain and range until the function itself
is called or returns.

The case-> contract is a specialized contract, designed to match
case-lambda and unconstrained-domain-> allows range checking without
requiring that the domain have any particular shape (see below for an
example use).

                                        *->*
(-> dom ... range)
 
  dom = dom-expr
      | keyword dom-expr
         
range = range-expr
      | (values range-expr ...)
      | any

Produces a contract for a function that accepts a fixed number of
arguments and returns either a fixed number of results or completely
unspecified results (the latter when any is specified).

Each dom-expr is a contract on an argument to a function, and each
range-expr is a contract on a result of the function.

Using a -> between two whitespace-delimited .s is the same as putting
the -> right after the enclosing opening parenthesis. See [missing] or
[missing] for more information.

For example,

  (integer? boolean? . -> . integer?)

produces a contract on functions of two arguments. The first argument
must be an integer, and the second argument must be a boolean. The
function must produce an integer.

A domain specification may include a keyword. If so, the function must
accept corresponding (mandatory) keyword arguments, and the values for
the keyword arguments must match the corresponding contracts. For
example:

  (integer? #:x boolean? . -> . integer?) ~

is a contract on a function that accepts a by-position argument that is
an integer and a #:x argument that is a boolean.

If any is used as the last sub-form for ->, no contract checking is
performed on the result of the function, and thus any number of values
is legal (even different numbers on different invocations of the
function).

If (values range-expr ...) is used as the last sub-form of ->, the
function must produce a result for each contract, and each value must
match its respective contract.

                                        *->**
(->* (mandatory-dom ...) optional-doms rest pre range post)
 
mandatory-dom = dom-expr
              | keyword dom-expr
                 
optional-doms = 
              | (optional-dom ...)
                 
 optional-dom = dom-expr
              | keyword dom-expr
                 
         rest = 
              | #:rest rest-expr ~
                 
          pre = 
              | #:pre pre-cond-expr ~
              | #:pre/desc pre-cond-expr ~
                 
        range = range-expr
              | (values range-expr ...)
              | any
                 
         post = 
              | #:post post-cond-expr ~
              | #:post/desc post-cond-expr ~

The ->* contract combinator produces contracts for functions that accept
optional arguments (either keyword or positional) and/or arbitrarily
many arguments. The first clause of a ->* contract describes the
mandatory arguments, and is similar to the argument description of a ->
contract. The second clause describes the optional arguments. The range
of description can either be any or a sequence of contracts, indicating
that the function must return multiple values.

If present, the rest-expr contract governs the arguments in the rest
parameter. Note that the rest-expr contract governs only the arguments
in the rest parameter, not those in mandatory arguments. For example,
this contract:

  (->* () #:rest (cons/c integer? (listof integer?)) any) ~

does not match the function

  (λ (x . rest) x)

because the contract insists that the function accept zero arguments
(because there are no mandatory arguments listed in the contract). The
->i contract does not know that the contract on the rest argument is
going to end up disallowing empty argument lists.

The pre-cond-expr and post-cond-expr expressions are checked as the
function is called and returns, respectively, and allow checking of the
environment without an explicit connection to an argument (or a result).
If the #:pre or #:post keywords are used, then a #f result is treated as
a failure and any other result is treated as success. If the #:pre/desc
or #:post/desc keyword is used, the result of the expression must be
either a boolean, a string, or a list of strings, where #t means success
and any of the other results mean failure. If the result is a string or
a list of strings, the strings are expected to have at exactly one space
after each newline and multiple are used as lines in the error message;
the contract itself adds single space of indentation to each of the
strings in that case. The formatting requirements are not checked but
they match the recommendations in [missing].

As an example, the contract

  (->* () (boolean? #:x integer?) #:rest (listof symbol?) symbol?) ~

matches functions that optionally accept a boolean, an integer keyword
argument #:x and arbitrarily more symbols, and that return a symbol.

                                        *->i*
(->i (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
(->i (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
 
mandatory-dependent-dom = id+ctc
                        | keyword id+ctc
                           
 optional-dependent-dom = id+ctc
                        | keyword id+ctc
                           
         dependent-rest = 
                        | #:rest id+ctc ~
                           
          pre-condition = 
                        | #:pre (id ...) ~
                          boolean-expr pre-condition
                        | #:pre/desc (id ...) ~
                          expr pre-condition
                        | #:pre/name (id ...) ~
                          string boolean-expr pre-condition
                           
        dependent-range = any
                        | id+ctc
                        | un+ctc
                        | (values id+ctc ...)
                        | (values un+ctc ...)
                           
         post-condition = 
                        | #:post (id ...) ~
                          boolean-expr post-condition
                        | #:post/desc (id ...) ~
                          expr post-condition
                        | #:post/name (id ...) ~
                          string boolean-expr post-condition
                           
                 id+ctc = [id contract-expr]
                        | [id (id ...) contract-expr]
                           
                 un+ctc = [_ contract-expr]
                        | [_ (id ...) contract-expr]

The ->i contract combinator differs from the ->* combinator in that each
argument and result is named and these names can be used in the
subcontracts and in the pre-/post-condition clauses. In other words, ->i
expresses dependencies among arguments and results.

The first sub-form of a ->i contract covers the mandatory and the second
sub-form covers the optional arguments. Following that is an optional
rest-args contract, and an optional pre-condition. The pre-condition is
introduced with the #:pre keyword followed by the list of names on which
it depends. If the #:pre/name keyword is used, the string supplied is
used as part of the error message; similarly with #:post/name. If
#:pre/desc or #:post/desc is used, the the result of the expression is
treated the same way as ->*.

The dependent-range non-terminal specifies the possible result
contracts. If it is any, then any value is allowed. Otherwise, the
result contract pairs a name and a contract or a multiple values return
with names and contracts. In the last two cases, the range contract may
be optionally followed by a post-condition; the post-condition
expression is not allowed if the range contract is any. Like the
pre-condition, the post-condition must specify the variables on which it
depends.

Consider this sample contract:

  (->i ([x number?]
        [y (x) (>=/c x)])
       [result (x y) (and/c number? (>=/c (+ x y)))])

It specifies a function of two arguments, both numbers. The contract on
the second argument (y) demands that it is greater than the first
argument. The result contract promises a number that is greater than the
sum of the two arguments. While the dependency specification for y
signals that the argument contract depends on the value of the first
argument, the dependency sequence for result indicates that the contract
depends on both argument values. In general, an empty sequence is
(nearly) equivalent to not adding a sequence at all except that the
former is more expensive than the latter. Since the contract for x does
not depend on anything else, it does not come with any dependency
sequence, not even ().

This example is like the previous one, except the x and y arguments are
now optional keyword arguments, instead of mandatory, by-position
arguments:

  (->i ()
       (#:x [x number?] ~
        #:y [y (x) (>=/c x)]) ~
       [result (x y) (and/c number? (>=/c (+ x y)))])

The contract expressions are not always evaluated in order. First, if
there is no dependency for a given contract expression, the contract
expression is evaluated at the time that the ->i expression is evaluated
rather than the time when the function is called or returns.  These
dependency-free contract expressions are evaluated in the order in which
they are listed. Second, the dependent contract sub-expressions are
evaluated when the contracted function is called or returns in some
order that satisfies the dependencies. That is, if a contract for an
argument depends on the value of some other contract, the former is
evaluated first (so that the argument, with its contract checked, is
available for the other).  When there is no dependency between two
arguments (or the result and an argument), then the contract that
appears earlier in the source text is evaluated first.

Finally, if all of the identifier positions of the range contract are _s
(underscores), then the range contract expressions are evaluated when
the function is called and the underscore is not bound in the range,
after the argument contracts are evaluated and checked. Otherwise, the
range expressions are evaluated when the function returns.

If there are optional arguments that are not supplied, then the
corresponding variables will be bound to a special value called
the-unsupplied-arg value.

                                        *->d*
(->d (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
(->d (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
 
mandatory-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
 optional-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
         dependent-rest = 
                        | #:rest id rest-expr ~
                           
          pre-condition = 
                        | #:pre boolean-expr ~
                        | #:pre-cond boolean-expr ~
                           
        dependent-range = any
                        | [_ range-expr]
                        | (values [_ range-expr] ...)
                        | [id range-expr]
                        | (values [id range-expr] ...)
                           
         post-condition = 
                        | #:post-cond boolean-expr ~

This contract is here for backwards compatibility; any new code should
use ->i instead.

This contract is similar to ->i, but is “lax”, meaning that it does not
enforce contracts internally. For example, using this contract

  (->d ([f (-> integer? integer?)])
       #:pre ~
       (zero? (f #f))
       any)

will allow f to be called with #f, trigger whatever bad behavior the
author of f was trying to prohibit by insisting that f’s contract accept
only integers.

The #:pre-cond and #:post-cond keywords are aliases for #:pre and #:post
and are provided for backwards compatibility.

                                        *case->*
(case-> (-> dom-expr ... rest range) ...) ~
 
 rest = 
      | #:rest rest-expr ~
         
range = range-expr
      | (values range-expr ...)
      | any

This contract form is designed to match case-lambda. Each argument to
case-> is a contract that governs a clause in the case-lambda. If the
#:rest keyword is present, the corresponding clause must accept an
arbitrary number of arguments. The range specification is just like that
for -> and ->*.

For example, this contract matches a function with two cases, one that
accepts an integer, returning void, and one that accepts no arguments
and returns an integer.

  (case-> (-> integer? void?)
          (-> integer?))

Such a contract could be used to guard a function that controls access
to a single shared integer.

                                        *dynamic->**
(dynamic->*                                                             ~
            [#:mandatory-domain-contracts mandatory-domain-contracts    ~
             #:optional-domain-contracts optional-domain-contracts      ~
             #:mandatory-keywords mandatory-keywords                    ~
             #:mandatory-keyword-contracts mandatory-keyword-contracts  ~
             #:optional-keywords optional-keywords                      ~
             #:optional-keyword-contracts optional-keyword-contracts    ~
             #:rest-contract rest-contract]                             ~
             #:range-contracts range-contracts)                         ~
 -> contract?
  mandatory-domain-contracts : (listof contract?) = '() ~
  optional-domain-contracts : (listof contract?) = '() ~
  mandatory-keywords : (listof keyword?) = '() ~
  mandatory-keyword-contracts : (listof contract?) = '() ~
  optional-keywords : (listof keyword?) = '() ~
  optional-keyword-contracts : (listof contract?) = '() ~
  rest-contract : (or/c #f contract?) = #f ~
  range-contracts : (or/c #f (listof contract?)) ~

Like ->*, except the number of arguments and results can be computed at
runtime, instead of being fixed at compile-time. Passing #f as the
#:range-contracts argument produces a contract like one where any is
used with -> or ->*.

For many uses, dynamic->*’s result is slower than ->* (or ->), but for
some it has comparable speed. The name of the contract returned by
dynamic->* uses the -> or ->* syntax.

                                        *unconstrained-domain->*
(unconstrained-domain-> range-expr ...) ~

Constructs a contract that accepts a function, but makes no constraint
on the function’s domain. The range-exprs determine the number of
results and the contract for each result.

Generally, this contract must be combined with another contract to
ensure that the domain is actually known to be able to safely call the
function itself.

For example, the contract

  (provide
   (contract-out
    [f (->d ([size natural-number/c]
             [proc (and/c (unconstrained-domain-> number?)
                          (lambda (p)
                            (procedure-arity-includes? p size)))])
            ()
            [_ number?])]))

says that the function f accepts a natural number and a function. The
domain of the function that f accepts must include a case for size
arguments, meaning that f can safely supply size arguments to its input.

For example, the following is a definition of f that cannot be blamed
using the above contract:

  (define (f i g)
    (apply g (build-list i add1)))

predicate/c : contract? ~

Use this contract to indicate that some function is a predicate. It is
semantically equivalent to (-> any/c boolean?).

This contract also includes an optimization so that functions returning
#t from struct-predicate-procedure? are just returned directly, without
being wrapped. This contract is used by provide/contract’s struct
subform so that struct predicates end up not being wrapped.

the-unsupplied-arg : unsupplied-arg? ~

Used by ->i (and ->d) to bind optional arguments that are not supplied
by a call site.

                                        *unsupplied-arg?*
(unsupplied-arg? v) -> boolean? ~
  v : any/c ~

A predicate to determine whether v is the-unsupplied-arg.

3. Parametric Contracts

 (require racket/contract/parametric) package: base ~

The most convenient way to use parametric contract is to use
contract-out’s #:exists keyword. The racket/contract/parametric provides
a few more, general-purpose parametric contracts.

                                        *parametric->/c*
(parametric->/c (x ...) c) ~

Creates a contract for parametric polymorphic functions.  Each function
is protected by c, where each x is bound in c and refers to a
polymorphic type that is instantiated each time the function is applied.

At each application of a function, the parametric->/c contract
constructs a new opaque wrapper for each x; values flowing into the
polymorphic function (i.e. values protected by some x in negative
position with respect to parametric->/c) are wrapped in the
corresponding opaque wrapper.  Values flowing out of the polymorphic
function (i.e. values protected by some x in positive position with
respect to parametric->/c) are checked for the appropriate wrapper.  If
they have it, they are unwrapped; if they do not, a contract violation
is signaled.

Examples:
  > (define/contract (check x y)
      (parametric->/c [X] (boolean? X . -> . X))
      (if (or (not x) (equal? y 'surprise))
          'invalid
          y))

  > (check #t 'ok)
  'ok
  > (check #f 'ignored)
  check: broke its contract
    promised: X ~
    produced: 'invalid ~
    in: the range of ~
        (parametric->/c (X) (-> boolean? X X))
    contract from: (function check) ~
    blaming: (function check) ~
     (assuming the contract is correct)
    at: eval:2.0 ~
  > (check #t 'surprise)
  'surprise

                                        *new-*
(new-∀/c [name]) -> contract? ~
  name : (or/c symbol? #f) = #f ~

Constructs a new universal contract.

Universal contracts accept all values when in negative positions (e.g.,
function inputs) and wrap them in an opaque struct, hiding the precise
value. In positive positions (e.g. function returns), a universal
contract accepts only values that were previously accepted in negative
positions (by checking for the wrappers).

The name is used to identify the contract in error messages and defaults
to a name based on the lexical context of new-∀/c.

For example, this contract:

  (let ([a (new-∀/c 'a)])
    (-> a a))

describes the identity function (or a non-terminating function). That
is, the first use of the a appears in a negative position and thus
inputs to that function are wrapped with an opaque struct. Then, when
the function returns, it is checked to determine whether the result is
wrapped, since the second a appears in a positive position.

The new-∀/c construct constructor is dual to new-∃/c.

                                        *new-*
(new-∃/c [name]) -> contract? ~
  name : (or/c symbol? #f) = #f ~

Constructs a new existential contract.

Existential contracts accept all values when in positive positions
(e.g., function returns) and wrap them in an opaque struct, hiding the
precise value. In negative positions (e.g. function inputs), they
accepts only values that were previously accepted in positive positions
(by checking for the wrappers).

The name is used to identify the contract in error messages and defaults
to a name based on the lexical context of new-∀/c.

For example, this contract:

  (let ([a (new-∃/c 'a)])
    (-> (-> a a)
        any/c))

describes a function that accepts the identity function (or a
non-terminating function) and returns an arbitrary value. That is, the
first use of the a appears in a positive position and thus inputs to
that function are wrapped with an opaque struct. Then, when the function
returns, it is checked to see if the result is wrapped, since the second
a appears in a negative position.

The new-∃/c construct constructor is dual to new-∀/c.

4. Lazy Data-structure Contracts

                                        *contract-struct*
(contract-struct id (field-id ...)) ~

  NOTE: This library is deprecated; use struct, instead. Lazy struct
  contracts no longer require a separate struct declaration; instead
  struct/dc and struct/c work directly with struct and define-struct.

Like struct, but with two differences: they do not define field
mutators, and they define two contract constructors: id/c and id/dc. The
first is a procedure that accepts as many arguments as there are fields
and returns a contract for struct values whose fields match the
arguments. The second is a syntactic form that also produces contracts
on the structs, but the contracts on later fields may depend on the
values of earlier fields.

The generated contract combinators are lazy: they only verify the
contract holds for the portion of some data structure that is actually
inspected. More precisely, a lazy data structure contract is not checked
until a selector extracts a field of a struct.

                                        *id/dc*
(id/dc field-spec ...) ~
 
field-spec = [field-id contract-expr]
           | [field-id (field-id ...) contract-expr]
In each field-spec case, the first field-id specifies which field the
contract applies to; the fields must be specified in the same order as
the original contract-struct. The first case is for when the contract on
the field does not depend on the value of any other field. The second
case is for when the contract on the field does depend on some other
fields, and the parenthesized field-ids indicate which fields it depends
on; these dependencies can only be to earlier fields.

                                        *define-contract-struct*
(define-contract-struct id (field-id ...)) ~

  NOTE: This library is deprecated; use struct, instead. Lazy struct
  contracts no longer require a separate struct declaration; instead
  struct/dc and struct/c work directly with struct and define-struct.

Like contract-struct, but where the constructor’s name is make-id, much
like define-struct.

5. Structure Type Property Contracts

                                        *struct-type-property/c*
(struct-type-property/c value-contract) -> contract? ~
  value-contract : contract? ~

Produces a contract for a structure type property. When the contract is
applied to a struct type property, it produces a wrapped struct type
property that applies value-contract to the value associated with the
property when it used to create a new struct type (via struct,
make-struct-type, etc).

The struct type property’s accessor function is not affected; if it is
exported, it must be protected separately.

As an example, consider the following module. It creates a structure
type property, prop, whose value should be a function mapping a
structure instance to a numeric predicate. The module also exports
app-prop, which extracts the predicate from a structure instance and
applies it to a given value.

  > (module propmod racket
      (require racket/contract)
      (define-values (prop prop? prop-ref)
        (make-struct-type-property 'prop))
      (define (app-prop x v)
        (((prop-ref x) x) v))
      (provide/contract
       [prop? (-> any/c boolean?)]
       [prop (struct-type-property/c
              (-> prop? (-> integer? boolean?)))]
       [app-prop (-> prop? integer? boolean?)])
      (provide prop-ref))


The structmod module creates a structure type named s with a single
field; the value of prop is a function that extracts the field value
from an instance. Thus the field ought to be an integer predicate, but
notice that structmod places no contract on s enforcing that constraint.

  > (module structmod racket
      (require 'propmod)
      (struct s (f) #:property prop (lambda (s) (s-f s))) ~
      (provide (struct-out s)))

  > (require 'propmod 'structmod)


First we create an s instance with an integer predicate, so the
constraint on prop is in fact satisfied. The first call to app-prop is
correct; the second simply violates the contract of app-prop.

  > (define s1 (s even?))

  > (app-prop s1 5)
  #f
  > (app-prop s1 'apple)
  app-prop: contract violation
    expected: integer? ~
    given: 'apple ~
    in: the 2nd argument of ~
        (-> prop? integer? boolean?)
    contract from: propmod ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~

We are able to create s instances with values other than integer
predicates, but applying app-prop on them blames structmod, because the
function associated with prop—that is, (lambda (s) (s-f s))—does not
always produce a value satisfying (-> integer? boolean?).

  > (define s2 (s "not a fun"))

  > (app-prop s2 5)
  prop: contract violation
    expected: a procedure ~
    given: "not a fun" ~
    in: the range of ~
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~
    blaming: structmod ~
     (assuming the contract is correct)
    at: eval:2.0 ~
  > (define s3 (s list))

  > (app-prop s3 5)
  prop: contract violation
    expected: boolean? ~
    given: '(5) ~
    in: the range of ~
        the range of
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~
    blaming: structmod ~
     (assuming the contract is correct)
    at: eval:2.0 ~

The fix would be to propagate the obligation inherited from prop to s:

  (provide (contract-out
             [struct s ([f (-> integer? boolean?)])]))

Finally, if we directly apply the property accessor, prop-ref, and then
misuse the resulting function, the propmod module is blamed:

  > ((prop-ref s3) 'apple)
  prop: broke its contract
    promised: prop? ~
    produced: 'apple ~
    in: the 1st argument of ~
        the struct property value of
        (struct-type-property/c
         (-> prop? (-> integer? boolean?)))
    contract from: propmod ~
    blaming: propmod ~
     (assuming the contract is correct)
    at: eval:2.0 ~

The propmod module has an obligation to ensure a function associated
with prop is applied only to values satisfying prop?. By directly
providing prop-ref, it enables that constraint to be violated (and thus
it is blamed), even though the bad application actually occurs
elsewhere.

Generally there is no need to provide a structure type property accessor
at all; it is typically only used by other functions within the module.
But if it must be provided, it should be protected thus:

  (provide (contract-out
             [prop-ref (-> prop? (-> prop? (-> integer? boolean?)))]))

6. Attaching Contracts to Values

                                        *contract-out*
(contract-out p/c-item ...) ~
 
      p/c-item = (struct id/super ((id contract-expr) ...)
                   struct-option)
               | (rename orig-id id contract-expr)
               | (id contract-expr)
               | #:∃ poly-variables ~
               | #:exists poly-variables ~
               | #:∀ poly-variables ~
               | #:forall poly-variables ~
                  
poly-variables = id
               | (id ...)
                  
      id/super = id
               | (id super-id)
                  
 struct-option = 
               | #:omit-constructor ~

A provide-spec for use in provide (currently only for the same phase
level as the provide form; for example, contract-out cannot be nested
within for-syntax). Each id is provided from the module. In addition,
clients of the module must live up to the contract specified by
contract-expr for each export.

The contract-out form treats modules as units of blame. The module that
defines the provided variable is expected to meet the positive
(co-variant) positions of the contract. Each module that imports the
provided variable must obey the negative (contra-variant) positions of
the contract. Each contract-expr in a contract-out form is effectively
moved to the end of the enclosing module, so a contract-expr can refer
to variables that are defined later in the same module.

Only uses of the contracted variable outside the module are checked.
Inside the module, no contract checking occurs.

The rename form of contract-out exports the first variable (the internal
name) with the name specified by the second variable (the external
name).

The struct form of contract-out provides a structure-type definition,
and each field has a contract that dictates the contents of the fields.
The structure-type definition must appear before the provide clause
within the enclosing module. If the structure type has a parent, the
second struct form (above) must be used, with the first name referring
to the structure type to export and the second name referring to the
parent structure type. Unlike a struct definition, however, all of the
fields (and their contracts) must be listed. The contract on the fields
that the sub-struct shares with its parent are only used in the contract
for the sub-struct’s constructor, and the selector or mutators for the
super-struct are not provided. The exported structure-type name always
doubles as a constructor, even if the original structure-type name does
not act as a constructor. If the #:omit-constructor option is present,
the constructor is not provided.

The #:∃, #:exists, #:∀, and #:forall clauses define new abstract
contracts. The variables are bound in the remainder of the contract-out
form to new contracts that hide the values they accept and ensure that
the exported functions are treated parametrically. See new-∃/c and
new-∀/c for details on how the clauses hide the values.

The implementation of contract-out uses syntax-property to attach
properties to the code it generates that records the syntax of the
contracts in the fully expanded program. Specifically, the symbol
'provide/contract-original-contract is bound to vectors of two elements,
the exported identifier and a syntax object for the expression that
produces the contract controlling the export.

                                        *recontract-out*
(recontract-out id ...) ~

A provide-spec for use in provide (currently,   just like contract-out,
only for   the same phase level as the provide form).

It re-exports id, but with positive blame associated to the module
containing recontract-out instead of the location of the original site
of id.

This can be useful when a public module wants to export an identifier
from a private module but where any contract violations should be
reported in terms of the public module instead of the private one.

Examples:
  > (module private-implementation racket/base
      (require racket/contract)
      (define (recip x) (/ 1 x))
      (define (non-zero? x) (not (= x 0)))
      (provide/contract [recip (-> (and/c real? non-zero?)
                                   (between/c -1 1))]))

  > (module public racket/base
      (require racket/contract
               'private-implementation)
      (provide (recontract-out recip)))

  > (require 'public)

  > (recip +nan.0)
  recip: broke its contract
    promised: (between/c -1 1) ~
    produced: +nan.0 ~
    in: the range of ~
        (->
         (and/c real? non-zero?)
         (between/c -1 1))
    contract from: public ~
    blaming: public ~
     (assuming the contract is correct)
    at: eval:3.0 ~

Replacing the use of contract-out with just recip would result in a
contract violation blaming the private module.

                                        *provide/contract*
(provide/contract p/c-item ...) ~

A legacy shorthand for (provide (contract-out p/c-item ...)), except
that a contract-expr within provide/contract is evaluated at the
position of the provide/contract form instead of at the end of the
enclosing module.

6.1. Nested Contract Boundaries

 (require racket/contract/region) package: base ~

                                        *with-contract*
(with-contract blame-id (wc-export ...) free-var-list ... body ...+) ~
(with-contract blame-id results-spec free-var-list ... body ...+)
 
    wc-export = (id contract-expr)
                 
  result-spec = #:result contract-expr ~
              | #:results (contract-expr ...) ~
                 
free-var-list = 
              | #:freevar id contract-expr ~
              | #:freevars ([id contract-expr] ...) ~

Generates a local contract boundary.

The first with-contract form cannot appear in expression position. All
names defined within the first with-contract form are visible
externally, but those names listed in the wc-export list are protected
with the corresponding contract.  The body of the form allows
definition/expression interleaving if its context does.

The second with-contract form must appear in expression position. The
final body expression should return the same number of values as the
number of contracts listed in the result-spec, and each returned value
is contracted with its respective contract.  The sequence of body forms
is treated as for let.

The blame-id is used for the positive positions of contracts paired with
exported ids.  Contracts broken within the with-contract body will use
the blame-id for their negative position.

If a free-var-list is given, then any uses of the free variables inside
the body will be protected with contracts that blame the context of the
with-contract form for the positive positions and the with-contract form
for the negative ones.

                                        *define/contract*
(define/contract id contract-expr free-var-list init-value-expr) ~
(define/contract (head args) contract-expr free-var-list body ...+)

Works like define, except that the contract contract-expr is attached to
the bound value.  For the definition of head and args, see define. For
the definition of free-var-list, see with-contract.

Examples:
  > (define/contract distance (>=/c 0) 43.52)

  > (define/contract (furlongs->feet fr)
      (-> real? real?)
      (* 660 fr))

  ; a contract violation expected here: ~
  > (furlongs->feet "not a furlong")
  furlongs->feet: contract violation
    expected: real? ~
    given: "not a furlong" ~
    in: the 1st argument of ~
        (-> real? real?)
    contract from: (function furlongs->feet) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:3.0 ~

The define/contract form treats the individual definition as a contract
region. The definition itself is responsible for positive (co-variant)
positions of the contract, and references to id outside of the
definition must meet the negative positions of the contract. Since the
contract boundary is between the definition and the surrounding context,
references to id inside the define/contract form are not checked.

Examples:
  ; an unsual predicate that prints when called
  > (define (printing-int? x)
      (displayln "I was called")
      (exact-integer? x))

  > (define/contract (fact n)
      (-> printing-int? printing-int?)
      (if (zero? n)
          1
          (* n (fact (sub1 n)))))

  > (fact 5)
  I was called
  I was called
  120
  ; only prints twice, not for each recursive call

If a free-var-list is given, then any uses of the free variables inside
the body will be protected with contracts that blame the context of the
define/contract form for the positive positions and the define/contract
form for the negative ones.

Examples:
  > (define (integer->binary-string n)
      (number->string n 2))

  > (define/contract (numbers->strings lst)
      (-> (listof number?) (listof string?))
      #:freevar integer->binary-string (-> exact-integer? string?) ~
      ; mistake, lst might contain inexact numbers
      (map integer->binary-string lst))

  > (numbers->strings '(4.0 3.3 5.8))
  integer->binary-string: contract violation
    expected: exact-integer? ~
    given: 4.0 ~
    in: the 1st argument of ~
        (-> exact-integer? string?)
    contract from: top-level ~
    blaming: (function numbers->strings) ~
     (assuming the contract is correct)
    at: eval:3.0 ~

                                        *define-struct/contract*
(define-struct/contract struct-id ([field contract-expr] ...) ~
                        struct-option ...)
(define-struct/contract (struct-id super-struct-id)
                        ([field contract-expr] ...)
                        struct-option ...)

Works like define-struct, except that the arguments to the constructor,
accessors, and mutators are protected by contracts.  For the definitions
of field and struct-option, see define-struct.

The define-struct/contract form only allows a subset of the
struct-option keywords: #:mutable, #:transparent, #:auto-value,
#:omit-define-syntaxes, #:property and #:omit-define-values.

Examples:
  > (define-struct/contract fish ([color number?]))

  > (make-fish 5)
  #<fish>
  > (make-fish #f)
  make-fish: contract violation
    expected: number? ~
    given: #f ~
    in: the 1st argument of ~
        (-> number? symbol? any)
    contract from: (struct fish) ~
    blaming: top-level ~
     (assuming the contract is correct)
  > (define-struct/contract (salmon fish) ([ocean symbol?]))

  > (make-salmon 5 'atlantic)
  #<salmon>
  > (make-salmon 5 #f)
  make-salmon: contract violation
    expected: symbol? ~
    given: #f ~
    in: the 2nd argument of ~
        (-> any/c symbol? symbol? any)
    contract from: (struct salmon) ~
    blaming: top-level ~
     (assuming the contract is correct)
  > (make-salmon #f 'pacific)
  make-fish: contract violation
    expected: number? ~
    given: #f ~
    in: the 1st argument of ~
        (-> number? symbol? any)
    contract from: (struct fish) ~
    blaming: top-level ~
     (assuming the contract is correct)

                                        *invariant-assertion*
(invariant-assertion invariant-expr expr) ~

Establishes an invariant of expr, determined by invariant-expr.

Unlike the specification of a contract, an invariant-assertion does not
establish a boundary between two parties. Instead, it simply attaches a
logical assertion to the value. Because the form uses contract machinery
to check the assertion, the surrounding module is treated as the party
to be blamed for any violations of the assertion.

This means, for example, that the assertion is checked on recursive
calls, when an invariant is used on the right-hand side of a definition:

Examples:
  > (define furlongss->feets
      (invariant-assertion
       (-> (listof real?) (listof real?))
       (λ (l)
         (cond
           [(empty? l) empty]
           [else
            (if (= 327 (car l))
                (furlongss->feets (list "wha?"))
                (cons (furlongs->feet (first l))
                      (furlongss->feets (rest l))))]))))

  > (furlongss->feets (list 1 2 3))
  '(660 1320 1980)
  > (furlongss->feets (list 1 327 3))
  furlongss->feets: contract violation
    expected: real? ~
    given: "wha?" ~
    in: an element of ~
        the 1st argument of
        (-> (listof real?) (listof real?))
    contract from: top-level ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:5.0 ~

Added in version 6.0.1.11 of package base.

current-contract-region

Bound by define-syntax-parameter, this contains information about the
current contract region, used by the above forms to determine the
candidates for blame assignment.

6.2. Low-level Contract Boundaries

                                        *define-module-boundary-contract*
(define-module-boundary-contract id ~
  orig-id
  contract-expr
  pos-blame-party
  source-loc)
 
pos-blame-party = 
                | #:pos-source pos-source-expr ~
                   
     source-loc = 
                | #:srcloc srcloc-expr ~

Defines id to be orig-id, but with the contract contract-expr.

The identifier id is defined as a macro transformer that consults the
context of its use to determine the name for negative blame assignment
(using the entire module where a reference appears as the negative
party).

The positive party defaults to the module containing the use of
define-module-boundary-contract, but can be specified explicitly via the
#:pos-source keyword.

The source location used in the blame error messages for the location of
the place where the contract was put on the value defaults to the source
location of the use of define-module-boundary-contract, but can be
specified via the #:srcloc argument, in which case it can be any of the
things that the third argument to datum->syntax can be.

Examples:
  > (module server racket/base
      (require racket/contract/base)
      (define (f x) #f)
      (define-module-boundary-contract g f (-> integer? integer?))
      (provide g))

  > (module client racket/base
      (require 'server)
      (define (clients-fault) (g #f))
      (define (servers-fault) (g 1))
      (provide servers-fault clients-fault))

  > (require 'client)

  > (clients-fault)
  g: contract violation
    expected: integer? ~
    given: #f ~
    in: the 1st argument of ~
        (-> integer? integer?)
    contract from: 'server ~
    blaming: client ~
     (assuming the contract is correct)
    at: eval:2.0 ~
  > (servers-fault)
  g: broke its contract
    promised: integer? ~
    produced: #f ~
    in: the range of ~
        (-> integer? integer?)
    contract from: 'server ~
    blaming: (quote server) ~
     (assuming the contract is correct)
    at: eval:2.0 ~

                                        *contract*
(contract contract-expr to-protect-expr ~
          positive-blame-expr negative-blame-expr)
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr
          value-name-expr source-location-expr)

The primitive mechanism for attaching a contract to a value. The purpose
of contract is as a target for the expansion of some higher-level
contract specifying form.

The contract expression adds the contract specified by contract-expr to
the value produced by to-protect-expr. The result of a contract
expression is the result of the to-protect-expr expression, but with the
contract specified by contract-expr enforced on to-protect-expr.

The values of positive-blame-expr and negative-blame-expr indicate how
to assign blame for positive and negative positions of the contract
specified by contract-expr.  They may be any value, and are formatted as
by display for purposes of contract violation error messages.

If specified, value-name-expr indicates a name for the protected value
to be used in error messages.  If not supplied, or if value-name-expr
produces #f, no name is printed.  Otherwise, it is also formatted as by
display. More precisely, the value-name-expr ends up in the blame-name
field of the blame record, which is used as the first portion of the
error message.

Examples:
  > (contract integer? #f 'pos 'neg 'timothy #f)
  timothy: broke its contract
    promised: integer? ~
    produced: #f ~
    in: integer? ~
    contract from: pos ~
    blaming: pos ~
     (assuming the contract is correct)
  > (contract integer? #f 'pos 'neg #f #f)
  broke its contract:
    promised: integer? ~
    produced: #f ~
    in: integer? ~
    contract from: pos ~
    blaming: pos ~
     (assuming the contract is correct)

If specified, source-location-expr indicates the source location
reported by contract violations.  The expression must produce a srcloc
structure, syntax object, #f, or a list or vector in the format accepted
by the third argument to datum->syntax.

7. Building New Contract Combinators

 (require racket/contract/combinator) package: base ~

                                        *make-contract*
(make-contract [#:name name                            ~ ~
                #:first-order test                     ~
                #:val-first-projection val-first-proj  ~
                #:projection proj                      ~
                #:stronger stronger                    ~
                #:list-contract? is-list-contract?])   ~
 -> contract?
  name : any/c = 'anonymous-contract ~
  test : (-> any/c any/c) = (λ (x) #t) ~
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~
       = (λ (b)
           (λ (x)
             (if (test x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~
  is-list-contract? : boolean? = #f ~
(make-chaperone-contract                                        
                         [#:name name                            ~
                          #:first-order test                     ~
                          #:val-first-projection val-first-proj  ~
                          #:projection proj                      ~
                          #:stronger stronger                    ~
                          #:list-contract? is-list-contract?])   ~
 -> chaperone-contract?
  name : any/c = 'anonymous-chaperone-contract ~
  test : (-> any/c any/c) = (λ (x) #t) ~
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~
       = (λ (b)
           (λ (x)
             (if (test x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~
  is-list-contract? : boolean? = #f ~
(make-flat-contract [#:name name                            ~
                     #:first-order test                     ~
                     #:val-first-projection val-first-proj  ~
                     #:projection proj                      ~
                     #:stronger stronger                    ~
                     #:list-contract? is-list-contract?])   ~
 -> flat-contract?
  name : any/c = 'anonymous-flat-contract ~
  test : (-> any/c any/c) = (λ (x) #t) ~
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  proj : (-> blame? (-> any/c any/c)) ~
       = (λ (b)
           (λ (x)
             (if (test x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e") ~
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f ~
  is-list-contract? : boolean? = #f ~

The precise details of the val-first-projection argument are subject to
change. (Probably also the default values of the project arguments will
change.

These functions build simple higher-order contracts, chaperone
contracts, and flat contracts, respectively.  They both take the same
set of three optional arguments: a name, a first-order predicate, and a
blame-tracking projection.

The name argument is any value to be rendered using display to describe
the contract when a violation occurs.  The default name for simple
higher-order contracts is anonymous-contract, for chaperone contracts is
anonymous-chaperone-contract, and for flat contracts is
anonymous-flat-contract.

The first-order predicate test can be used to determine which values the
contract applies to; usually, this is the set of values for which the
contract fails immediately without any higher-order wrapping.  This test
is used by contract-first-order-passes?, and indirectly by or/c to
determine which of multiple higher-order contracts to wrap a value with.
The default test accepts any value.

The projection proj defines the behavior of applying the contract.  It
is a curried function of two arguments: the first application accepts a
blame object, and the second accepts a value to protect with the
contract.  The projection must either produce the value, suitably
wrapped to enforce any higher-order aspects of the contract, or signal a
contract violation using raise-blame-error.  The default projection
produces an error when the first-order test fails, and produces the
value unchanged otherwise.

Projections for chaperone contracts must produce a value that passes
chaperone-of? when compared with the original, uncontracted value.
Projections for flat contracts must fail precisely when the first-order
test does, and must produce the input value unchanged otherwise.
Applying a flat contract may result in either an application of the
predicate, or the projection, or both; therefore, the two must be
consistent.  The existence of a separate projection only serves to
provide more specific error messages.  Most flat contracts do not need
to supply an explicit projection.

The stronger argument is used to implement contract-stronger?. The first
argument is always the contract itself and the second argument is
whatever was passed as the second argument to contract-stronger?.

The is-list-contract? argument is used by the list-contract? predicate
to determine if this is a contract that accepts only list? values.

Examples:
  (define int/c
    (make-flat-contract #:name 'int/c #:first-order integer?)) ~


  > (contract int/c 1 'positive 'negative)
  1
  > (contract int/c "not one" 'positive 'negative)
  eval:4:0: broke its contract
    promised: int/c ~
    produced: "not one" ~
    in: int/c ~
    contract from: positive ~
    blaming: positive ~
     (assuming the contract is correct)
  > (int/c 1)
  #t
  > (int/c "not one")
  #f
  (define int->int/c
    (make-contract
     #:name 'int->int/c ~
     #:first-order ~
     (λ (x) (and (procedure? x) (procedure-arity-includes? x 1)))
     #:projection ~
     (λ (b)
       (let ([domain ((contract-projection int/c) (blame-swap b))]
             [range ((contract-projection int/c) b)])
         (λ (f)
           (if (and (procedure? f) (procedure-arity-includes? f 1))
             (λ (x) (range (f (domain x))))
             (raise-blame-error
              b f
              '(expected "a function of one argument" 'given: "~e") ~
              f)))))))


  > (contract int->int/c "not fun" 'positive 'negative)
  regexp-match: contract violation
    expected: (or/c string? bytes? path? input-port?) ~
    given: ''given: ~
    argument position: 2nd ~
    other arguments...: ~
     #rx"^[\n ]"
  (define halve
    (contract int->int/c (λ (x) (/ x 2)) 'positive 'negative))


  > (halve 2)
  1
  > (halve 1/2)
  halve: contract violation
    expected: int/c ~
    given: 1/2 ~
    in: ... ~
        int->int/c
    contract from: positive ~
    blaming: negative ~
     (assuming the contract is correct)
  > (halve 1)
  halve: broke its contract
    promised: int/c ~
    produced: 1/2 ~
    in: ... ~
        int->int/c
    contract from: positive ~
    blaming: positive ~
     (assuming the contract is correct)

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
argument.

                                        *build-compound-type-name*
(build-compound-type-name c/s ...) -> any ~
  c/s : any/c ~

Produces an S-expression to be used as a name for a contract. The
arguments should be either contracts or symbols. It wraps parentheses
around its arguments and extracts the names from any contracts it is
supplied with.

                                        *coerce-contract*
(coerce-contract id x) -> contract? ~
  id : symbol? ~
  x : any/c ~

Converts a regular Racket value into an instance of a contract struct,
converting it according to the description of contracts.

If x is not one of the coercible values, coerce-contract signals an
error, using the first argument in the error message.

                                        *coerce-contracts*
(coerce-contracts id xs) -> (listof contract?) ~
  id : symbol? ~
  xs : (listof any/c) ~

Coerces all of the arguments in ’xs’ into contracts (via
coerce-contract/f) and signals an error if any of them are not
contracts.  The error messages assume that the function named by id got
xs as its entire argument list.

                                        *coerce-chaperone-contract*
(coerce-chaperone-contract id x) -> chaperone-contract? ~
  id : symbol? ~
  x : any/c ~

Like coerce-contract, but requires the result to be a chaperone
contract, not an arbitrary contract.

                                        *coerce-chaperone-contracts*
(coerce-chaperone-contracts id x) -> (listof chaperone-contract?) ~
  id : symbol? ~
  x : (listof any/c) ~

Like coerce-contracts, but requires the results to be chaperone
contracts, not arbitrary contracts.

                                        *coerce-flat-contract*
(coerce-flat-contract id x) -> flat-contract? ~
  id : symbol? ~
  x : any/c ~

Like coerce-contract, but requires the result to be a flat contract, not
an arbitrary contract.

                                        *coerce-flat-contracts*
(coerce-flat-contracts id x) -> (listof flat-contract?) ~
  id : symbol? ~
  x : (listof any/c) ~

Like coerce-contracts, but requires the results to be flat contracts,
not arbitrary contracts.

                                        *coerce-contract/f*
(coerce-contract/f x) -> (or/c contract? #f) ~
  x : any/c ~

Like coerce-contract, but returns #f if the value cannot be coerced to a
contract.

                                        *get/build-val-first-projection*
(get/build-val-first-projection c) ~
 -> (-> contract? blame? (-> any/c (-> any/c any/c)))
  c : contract? ~

Returns the val-first projection for c.

See make-contract for more details.

Added in version 6.1.1.5 of package base.

7.1. Blame Objects

                                        *blame?*
(blame? x) -> boolean? ~
  x : any/c ~

This predicate recognizes blame objects.

                                        *blame-add-context*
(blame-add-context  blame                      ~
                    context                   
                   [#:important important      ~
                    #:swap? swap?])       -> blame? ~
  blame : blame? ~
  context : (or/c string? #f) ~
  important : (or/c string? #f) = #f ~
  swap? : boolean? = #f ~

Adds some context information to blame error messages   that explicates
which portion of the contract failed   (and that gets rendered by
raise-blame-error).

The context argument describes one layer of the   portion of the
contract, typically of the form "the 1st argument of"   (in the case of
a function contract)   or "a conjunct of" (in the case of an and/c
contract).

For example, consider this contract violation:

  > (define/contract f
      (list/c (-> integer? integer?))
      (list (λ (x) x)))

  > ((car f) #f)
  f: contract violation
    expected: integer? ~
    given: #f ~
    in: the 1st argument of ~
        the 1st element of
        (list/c (-> integer? integer?))
    contract from: (definition f) ~
    blaming: top-level ~
     (assuming the contract is correct)
    at: eval:2.0 ~

It shows that the portion of the contract being violated is the first
occurrence of integer?, because the -> and the list/c combinators each
internally called blame-add-context to add the two lines following “in”
in the error message.

The important argument is used to build the beginning part of the
contract violation. The last important argument that gets added to a
blame object is used. The class/c contract adds an important argument,
as does the -> contract (when -> knows the name of the function getting
the contract).

The swap? argument has the effect of calling blame-swap while adding the
layer of context, but without creating an extra blame object.

The context information recorded in blame structs keeps track of
combinators that do not add information, and add the string "..." for
them, so programmers at least see that there was some context they are
missing in the error messages. Accordingly, since there are combinators
that should not add any context (e.g., recursive-contract), passing #f
as the context string argument avoids adding the "..." string.

                                        *blame-positive*
(blame-positive b) -> any/c ~
  b : blame? ~
(blame-negative b) -> any/c
  b : blame? ~

These functions produce printable descriptions of the current positive
and negative parties of a blame object.

                                        *blame-contract*
(blame-contract b) -> any/c ~
  b : blame? ~

This function produces a description of the contract associated with a
blame object (the result of contract-name).

                                        *blame-value*
(blame-value b) -> any/c ~
  b : blame? ~

This function produces the name of the value to which the contract was
applied, or #f if no name was provided.

                                        *blame-source*
(blame-source b) -> srcloc? ~
  b : blame? ~

This function produces the source location associated with a contract.
If no source location was provided, all fields of the structure will
contain #f.

                                        *blame-swap*
(blame-swap b) -> blame? ~
  b : blame? ~

This function swaps the positive and negative parties of a blame object.
(See also blame-add-context.)

                                        *blame-original?*
(blame-original? b) -> boolean? ~
  b : blame? ~
(blame-swapped? b) -> boolean?
  b : blame? ~

These functions report whether the current blame of a given blame object
is the same as in the original contract invocation (possibly of a
compound contract containing the current one), or swapped, respectively.
Each is the negation of the other; both are provided for convenience and
clarity.

                                        *blame-replace-negative*
(blame-replace-negative b neg) -> blame? ~
  b : blame? ~
  neg : any/c ~

Produces a blame? object just like b except            that it uses neg
instead of the negative            position b has.

                                        *blame-update*
(blame-update b pos neg) -> blame? ~
  b : blame? ~
  pos : any/c ~
  neg : any/c ~

Produces a blame? object just like b except            that it adds pos
and neg to the positive            and negative parties of b
respectively.

                                        *raise-blame-error*
(raise-blame-error b x fmt v ...) -> none/c ~
  b : blame? ~
  x : any/c ~
  fmt : (or/c string? ~
              (listof (or/c string?
                            'given 'given: ~
                            'expected 'expected:))) ~
  v : any/c ~

Signals a contract violation.  The first argument, b, records the
current blame information, including positive and negative parties, the
name of the contract, the name of the value, and the source location of
the contract application.  The second argument, x, is the value that
failed to satisfy the contract.

The remaining arguments are a format string, fmt, and its arguments, v
..., specifying an error message specific to the precise violation.

If fmt is a list, then the elements are concatenated together (with
spaces added, unless there are already spaces at the ends of the
strings), after first replacing symbols with either their string
counterparts, or replacing 'given with "produced" and 'expected with
"promised", depending on whether or not the b argument has been swapped
or not (see blame-swap).

If fmt contains the symbols 'given: or 'expected:, they are replaced
like 'given: and 'expected: are, but the replacements are prefixed with
the string "\n  " to conform to the error message guidelines in
[missing].

                                        *struct*
(struct exn:fail:contract:blame exn:fail:contract (object) ~ ~
    #:extra-constructor-name make-exn:fail:contract:blame) ~
  object : blame? ~

This exception is raised to signal a contract error. The object field
contains a blame object associated with a contract violation.

                                        *current-blame-format*
(current-blame-format) -> (-> blame? any/c string? string?) ~
(current-blame-format proc) -> void?
  proc : (-> blame? any/c string? string?) ~

A parameter that is used when constructing a contract violation error.
Its value is procedure that accepts three arguments:

* the blame object for the violation,

* the value that the contract applies to, and

* a message indicating the kind of violation.

The procedure then returns a string that is put into the contract error
message. Note that the value is often already included in the message
that indicates the violation.

Examples:
  (define (show-blame-error blame value message)
    (string-append
     "Contract Violation!\n"
     (format "Guilty Party: ~a\n" (blame-positive blame)) ~
     (format "Innocent Party: ~a\n" (blame-negative blame)) ~
     (format "Contracted Value Name: ~a\n" (blame-value blame)) ~
     (format "Contract Location: ~s\n" (blame-source blame)) ~
     (format "Contract Name: ~a\n" (blame-contract blame)) ~
     (format "Offending Value: ~s\n" value) ~
     (format "Offense: ~a\n" message))) ~


  > (current-blame-format show-blame-error)

  > (define/contract (f x)
      (-> integer? integer?)
      (/ x 2))

  > (f 2)
  1
  > (f 1)
  Contract Violation!
  Guilty Party: (function f)
  Innocent Party: top-level
  Contracted Value Name: f
  Contract Location: #(struct:srcloc eval 4 0 4 1)
  Contract Name: (-> integer? integer?)
  Offending Value: 1/2
  Offense: promised: integer?
    produced: 1/2 ~

  > (f 1/2)
  Contract Violation!
  Guilty Party: top-level
  Innocent Party: (function f)
  Contracted Value Name: f
  Contract Location: #(struct:srcloc eval 4 0 4 1)
  Contract Name: (-> integer? integer?)
  Offending Value: 1/2
  Offense: expected: integer?
    given: 1/2 ~


7.2. Contracts as structs

The property prop:contract allows arbitrary structures to act as
contracts.  The property prop:chaperone-contract allows arbitrary
structures to act as chaperone contracts; prop:chaperone-contract
inherits prop:contract, so chaperone contract structures may also act as
general contracts.  The property prop:flat-contract allows arbitrary
structures to act as flat contracts; prop:flat-contract inherits both
prop:chaperone-contract and prop:procedure, so flat contract structures
may also act as chaperone contracts, as general contracts, and as
predicate procedures.

prop:contract : struct-type-property? ~
prop:chaperone-contract : struct-type-property? ~
prop:flat-contract : struct-type-property? ~

These properties declare structures to be contracts or flat contracts,
respectively.  The value for prop:contract must be a contract property
constructed by build-contract-property; likewise, the value for
prop:chaperone-contract must be a chaperone contract property
constructed by build-chaperone-contract-property and the value for
prop:flat-contract must be a flat contract property constructed by
build-flat-contract-property.

prop:contracted : struct-type-property? ~
impersonator-prop:contracted : impersonator-property? ~

These properties attach a contract value to the protected structure,
chaperone, or impersonator value.  The function has-contract? returns #t
for values that have one of these properties, and value-contract
extracts the value from the property (which is expected to be the
contract on the value).

prop:blame : struct-type-property? ~
impersonator-prop:blame : impersonator-property? ~

These properties attach a blame information to the protected structure,
chaperone, or impersonator value.  The function blame-contract? returns
#t for values that have one of these properties, and blame-contract
extracts the value from the property (which is expected to be the blame
record for the contract on the value).

                                        *build-flat-contract-property*
(build-flat-contract-property                                         ~
                              [#:name get-name                        ~
                               #:first-order get-first-order          ~
                               #:val-first-projection val-first-proj  ~
                               #:projection get-projection            ~
                               #:stronger stronger                    ~
                               #:generate generate                    ~
                               #:exercise exercise                    ~
                               #:list-contract? is-list-contract?])   ~
 -> flat-contract-property?
  get-name : (-> contract? any/c) ~
           = (λ (c) 'anonymous-flat-contract)
  get-first-order : (-> contract? (-> any/c boolean?)) ~
                  = (λ (c) (λ (x) #t))
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~
  generate : (->i ([c contract?]) ~
                  ([generator
                    (c)
                    (-> (and/c positive? real?)
                        (or/c (-> (or/c contract-random-generate-fail? c))
                              #f))]))
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?]) ~
                  ([result
                    (c)
                    (-> (and/c positive? real?)
                        (values
                         (-> c void?)
                         (listof contract?)))]))
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~
(build-chaperone-contract-property                                        
                                   [#:name get-name                        ~
                                    #:first-order get-first-order          ~
                                    #:val-first-projection val-first-proj  ~
                                    #:projection get-projection            ~
                                    #:stronger stronger                    ~
                                    #:generate generate                    ~
                                    #:exercise exercise                    ~
                                    #:list-contract? is-list-contract?])   ~
 -> chaperone-contract-property?
  get-name : (-> contract? any/c) ~
           = (λ (c) 'anonymous-chaperone-contract)
  get-first-order : (-> contract? (-> any/c boolean?)) ~
                  = (λ (c) (λ (x) #t))
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~
  generate : (->i ([c contract?]) ~
                  ([generator
                    (c)
                    (-> (and/c positive? real?)
                        (or/c (-> (or/c contract-random-generate-fail? c))
                              #f))]))
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?]) ~
                  ([result
                    (c)
                    (-> (and/c positive? real?)
                        (values
                         (-> c void?)
                         (listof contract?)))]))
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~
(build-contract-property                                        
                         [#:name get-name                        ~
                          #:first-order get-first-order          ~
                          #:val-first-projection val-first-proj  ~
                          #:projection get-projection            ~
                          #:stronger stronger                    ~
                          #:generate generate                    ~
                          #:exercise exercise                    ~
                          #:list-contract? is-list-contract?])   ~
 -> contract-property?
  get-name : (-> contract? any/c) = (λ (c) 'anonymous-contract) ~
  get-first-order : (-> contract? (-> any/c boolean?)) ~
                  = (λ (c) (λ (x) #t))
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c)))) ~
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c))) ~
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e") ~
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f ~
  generate : (->i ([c contract?]) ~
                  ([generator
                    (c)
                    (-> (and/c positive? real?)
                        (or/c (-> (or/c contract-random-generate-fail? c))
                              #f))]))
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?]) ~
                  ([result
                    (c)
                    (-> (and/c positive? real?)
                        (values
                         (-> c void?)
                         (listof contract?)))]))
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f) ~

The precise details of the val-first-projection argument are subject to
change. (Probably also the default values of the project arguments will
change.)

These functions build the arguments for prop:contract,
prop:chaperone-contract, and prop:flat-contract, respectively.

A contract property specifies the behavior of a structure when used as a
contract.  It is specified in terms of five accessors: get-name, which
produces a description to write as part of a contract violation;
get-first-order, which produces a first-order predicate to be used by
contract-first-order-passes?; get-projection, which produces a
blame-tracking projection defining the behavior of the contract;
stronger, which is a predicate that determines whether this contract
(passed in the first argument) is stronger than some other contract
(passed in the second argument); generate, which returns a thunk that
generates random values matching the contract (using
contract-random-generate-fail) to indicate failure) or #f to indicate
that random generation for this contract isn’t supported; exercise,
which returns a function that exercises values matching the contract
(e.g., if it is a function contract, it may call the function) and a
list of contracts whose values will be generated by this process; and
is-flat-contract?, which is used by flat-contract? to determine if this
contract accepts only list?s.

These accessors are passed as (optional) keyword arguments to
build-contract-property, and are applied to instances of the appropriate
structure type by the contract system.  Their results are used
analogously to the arguments of make-contract.

A chaperone contract property specifies the behavior of a structure when
used as a chaperone contract.  It is specified using
build-chaperone-contract-property, and accepts exactly the same set of
arguments as build-contract-property.  The only difference is that the
projection accessor must return a value that passes chaperone-of? when
compared with the original, uncontracted value.

A flat contract property specifies the behavior of a structure when used
as a flat contract.  It is specified using build-flat-contract-property,
and accepts exactly the same set of arguments as
build-contract-property.  The only difference is that the projection
accessor is expected not to wrap its argument in a higher-order fashion,
analogous to the constraint on projections in make-flat-contract.

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
argument. Changed in version 6.1.1.4: Allow generate to return
contract-random-generate-fail

                                        *contract-property?*
(contract-property? x) -> boolean? ~
  x : any/c ~
(chaperone-contract-property? x) -> boolean?
  x : any/c ~
(flat-contract-property? x) -> boolean?
  x : any/c ~

These predicates detect whether a value is a contract property,
chaperone contract property, or a flat contract property, respectively.

7.3. Obligation Information in Check Syntax

Check Syntax in DrRacket shows obligation information for contracts
according to syntax-propertys that the contract combinators leave in the
expanded form of the program. These properties indicate where contracts
appear in the source and where the positive and negative positions of
the contracts appear.

To make Check Syntax show obligation information for your new contract
combinators, use the following properties (some helper macros and
functions are below):

* 'racket/contract:contract : ~
  (vector/c symbol? (listof syntax?) (listof syntax?))

  This property should be attached to the result of a transformer  that
  implements a contract combinator. It signals to Check Syntax  that
  this is where a contract begins.

  The first element in the  vector should be a unique (in the sense of
  eq?) value  that Check Syntax can use a tag to match up this contract
  with  its subpieces (specified by the two following syntax
  properties).

  The second and third elements of the vector are syntax objects  from
  pieces of the contract, and Check Syntax will color them.  The first
  list should contain subparts that are the responsibility  of parties
  (typically modules) that provide implementations of the contract.  The
  second list should contain subparts that are the  responsibility of
  clients.

  For example, in (->* () #:pre #t any/c #:post #t),  the ->* and the
  #:post should be in the first  list and #:pre in the second list.

* 'racket/contract:negative-position : symbol? ~

  This property should be attached to sub-expressions of  a contract
  combinator that are expected to be other contracts.  The value of the
  property should be the key (the first element from  the vector for the
  'racket/contract:contract property)  indicating which contract this
  is.

  This property should be used when the expression’s value is a contract
  that clients are responsible for.

* 'racket/contract:positive-position : symbol? ~

  This form is just like 'racket/contract:negative-position,  except
  that it should be used when the expression’s value is  a contract that
  the original party should be responsible for.

* 'racket/contract:contract-on-boundary : symbol? ~

  The presence of this property tells Check Syntax that it  should start
  coloring from this point. It expects the expression  to be a contract
  (and, thus, to have the 'racket/contract:contract property);  this
  property indicates that this contract is on a (module) boundary.

  (The value of the property is not used.)

* 'racket/contract:internal-contract : symbol? ~

  Like 'racket/contract:contract-on-boundary, the presence  of this
  property triggers coloring, but this is meant for use  when the party
  (module) containing the contract (regardless of whether  or not this
  module exports anything matching the contract)  can be blamed for
  violating the contract. This comes into play  for ->i contracts, since
  the contract itself has  access to values under contract via the
  dependency.

                                        *define/final-prop*
(define/final-prop header body ...) ~
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)

The same as (define header body ...), except that uses of
main-id in the header are annotated             with the
'racket/contract:contract property             (as above).

                                        *define/subexpression-pos-prop*
(define/subexpression-pos-prop header body ...) ~
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)

The same as (define header body ...), except that uses of
main-id in the header are annotated             with the
'racket/contract:contract property             (as above) and arguments
are annotated with the             'racket/contract:positive-position
property.

7.4. Utilities for Building New Combinators

                                        *contract-stronger?*
(contract-stronger? x y) -> boolean? ~
  x : contract? ~
  y : contract? ~

Returns #t if the contract x accepts either fewer   or the same number
of values as y does.

This function is conservative, so it may return #f when   x does, in
fact, accept fewer values.

Examples:
  > (contract-stronger? integer? integer?)
  #t
  > (contract-stronger? (between/c 25 75) (between/c 0 100))
  #t
  > (contract-stronger? (between/c 0 100) (between/c 25 75))
  #f
  > (contract-stronger? (between/c -10 0) (between/c 0 10))
  #f
  > (contract-stronger? (λ (x) (and (real? x) (<= x (random 10))))
                        (λ (x) (and (real? x) (<= x (+ 100 (random 10))))))
  #f

                                        *contract-first-order-passes?*
(contract-first-order-passes? contract v) -> boolean? ~
  contract : contract? ~
  v : any/c ~

Returns a boolean indicating whether the first-order tests of contract
pass for v.

If it returns #f, the contract is guaranteed not to hold for that value;
if it returns #t, the contract may or may not hold. If the contract is a
first-order contract, a result of #t guarantees that the contract holds.

                                        *contract-first-order*
(contract-first-order c) -> (-> any/c boolean?) ~
  c : contract? ~

Produces the first-order test used by or/c to match values to
higher-order contracts.

8. Contract Utilities

                                        *contract?*
(contract? v) -> boolean? ~
  v : any/c ~

Returns #t if its argument is a contract (i.e., constructed with one of
the combinators described in this section or a value that can be used as
a contract) and #f otherwise.

                                        *chaperone-contract?*
(chaperone-contract? v) -> boolean? ~
  v : any/c ~

Returns #t if its argument is a contract that guarantees that it returns
a value which passes chaperone-of? when compared to the original,
uncontracted value.

                                        *impersonator-contract?*
(impersonator-contract? v) -> boolean? ~
  v : any/c ~

Returns #t if its argument is a contract that is not a chaperone
contract nor a flat contract.

                                        *flat-contract?*
(flat-contract? v) -> boolean? ~
  v : any/c ~

Returns #t when its argument is a contract that can be checked
immediately (unlike, say, a function contract).

For example, flat-contract constructs flat contracts from predicates,
and symbols, booleans, numbers, and other ordinary Racket values (that
are defined as contracts) are also flat contracts.

                                        *list-contract?*
(list-contract? v) -> boolean? ~
  v : any/c ~

Recognizes certain contract? values that accept list?s.

A list contract is one that insists that its argument is a list?,
meaning that the value cannot be cyclic and must either be the empty
list or a pair constructed with cons and another list.

Added in version 6.0.1.13 of package base.

                                        *contract-name*
(contract-name c) -> any/c ~
  c : contract? ~

Produces the name used to describe the contract in error messages.

                                        *value-contract*
(value-contract v) -> contract? ~
  v : has-contract? ~

Returns the contract attached to v, if recorded. Otherwise it returns
#f.

To support value-contract and value-contract in your own contract
combinators, use prop:contracted or impersonator-prop:contracted.

                                        *has-contract?*
(has-contract? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a value that has a recorded contract attached to it.

                                        *value-blame*
(value-blame v) -> (or/c blame? #f) ~
  v : has-blame? ~

Returns the blame object for the contract attached to v, if recorded.
Otherwise it returns #f.

To support value-contract and value-blame in your own contract
combinators, use prop:blame or impersonator-prop:blame.

Added in version 6.0.1.12 of package base.

                                        *has-blame?*
(has-blame? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a value that has a contract with blame information
attached to it.

Added in version 6.0.1.12 of package base.

                                        *contract-projection*
(contract-projection c) -> (-> blame? (-> any/c any/c)) ~
  c : contract? ~

Produces the projection defining a contract’s behavior on protected
values.

                                        *make-none/c*
(make-none/c sexp-name) -> contract? ~
  sexp-name : any/c ~

Makes a contract that accepts no values, and reports the name sexp-name
when signaling a contract violation.

                                        *recursive-contract*
(recursive-contract contract-expr) ~
(recursive-contract contract-expr #:list-contract?) ~
(recursive-contract contract-expr type)
(recursive-contract contract-expr type #:list-contract?) ~

Delays the evaluation of its argument until the contract is checked,
making recursive contracts possible.  If type is given, it describes the
expected type of contract and must be one of the keywords
#:impersonator, #:chaperone, or #:flat.  If type is not given, an
impersonator contract is created.

If #:list-contract? is returned, then the result is a list-contract? and
the contract-expr must evaluate to a list-contract?.

Changed in version 6.0.1.13 of package base: Added the #:list-contract?
argument.

                                        *opt/c*
(opt/c contract-expr maybe-name) ~
 
maybe-name = 
           | #:error-name id ~

This optimizes its argument contract expression by traversing its syntax
and, for known contract combinators, fuses them into a single contract
combinator that avoids as much allocation overhead as possible. The
result is a contract that should behave identically to its argument,
except faster.

If the #:error-name argument is present, and contract-expr evaluates to
a non-contract expression, then opt/c raises an error using id as the
name of the primitive, instead of using the name opt/c.

Examples:
  > (define/contract (f x)
      (opt/c '(not-a-contract))
      x)
  opt/c: contract violation
    expected: contract? ~
    given: '(not-a-contract) ~
  > (define/contract (f x)
      (opt/c '(not-a-contract) #:error-name define/contract) ~
      x)
  define/contract: contract violation
    expected: contract? ~
    given: '(not-a-contract) ~

                                        *define-opt/c*
(define-opt/c (id id ...) expr) ~

This defines a recursive contract and simultaneously optimizes it.
Semantically, it behaves just as if the -opt/c were not present,
defining a function on contracts (except that the body expression must
return a contract). But, it also optimizes that contract definition,
avoiding extra allocation, much like opt/c does.

For example,

  (define-contract-struct bt (val left right))
   
  (define-opt/c (bst-between/c lo hi)
    (or/c null?
          (bt/c [val (real-in lo hi)]
                [left (val) (bst-between/c lo val)]
                [right (val) (bst-between/c val hi)])))
   
  (define bst/c (bst-between/c -inf.0 +inf.0))

defines the bst/c contract that checks the binary search tree invariant.
Removing the -opt/c also makes a binary search tree contract, but one
that is (approximately) 20 times slower.

contract-continuation-mark-key : continuation-mark-key? ~

Key used by continuation marks that are present during contract
checking. The value of these marks are the blame objects that correspond
to the contract currently being checked.

                                        *contract-custom-write-property-proc*
(contract-custom-write-property-proc c          ~
                                     p         
                                     mode) -> void?
  c : contract? ~
  p : output-port? ~
  mode : (or/c #f #t 0 1) ~

Prints c to p using the contract’s name.

Added in version 6.1.1.5 of package base.

9. racket/contract/base

 (require racket/contract/base) package: base ~

The racket/contract/base module provides a subset of the exports of
racket/contract module. In particular, it contains everything in the

* Data-structure Contracts

* Function Contracts

* Attaching Contracts to Values and

* Contract Utilities sections.

Unfortunately, using racket/contract/base does not yield a significantly
smaller memory footprint than racket/contract, but it can still be
useful to add contracts to libraries that racket/contract uses to
implement some of the more sophisticated parts of the contract system.

10. Legacy Contracts

                                        *make-proj-contract*
(make-proj-contract name proj first-order) -> contract? ~
  name : any/c ~
  proj : (or/c (-> any/c ~
                   any/c
                   (list/c any/c any/c)
                   contact?
                   (-> any/c any/c))
               (-> any/c
                   any/c
                   (list/c any/c any/c)
                   contact?
                   boolean?
                   (-> any/c any/c)))
  first-order : (-> any/c boolean?) ~

Builds a contract using an old interface.

Modulo errors, it is equivalent to:

  (make-contract
   #:name name ~
   #:first-order first-order ~
   #:projection ~
   (cond
     [(procedure-arity-includes? proj 5)
      (lambda (blame)
        (proj (blame-positive blame)
              (blame-negative blame)
              (list (blame-source blame) (blame-value blame))
              (blame-contract blame)
              (not (blame-swapped? blame))))]
     [(procedure-arity-includes? proj 4)
      (lambda (blame)
        (proj (blame-positive blame)
              (blame-negative blame)
              (list (blame-source blame) (blame-value blame))
              (blame-contract blame)))]))

                                        *raise-contract-error*
(raise-contract-error val           ~
                      src          
                      pos          
                      name         
                      fmt          
                      arg ...) -> any/c
  val : any/c ~
  src : any/c ~
  pos : any/c ~
  name : any/c ~
  fmt : string? ~
  arg : any/c ~

Calls raise-blame-error after building a blame struct from the val, src,
pos, and name arguments. The fmt string and following arguments are
passed to format and used as the string in the error message.

                                        *contract-proc*
(contract-proc c) ~
 -> (->* (symbol? symbol? (or/c syntax? (list/c any/c any/c)))
         (boolean?)
         (-> any/c any))
  c : contract? ~

Constructs an old-style projection from a contract.

The resulting function accepts the information that is in a blame struct
and returns a projection function that checks the contract.

11. Random generation

                                        *contract-random-generate*
(contract-random-generate ctc [fuel fail]) -> any/c ~
  ctc : contract? ~
  fuel : 5 = exact-nonnegative-integer? ~
  fail : (or/c #f (-> any) (-> boolean? any)) = #f ~

Attempts to randomly generate a value which will match the contract. The
fuel argument limits how hard the generator tries to generate a value
matching the contract and is a rough limit of the size of the resulting
value.

The generator may fail to generate a value, either because some
contracts do not have corresponding generators (for example, not all
predicates have generators) or because there is not enough fuel. In
either case, the function fail is invoked. If fail accepts an argument,
it is called with #t when there is no generator for ctc and called with
#f when there is a generator, but the generator ended up returning
contract-random-generate-fail.

Changed in version 6.1.1.5 of package base: Allow fail to accept a
boolean.

                                        *contract-exercise*
(contract-exercise val ...+) -> void? ~
  val : any/c ~

Attempts to get the vals to break their contracts (if any).

Uses value-contract to determine if any of the vals have a contract and,
for those that do, uses information about the contract’s shape to poke
and prod at the value. For example, if the value is function, it will
use the contract to tell it what arguments to supply to the value.

                                        *contract-random-generate/choose*
(contract-random-generate/choose c fuel) -> (or/c #f (-> c)) ~
  c : contract? ~
  fuel : exact-nonnegative-integer? ~

This function is like contract-random-generate, but it is intended to
be used with combinators that generate values based on sub-contracts
they have. It cannot be called, except during contract   generation. It
will never fail, but it might escape back to an enclosing   call or to
the original call to contract-random-generate.

It chooses one of several possible generation strategies, and thus it
may not   actually use the generator associated with c, but might
instead   use a stashed value that matches c that it knows about via
contract-random-generate-stash.

Added in version 6.1.1.5 of package base.

contract-random-generate-fail : contract-random-generate-fail? ~

An atomic value that is used to indicate that a generator   failed to
generate a value.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-fail?*
(contract-random-generate-fail? v) -> boolean? ~
  v : any/c ~

A predicate to recognize contract-random-generate-fail.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-env?*
(contract-random-generate-env? v) -> boolean? ~
  v : any/c ~

Recognizes contract generation environments.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-stash*
(contract-random-generate-stash env c v) -> void? ~
  env : contract-random-generate-env? ~
  c : contract? ~
  v : c ~

This should be called with values that the program under   test supplies
during contract generation. For example, when   (-> (-> integer?
integer?) integer?) is generated,   it may call its argument function.
That argument function may   return an integer and, if so, that integer
should be saved by   calling contract-random-generate-stash, so it can
be used by other integer generators.

Added in version 6.1.1.5 of package base.

                                        *contract-random-generate-get-current-environment*
(contract-random-generate-get-current-environment) ~
 -> contract-random-generate-env?

Returns the environment currently being for generation. This function
can be called only during the dynamic extent of contract generation.
It is intended to be grabbed during the construction of a contract
generator and then used with contract-random-generate-stash   while
generation is happening.

Added in version 6.1.1.5 of package base.
