Ports

Ports produce and/or consume bytes. An input port produces bytes, while
an output port consumes bytes (and some ports are both input ports and
output ports). When an input port is provided to a character-based
operation, the bytes are decoded to a character, and character-based
output operations similarly encode the character to bytes; see Encodings
and Locales. In addition to bytes and characters encoded as bytes, some
ports can produce and/or consume arbitrary values as special results.

When a port corresponds to a file, network connection, or some other
system resource, it must be explicitly closed via close-input-port or
close-output-port (or indirectly via custodian-shutdown-all) to release
low-level resources associated with the port. For any kind of port,
after it is closed, attempting to read from or write to the port raises
exn:fail.

Data produced by a input port can be read or peeked. When data is read,
it is considered consumed and removed from the port’s stream. When data
is peeked, it remains in the port’s stream to be returned again by the
next read or peek. Previously peeked data can be committed, which causes
the data to be removed from the port as for a read in a way that can be
synchronized with other attempts to peek or read through a
synchronizable event. Both read and peek operations are normally
blocking, in the sense that the read or peek operation does not complete
until data is available from the port; non-blocking variants of read and
peek operations are also available.

The global variable eof is bound to the end-of-file value, and
eof-object? returns #t only when applied to this value. Reading from a
port produces an end-of-file result when the port has no more data, but
some ports may also return end-of-file mid-stream. For example, a port
connected to a Unix terminal returns an end-of-file when the user types
control-D; if the user provides more input, the port returns additional
bytes after the end-of-file.

Every port has a name, as reported by object-name. The name can be any
value, and it is used mostly for error-reporting purposes. The
read-syntax procedure uses the name of an input port as the default
source location for the syntax objects that it produces.

A port can be used as a synchronizable event. An input port is ready for
synchronization when read-byte would not block, and an output port is
ready for synchronization when write-bytes-avail would not block or when
the port contains buffered characters and write-bytes-avail* can flush
part of the buffer (although write-bytes-avail might block). A value
that can act as both an input port and an output port acts as an input
port for a synchronizable event. The synchronization result of a port is
the port itself.

    1 Encodings and Locales

    2 Managing Ports

    3 Port Buffers and Positions

    4 Counting Positions, Lines, and Columns

    5 File Ports

    6 String Ports

    7 Pipes

    8 Structures as Ports

    9 Custom Ports

    10 More Port Constructors, Procedures, and Events
      10.1 Port String and List Conversions
      10.2 Creating Ports
      10.3 Port Events
      10.4 Copying Streams

1. Encodings and Locales

When a port is provided to a character-based operation, such as
read-char or read, the port’s bytes are read and interpreted as a UTF-8
encoding of characters. Thus, reading a single character may require
reading multiple bytes, and a procedure like char-ready? may need to
peek several bytes into the stream to determine whether a character is
available. In the case of a byte stream that does not correspond to a
valid UTF-8 encoding, functions such as read-char may need to peek one
byte ahead in the stream to discover that the stream is not a valid
encoding.

When an input port produces a sequence of bytes that is not a valid
UTF-8 encoding in a character-reading context, then bytes that
constitute an invalid sequence are converted to the character #\uFFFD.
Specifically, bytes 255 and 254 are always converted to #\uFFFD, bytes
in the range 192 to 253 produce #\uFFFD when they are not followed by
bytes that form a valid UTF-8 encoding, and bytes in the range 128 to
191 are converted to #\uFFFD when they are not part of a valid encoding
that was started by a preceding byte in the range 192 to 253. To put it
another way, when reading a sequence of bytes as characters, a minimal
set of bytes are changed to the encoding of #\uFFFD so that the entire
sequence of bytes is a valid UTF-8 encoding.

See [missing] for procedures that facilitate conversions using UTF-8 or
other encodings. See also reencode-input-port and reencode-output-port
for obtaining a UTF-8-based port from one that uses a different encoding
of characters.

A locale captures information about a user’s language-specific
interpretation of character sequences. In particular, a locale
determines how strings are “alphabetized,” how a lowercase character is
converted to an uppercase character, and how strings are compared
without regard to case. String operations such as string-ci=? are not
sensitive to the current locale, but operations such as
string-locale-ci=? (see [missing]) produce results consistent with the
current locale.

A locale also designates a particular encoding of code-point sequences
into byte sequences. Racket generally ignores this aspect of the locale,
with a few notable exceptions: command-line arguments passed to Racket
as byte strings are converted to character strings using the locale’s
encoding; command-line strings passed as byte strings to other processes
(through subprocess) are converted to byte strings using the locale’s
encoding; environment variables are converted to and from strings using
the locale’s encoding; filesystem paths are converted to and from
strings (for display purposes) using the locale’s encoding; and,
finally, Racket provides functions such as string->bytes/locale to
specifically invoke a locale-specific encoding.

A Unix user selects a locale by setting environment variables, such as
LC_ALL. On Windows and Mac OS, the operating system provides other
mechanisms for setting the locale. Within Racket, the current locale can
be changed by setting the current-locale parameter. The locale name
within Racket is a string, and the available locale names depend on the
platform and its configuration, but the "" locale means the current
user’s default locale; on Windows and Mac OS, the encoding for "" is
always UTF-8, and locale-sensitive operations use the operating system’s
native interface. (In particular, setting the LC_ALL and LC_CTYPE
environment variables does not affect the locale "" on Mac OS. Use
getenv and current-locale to explicitly install the
environment-specified locale, if desired.) Setting the current locale to
#f makes locale-sensitive operations locale-insensitive, which means
using the Unicode mapping for case operations and using UTF-8 for
encoding.

                                        *current-locale*
(current-locale) -> (or/c string? #f) ~
(current-locale locale) -> void?
  locale : (or/c string? #f) ~ ~

A parameter that determines the current locale for procedures such as
string-locale-ci=?.

When locale sensitivity is disabled by setting the parameter to #f,
strings are compared, etc., in a fully portable manner, which is the
same as the standard procedures. Otherwise, strings are interpreted
according to a locale setting (in the sense of the C library’s
setlocale). The "" locale is always an alias for the current machine’s
default locale, and it is the default.  The "C" locale is also always
available; setting the locale to "C" is the same as disabling locale
sensitivity with #f only when string operations are restricted to the
first 128 characters. Other locale names are platform-specific.

String or character printing with write is not affected by the
parameter, and neither are symbol case or regular expressions (see
[missing]).

2. Managing Ports

                                        *input-port?*
(input-port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is an input port, #f otherwise.

                                        *output-port?*
(output-port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is an output port, #f otherwise.

                                        *port?*
(port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if either (input-port? v) or (output-port? v) is #t, #f
otherwise.

                                        *close-input-port*
(close-input-port in) -> void? ~
  in : input-port? ~ ~

Closes the input port in. For some kinds of ports, closing the port
releases lower-level resources, such as a file handle. If the port is
already closed, close-input-port has no effect.

                                        *close-output-port*
(close-output-port out) -> void? ~
  out : output-port? ~ ~

Closes the output port out. For some kinds of ports, closing the port
releases lower-level resources, such as a file handle. Also, if the port
is buffered, closing may first flush the port before closing it, and
this flushing process can block. If the port is already closed,
close-output-port has no effect.

                                        *port-closed?*
(port-closed? port) -> boolean? ~
  port : port? ~ ~

Returns #t if the input or output port port is closed, #f otherwise.

                                        *port-closed-evt*
(port-closed-evt port) -> evt? ~
  port : port? ~ ~

Return a synchronizable event that becomes ready for synchronization
when port is closed. The synchronization result of a port-closed event
is the port-closed event itself.

                                        *current-input-port*
(current-input-port) -> input-port? ~
(current-input-port in) -> void?
  in : input-port? ~ ~

A parameter that determines a default input port for many operations,
such as read.

                                        *current-output-port*
(current-output-port) -> output-port? ~
(current-output-port out) -> void?
  out : output-port? ~ ~

A parameter that determines a default output port for many operations,
such as write.

                                        *current-error-port*
(current-error-port) -> output-port? ~
(current-error-port out) -> void?
  out : output-port? ~ ~

A parameter that determines an output port that is typically used for
errors and logging. For example, the default error display handler
writes to this port.

                                        *file-stream-port?*
(file-stream-port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a file-stream port (see File Ports), #f otherwise.

Changed in version 7.2.0.5: Extended file-stream-port? to any value,
instead of resticting the domain to ports

                                        *terminal-port?*
(terminal-port? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a port that is attached to an interactive terminal,
#f otherwise.

Changed in version 7.2.0.5: Extended terminal-port? to any value,
instead of resticting the domain to ports

                                        *port-waiting-peer?*
(port-waiting-peer? port) -> boolean? ~
  port : port? ~ ~

Returns #t if port is not ready for reading or writing because it is
waiting for a peer process to complete a stream construction, #f
otherwise.

On Unix and Mac OS, opening a fifo for output creates a peer-waiting
port if no reader for the same fifo is already opened. In that case, the
output port is not ready for writing until a reader is opened; that is,
write opertaions will block. Use sync if necessary to wait until writing
will not block—that is, until the read end of the fifo is opened.

Added in version 7.4.0.5.

eof : eof-object? ~ ~

A value (distinct from all other values) that represents an end-of-file.

                                        *eof-object?*
(eof-object? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is eof, #f otherwise.

3. Port Buffers and Positions

Some ports—especially those that read from and write to files—are
internally buffered:

* An input port is typically block-buffered by default, which means that
  on any read, the buffer is filled with immediately-available bytes to
  speed up future reads. Thus, if a file is modified between a pair of
  reads to the file, the second read can produce stale data. Calling
  file-position to set an input port’s file position flushes its buffer.

* An output port is typically block-buffered by default, though a
  terminal output port is line-buffered, and the initial error output
  port is unbuffered.  An output buffer is filled with a sequence of
  written bytes to be committed as a group, either when the buffer is
  full (in block mode), when a newline is written (in line mode), when
  the port is closed via close-output-port, or when a flush is
  explicitly requested via a procedure like flush-output.

If a port supports buffering, its buffer mode can be changed via
file-stream-buffer-mode (even if the port is not a file-stream port).

For an input port, peeking always places peeked bytes into the port’s
buffer, even when the port’s buffer mode is 'none; furthermore, on some
platforms, testing the port for input (via char-ready? or sync) may be
implemented with a peek. If an input port’s buffer mode is 'none, then
at most one byte is read for read-bytes-avail!*, read-bytes-avail!,
peek-bytes-avail!*, or peek-bytes-avail!; if any bytes are buffered in
the port (e.g., to satisfy a previous peek), the procedures may access
multiple buffered bytes, but no further bytes are read.

In addition, the initial current output and error ports are
automatically flushed when read, read-line, read-bytes, read-string,
etc., are performed on the initial standard input port; more precisely,
flushing is performed by the default port read handler (see
port-read-handler).

                                        *flush-output*
(flush-output [out]) -> void? ~
  out : output-port? = (current-output-port) ~ ~

Forces all buffered data in the given output port to be physically
written. Only file-stream ports, TCP ports, and custom ports (see Custom
Ports) use buffers; when called on a port without a buffer, flush-output
has no effect.

If flushing a file-stream port or TCP port encounters an error when
writing, then all buffered bytes in the port are discarded.
Consequently, a further attempt to flush or close the port will not
fail.

Changed in version 7.4.0.10: Consistently, discard buffered bytes on
error, including in a TCP output port.

                                        *file-stream-buffer-mode*
(file-stream-buffer-mode port) -> (or/c 'none 'line 'block #f) ~
  port : port? ~ ~
(file-stream-buffer-mode port mode) -> void?
  port : port? ~ ~
  mode : (or/c 'none 'line 'block) ~ ~

Gets or sets the buffer mode for port, if possible. File-stream ports
support setting the buffer mode, TCP ports (see [missing]) support
setting and getting the buffer mode, and custom ports (see Custom Ports)
may support getting and setting buffer modes.

If mode is provided, it must be one of 'none, 'line (output only), or
'block, and the port’s buffering is set accordingly. If the port does
not support setting the mode, the exn:fail exception is raised.

If mode is not provided, the current mode is returned, or #f is returned
if the mode cannot be determined. If port is an input port and mode is
'line, the exn:fail:contract exception is raised.

                                        *file-position*
(file-position port) -> exact-nonnegative-integer? ~
  port : port? ~ ~
(file-position port pos) -> void?
  port : port? ~ ~
  pos : (or/c exact-nonnegative-integer? eof-object?) ~ ~

Returns or sets the current read/write position of port.

Calling file-position without a position on a port other than a
file-stream port or string port returns the number of bytes that have
been read from that port if the position is known (see Counting
Positions, Lines, and Columns), otherwise the exn:fail:filesystem
exception is raised.

For file-stream ports and string ports, the position-setting variant
sets the read/write position to pos relative to the beginning of the
file or (byte) string if pos is a number, or to the current end of the
file or (byte) string if pos is eof. In position-setting mode,
file-position raises the exn:fail:contract exception for port kinds
other than file-stream ports and string ports. Furthermore, not all
file-stream ports support setting the position; if file-position is
called with a position argument on such a file-stream port, the
exn:fail:filesystem exception is raised.

When file-position sets the position pos beyond the current size of an
output file or (byte) string, the file/string is enlarged to size pos
and the new region is filled with 0 bytes; in the case of a file. In the
case of a file output port, the file might not be enlarged until more
data is written to the file; in that case, beware that writing to a file
opened in 'append mode on Unix and Mac OS will reset the file pointer to
the end of a file before each write, which defeats file enlargement via
file-position. If pos is beyond the end of an input file or (byte)
string, then reading thereafter returns eof without changing the port’s
position.

When changing the file position for an output port, the port is first
flushed if its buffer is not empty. Similarly, setting the position for
an input port clears the port’s buffer (even if the new position is the
same as the old position). However, although input and output ports
produced by open-input-output-file share the file position, setting the
position via one port does not flush the other port’s buffer.

                                        *file-position**
(file-position* port) -> (or/c exact-nonnegative-integer? #f) ~
  port : port? ~ ~

Like file-position on a single argument, but returns #f if the position
is not known.

                                        *file-truncate*
(file-truncate port size) -> void? ~
  port : (and/c output-port? file-stream-port?) ~ ~
  size : exact-nonnegative-integer? ~ ~

Sets the size of the file written by port to size, assuming that the
port is associated to a file whose size can be set.

The new file size can be either larger or smaller than its current size,
but “truncate” in this function’s name reflects that it is normally used
to decrease the size of a file, since writing to a file or using
file-position can extend a file’s size.

4. Counting Positions, Lines, and Columns

By default, Racket keeps track of the position in a port as the number
of bytes that have been read from or written to any port (independent of
the read/write position, which is accessed or changed with
file-position). Optionally, however, Racket can track the position in
terms of characters (after UTF-8 decoding), instead of bytes, and it can
track line locations and column locations; this optional tracking must
be specifically enabled for a port via port-count-lines! or the
port-count-lines-enabled parameter. Position, line, and column locations
for a port are used by read-syntax. Position and line locations are
numbered from 1; column locations are numbered from 0.

When counting lines, Racket treats linefeed, return, and return-linefeed
combinations as a line terminator and as a single position (on all
platforms). Each tab advances the column count to one before the next
multiple of 8. When a sequence of bytes in the range 128 to 253 forms a
UTF-8 encoding of a character, the position/column is incremented once
for each byte, and then decremented appropriately when a complete
encoding sequence is discovered. See also Ports for more information on
UTF-8 decoding for ports.

A position is known for any port as long as its value can be expressed
as a fixnum (which is more than enough tracking for realistic
applications in, say, syntax-error reporting).  If the position for a
port exceeds the value of the largest fixnum, then the position for the
port becomes unknown, and line and column tacking is disabled.
Return-linefeed combinations are treated as a single character position
only when line and column counting is enabled.

Custom ports can define their own counting functions, which are not
subject to the rules above, except that the counting functions are
invoked only when tracking is specifically enabled with
port-count-lines!.

                                        *port-count-lines!*
(port-count-lines! port) -> void? ~
  port : port? ~ ~

Turns on line location and column location counting for a port. Counting
can be turned on at any time, though generally it is turned on before
any data is read from or written to a port. At the point that line
counting is turned on, port-next-location typically starts reporting as
its last result (one more than) the number of characters read since line
counting was enabled, instead of (one more than) bytes read since the
port was opened.

When a port is created, if the value of the port-count-lines-enabled
parameter is true, then line counting is automatically enabled for the
port. Line counting cannot be disabled for a port after it is enabled.

                                        *port-counts-lines?*
(port-counts-lines? port) -> boolean? ~
  port : port? ~ ~

Returns #t if line location and column location counting has been
enabled for port, #f otherwise.

                                        *port-next-location*
(port-next-location port) ~
 -> (or/c exact-positive-integer? #f)
    (or/c exact-nonnegative-integer? #f)
    (or/c exact-positive-integer? #f)
  port : port? ~ ~

Returns three values: an integer or #f for the line number of the next
read/written item, an integer or #f for the next item’s column, and an
integer or #f for the next item’s position. The next column and position
normally increase as bytes are read from or written to the port, but if
line/character counting is enabled for port, the column and position
results can decrease after reading or writing a byte that ends a UTF-8
encoding sequence.

If line counting is not enabled for a port, than the first two results
are #f, and the last result is one more than the number of bytes read so
far. At the point when line counting is enabled, the first two results
typically become non-#f, and last result starts reporting characters
instead of bytes, typically starting from the point when line counting
is enabled.

Even with line counting enabled, a port may return #f values if it
somehow cannot keep track of lines, columns, or positions.

                                        *set-port-next-location!*
(set-port-next-location! port           ~
                         line          
                         column        
                         position) -> void?
  port : port? ~ ~
  line : (or/c exact-positive-integer? #f) ~ ~
  column : (or/c exact-nonnegative-integer? #f) ~ ~
  position : (or/c exact-positive-integer? #f) ~ ~

Sets the next line, column, and position for port. If line counting has
not been enabled for port or if port is a custom port that defines its
own counting function, then set-port-next-location! has no effect.

                                        *port-count-lines-enabled*
(port-count-lines-enabled) -> boolean? ~
(port-count-lines-enabled on?) -> void?
  on? : any/c ~ ~

A parameter that determines whether line counting is enabled
automatically for newly created ports. The default value is #f.

5. File Ports

A port created by open-input-file, open-output-file, subprocess, and
related functions is a file-stream port.  The initial input, output, and
error ports in racket are also file-stream ports. The file-stream-port?
predicate recognizes file-stream ports.

When an input or output file-stream port is created, it is placed into
the management of the current custodian (see [missing]). In the case of
an output port, a flush callback is registered with the current plumber
to flush the port.

                                        *open-input-file*
(open-input-file  path                             ~
                 [#:mode mode-flag                 ~ ~
                  #:for-module? for-module?]) -> input-port? ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  for-module? : any/c = #f ~ ~

Opens the file specified by path for input. The mode-flag argument
specifies how the file’s bytes are translated on input:

* 'binary — bytes are returned from the port exactly as they are read
  from the file.

* 'text — return and linefeed bytes (10 and 13) as read from the file
  are filtered by the port in a platform specific manner:

  * Unix and Mac OS: no filtering occurs.

  * Windows: a return-linefeed combination from a file is returned by
    the port as a single linefeed; no filtering occurs for return bytes
    that are not followed by a linefeed, or for a linefeed that is not
    preceded by a return.

On Windows, 'text mode works only with regular files; attempting to use
'text with other kinds of files triggers an exn:fail:filesystem
exception.

Otherwise, the file specified by path need not be a regular file. It
might be a device that is connected through the filesystem, such as
"aux" on Windows or "/dev/null" on Unix. In all cases, the port is
buffered by default.

The port produced by open-input-file should be explicitly closed, either
though close-input-port or indirectly via custodian-shutdown-all, to
release the OS-level file handle. The input port will not be closed
automatically if it is otherwise available for garbage collection (see
[missing]); a will could be associated with an input port to close it
more automatically (see [missing]).

A path value that is the cleansed version of path is used as the name of
the opened port.

If opening the file fails due to an error in the filesystem, then
exn:fail:filesystem:errno exception is raised—as long as for-module? is
#f, current-module-path-for-load has a non-#f value, or the filesystem
error is not recognized as a file-not-found error. Otherwise, when
for-module? is true, current-module-path-for-load has a non-#f value,
and the filesystem error is recognized as a file-not-found error, then
the raised exception is either exn:fail:syntax:missing-module (if the
value of current-module-path-for-load is a syntax object) or
exn:fail:filesystem:missing-module (otherwise).

Changed in version 6.0.1.6: Added #:for-module?.

Examples:

  > (with-output-to-file some-file
      (lambda () (printf "hello world")))
  > (define in (open-input-file some-file))
  > (read-string 11 in)
  "hello world"
  > (close-input-port in)

                                        *open-output-file*
(open-output-file  path                        ~
                  [#:mode mode-flag            ~ ~
                   #:exists exists-flag]) -> output-port? ~ ~
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update 'can-update ~ ~
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error

Opens the file specified by path for output. The mode-flag argument
specifies how bytes written to the port are translated when written to
the file:

* 'binary — bytes are written to the file exactly as written to the
  port.

* 'text — on Windows, a linefeed byte (10) written to the port is
  translated to a return-linefeed combination in the file; no filtering
  occurs for returns.

On Windows, 'text mode works only with regular files; attempting to use
'text with other kinds of files triggers an exn:fail:filesystem
exception.

The exists-flag argument specifies how to handle/require files that
already exist:

* 'error — raise exn:fail:filesystem if the file exists.

* 'replace — remove the old file, if it exists, and write a new one.

* 'truncate — remove all old data, if the file exists.

* 'must-truncate — remove all old data in an existing file; if the file
  does not exist, the exn:fail:filesystem exception is raised.

* 'truncate/replace — try 'truncate; if it fails (perhaps due to file
  permissions), try 'replace.

* 'update — open an existing file without truncating it; if the file
  does not exist, the exn:fail:filesystem exception is raised. Use
  file-position to change the current read/write position.

* 'can-update — open an existing file without truncating it, or create
  the file if it does not exist.

* 'append — append to the end of the file, whether it already exists or
  not; on Windows, 'append is equivalent to 'update, except that the
  file is not required to exist, and the file position is immediately
  set to the end of the file after opening it.

The file specified by path need not be a regular file. It might be a
device that is connected through the filesystem, such as "aux" on
Windows or "/dev/null" on Unix. The output port is block-buffered by
default, unless the file corresponds to a terminal, in which case it is
line-buffered by default. On Unix and Mac OS, if the file is a fifo,
then the port will block for writing until a reader for the fifo is
available; see also port-waiting-peer?.

The port produced by open-output-file should be explicitly closed,
either though close-output-port or indirectly via
custodian-shutdown-all, to release the OS-level file handle. The output
port will not be closed automatically if it is otherwise available for
garbage collection (see [missing]); a will could be associated with an
output port to close it more automatically (see [missing]).

A path value that is the cleansed version of path is used as the name of
the opened port.

If opening the file fails due to an error in the underlying filesystem
then exn:fail:filesystem:errno exception is raised.

Examples:

  > (define out (open-output-file some-file))
  > (write "hello world" out)
  > (close-output-port out)

Changed in version 6.9.0.6: On Unix and Mac OS, make 'truncate/replace
replace on a permission error. On Windows, make 'replace always replace
instead truncating like 'truncate/replace. Changed in version 7.4.0.5:
Changed handling of a fifo on Unix and Mac OS to make the port block for
output until the fifo has a reader.

                                        *open-input-output-file*
(open-input-output-file  path                    ~
                        [#:mode mode-flag        ~ ~
                         #:exists exists-flag])  ~ ~
 -> input-port? output-port?
  path : path-string? ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update 'can-update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like open-output-file, but producing two values: an input port and an
output port. The two ports are connected in that they share the
underlying file descriptor. This procedure is intended for use with
special devices that can be opened by only one process, such as "COM1"
in Windows. For regular files, sharing the file descriptor can be
confusing. For example, using one port does not automatically flush the
other port’s buffer, and reading or writing in one port moves the file
position (if any) for the other port. For regular files, use separate
open-input-file and open-output-file calls to avoid confusion.

                                        *call-with-input-file*
(call-with-input-file  path                    ~
                       proc                   
                      [#:mode mode-flag]) -> any ~ ~
  path : path-string? ~ ~
  proc : (input-port? . -> . any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Calls open-input-file with the path and mode-flag arguments, and passes
the resulting port to proc. The result of proc is the result of the
call-with-input-file call, but the newly opened port is closed when proc
returns.

Examples:

  > (with-output-to-file some-file
      (lambda () (printf "text in a file")))
  > (call-with-input-file some-file
      (lambda (in) (read-string 14 in)))
  "text in a file"

                                        *call-with-output-file*
(call-with-output-file  path                        ~
                        proc                       
                       [#:mode mode-flag            ~ ~
                        #:exists exists-flag]) -> any ~ ~
  path : path-string? ~ ~
  proc : (output-port? . -> . any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Analogous to call-with-input-file, but passing path, mode-flag and
exists-flag to open-output-file.

Examples:

  > (call-with-output-file some-file
      (lambda (out)
        (write 'hello out)))
  > (call-with-input-file some-file
      (lambda (in)
        (read-string 5 in)))
  "hello"

                                        *call-with-input-file**
(call-with-input-file*  path                    ~
                        proc                   
                       [#:mode mode-flag]) -> any ~ ~
  path : path-string? ~ ~
  proc : (input-port? . -> . any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Like call-with-input-file, but the newly opened port is closed whenever
control escapes the dynamic extent of the call-with-input-file* call,
whether through proc’s return, a continuation application, or a
prompt-based abort.

                                        *call-with-output-file**
(call-with-output-file*  path                        ~
                         proc                       
                        [#:mode mode-flag            ~ ~
                         #:exists exists-flag]) -> any ~ ~
  path : path-string? ~ ~
  proc : (output-port? . -> . any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like call-with-output-file, but the newly opened port is closed whenever
control escapes the dynamic extent of the call-with-output-file* call,
whether through proc’s return, a continuation application, or a
prompt-based abort.

                                        *with-input-from-file*
(with-input-from-file  path                    ~
                       thunk                  
                      [#:mode mode-flag]) -> any ~ ~
  path : path-string? ~ ~
  thunk : (-> any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~

Like call-with-input-file*, but instead of passing the newly opened port
to the given procedure argument, the port is installed as the current
input port (see current-input-port) using parameterize around the call
to thunk.

Examples:

  > (with-output-to-file some-file
      (lambda () (printf "hello")))
  > (with-input-from-file some-file
      (lambda () (read-string 5)))
  "hello"

                                        *with-output-to-file*
(with-output-to-file  path                        ~
                      thunk                      
                     [#:mode mode-flag            ~ ~
                      #:exists exists-flag]) -> any ~ ~
  path : path-string? ~ ~
  thunk : (-> any) ~ ~
  mode-flag : (or/c 'binary 'text) = 'binary ~ ~
  exists-flag : (or/c 'error 'append 'update ~ ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like call-with-output-file*, but instead of passing the newly opened
port to the given procedure argument, the port is installed as the
current output port (see current-output-port) using parameterize around
the call to thunk.

Examples:

  > (with-output-to-file some-file
      (lambda () (printf "hello")))
  > (with-input-from-file some-file
      (lambda () (read-string 5)))
  "hello"

                                        *port-try-file-lock?*
(port-try-file-lock? port mode) -> boolean? ~
  port : file-stream-port? ~ ~
  mode : (or/c 'shared 'exclusive) ~ ~

Attempts to acquire a lock on the file using the current platform’s
facilities for file locking. Multiple processes can acquire a 'shared
lock on a file, but at most one process can hold an 'exclusive lock, and
'shared and 'exclusive locks are mutually exclusive. When mode is
'shared, then port must be an input port; when mode is 'exclusive, then
port must be an output port.

The result is #t if the requested lock is acquired, #f otherwise. When a
lock is acquired, it is held until either it is released with
port-file-unlock or the port is closed (perhaps because the process
terminates).

Depending on the platform, locks may be merely advisory (i.e., locks
affect only the ability of processes to acquire locks) or they may
correspond to mandatory locks that prevent reads and writes to the
locked file. Specifically, locks are mandatory on Windows and advisory
on other platforms. Multiple tries for a 'shared lock on a single port
can succeed; on Unix and Mac OS, a single port-file-unlock release the
lock, while on other Windows, a port-file-unlock is needed for each
successful port-try-file-lock?. On Unix and Mac OS, multiple tries for a
'exclusive lock can succeed and a single port-file-unlock releases the
lock, while on Windows, a try for an 'exclusive lock fails for a given
port if the port already holds the lock.

A lock acquired for an input port from open-input-output-file can be
released through port-file-unlock on the corresponding output port, and
vice versa. If the output port from open-input-output-file holds an
'exclusive lock, the corresponding input port can still acquire a
'shared lock, even multiple times; on Windows, a port-file-unlock is
needed for each successful lock try, while a single port-file-unlock
balances the lock tries on Unix and Mac OS. A 'shared lock on an input
port can be upgraded to an 'exclusive lock through the corresponding
output port on Unix and Mac OS, in which case a single port-file-unlock
(on either port) releases the lock, while such upgrades are not allowed
on Windows.

Locking is normally supported only for file ports, and attempting to
acquire a lock with other kinds of file-stream ports raises an
exn:fail:filesystem exception.

                                        *port-file-unlock*
(port-file-unlock port) -> void? ~
  port : file-stream-port? ~ ~

Releases a lock held by the current process on the file of port.

                                        *port-file-identity*
(port-file-identity port) -> exact-positive-integer? ~
  port : file-stream-port? ~ ~

Returns a number that represents the identity of the device and file
read or written by port. For two ports whose open times overlap, the
result of port-file-identity is the same for both ports if and only if
the ports access the same device and file. For ports whose open times do
not overlap, no guarantee can be provided for the port identities (even
if the ports actually access the same file)—except as can be inferred
through relationships with other ports. If port is closed, the exn:fail
exception is raised.  On Windows 95, 98, and Me, if port is connected to
a pipe instead of a file, the exn:fail:filesystem exception is raised.

Examples:

  > (define file1 (open-output-file some-file))
  > (define file2 (open-output-file some-other-file))
  > (port-file-identity file1)
  37797378607030872834203
  > (port-file-identity file2)
  37797378607030872840167
  > (close-output-port file1)
  > (close-output-port file2)

6. String Ports

A string port reads or writes from a byte string. An input string port
can be created from either a byte string or a string; in the latter
case, the string is effectively converted to a byte string using
string->bytes/utf-8. An output string port collects output into a byte
string, but get-output-string conveniently converts the accumulated
bytes to a string.

Input and output string ports do not need to be explicitly closed. The
file-position procedure works for string ports in position-setting mode.

+[missing] also provides information on bytestrings.

                                        *string-port?*
(string-port? p) -> boolean? ~
  p : port? ~ ~

Returns #t if p is a string port, #f otherwise.

Added in version 6.0.1.6.

                                        *open-input-bytes*
(open-input-bytes bstr [name]) -> (and/c input-port? string-port?) ~
  bstr : bytes? ~ ~
  name : any/c = 'string ~ ~

Creates an input string port that reads characters from bstr (see
[missing]). Modifying bstr afterward does not affect the byte stream
produced by the port. The optional name argument is used as the name for
the returned port.

Examples:

  > (define sp (open-input-bytes #"(apples 42 day)"))
  > (define sexp1 (read sp))
  > (first sexp1)
  'apples
  > (rest sexp1)
  '(42 day)
  > (read-line (open-input-bytes
                #"the cow jumped over the moon\nthe little dog\n"))
  "the cow jumped over the moon"

+[missing] also provides information on strings.

                                        *open-input-string*
(open-input-string str [name]) -> (and/c input-port? string-port?) ~
  str : string? ~ ~
  name : any/c = 'string ~ ~

Creates an input string port that reads bytes from the UTF-8 encoding
(see Encodings and Locales) of str. The optional name argument is used
as the name for the returned port.

Examples:

  > (define sp (open-input-string "(λ (x) x)"))
  > (read sp)
  '(λ (x) x)
  > (define names (open-input-string "Günter Harder\nFrédéric Paulin\n"))
  > (read-line names)
  "Günter Harder"
  > (read-line names)
  "Frédéric Paulin"

                                        *open-output-bytes*
(open-output-bytes [name]) -> (and/c output-port? string-port?) ~
  name : any/c = 'string ~ ~

Creates an output string port that accumulates the output into a byte
string. The optional name argument is used as the name for the returned
port.

Examples:

  > (define op1 (open-output-bytes))
  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op1)
  > (get-output-bytes op1)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (define op2 (open-output-bytes))
  > (write "Hi " op2)
  > (write "there" op2)
  > (get-output-bytes op2)
  #"\"Hi \"\"there\""
  > (define op3 (open-output-bytes))
  > (write-bytes #"Hi " op3)
  3
  > (write-bytes #"there" op3)
  5
  > (get-output-bytes op3)
  #"Hi there"

                                        *open-output-string*
(open-output-string [name]) -> (and/c output-port? string-port?) ~
  name : any/c = 'string ~ ~

The same as open-output-bytes.

Examples:

  > (define op1 (open-output-string))
  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op1)
  > (get-output-string op1)
  "((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (define op2 (open-output-string))
  > (write "Hi " op2)
  > (write "there" op2)
  > (get-output-string op2)
  "\"Hi \"\"there\""
  > (define op3 (open-output-string))
  > (write-string "Hi " op3)
  3
  > (write-string "there" op3)
  5
  > (get-output-string op3)
  "Hi there"

                                        *get-output-bytes*
(get-output-bytes  out            ~
                  [reset?        
                   start-pos     
                   end-pos]) -> bytes?
  out : (and/c output-port? string-port?) ~ ~
  reset? : any/c = #f ~ ~
  start-pos : exact-nonnegative-integer? = 0 ~ ~
  end-pos : exact-nonnegative-integer? = #f ~ ~

Returns the bytes accumulated in the string port out so far in a freshly
allocated byte string (including any bytes written after the port’s
current position, if any). The out port must be an output string port
produced by open-output-bytes (or open-output-string) or a structure
whose prop:output-port property refers to such an output port
(transitively).

If reset? is true, then all bytes are removed from the port, and the
port’s position is reset to 0; if reset? is #f, then all bytes remain in
the port for further accumulation (so they are returned for later calls
to get-output-bytes or get-output-string), and the port’s position is
unchanged.

The start-pos and end-pos arguments specify the range of bytes in the
port to return; supplying start-pos and end-pos is the same as using
subbytes on the result of get-output-bytes, but supplying them to
get-output-bytes can avoid an allocation. The end-pos argument can be
#f, which corresponds to not passing a second argument to subbytes.

Examples:

  > (define op (open-output-bytes))
  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op)
  > (get-output-bytes op)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (get-output-bytes op #f 3 16)
  #" 2 3) (\"Tom\" "
  > (get-output-bytes op #t)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (get-output-bytes op)
  #""

                                        *get-output-string*
(get-output-string out) -> string? ~
  out : (and/c output-port? string-port?) ~ ~

Returns (bytes->string/utf-8 (get-output-bytes out) #\?).

Examples:

  > (define i (open-input-string "hello world"))
  > (define o (open-output-string))
  > (write (read i) o)
  > (get-output-string o)
  "hello"

7. Pipes

A Racket pipe is internal to Racket, and not related to OS-level pipes
for communicating between different processes.OS-level pipes may be
created by subprocess, opening an existing named file on a Unix
filesystem, or starting Racket with pipes for its original input,
output, or error port. Such pipes are file-stream ports, unlike the
pipes produced by make-pipe.

                                        *make-pipe*
(make-pipe [limit input-name output-name]) ~
 -> input-port? output-port?
  limit : exact-positive-integer? = #f ~ ~
  input-name : any/c = 'pipe ~ ~
  output-name : any/c = 'pipe ~ ~

Returns two port values: the first port is an input port and the second
is an output port. Data written to the output port is read from the
input port, with no intermediate buffering. Unlike some other kinds of
ports, pipe ports do not need to be explicitly closed to be reclaimed by
garbage collection.

If limit is #f, the new pipe holds an unlimited number of unread bytes
(i.e., limited only by the available memory). If limit is a positive
number, then the pipe will hold at most limit unread/unpeeked bytes;
writing to the pipe’s output port thereafter will block until a read or
peek from the input port makes more space available. (Peeks effectively
extend the port’s capacity until the peeked bytes are read.)

The optional input-name and output-name are used as the names for the
returned input and output ports, respectively.

                                        *pipe-content-length*
(pipe-content-length pipe-port) -> exact-nonnegative-integer? ~
  pipe-port : port? ~ ~

Returns the number of bytes contained in a pipe, where pipe-port is
either of the pipe’s ports produced by make-pipe. The pipe’s content
length counts all bytes that have been written to the pipe and not yet
read (though possibly peeked).

8. Structures as Ports

prop:input-port : struct-type-property? ~ ~

prop:output-port : struct-type-property? ~ ~

The prop:input-port and prop:output-port structure type properties
identify structure types whose instances can serve as input and output
ports, respectively.

Each property value can be either of the following:

* An input port (for prop:input-port) or output port (for
  prop:output-port): In this case, using the structure as port is
  equivalent to using the given input or output port.

* An exact, non-negative integer between 0 (inclusive) and the number of
  non-automatic fields in the structure type (exclusive, not counting
  supertype fields): The integer identifies a field in the structure,
  and the field must be designated as immutable. If the field contains
  an input port (for prop:input-port) or output port (for
  prop:output-port), the port is used. Otherwise, an empty string input
  port is used for prop:input-port, and a port that discards all data is
  used for prop:output-port.

Some procedures, such as file-position, work on both input and output
ports. When given an instance of a structure type with both the
prop:input-port and prop:output-port properties, the instance is used as
an input port.

9. Custom Ports

The make-input-port and make-output-port procedures create custom ports
with arbitrary control procedures (much like implementing a device
driver). Custom ports are mainly useful to obtain fine control over the
action of committing bytes as read or written.

                                        *make-input-port*
(make-input-port  name                  ~
                  read-in              
                  peek                 
                  close                
                 [get-progress-evt     
                  commit               
                  get-location         
                  count-lines!         
                  init-position        
                  buffer-mode])    -> input-port?
  name : any/c ~ ~
  read-in : (or/c ~ ~
             (bytes?
              . -> . (or/c exact-nonnegative-integer?
                           eof-object?
                           procedure?
                           evt?))
             input-port?)
  peek : (or/c ~ ~
          (bytes? exact-nonnegative-integer? (or/c evt? #f)
                  . -> . (or/c exact-nonnegative-integer?
                               eof-object?
                               procedure?
                               evt?
                               #f))
          input-port?)
  close : (-> any) ~ ~
  get-progress-evt : (or/c (-> evt?) #f) = #f ~ ~
  commit : (or/c (exact-positive-integer? evt? evt? . -> . any) ~ ~
                 #f)
         = #f
  get-location : (or/c ~ ~
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void ~ ~
  init-position : (or/c exact-positive-integer? ~ ~
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any) ~ ~
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f

Creates an input port, which is immediately open for reading. If close
procedure has no side effects, then the port need not be explicitly
closed. See also make-input-port/read-to-peek.

The arguments implement the port as follows:

* name — the name for the input port.

* read-in — either an input port, in which case reads     are redirected
  to the given port, or a procedure that takes a single     argument:
  a mutable byte string to receive read bytes. The procedure’s
  result is one of the following:

  * the number of bytes read, as an exact, non-negative integer;

  * eof;

  * a procedure of arity four (representing a “special” result, as
    discussed further below), but a procedure result is allowed only
    when peek is not #f;

  * a pipe input port that supplies bytes to be used as long as the pipe
    has content (see pipe-content-length) or until read-in or peek is
    called again; or

  * a synchronizable event (see [missing]) other than a pipe input port
    or procedure of arity four; the event becomes ready when the read is
    complete (roughly): the event’s value can be one of the above three
    results or another event like itself; in the last case, a reading
    process loops with sync until it gets a non-event result.

  The read-in procedure must not block indefinitely. If no     bytes are
  immediately available for reading, the read-in     must return 0 or an
  event, and preferably an event (to     avoid busy waits). The read-in
  should not return     0 (or an event whose value is 0) when data is
  available in the port, otherwise polling the port will behave
  incorrectly. An event result from an event can also break polling.

  If the result of a read-in call is not one of the above     values,
  the exn:fail:contract exception is raised. If a returned integer is
  larger than the supplied byte string’s length, the
  exn:fail:contract exception is raised. If peek is #f and     a
  procedure for a special result is returned,     the exn:fail:contract
  exception is raised.

  The read-in procedure can report an error by raising an     exception,
  but only if no bytes are read. Similarly, no bytes     should be read
  if eof, an event, or a procedure is     returned. In other words, no
  bytes should be lost due to spurious     exceptions or non-byte data.

  A port’s reading procedure may be called in multiple threads
  simultaneously (if the port is accessible in multiple threads),
  and the port is responsible for its own internal     synchronization.
  Note that improper implementation of such     synchronization
  mechanisms might cause a non-blocking read     procedure to block
  indefinitely.

  If the result is a pipe input port, then previous     get-progress-evt
  calls whose event is not yet ready must     have been the pipe input
  port itself. Furthermore,     get-progress-evt must continue to return
  the pipe as long     as it contains data, or until the read-in or
  peek-in procedure is called again (instead of using the     pipe, for
  whatever reason). If read-in or     peek-in is called, any previously
  associated pipe (as     returned by a previous call) is disassociated
  from the     port and is not in use by any other thread as a result of
  the     previous association.

  If peek, get-progress-evt, and     commit are all provided and
  non-#f, then the following is an acceptable implementation     of
  read-in:

    (lambda (bstr)
      (let* ([progress-evt (get-progress-evt)]
             [v (peek bstr 0 progress-evt)])
        (cond
         [(sync/timeout 0 progress-evt) 0] ; try again
         [(evt? v) (wrap-evt v (lambda (x) 0))] ; sync, try again
         [(and (number? v) (zero? v)) 0] ; try again
         [else
          (if (commit (if (number? v) v 1)
                          progress-evt
                          always-evt)
              v      ; got a result
              0)]))) ; try again

  An implementor may choose not to implement the peek,
  get-progress-evt, and commit     procedures, however, and even an
  implementor who does supply     them may provide a different read-in
  that uses a fast path for non-blocking reads.

  In an input port is provided for read-in, then an input port     must
  also be provided for peek.

* peek — either #f, an input port (in which case peeks are redirected to
  the given port), or a procedure that takes three arguments:

  * a mutable byte string to receive peeked bytes;

  * a non-negative number of bytes (or specials) to skip before peeking;
    and

  * either #f or a progress event produced by get-progress-evt.

  The results and conventions for peek are mostly the same  as for
  read-in. The main difference is in the handling of  the progress
  event, if it is not #f.  If the given  progress event becomes ready,
  the peek must abort any  skip attempts and not peek any values. In
  particular,  peek must not peek any values if the progress event is
  initially ready. If the port has been closed, the progress event
  should be ready, in which case peek should complete  (instead of
  failing because the port is closed).

  Unlike read-in, peek should produce  #f (or an event whose value is
  #f) if no bytes  were peeked because the progress event became ready.
  Like  read-in, a 0 result indicates that another  attempt is likely to
  succeed, so 0 is inappropriate when  the progress event is ready. Also
  like read-in,  peek must not block indefinitely.

  The skip count provided to peek is a number of bytes (or  specials)
  that must remain present in the  port—in addition to the peek
  results—when the peek results are  reported. If a progress event is
  supplied, then the peek is  effectively canceled when another process
  reads data before the  given number can be skipped. If a progress
  event is not supplied  and data is read, then the peek must
  effectively restart with the  original skip count.

  The system does not check that multiple peeks return consistent
  results, or that peeking and reading produce consistent results.

  If peek is #f, then peeking for the port is  implemented automatically
  in terms of reads, but with several  limitations. First, the automatic
  implementation is not  thread-safe. Second, the automatic
  implementation cannot handle  special results (non-byte and non-eof),
  so  read-in cannot return a procedure for a  special when peek is  #f.
  Finally, the automatic peek implementation is  incompatible with
  progress events, so if peek is  #f, then get-progress-evt and commit
  must  be #f. See also make-input-port/read-to-peek,  which implements
  peeking in terms of read-in without  these constraints.

  In an input port is provided for peek, then an input port  must also
  be provided for read-in.

* close — a procedure of zero arguments that is called to close the
  port. The port is not considered closed until the closing procedure
  returns. The port’s procedures will never be used again via the port
  after it is closed. However, the closing procedure can be called
  simultaneously in multiple threads (if the port is accessible in
  multiple threads), and it may be called during a call to the other
  procedures in another thread; in the latter case, any outstanding
  reads and peeks should be terminated with an error.

* get-progress-evt — either #f (the default), or a procedure that takes
  no arguments and returns an event. The event must become ready only
  after data is next read from the port or the port is closed. If the
  port is already closed, the event must be ready. After the event
  becomes ready, it must remain so. See the description of read-in for
  information about the allowed results of this function when read-in
  returns a pipe input port. See also semaphore-peek-evt, which is
  sometimes useful for implementing get-progress-evt.

  If get-progress-evt is #f, then port-provides-progress-evts? applied
  to the port will produce #f, and the port will not be a valid argument
  to port-progress-evt.

  The result event will not be exposed directly by port-progress-evt.
  Instead, it will be wrapped in an event for which progress-evt?
  returns true.

* commit — either #f (the default), or a procedure that takes three
  arguments:

  * an exact, positive integer kr;

  * a progress event produced by get-progress-evt;

  * an event, done, that is either a channel-put event, channel,
    semaphore, semaphore-peek event, always event, or never event.

  A commit corresponds to removing data from the stream  that was
  previously peeked, but only if no other process removed  data first.
  (The removed data does not need to be reported,  because it has been
  peeked already.) More precisely, assuming  that kp bytes, specials,
  and  mid-stream eofs have been previously peeked or skipped  at the
  start of the port’s stream, commit must satisfy  the following
  constraints:

  * It must return only when the commit is complete or when the given
    progress event becomes ready.

  * It must commit only if kp is positive.

  * If it commits, then it must do so with either kr items or kp items,
    whichever is smaller, and only if kp is positive.

  * It must never choose done in a synchronization after the given
    progress event is ready, or after done has been synchronized once.

  * It must not treat any data as read from the port unless done is
    chosen in a synchronization.

  * It must not block indefinitely if done is ready; it must return soon
    after the read completes or soon after the given progress event is
    ready, whichever is first.

  * It can report an error by raising an exception, but only if no data
    has been committed. In other words, no data should be lost due to an
    exception, including a break exception.

  * It must return a true value if data has been committed, #f
    otherwise. When it returns a value, the given progress event must be
    ready (perhaps because data has just been committed).

  * It should return a byte string as a true result when line counting
    is enabled and get-location is #f (so that line counting is
    implemented the default way); the result byte string represents the
    data that was committed for the purposes of character and line
    counting. If any other true result is returned when a byte string is
    expected, it is treated like a byte string where each byte
    corresponds to a non-newline character.

  * It must raise an exception if no data (including eof) has been
    peeked from the beginning of the port’s stream, or if it would have
    to block indefinitely to wait for the given progress event to become
    ready.

  A call to commit is parameterize-breaked to disable breaks.

* get-location — either #f (the default), or a procedure that takes no
  arguments and returns three values: the line number for the next item
  in the port’s stream (a positive number or #f), the column number for
  the next item in the port’s stream (a non-negative number or #f), and
  the position for the next item in the port’s stream (a positive number
  or #f). See also Counting Positions, Lines, and Columns.

  This procedure is called to implement port-next-location, but only if
  line counting is enabled for the port via port-count-lines! (in which
  case count-lines! is called). The read and read-syntax procedures
  assume that reading a non-whitespace character increments the column
  and position by one.

* count-lines! — a procedure of no arguments that is called if and when
  line counting is enabled for the port. The default procedure is void.

* init-position — normally an exact, positive integer that determines
  the position of the port’s first item, which is used by file-position
  or when line counting is not enabled for the port. The default is 1.
  If init-position is #f, the port is treated as having an unknown
  position. If init-position is a port, then the given port’s position
  is always used for the new port’s position. If init-position is a
  procedure, it is called as needed to obtain the port’s position.

* buffer-mode — either #f (the default) or a procedure that accepts zero
  or one arguments. If buffer-mode is #f, then the resulting port does
  not support a buffer-mode setting. Otherwise, the procedure is called
  with one symbol argument ('block or 'none) to set the buffer mode, and
  it is called with zero arguments to get the current buffer mode. In
  the latter case, the result must be 'block, 'none, or #f (unknown).
  See Port Buffers and Positions for more information on buffer modes.

“Special” results: When  read-in or peek (or an event produced by one of
these) returns a procedure, the procedure is used to obtain a  non-byte
result. (This non-byte result is not intended to  return a character or
eof; in particular, read-char  raises an exception if it encounters a
special-result procedure, even  if the procedure produces a byte.) A
special-result procedure must  accept four arguments that represent a
source location. The first  argument is #f when the special read is
triggered by read  or read/recursive.

The special-value procedure can return an arbitrary value, and it  will
be called zero or one times (not necessarily before further  reads or
peeks from the port). See [missing] for  more details on the procedure’s
result.

If read-in or peek returns a special  procedure when called by any
reading procedure other than  read, read-syntax, read-char-or-special,
peek-char-or-special, read-byte-or-special, or  peek-byte-or-special,
then the exn:fail:contract exception is raised.

Examples:

  ; A port with no input...
  ; Easy: (open-input-bytes #"") ~ ~
  ; Hard: ~ ~
  > (define /dev/null-in
      (make-input-port 'null
                       (lambda (s) eof)
                       (lambda (skip s progress-evt) eof)
                       void
                       (lambda () never-evt)
                       (lambda (k progress-evt done-evt)
                         (error "no successful peeks!"))))
  > (read-char /dev/null-in)
  #<eof>
  > (peek-char /dev/null-in)
  #<eof>
  > (read-byte-or-special /dev/null-in)
  #<eof>
  > (peek-byte-or-special /dev/null-in 100)
  #<eof>
  ; A port that produces a stream of 1s: ~ ~
  > (define infinite-ones
      (make-input-port
       'ones
       (lambda (s)
         (bytes-set! s 0 (char->integer #\1)) 1)
       #f
       void))
  > (read-string 5 infinite-ones)
  "11111"
  ; But we can't peek ahead arbitrarily far, because the
  ; automatic peek must record the skipped bytes, so
  ; we'd run out of memory.
  ; An infinite stream of 1s with a specific peek procedure: ~ ~
  > (define infinite-ones
      (let ([one! (lambda (s)
                    (bytes-set! s 0 (char->integer #\1)) 1)])
        (make-input-port
         'ones
         one!
         (lambda (s skip progress-evt) (one! s))
         void)))
  > (read-string 5 infinite-ones)
  "11111"
  ; Now we can peek ahead arbitrarily far: ~ ~
  > (peek-string 5 (expt 2 5000) infinite-ones)
  "11111"
  ; The port doesn't supply procedures to implement progress events: ~ ~
  > (port-provides-progress-evts? infinite-ones)
  #f
  > (port-progress-evt infinite-ones)
  port-progress-evt: port does not provide progress evts
    port: #<input-port:ones> ~ ~
  ; Non-byte port results: ~ ~
  > (define infinite-voids
      (make-input-port
       'voids
       (lambda (s) (lambda args 'void))
       (lambda (skip s evt) (lambda args 'void))
       void))
  > (read-char infinite-voids)
  read-char: non-character in an unsupported context
    port: #<input-port:voids> ~ ~
  > (read-char-or-special infinite-voids)
  'void
  ; This port produces 0, 1, 2, 0, 1, 2, etc., but it is not
  ; thread-safe, because multiple threads might read and change n.
  > (define mod3-cycle/one-thread
      (let* ([n 2]
             [mod! (lambda (s delta)
                     (bytes-set! s 0 (+ 48 (modulo (+ n delta) 3)))
                     1)])
        (make-input-port
         'mod3-cycle/not-thread-safe
         (lambda (s)
           (set! n (modulo (add1 n) 3))
           (mod! s 0))
         (lambda (s skip evt)
           (mod! s skip))
         void)))
  > (read-string 5 mod3-cycle/one-thread)
  "01201"
  > (peek-string 5 (expt 2 5000) mod3-cycle/one-thread)
  "20120"
  ; Same thing, but thread-safe and kill-safe, and with progress
  ; events. Only the server thread touches the stateful part
  ; directly. (See the output port examples for a simpler thread-safe
  ; example, but this one is more general.)
  > (define (make-mod3-cycle)
      (define read-req-ch (make-channel))
      (define peek-req-ch (make-channel))
      (define progress-req-ch (make-channel))
      (define commit-req-ch (make-channel))
      (define close-req-ch (make-channel))
      (define closed? #f)
      (define n 0)
      (define progress-sema #f)
      (define (mod! s delta)
        (bytes-set! s 0 (+ 48 (modulo (+ n delta) 3)))
        1)
      ; —————————————-
      ; The server has a list of outstanding commit requests,
      ;  and it also must service each port operation (read,
      ;  progress-evt, etc.)
      (define (serve commit-reqs response-evts)
        (apply
         sync
         (handle-evt read-req-ch
                     (handle-read commit-reqs response-evts))
         (handle-evt progress-req-ch
                     (handle-progress commit-reqs response-evts))
         (handle-evt commit-req-ch
                     (add-commit commit-reqs response-evts))
         (handle-evt close-req-ch
                     (handle-close commit-reqs response-evts))
         (append
          (map (make-handle-response commit-reqs response-evts)
               response-evts)
          (map (make-handle-commit commit-reqs response-evts)
               commit-reqs))))
      ; Read/peek request: fill in the string and commit ~ ~
      (define ((handle-read commit-reqs response-evts) r)
        (let ([s (car r)]
              [skip (cadr r)]
              [ch (caddr r)]
              [nack (cadddr r)]
              [evt (car (cddddr r))]
              [peek? (cdr (cddddr r))])
          (let ([fail? (and evt
                            (sync/timeout 0 evt))])
            (unless (or closed? fail?)
              (mod! s skip)
              (unless peek?
                (commit! 1)))
            ; Add an event to respond: ~ ~
            (serve commit-reqs
                   (cons (choice-evt
                          nack
                          (channel-put-evt ch (if closed?
                                                  0
                                                  (if fail? #f 1))))
                         response-evts)))))
      ; Progress request: send a peek evt for the current ~ ~
      ;  progress-sema
      (define ((handle-progress commit-reqs response-evts) r)
        (let ([ch (car r)]
              [nack (cdr r)])
          (unless progress-sema
            (set! progress-sema (make-semaphore (if closed? 1 0))))
          ; Add an event to respond: ~ ~
          (serve commit-reqs
                 (cons (choice-evt
                        nack
                        (channel-put-evt
                         ch
                         (semaphore-peek-evt progress-sema)))
                       response-evts))))
      ; Commit request: add the request to the list ~ ~
      (define ((add-commit commit-reqs response-evts) r)
        (serve (cons r commit-reqs) response-evts))
      ; Commit handling: watch out for progress, in which case ~ ~
      ;  the response is a commit failure; otherwise, try
      ;  to sync for a commit. In either event, remove the
      ;  request from the list
      (define ((make-handle-commit commit-reqs response-evts) r)
        (let ([k (car r)]
              [progress-evt (cadr r)]
              [done-evt (caddr r)]
              [ch (cadddr r)]
              [nack (cddddr r)])
          ; Note: we don't check that k is <= the sum of ~ ~
          ;  previous peeks, because the entire stream is actually
          ;  known, but we could send an exception in that case.
          (choice-evt
           (handle-evt progress-evt
                       (lambda (x)
                         (sync nack (channel-put-evt ch #f))
                         (serve (remq r commit-reqs) response-evts)))
           ; Only create an event to satisfy done-evt if progress-evt
           ;  isn't already ready.
           ; Afterward, if progress-evt becomes ready, then this
           ;  event-making function will be called again, because
           ;  the server controls all posts to progress-evt.
           (if (sync/timeout 0 progress-evt)
               never-evt
               (handle-evt done-evt
                           (lambda (v)
                             (commit! k)
                             (sync nack (channel-put-evt ch #t))
                             (serve (remq r commit-reqs)
                                    response-evts)))))))
      ; Response handling: as soon as the respondee listens, ~ ~
      ;  remove the response
      (define ((make-handle-response commit-reqs response-evts) evt)
        (handle-evt evt
                    (lambda (x)
                      (serve commit-reqs
                             (remq evt response-evts)))))
      ; Close handling: post the progress sema, if any, and set ~ ~
      ;   the closed? flag
      (define ((handle-close commit-reqs response-evts) r)
        (let ([ch (car r)]
              [nack (cdr r)])
          (set! closed? #t)
          (when progress-sema
            (semaphore-post progress-sema))
          (serve commit-reqs
                 (cons (choice-evt nack
                                   (channel-put-evt ch (void)))
                       response-evts))))
      ; Helper for reads and post-peek commits: ~ ~
      (define (commit! k)
        (when progress-sema
          (semaphore-post progress-sema)
          (set! progress-sema #f))
        (set! n (+ n k)))
      ; Start the server thread: ~ ~
      (define server-thread (thread (lambda () (serve null null))))
      ; —————————————-
      ; Client-side helpers: ~ ~
      (define (req-evt f)
        (nack-guard-evt
         (lambda (nack)
           ; Be sure that the server thread is running: ~ ~
           (thread-resume server-thread (current-thread))
           ; Create a channel to hold the reply: ~ ~
           (let ([ch (make-channel)])
             (f ch nack)
             ch))))
      (define (read-or-peek-evt s skip evt peek?)
        (req-evt (lambda (ch nack)
                   (channel-put read-req-ch
                                (list* s skip ch nack evt peek?)))))
      ; Make the port: ~ ~
      (make-input-port 'mod3-cycle
                       ; Each handler for the port just sends
                       ;  a request to the server
                       (lambda (s) (read-or-peek-evt s 0 #f #f))
                       (lambda (s skip evt)
                         (read-or-peek-evt s skip evt #t))
                       (lambda () ; close
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put progress-req-ch
                                               (list* ch nack))))))
                       (lambda () ; progress-evt
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put progress-req-ch
                                               (list* ch nack))))))
                       (lambda (k progress-evt done-evt)  ; commit
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put
                                   commit-req-ch
                                   (list* k progress-evt done-evt ch
                                          nack))))))))
  > (define mod3-cycle (make-mod3-cycle))
  > (let ([result1 #f]
          [result2 #f])
      (let ([t1 (thread
                 (lambda ()
                   (set! result1 (read-string 5 mod3-cycle))))]
            [t2 (thread
                 (lambda ()
                   (set! result2 (read-string 5 mod3-cycle))))])
        (thread-wait t1)
        (thread-wait t2)
        (string-append result1 "," result2)))
  "12020,01201"
  > (define s (make-bytes 1))
  > (define progress-evt (port-progress-evt mod3-cycle))
  > (peek-bytes-avail! s 0 progress-evt mod3-cycle)
  1
  > s
  #"1"
  > (port-commit-peeked 1 progress-evt (make-semaphore 1)
                        mod3-cycle)
  #t
  > (sync/timeout 0 progress-evt)
  #<progress-evt>
  > (peek-bytes-avail! s 0 progress-evt mod3-cycle)
  0
  > (port-commit-peeked 1 progress-evt (make-semaphore 1)
                        mod3-cycle)
  #f
  > (close-input-port mod3-cycle)

                                        *make-output-port*
(make-output-port  name                       ~
                   evt                       
                   write-out                 
                   close                     
                  [write-out-special         
                   get-write-evt             
                   get-write-special-evt     
                   get-location              
                   count-lines!              
                   init-position             
                   buffer-mode])         -> output-port?
  name : any/c ~ ~
  evt : evt? ~ ~
  write-out : (or/c ~ ~
               (bytes? exact-nonnegative-integer?
                       exact-nonnegative-integer?
                       boolean?
                       boolean?
                       . -> .
                       (or/c exact-nonnegative-integer?
                             #f
                             evt?))
               output-port?)
  close : (-> any) ~ ~
  write-out-special : (or/c (any/c boolean? boolean? = #f ~ ~
                                   . -> .
                                   (or/c any/c
                                         #f
                                         evt?))
                            output-port?
                            #f)
  get-write-evt : (or/c                               = #f ~ ~
                   (bytes? exact-nonnegative-integer?
                           exact-nonnegative-integer?
                           . -> .
                           evt?)
                   #f)
  get-write-special-evt : (or/c                = #f ~ ~
                           (any/c . -> . evt?)
                           #f)
  get-location : (or/c ~ ~
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void ~ ~
  init-position : (or/c exact-positive-integer? ~ ~
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case-> ~ ~
                       ((or/c 'block 'line 'none) . -> . any)
                       (-> (or/c 'block 'line 'none #f)))
                      #f)
              = #f

Creates an output port, which is immediately open for writing. If close
procedure has no side effects, then the port need not be explicitly
closed. The port can buffer data within its write-out and
write-out-special procedures.

* name — the name for the output port.

* evt — a synchronization event (see [missing]; e.g., a semaphore or
  another port). The event is used in place of the output port when the
  port is supplied to synchronization procedures like sync.  Thus, the
  event should be unblocked when the port is ready for writing at least
  one byte without blocking, or ready to make progress in flushing an
  internal buffer without blocking. The event must not unblock unless
  the port is ready for writing; otherwise, the guarantees of sync will
  be broken for the output port. Use always-evt if writes to the port
  always succeed without blocking.

* write-out — either an output port, which indicates that      writes
  should be redirected to the given port, or a procedure      of five
  arguments:

  * an immutable byte string containing bytes to write;

  * a non-negative exact integer for a starting offset (inclusive) into
    the byte string;

  * a non-negative exact integer for an ending offset (exclusive) into
    the byte string;

  * a boolean; #f indicates that the port is allowed to keep the written
    bytes in a buffer, and that it is allowed to block indefinitely; #t
    indicates that the write should not block, and that the port should
    attempt to flush its buffer and completely write new bytes instead
    of buffering them;

  * a boolean; #t indicates that if the port blocks for a write, then it
    should enable breaks while blocking (e.g., using sync/enable-break);
    this argument is always #f if the fourth argument is #t.

  The procedure returns one of the following:

  * a non-negative exact integer representing the number of bytes
    written or buffered;

  * #f if no bytes could be written, perhaps because the internal buffer
    could not be completely flushed;

  * a pipe output port (when buffering is allowed and not when flushing)
    for buffering bytes as long as the pipe is not full and until
    write-out or write-out-special is called; or

  * a synchronizable event (see [missing]) other than a pipe output port
    that acts like the result of write-bytes-avail-evt to complete the
    write.

  Since write-out can produce an event, an acceptable implementation of
  write-out is to pass its first three arguments to the port’s
  get-write-evt. Some port implementors, however, may choose not to
  provide get-write-evt (perhaps because writes cannot be made atomic),
  or may implement write-out to enable a fast path for non-blocking
  writes or to enable buffering.

  From a user’s perspective, the difference between buffered and
  completely written data is (1) buffered data can be lost in the future
  due to a failed write, and (2) flush-output forces all buffered data
  to be completely written. Under no circumstances is buffering
  required.

  If the start and end indices are the same, then the fourth argument to
  write-out will be #f, and the write request is actually a flush
  request for the port’s buffer (if any), and the result should be 0 for
  a successful flush (or if there is no buffer).

  The result should never be 0 if the start and end indices are
  different, otherwise the exn:fail:contract exception is raised.
  Similarly, the exn:fail:contract exception is raised if write-out
  returns a pipe output port when buffering is disallowed or when it is
  called for flushing.  If a returned integer is larger than the
  supplied byte-string range, the exn:fail:contract exception is raised.

  The #f result should be avoided, unless the next write attempt is
  likely to work. Otherwise, if data cannot be written, return an event
  instead.

  An event returned by write-out can return #f or another event like
  itself, in contrast to events produced by write-bytes-avail-evt or
  get-write-evt. A writing process loops with sync until it obtains a
  non-event result.

  The write-out procedure is always called with breaks disabled,
  independent of whether breaks were enabled when the write was
  requested by a client of the port. If breaks were enabled for a
  blocking operation, then the fifth argument to write-out will be #t,
  which indicates that write-out should re-enable breaks while blocking.

  If the writing procedure raises an exception, due to write or commit
  operations, it must not have committed any bytes (though it may have
  committed previously buffered bytes).

  A port’s writing procedure may be called in multiple threads
  simultaneously (if the port is accessible in multiple threads). The
  port is responsible for its own internal synchronization. Note that
  improper implementation of such synchronization mechanisms might cause
  a non-blocking write procedure to block.

* close — a procedure of zero arguments that is called to close the
  port. The port is not considered closed until the closing procedure
  returns. The port’s procedures will never be used again via the port
  after it is closed. However, the closing procedure can be called
  simultaneously in multiple threads (if the port is accessible in
  multiple threads), and it may be called during a call to the other
  procedures in another thread; in the latter case, any outstanding
  writes or flushes should be terminated immediately with an error.

* write-out-special — either #f (the default), an output port (which
  indicates that special writes should be redirected to the given port),
  or a procedure to handle write-special calls for the port. If #f, then
  the port does not support special output, and port-writes-special?
  will return #f when applied to the port.

  If a procedure is supplied, it takes three arguments: the special
  value to write, a boolean that is #f if the procedure can buffer the
  special value and block indefinitely, and a boolean that is #t if the
  procedure should enable breaks while blocking. The result is one of
  the following:

  * a non-event true value, which indicates that the special is written;

  * #f if the special could not be written, perhaps because an internal
    buffer could not be completely flushed;

  * a synchronizable event (see [missing]) that acts like the result of
    get-write-special-evt to complete the write.

  Since write-out-special can return an event, passing the first
  argument to an implementation of get-write-special-evt is acceptable
  as a write-out-special.

  As for write-out, the #f result is discouraged, since it can lead to
  busy waiting. Also as for write-out, an event produced by
  write-out-special is allowed to produce #f or another event like
  itself.  The write-out-special procedure is always called with breaks
  disabled, independent of whether breaks were enabled when the write
  was requested by a client of the port.

* get-write-evt — either #f (the default) or a procedure of three
  arguments:

  * an immutable byte string containing bytes to write;

  * a non-negative exact integer for a starting offset (inclusive) into
    the byte string; and

  * a non-negative exact integer for an ending offset (exclusive) into
    the byte string.

  The result is a synchronizable event (see [missing]) to act as  the
  result of write-bytes-avail-evt for the port (i.e.,  to complete a
  write or flush), which becomes available only as  data is committed to
  the port’s underlying device, and whose  result is the number of bytes
  written.

  If get-write-evt is #f, then  port-writes-atomic? will produce #f when
  applied  to the port, and the port will not be a valid argument to
  procedures such as write-bytes-avail-evt.  Otherwise, an event
  returned by get-write-evt must  not cause data to be written to the
  port unless the event is  chosen in a synchronization, and it must
  write to the port if the  event is chosen (i.e., the write must appear
  atomic with respect  to the synchronization).

  If the event’s result integer is larger than the supplied  byte-string
  range, the exn:fail:contract exception is raised by a wrapper  on the
  event. If the start and end indices are the same (i.e., no  bytes are
  to be written), then the event should produce 0  when the buffer is
  completely flushed. (If the port has no buffer,  then it is
  effectively always flushed.)

  If the event raises an exception, due to write or commit  operations,
  it must not have committed any new bytes (though it  may have
  committed previously buffered bytes).

  Naturally, a port’s events may be used in multiple threads
  simultaneously (if the port is accessible in multiple  threads). The
  port is responsible for its own internal  synchronization.

* get-write-special-evt — either #f (the default), or a procedure to
  handle write-special-evt calls for the port. This argument must be #f
  if either write-out-special or get-write-evt is #f, and it must be a
  procedure if both of those arguments are procedures.

  If it is a procedure, it takes one argument: the special value to
  write. The resulting event (with its constraints) is analogous to the
  result of get-write-evt.

  If the event raises an exception, due to write or commit operations,
  it must not have committed the special value (though it may have
  committed previously buffered bytes and values).

* get-location — either #f (the default), or a procedure that takes no
  arguments and returns three values: the line number for the next item
  written to the port’s stream (a positive number or #f), the column
  number for the next item written to port’s stream (a non-negative
  number or #f), and the position for the next item written to port’s
  stream (a positive number or #f). See also Counting Positions, Lines,
  and Columns.

  This procedure is called to implement port-next-location for the port,
  but only if line counting is enabled for the port via
  port-count-lines! (in which case count-lines! is called).

* count-lines! — a procedure of no arguments that is called if and when
  line counting is enabled for the port. The default procedure is void.

* init-position — normally an exact, positive integer that determines
  the position of the port’s first item, which is used by file-position
  or when line counting is not enabled for the port. The default is 1.
  If init-position is #f, the port is treated as having an unknown
  position. If init-position is a port, then the given port’s position
  is always used for the new port’s position. If init-position is a
  procedure, it is called as needed to obtain the port’s position.

* buffer-mode — either #f (the default) or a procedure that accepts zero
  or one arguments. If buffer-mode is #f, then the resulting port does
  not support a buffer-mode setting. Otherwise, the procedure is called
  with one symbol argument ('block, 'line, or 'none) to set the buffer
  mode, and it is called with zero arguments to get the current buffer
  mode. In the latter case, the result must be 'block, 'line, 'none, or
  #f (unknown). See Port Buffers and Positions for more information on
  buffer modes.

Examples:

  ; A port that writes anything to nowhere: ~ ~
  > (define /dev/null-out
      (make-output-port
       'null
       always-evt
       (lambda (s start end non-block? breakable?) (- end start))
       void
       (lambda (special non-block? breakable?) #t)
       (lambda (s start end) (wrap-evt
                              always-evt
                              (lambda (x)
                                (- end start))))
       (lambda (special) always-evt)))
  > (display "hello" /dev/null-out)
  > (write-bytes-avail #"hello" /dev/null-out)
  5
  > (write-special 'hello /dev/null-out)
  #t
  > (sync (write-bytes-avail-evt #"hello" /dev/null-out))
  5
  ; A port that accumulates bytes as characters in a list,
  ;  but not in a thread-safe way: ~ ~
  > (define accum-list null)
  > (define accumulator/not-thread-safe
      (make-output-port
       'accum/not-thread-safe
       always-evt
       (lambda (s start end non-block? breakable?)
         (set! accum-list
               (append accum-list
                       (map integer->char
                            (bytes->list (subbytes s start end)))))
         (- end start))
       void))
  > (display "hello" accumulator/not-thread-safe)
  > accum-list
  '(#\h #\e #\l #\l #\o)
  ; Same as before, but with simple thread-safety: ~ ~
  > (define accum-list null)
  > (define accumulator
      (let* ([lock (make-semaphore 1)]
             [lock-peek-evt (semaphore-peek-evt lock)])
        (make-output-port
         'accum
         lock-peek-evt
         (lambda (s start end non-block? breakable?)
           (if (semaphore-try-wait? lock)
               (begin
                 (set! accum-list
                       (append accum-list
                               (map integer->char
                                    (bytes->list
                                     (subbytes s start end)))))
                 (semaphore-post lock)
                 (- end start))
               ; Cheap strategy: block until the list is unlocked, ~ ~
               ;   then return 0, so we get called again
               (wrap-evt
                lock-peek
                (lambda (x) 0))))
         void)))
  > (display "hello" accumulator)
  > accum-list
  '(#\h #\e #\l #\l #\o)
  ; A port that transforms data before sending it on
  ;  to another port. Atomic writes exploit the
  ;  underlying port's ability for atomic writes.
  > (define (make-latin-1-capitalize port)
      (define (byte-upcase s start end)
        (list->bytes
         (map (lambda (b) (char->integer
                           (char-upcase
                            (integer->char b))))
              (bytes->list (subbytes s start end)))))
      (make-output-port
       'byte-upcase
       ; This port is ready when the original is ready: ~ ~
       port
       ; Writing procedure: ~ ~
       (lambda (s start end non-block? breakable?)
         (let ([s (byte-upcase s start end)])
           (if non-block?
               (write-bytes-avail* s port)
               (begin
                 (display s port)
                 (bytes-length s)))))
       ; Close procedure — close original port: ~ ~
       (lambda () (close-output-port port))
       #f
       ; Write event: ~ ~
       (and (port-writes-atomic? port)
            (lambda (s start end)
              (write-bytes-avail-evt
               (byte-upcase s start end)
               port)))))
  > (define orig-port (open-output-string))
  > (define cap-port (make-latin-1-capitalize orig-port))
  > (display "Hello" cap-port)
  > (get-output-string orig-port)
  "HELLO"
  > (sync (write-bytes-avail-evt #"Bye" cap-port))
  3
  > (get-output-string orig-port)
  "HELLOBYE"

10. More Port Constructors, Procedures, and Events

 (require racket/port) package: base ~ ~

The bindings documented in this section are provided by the racket/port
and racket libraries, but not racket/base.

10.1. Port String and List Conversions

                                        *port->list*
(port->list [r in]) -> (listof any/c) ~
  r : (input-port? . -> . any/c) = read ~ ~
  in : input-port? = (current-input-port) ~ ~

Returns a list whose elements are produced by calling r on in until it
produces eof.

Examples:

  > (define (read-number input-port)
      (define char (read-char input-port))
      (if (eof-object? char)
       char
       (string->number (string char))))
  > (port->list read-number (open-input-string "12345"))
  '(1 2 3 4 5)

                                        *port->string*
(port->string [in #:close? close?]) -> string? ~ ~ ~
  in : input-port? = (current-input-port) ~ ~
  close? : any/c = #f ~ ~

Reads all characters from in and returns them as a string. The input
port is closed unless close? is #f.

Example:

  > (port->string (open-input-string "hello world"))
  "hello world"

Changed in version 6.8.0.2 of package base: Added the #:close? argument.

                                        *port->bytes*
(port->bytes [in #:close? close?]) -> bytes? ~ ~ ~
  in : input-port? = (current-input-port) ~ ~
  close? : any/c = #f ~ ~

Reads all bytes from in and returns them as a byte string. The input
port is closed unless close? is #f.

Example:

  > (port->bytes (open-input-string "hello world"))
  #"hello world"

Changed in version 6.8.0.2 of package base: Added the #:close? argument.

                                        *port->lines*
(port->lines [in                         ~
              #:line-mode line-mode      ~ ~
              #:close? close?])     -> (listof string?) ~ ~
  in : input-port? = (current-input-port) ~ ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
            = 'any
  close? : any/c = #f ~ ~

Read all characters from in, breaking them into lines. The line-mode
argument is the same as the second argument to read-line, but the
default is 'any instead of 'linefeed. The input port is closed unless
close? is #f.

Example:

  > (port->lines
     (open-input-string "line 1\nline 2\n  line 3\nline 4"))
  '("line 1" "line 2" "  line 3" "line 4")

Changed in version 6.8.0.2 of package base: Added the #:close? argument.

                                        *port->bytes-lines*
(port->bytes-lines [in                         ~
                    #:line-mode line-mode      ~ ~
                    #:close? close?])     -> (listof bytes?) ~ ~
  in : input-port? = (current-input-port) ~ ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
            = 'any
  close? : any/c = #f ~ ~

Like port->lines, but reading bytes and collecting them into lines like
read-bytes-line. The input port is closed unless close? is #f.

Example:

  > (port->bytes-lines
     (open-input-string "line 1\nline 2\n  line 3\nline 4"))
  '(#"line 1" #"line 2" #"  line 3" #"line 4")

Changed in version 6.8.0.2 of package base: Added the #:close? argument.

                                        *display-lines*
(display-lines  lst                          ~
               [out                         
                #:separator separator]) -> void? ~ ~
  lst : list? ~ ~
  out : output-port? = (current-output-port) ~ ~
  separator : any/c = #"\n" ~ ~

Uses display on each element of lst to out, adding separator after each
element.

                                        *call-with-output-string*
(call-with-output-string proc) -> string? ~
  proc : (output-port? . -> . any) ~ ~

Calls proc with an output port that accumulates all output into a
string, and returns the string.

The port passed to proc is like the one created by open-output-string,
except that it is wrapped via dup-output-port, so that proc cannot
access the port’s content using get-output-string. If control jumps back
into proc, the port continues to accumulate new data, and
call-with-output-string returns both the old data and newly accumulated
data.

                                        *call-with-output-bytes*
(call-with-output-bytes proc) -> bytes? ~
  proc : (output-port? . -> . any) ~ ~

Like call-with-output-string, but returns the accumulated result in a
byte string instead of a string. Furthermore, the port’s content is
emptied when call-with-output-bytes returns, so that if control jumps
back into proc and returns a second time, only the newly accumulated
bytes are returned.

                                        *with-output-to-string*
(with-output-to-string proc) -> string? ~
  proc : (-> any) ~ ~

Equivalent to

  (call-with-output-string
   (lambda (p) (parameterize ([current-output-port p])
                 (proc))))

                                        *with-output-to-bytes*
(with-output-to-bytes proc) -> bytes? ~
  proc : (-> any) ~ ~

Equivalent to

  (call-with-output-bytes
   (lambda (p) (parameterize ([current-output-port p])
                 (proc))))

                                        *call-with-input-string*
(call-with-input-string str proc) -> any ~
  str : string? ~ ~
  proc : (input-port? . -> . any) ~ ~

Equivalent to (proc (open-input-string str)).

                                        *call-with-input-bytes*
(call-with-input-bytes bstr proc) -> any ~
  bstr : bytes? ~ ~
  proc : (input-port? . -> . any) ~ ~

Equivalent to (proc (open-input-bytes bstr)).

                                        *with-input-from-string*
(with-input-from-string str proc) -> any ~
  str : string? ~ ~
  proc : (-> any) ~ ~

Equivalent to

  (parameterize ([current-input-port (open-input-string str)])
    (proc))

                                        *with-input-from-bytes*
(with-input-from-bytes bstr proc) -> any ~
  bstr : bytes? ~ ~
  proc : (-> any) ~ ~

Equivalent to

  (parameterize ([current-input-port (open-input-bytes str)])
    (proc))

10.2. Creating Ports

                                        *input-port-append*
(input-port-append  close-at-eof?      ~
                    in ...            
                   [#:name name]) -> input-port? ~ ~
  close-at-eof? : any/c ~ ~
  in : input-port? ~ ~
  name : any/c = (map object-name in) ~ ~

Takes any number of input ports and returns an input port. Reading from
the input port draws bytes (and special non-byte values) from the given
input ports in order. If close-at-eof? is true, then each port is closed
when an end-of-file is encountered from the port, or when the result
input port is closed. Otherwise, data not read from the returned input
port remains available for reading in its original input port.

The name argument determines the name as reported by object-name for the
returned input port.

See also merge-input, which interleaves data from multiple input ports
as it becomes available.

Changed in version 6.90.0.19 of package base: Added the name argument.

                                        *make-input-port/read-to-peek*
(make-input-port/read-to-peek  name               ~
                               read-in           
                               fast-peek         
                               close             
                              [get-location      
                               count-lines!      
                               init-position     
                               buffer-mode       
                               buffering?        
                               on-consumed]) -> input-port?
  name : any/c ~ ~
  read-in : (bytes? ~ ~
             . -> . (or/c exact-nonnegative-integer?
                          eof-object?
                          procedure?
                          evt?))
  fast-peek : (or/c #f ~ ~
                    (bytes? exact-nonnegative-integer?
                     (bytes? exact-nonnegative-integer?
                      . -> . (or/c exact-nonnegative-integer?
                                   eof-object?
                                   procedure?
                                   evt?
                                   #f))
                     . -> . (or/c exact-nonnegative-integer?
                                  eof-object?
                                  procedure?
                                  evt?
                                  #f)))
  close : (-> any) ~ ~
  get-location : (or/c                                   = #f ~ ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  count-lines! : (-> any) = void ~ ~
  init-position : exact-positive-integer? = 1 ~ ~
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any) ~ ~
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f
  buffering? : any/c = #f ~ ~
  on-consumed : (or/c ((or/c exact-nonnegative-integer? eof-object? ~ ~
                             procedure? evt?)
                       . -> . any)
                      #f)
              = #f

Similar to make-input-port, but if the given read-in returns an event,
the event’s value must be 0.  The resulting port’s peek operation is
implemented automatically (in terms of read-in) in a way that can handle
special non-byte values. The progress-event and commit operations are
also implemented automatically. The resulting port is thread-safe, but
not kill-safe (i.e., if a thread is terminated or suspended while using
the port, the port may become damaged).

The read-in, close, get-location, count-lines!, init-position, and
buffer-mode procedures are the same as for make-input-port.

The fast-peek argument can be either #f or a procedure of three
arguments: a byte string to receive a peek, a skip count, and a
procedure of two arguments. The fast-peek procedure can either implement
the requested peek, or it can dispatch to its third argument to
implement the peek. The fast-peek is not used when a peek request has an
associated progress event.

The buffering? argument determines whether read-in can be called to read
more characters than are immediately demanded by the user of the new
port. If buffer-mode is not #f, then buffering? determines the initial
buffer mode, and buffering? is enabled after a buffering change only if
the new mode is 'block.

If on-consumed is not #f, it is called when data is read (or committed)
from the port, as opposed to merely peeked. The argument to on-consumed
is the result value of the port’s reading procedure, so it can be an
integer or any result from read-in.

                                        *make-limited-input-port*
(make-limited-input-port  in                 ~
                          limit             
                         [close-orig?]) -> input-port?
  in : input-port? ~ ~
  limit : exact-nonnegative-integer? ~ ~
  close-orig? : any/c = #t ~ ~

Returns a port whose content is drawn from in, but where an end-of-file
is reported after limit bytes (and non-byte special values) have been
read.  If close-orig? is true, then the original port is closed if the
returned port is closed.

Bytes are consumed from in only when they are consumed from the returned
port. In particular, peeking into the returned port peeks into the
original port.

If in is used directly while the resulting port is also used, then the
limit bytes provided by the port need not be contiguous parts of the
original port’s stream.

                                        *make-pipe-with-specials*
(make-pipe-with-specials [limit           ~
                          in-name        
                          out-name]) -> input-port? output-port?
  limit : exact-nonnegative-integer? = #f ~ ~
  in-name : any/c = 'pipe ~ ~
  out-name : any/c = 'pipe ~ ~

Returns two ports: an input port and an output port. The ports behave
like those returned by make-pipe, except that the ports support non-byte
values written with procedures such as write-special and read with
procedures such as get-byte-or-special.

The limit argument determines the maximum capacity of the pipe in bytes,
but this limit is disabled if special values are written to the pipe
before limit is reached. The limit is re-enabled after the special value
is read from the pipe.

The optional in-name and out-name arguments determine the names of the
result ports.

                                        *combine-output*
(combine-output a-out b-out) -> output-port? ~
  a-out : output-port? ~ ~
  b-out : output-port? ~ ~

Accepts two output ports and returns a new output port combining the
original ports. When written to, the combined port first writes as many
bytes as possible to a-out, and then tries to write the same number of
bytes to b-out. If that doesn’t succeed, what is left over is buffered
and no further writes can go through until the ports are evened out. The
port is ready (for the purposes of synchronization) when each port
reports being ready. However, the first port may stop being ready while
waiting on the second port to sync, so it cannot be guaranteed that both
ports are ready at once. Closing the combined port is done after writing
all remaining bytes to b-out.

Added in version 7.7.0.10 of package base.

                                        *merge-input*
(merge-input a-in b-in [buffer-limit]) -> input-port? ~
  a-in : input-port? ~ ~
  b-in : input-port? ~ ~
  buffer-limit : (or/c exact-nonnegative-integer? #f) = 4096 ~ ~

Accepts two input ports and returns a new input port. The new port
merges the data from two original ports, so data can be read from the
new port whenever it is available from either of the two original ports.
The data from the original ports are interleaved. When an end-of-file
has been read from an original port, it no longer contributes characters
to the new port. After an end-of-file has been read from both original
ports, the new port returns end-of-file. Closing the merged port does
not close the original ports.

The optional buffer-limit argument limits the number of bytes to be
buffered from a-in and b-in, so that the merge process does not advance
arbitrarily beyond the rate of consumption of the merged data. A #f
value disables the limit. As for make-pipe-with-specials, buffer-limit
does not apply when a special value is produced by one of the input
ports before the limit is reached.

See also input-port-append, which concatenates input streams instead of
interleaving them.

                                        *open-output-nowhere*
(open-output-nowhere [name special-ok?]) -> output-port? ~
  name : any/c = 'nowhere ~ ~
  special-ok? : any/c = #t ~ ~

Creates and returns an output port that discards all output sent to it
(without blocking). The name argument is used as the port’s name. If the
special-ok?  argument is true, then the resulting port supports
write-special, otherwise it does not.

                                        *peeking-input-port*
(peeking-input-port  in                                   ~
                    [name                                
                     skip                                
                     #:init-position init-position]) -> input-port ~ ~
  in : input-port? ~ ~
  name : any/c = (object-name in) ~ ~
  skip : exact-nonnegative-integer? = 0 ~ ~
  init-position : exact-positive-integer? = 1 ~ ~

Returns an input port whose content is determined by peeking into in. In
other words, the resulting port contains an internal skip count, and
each read of the port peeks into in with the internal skip count, and
then increments the skip count according to the amount of data
successfully peeked.

The optional name argument is the name of the resulting port. The skip
argument is the port initial skip count, and it defaults to 0.

The resulting port’s initial position (as reported by file-position) is
(- init-position 1), no matter the position of in.

The resulting port supports buffering, and a 'block buffer mode allows
the port to peek further into in than requested. The resulting port’s
initial buffer mode is 'block, unless in supports buffer mode and its
mode is initially 'none (i.e., the initial buffer mode is taken from in
when it supports buffering). If in supports buffering, adjusting the
resulting port’s buffer mode via file-stream-buffer-mode adjusts in’s
buffer mode.

For example, when you read from a peeking port, you see the same answers
as when you read from the original port:

Examples:

  > (define an-original-port (open-input-string "123456789"))
  > (define a-peeking-port (peeking-input-port an-original-port))
  > (file-stream-buffer-mode a-peeking-port 'none)
  > (read-string 3 a-peeking-port)
  "123"
  > (read-string 3 an-original-port)
  "123"

Beware that the read from the original port is invisible to the peeking
port, which keeps its own separate internal counter, and thus
interleaving reads on the two ports can produce confusing results.
Continuing the example before, if we read three more characters from the
peeking port, we end up skipping over the 456 in the port (but only
because we disabled buffering above):

Example:

  > (read-string 3 a-peeking-port)
  "789"

If we had left the buffer mode of a-peeking-port alone, that last
read-string would have likely produced "456" as a result of buffering
bytes from an-original-port earlier.

Changed in version 6.1.0.3 of package base: Enabled buffering and
buffer-mode adjustments via file-stream-buffer-mode, and set the port’s
initial buffer mode to that of in.

                                        *reencode-input-port*
(reencode-input-port  in                     ~
                      encoding              
                     [error-bytes           
                      close?                
                      name                  
                      convert-newlines?     
                      enc-error])       -> input-port?
  in : input-port? ~ ~
  encoding : string? ~ ~
  error-bytes : (or/c #f bytes?) = #f ~ ~
  close? : any/c = #f ~ ~
  name : any/c = (object-name in) ~ ~
  convert-newlines? : any/c = #f ~ ~
  enc-error : (string? input-port? . -> . any) ~ ~
            = (lambda (msg port) (error ...))

Produces an input port that draws bytes from in, but converts the byte
stream using (bytes-open-converter encoding-str "UTF-8"). In addition,
if convert-newlines? is true, then decoded sequences that correspond to
UTF-8 encodings of "\r\n", "\r\u0085", "\r", "\u0085", and "\u2028" are
all converted to the UTF-8 encoding of "\n".

If error-bytes is provided and not #f, then the given byte sequence is
used in place of bytes from in that trigger conversion errors.
Otherwise, if a conversion is encountered, enc-error is called, which
must raise an exception.

If close? is true, then closing the result input port also closes in.
The name argument is used as the name of the result input port.

In non-buffered mode, the resulting input port attempts to draw bytes
from in only as needed to satisfy requests. Toward that end, the input
port assumes that at least n bytes must be read to satisfy a request for
n bytes. (This is true even if the port has already drawn some bytes, as
long as those bytes form an incomplete encoding sequence.)

                                        *reencode-output-port*
(reencode-output-port  out                ~
                       encoding          
                      [error-bytes       
                       close?            
                       name              
                       newline-bytes     
                       enc-error])   -> output-port?
  out : output-port? ~ ~
  encoding : string? ~ ~
  error-bytes : (or/c #f bytes?) = #f ~ ~
  close? : any/c = #f ~ ~
  name : any/c = (object-name out) ~ ~
  newline-bytes : (or/c #f bytes?) = #f ~ ~
  enc-error : (string? output-port? . -> . any) ~ ~
            = (lambda (msg port) (error ...))

Produces an output port that directs bytes to out, but converts its byte
stream using (bytes-open-converter "UTF-8" encoding-str). In addition,
if newline-bytes is not #f, then bytes written to the port that are the
UTF-8 encoding of "\n" are first converted to newline-bytes (before
applying the convert from UTF-8 to encoding-str).

If error-bytes is provided and not #f, then the given byte sequence is
used in place of bytes that have been sent to the output port and that
trigger conversion errors. Otherwise, enc-error is called, which must
raise an exception.

If close? is true, then closing the result output port also closes out.
The name argument is used as the name of the result output port.

The resulting port supports buffering, and the initial buffer mode is
(or (file-stream-buffer-mode out) 'block). In 'block mode, the port’s
buffer is flushed only when it is full or a flush is requested
explicitly. In 'line mode, the buffer is flushed whenever a newline or
carriage-return byte is written to the port. In 'none mode, the port’s
buffer is flushed after every write. Implicit flushes for 'line or 'none
leave bytes in the buffer when they are part of an incomplete encoding
sequence.

The resulting output port does not support atomic writes. An explicit
flush or special-write to the output port can hang if the most recently
written bytes form an incomplete encoding sequence.

When the port is buffered, a flush callback is registered with the
current plumber to flush the buffer.

                                        *dup-input-port*
(dup-input-port in [close?]) -> input-port? ~
  in : input-port? ~ ~
  close? : any/c = #f ~ ~

Returns an input port that draws directly from in. Closing the resulting
port closes in only if close? is #t.

The new port is initialized with the port read handler of in, but
setting the handler on the result port does not affect reading directly
from in.

                                        *dup-output-port*
(dup-output-port out [close?]) -> output-port? ~
  out : output-port? ~ ~
  close? : any/c = #f ~ ~

Returns an output port that propagates data directly to out. Closing the
resulting port closes out only if close? is #t.

The new port is initialized with the port display handler and port write
handler of out, but setting the handlers on the result port does not
affect writing directly to out.

                                        *relocate-input-port*
(relocate-input-port  in                ~
                      line             
                      column           
                      position         
                     [close?]          
                      #:name name) -> input-port? ~ ~
  in : input-port? ~ ~
  line : (or/c exact-positive-integer? #f) ~ ~
  column : (or/c exact-nonnegative-integer? #f) ~ ~
  position : exact-positive-integer? ~ ~
  close? : any/c = #t ~ ~
  name : (object-name out) ~ ~

Produces an input port that is equivalent to in except in how it reports
location information (and possibly its name). The resulting port’s
content starts with the remaining content of in, and it starts at the
given line, column, and position. A #f for the line or column means that
the line and column will always be reported as #f.

The line and column values are used only if line counting is enabled for
in and for the resulting port, typically through port-count-lines!. The
column value determines the column for the first line (i.e., the one
numbered line), and later lines start at column 0. The given position is
used even if line counting is not enabled.

When line counting is on for the resulting port, reading from in instead
of the resulting port increments location reports from the resulting
port. Otherwise, the resulting port’s position does not increment when
data is read from in.

If close? is true, then closing the resulting port also closes in. If
close? is #f, then closing the resulting port does not close in.

The name argument is used as the name for the resulting port; the
default value keeps the same name as in.

                                        *relocate-output-port*
(relocate-output-port  out               ~
                       line             
                       column           
                       position         
                      [close?]          
                       #:name name) -> output-port? ~ ~
  out : output-port? ~ ~
  line : (or/c exact-positive-integer? #f) ~ ~
  column : (or/c exact-nonnegative-integer? #f) ~ ~
  position : exact-positive-integer? ~ ~
  close? : any/c = #t ~ ~
  name : (object-name out) ~ ~

Like relocate-input-port, but for output ports.

                                        *transplant-input-port*
(transplant-input-port  in                 ~
                        get-location      
                        init-pos          
                       [close?            
                        count-lines!]     
                        #:name name)  -> input-port? ~ ~
  in : input-port? ~ ~
  get-location : (or/c ~ ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer? ~ ~
  close? : any/c = #t ~ ~
  count-lines! : (-> any) = void ~ ~
  name : (object-name out) ~ ~

Like relocate-input-port, except that arbitrary position information can
be produced (when line counting is enabled) via get-location, which is
used as for make-input-port. If get-location is #f, then the port counts
lines in the usual way starting from init-pos, independent of locations
reported by in.

If count-lines! is supplied, it is called when line counting is enabled
for the resulting port. The default is void.

                                        *transplant-output-port*
(transplant-output-port  out                ~
                         get-location      
                         init-pos          
                        [close?            
                         count-lines!]     
                         #:name name)  -> output-port? ~ ~
  out : output-port? ~ ~
  get-location : (or/c ~ ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer? ~ ~
  close? : any/c = #t ~ ~
  count-lines! : (-> any) = void ~ ~
  name : (object-name out) ~ ~

Like transplant-input-port, but for output ports.

                                        *filter-read-input-port*
(filter-read-input-port  in             ~
                         read-wrap     
                         peek-wrap     
                        [close?])  -> input-port?
  in : input-port? ~ ~
  read-wrap : (bytes? (or/c exact-nonnegative-integer? ~ ~
                            eof-object?
                            procedure?
                            evt?)
                      . -> .
                      (or/c exact-nonnegative-integer?
                            eof-object?
                            procedure?
                            evt?))
  peek-wrap : (bytes? exact-nonnegative-integer? (or/c evt? #f) ~ ~
                      (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f)
               . -> . (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f))
  close? : any/c = #t ~ ~

Creates a port that draws from in, but each result from the port’s read
and peek procedures (in the sense of make-input-port) is filtered by
read-wrap and peek-wrap. The filtering procedures each receive both the
arguments and results of the read and peek procedures on in for each
call.

If close? is true, then closing the resulting port also closes in.

                                        *special-filter-input-port*
(special-filter-input-port in proc [close?]) -> input-port? ~
  in : input-port? ~ ~
  proc : (procedure? bytes? . -> . (or/c exact-nonnegative-integer? ~ ~
                                         eof-object?
                                         procedure?
                                         evt?))
  close? : any/c = #t ~ ~

Produces an input port that is equivalent to in, except that when in
produces a procedure to access a special value, proc is applied to the
procedure to allow the special value to be replaced with an alternative.
The proc is called with the special-value procedure and the byte string
that was given to the port’s read or peek function (see
make-input-port), and the result is used as the read or peek function’s
result.  The proc can modify the byte string to substitute a byte for
the special value, but the byte string is guaranteed only to hold at
least one byte.

If close? is true, then closing the resulting input port also closes in.

10.3. Port Events

                                        *eof-evt*
(eof-evt in) -> evt? ~
  in : input-port? ~ ~

Returns a synchronizable event that is ready when in produces an eof. If
in produces a mid-stream eof, the eof is consumed by the event only if
the event is chosen in a synchronization.

If attempting to read from in raises an exception during a
synchronization attempt, then the exception may be reported during the
synchronization attempt, but it will silently discarded if some another
event in the same synchronization is selected or if some other event
raises an exception first.

Changed in version 7.5.0.3 of package base: Changed handling of read
errors so they are propagated to a synchronization attempt, instead of
treated as unhandled errors in a background thread.

                                        *read-bytes-evt*
(read-bytes-evt k in) -> evt? ~
  k : exact-nonnegative-integer? ~ ~
  in : input-port? ~ ~

Returns a synchronizable event that is ready when k bytes can be read
from in, or when an end-of-file is encountered in in. If k is 0, then
the event is ready immediately with "". For non-zero k, if no bytes are
available before an end-of-file, the event’s result is eof. Otherwise,
the event’s result is a byte string of up to k bytes, which contains as
many bytes as are available (up to k) before an available end-of-file.
(The result is a byte string on less than k bytes only when an
end-of-file is encountered.)

Bytes are read from the port if and only if the event is chosen in a
synchronization, and the returned bytes always represent contiguous
bytes in the port’s stream.

The event can be synchronized multiple times—event concurrently—and each
synchronization corresponds to a distinct read request.

The in must support progress events, and it must not produce a special
non-byte value during the read attempt.

Exceptions attempting to read from in are handled in the same way as by
eof-evt.

                                        *read-bytes!-evt*
(read-bytes!-evt bstr in) -> evt? ~
  bstr : (and/c bytes? (not/c immutable?)) ~ ~
  in : input-port? ~ ~

Like read-bytes-evt, except that the read bytes are placed into bstr,
and the number of bytes to read corresponds to (bytes-length bstr). The
event’s result is either eof or the number of read bytes.

The bstr may be mutated any time after the first synchronization attempt
on the event and until either the event is selected, a non-#f
progress-evt is ready, or the current custodian (at the time of
synchronization) is shut down. Note that there is no time bound
otherwise on when bstr might be mutated if the event is not selected by
a synchronzation; nevertheless, multiple synchronization attempts can
use the same result from read-bytes!-evt as long as there is no
intervening read on in until one of the synchronization attempts selects
the event.

Exceptions attempting to read from in are handled in the same way as by
eof-evt.

                                        *read-bytes-avail!-evt*
(read-bytes-avail!-evt bstr in) -> evt? ~
  bstr : (and/c bytes? (not/c immutable?)) ~ ~
  in : input-port? ~ ~

Like read-bytes!-evt, except that the event reads only as many bytes as
are immediately available, after at least one byte or one eof becomes
available.

                                        *read-string-evt*
(read-string-evt k in) -> evt? ~
  k : exact-nonnegative-integer? ~ ~
  in : input-port? ~ ~

Like read-bytes-evt, but for character strings instead of byte strings.

                                        *read-string!-evt*
(read-string!-evt str in) -> evt? ~
  str : (and/c string? (not/c immutable?)) ~ ~
  in : input-port? ~ ~

Like read-bytes!-evt, but for a character string instead of a byte
string.

                                        *read-line-evt*
(read-line-evt in [mode]) -> evt? ~
  in : input-port? ~ ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
       = 'linefeed

Returns a synchronizable event that is ready when a line of characters
or end-of-file can be read from in. The meaning of mode is the same as
for read-line. The event result is the read line of characters (not
including the line separator).

A line is read from the port if and only if the event is chosen in a
synchronization, and the returned line always represents contiguous
bytes in the port’s stream.

Exceptions attempting to read from in are handled in the same way as by
eof-evt.

                                        *read-bytes-line-evt*
(read-bytes-line-evt in [mode]) -> evt? ~
  in : input-port? ~ ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~ ~
       = 'linefeed

Like read-line-evt, but returns a byte string instead of a string.

                                        *peek-bytes-evt*
(peek-bytes-evt k skip progress-evt in) -> evt? ~
  k : exact-nonnegative-integer? ~ ~
  skip : exact-nonnegative-integer? ~ ~
  progress-evt : (or/c progress-evt? #f) ~ ~
  in : input-port? ~ ~
(peek-bytes!-evt bstr skip progress-evt in) -> evt?
  bstr : (and/c bytes? (not/c immutable?)) ~ ~
  skip : exact-nonnegative-integer? ~ ~
  progress-evt : (or/c progress-evt? #f) ~ ~
  in : input-port? ~ ~
(peek-bytes-avail!-evt bstr             
                       skip             
                       progress-evt     
                       in)          -> evt?
  bstr : (and/c bytes? (not/c immutable?)) ~ ~
  skip : exact-nonnegative-integer? ~ ~
  progress-evt : (or/c progress-evt? #f) ~ ~
  in : input-port? ~ ~
(peek-string-evt k skip progress-evt in) -> evt?
  k : exact-nonnegative-integer? ~ ~
  skip : exact-nonnegative-integer? ~ ~
  progress-evt : (or/c progress-evt? #f) ~ ~
  in : input-port? ~ ~
(peek-string!-evt str skip progress-evt in) -> evt?
  str : (and/c string? (not/c immutable?)) ~ ~
  skip : exact-nonnegative-integer? ~ ~
  progress-evt : (or/c progress-evt? #f) ~ ~
  in : input-port? ~ ~

Like the read-bytes-evt, etc., functions, but for peeking. The skip
argument indicates the number of bytes to skip, and progress-evt
indicates an event that effectively cancels the peek (so that the event
never becomes ready). The progress-evt argument can be #f, in which case
the event is never canceled.

                                        *regexp-match-evt*
(regexp-match-evt pattern in) -> any ~
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~ ~
  in : input-port? ~ ~

Returns a synchronizable event that is ready when pattern matches the
stream of bytes/characters from in; see also regexp-match. The event’s
value is the result of the match, in the same form as the result of
regexp-match.

If pattern does not require a start-of-stream match, then bytes skipped
to complete the match are read and discarded when the event is chosen in
a synchronization.

Bytes are read from the port if and only if the event is chosen in a
synchronization, and the returned match always represents contiguous
bytes in the port’s stream. If not-yet-available bytes from the port
might contribute to the match, the event is not ready.  Similarly, if
pattern begins with a start-of-stream ^ and the pattern does not
initially match, then the event cannot become ready until bytes have
been read from the port.

The event can be synchronized multiple times—even concurrently—and each
synchronization corresponds to a distinct match request.

The in port must support progress events. If in returns a special
non-byte value during the match attempt, it is treated like eof.

Exceptions attempting to read from in are handled in the same way as by
eof-evt.

10.4. Copying Streams

                                        *convert-stream*
(convert-stream from-encoding      ~
                in                
                to-encoding       
                out)          -> void?
  from-encoding : string? ~ ~
  in : input-port? ~ ~
  to-encoding : string? ~ ~
  out : output-port? ~ ~

Reads data from in, converts it using (bytes-open-converter
from-encoding to-encoding) and writes the converted bytes to out. The
convert-stream procedure returns after reaching eof in in.

If opening the converter fails, the exn:fail exception is raised.
Similarly, if a conversion error occurs at any point while reading from
in, then exn:fail exception is raised.

                                        *copy-port*
(copy-port in out ...+) -> void? ~
  in : input-port? ~ ~
  out : output-port? ~ ~

Reads data from in and writes it back out to out, returning when in
produces eof.  The copy is efficient, and it is without significant
buffer delays (i.e., a byte that becomes available on in is immediately
transferred to out, even if future reads on in must block). If in
produces a special non-byte value, it is transferred to out using
write-special.

This function is often called from a “background” thread to continuously
pump data from one stream to another.

If multiple outs are provided, data from in is written to every out. The
different outs block output to each other, because each block of data
read from in is written completely to one out before moving to the next
out. The outs are written in the provided order, so non-blocking ports
(e.g., file output ports) should be placed first in the argument list.
