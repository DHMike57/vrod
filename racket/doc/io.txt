Input and Output

+[missing] in [missing] introduces Ports and I/O.

    1 Ports
      1.1 Encodings and Locales
      1.2 Managing Ports
      1.3 Port Buffers and Positions
      1.4 Counting Positions, Lines, and Columns
      1.5 File Ports
      1.6 String Ports
      1.7 Pipes
      1.8 Structures as Ports
      1.9 Custom Ports
      1.10 More Port Constructors, Procedures, and Events
        1.10.1 Port String and List Conversions
        1.10.2 Creating Ports
        1.10.3 Port Events
        1.10.4 Copying Streams

    2 Byte and String Input

    3 Byte and String Output

    4 Reading

    5 Writing

    6 Pretty Printing
      6.1 Basic Pretty-Print Options
      6.2 Per-Symbol Special Printing
      6.3 Line-Output Hook
      6.4 Value Output Hook
      6.5 Additional Custom-Output Support

    7 Reader Extension
      7.1 Readtables
      7.2 Reader-Extension Procedures
      7.3 Special Comments

    8 Printer Extension

    9 Serialization

    10 Fast-Load Serialization

1. Ports

Ports produce and/or consume bytes. An input port produces bytes, while
an output port consumes bytes (and some ports are both input ports and
output ports). When an input port is provided to a character-based
operation, the bytes are decoded to a character, and character-based
output operations similarly encode the character to bytes; see Encodings
and Locales. In addition to bytes and characters encoded as bytes, some
ports can produce and/or consume arbitrary values as special results.

When a port corresponds to a file, network connection, or some other
system resource, it must be explicitly closed via close-input-port or
close-output-port (or indirectly via custodian-shutdown-all) to release
low-level resources associated with the port. For any kind of port,
after it is closed, attempting to read from or write to the port raises
exn:fail.

Data produced by a input port can be read or peeked. When data is read,
it is considered consumed and removed from the port’s stream. When data
is peeked, it remains in the port’s stream to be returned again by the
next read or peek. Previously peeked data can be committed, which causes
the data to be removed from the port as for a read in a way that can be
synchronized with other attempts to peek or read through a
synchronizable event. Both read and peek operations are normally
blocking, in the sense that the read or peek operation does not complete
until data is available from the port; non-blocking variants of read and
peek operations are also available.

The global variable eof is bound to the end-of-file value, and
eof-object? returns #t only when applied to this value. Reading from a
port produces an end-of-file result when the port has no more data, but
some ports may also return end-of-file mid-stream. For example, a port
connected to a Unix terminal returns an end-of-file when the user types
control-D; if the user provides more input, the port returns additional
bytes after the end-of-file.

Every port has a name, as reported by object-name. The name can be any
value, and it is used mostly for error-reporting purposes. The
read-syntax procedure uses the name of an input port as the default
source location for the syntax objects that it produces.

A port can be used as a synchronizable event. An input port is ready for
synchronization when read-byte would not block, and an output port is
ready for synchronization when write-bytes-avail would not block or when
the port contains buffered characters and write-bytes-avail* can flush
part of the buffer (although write-bytes-avail might block). A value
that can act as both an input port and an output port acts as an input
port for a synchronizable event. The synchronization result of a port is
the port itself.

    1.1 Encodings and Locales
    1.2 Managing Ports
    1.3 Port Buffers and Positions
    1.4 Counting Positions, Lines, and Columns
    1.5 File Ports
    1.6 String Ports
    1.7 Pipes
    1.8 Structures as Ports
    1.9 Custom Ports
    1.10 More Port Constructors, Procedures, and Events
      1.10.1 Port String and List Conversions
      1.10.2 Creating Ports
      1.10.3 Port Events
      1.10.4 Copying Streams

1.1. Encodings and Locales

When a port is provided to a character-based operation, such as
read-char or read, the port’s bytes are read and interpreted as a UTF-8
encoding of characters. Thus, reading a single character may require
reading multiple bytes, and a procedure like char-ready? may need to
peek several bytes into the stream to determine whether a character is
available. In the case of a byte stream that does not correspond to a
valid UTF-8 encoding, functions such as read-char may need to peek one
byte ahead in the stream to discover that the stream is not a valid
encoding.

When an input port produces a sequence of bytes that is not a valid
UTF-8 encoding in a character-reading context, then bytes that
constitute an invalid sequence are converted to the character #\uFFFD.
Specifically, bytes 255 and 254 are always converted to #\uFFFD, bytes
in the range 192 to 253 produce #\uFFFD when they are not followed by
bytes that form a valid UTF-8 encoding, and bytes in the range 128 to
191 are converted to #\uFFFD when they are not part of a valid encoding
that was started by a preceding byte in the range 192 to 253. To put it
another way, when reading a sequence of bytes as characters, a minimal
set of bytes are changed to the encoding of #\uFFFD so that the entire
sequence of bytes is a valid UTF-8 encoding.

See [missing] for procedures that facilitate conversions using UTF-8 or
other encodings. See also reencode-input-port and reencode-output-port
for obtaining a UTF-8-based port from one that uses a different encoding
of characters.

A locale captures information about a user’s language-specific
interpretation of character sequences. In particular, a locale
determines how strings are “alphabetized,” how a lowercase character is
converted to an uppercase character, and how strings are compared
without regard to case. String operations such as string-ci=? are not
sensitive to the current locale, but operations such as
string-locale-ci=? (see [missing]) produce results consistent with the
current locale.

A locale also designates a particular encoding of code-point sequences
into byte sequences. Racket generally ignores this aspect of the locale,
with a few notable exceptions: command-line arguments passed to Racket
as byte strings are converted to character strings using the locale’s
encoding; command-line strings passed as byte strings to other processes
(through subprocess) are converted to byte strings using the locale’s
encoding; environment variables are converted to and from strings using
the locale’s encoding; filesystem paths are converted to and from
strings (for display purposes) using the locale’s encoding; and,
finally, Racket provides functions such as string->bytes/locale to
specifically invoke a locale-specific encoding.

A Unix user selects a locale by setting environment variables, such as
LC_ALL. On Windows and Mac OS X, the operating system provides other
mechanisms for setting the locale. Within Racket, the current locale can
be changed by setting the current-locale parameter. The locale name
within Racket is a string, and the available locale names depend on the
platform and its configuration, but the "" locale means the current
user’s default locale; on Windows and Mac OS X, the encoding for "" is
always UTF-8, and locale-sensitive operations use the operating system’s
native interface. (In particular, setting the LC_ALL and LC_CTYPE
environment variables does not affect the locale "" on Mac OS X. Use
getenv and current-locale to explicitly install the
environment-specified locale, if desired.) Setting the current locale to
#f makes locale-sensitive operations locale-insensitive, which means
using the Unicode mapping for case operations and using UTF-8 for
encoding.

                                        *current-locale*
(current-locale) -> (or/c string? #f) ~
(current-locale locale) -> void?
  locale : (or/c string? #f) ~

A parameter that determines the current locale for procedures such as
string-locale-ci=?.

When locale sensitivity is disabled by setting the parameter to #f,
strings are compared, etc., in a fully portable manner, which is the
same as the standard procedures. Otherwise, strings are interpreted
according to a locale setting (in the sense of the C library’s
setlocale). The "" locale is always an alias for the current machine’s
default locale, and it is the default.  The "C" locale is also always
available; setting the locale to "C" is the same as disabling locale
sensitivity with #f only when string operations are restricted to the
first 128 characters. Other locale names are platform-specific.

String or character printing with write is not affected by the
parameter, and neither are symbol case or regular expressions (see
[missing]).

1.2. Managing Ports

                                        *input-port?*
(input-port? v) -> boolean? ~
  v : any/c ~

Returns #t if v is an input port, #f otherwise.

                                        *output-port?*
(output-port? v) -> boolean? ~
  v : any/c ~

Returns #t if v is an output port, #f otherwise.

                                        *port?*
(port? v) -> boolean? ~
  v : any/c ~

Returns #t if either (input-port? v) or (output-port? v) is #t, #f
otherwise.

                                        *close-input-port*
(close-input-port in) -> void? ~
  in : input-port? ~

Closes the input port in. For some kinds of ports, closing the port
releases lower-level resources, such as a file handle. If the port is
already closed, close-input-port has no effect.

                                        *close-output-port*
(close-output-port out) -> void? ~
  out : output-port? ~

Closes the output port out. For some kinds of ports, closing the port
releases lower-level resources, such as a file handle. Also, if the port
is buffered, closing may first flush the port before closing it, and
this flushing process can block. If the port is already closed,
close-output-port has no effect.

                                        *port-closed?*
(port-closed? port) -> boolean? ~
  port : port? ~

Returns #t if the input or output port port is closed, #f otherwise.

                                        *port-closed-evt*
(port-closed-evt port) -> evt? ~
  port : port? ~

Return a synchronizable event that becomes ready for synchronization
when port is closed. The synchronization result of a port-closed event
is the port-closed event itself.

                                        *current-input-port*
(current-input-port) -> input-port? ~
(current-input-port in) -> void?
  in : input-port? ~

A parameter that determines a default input port for many operations,
such as read.

                                        *current-output-port*
(current-output-port) -> output-port? ~
(current-output-port out) -> void?
  out : output-port? ~

A parameter that determines a default output port for many operations,
such as write.

                                        *current-error-port*
(current-error-port) -> output-port? ~
(current-error-port out) -> void?
  out : output-port? ~

A parameter that determines an output port that is typically used for
errors and logging. For example, the default error display handler
writes to this port.

                                        *file-stream-port?*
(file-stream-port? port) -> boolean? ~
  port : port? ~

Returns #t if the given port is a file-stream port (see File Ports), #f
otherwise.

                                        *terminal-port?*
(terminal-port? port) -> boolean? ~
  port : port? ~

Returns #t if the given port is attached to an interactive terminal, #f
otherwise.

eof : eof-object? ~

A value (distinct from all other values) that represents an end-of-file.

                                        *eof-object?*
(eof-object? a) -> boolean? ~
  a : any/c ~

Returns #t if v is eof, #f otherwise.

1.3. Port Buffers and Positions

Some ports—especially those that read from and write to files—are
internally buffered:

* An input port is typically block-buffered by default, which means that
  on any read, the buffer is filled with immediately-available bytes to
  speed up future reads. Thus, if a file is modified between a pair of
  reads to the file, the second read can produce stale data. Calling
  file-position to set an input port’s file position flushes its buffer.

* An output port is typically block-buffered by default, though a
  terminal output port is line-buffered, and the initial error output
  port is unbuffered.  An output buffer is filled with a sequence of
  written bytes to be committed as a group, either when the buffer is
  full (in block mode), when a newline is written (in line mode), when
  the port is closed via close-output-port, or when a flush is
  explicitly requested via a procedure like flush-output.

If a port supports buffering, its buffer mode can be changed via
file-stream-buffer-mode (even if the port is not a file-stream port).

For an input port, peeking always places peeked bytes into the port’s
buffer, even when the port’s buffer mode is 'none; furthermore, on some
platforms, testing the port for input (via char-ready? or sync) may be
implemented with a peek. If an input port’s buffer mode is 'none, then
at most one byte is read for read-bytes-avail!*, read-bytes-avail!,
peek-bytes-avail!*, or peek-bytes-avail!; if any bytes are buffered in
the port (e.g., to satisfy a previous peek), the procedures may access
multiple buffered bytes, but no further bytes are read.

In addition, the initial current output and error ports are
automatically flushed when read, read-line, read-bytes, read-string,
etc., are performed on the initial standard input port; more precisely,
flushing is performed by the default port read handler (see
port-read-handler).

                                        *flush-output*
(flush-output [out]) -> void? ~
  out : output-port? = (current-output-port) ~

Forces all buffered data in the given output port to be physically
written. Only file-stream ports, TCP ports, and custom ports (see Custom
Ports) use buffers; when called on a port without a buffer, flush-output
has no effect.

                                        *file-stream-buffer-mode*
(file-stream-buffer-mode port) -> (or/c 'none 'line 'block #f) ~
  port : port? ~
(file-stream-buffer-mode port mode) -> void?
  port : port? ~
  mode : (or/c 'none 'line 'block) ~

Gets or sets the buffer mode for port, if possible. File-stream ports
support setting the buffer mode, TCP ports (see [missing]) support
setting and getting the buffer mode, and custom ports (see Custom Ports)
may support getting and setting buffer modes.

If mode is provided, it must be one of 'none, 'line (output only), or
'block, and the port’s buffering is set accordingly. If the port does
not support setting the mode, the exn:fail exception is raised.

If mode is not provided, the current mode is returned, or #f is returned
if the mode cannot be determined. If port is an input port and mode is
'line, the exn:fail:contract exception is raised.

                                        *file-position*
(file-position port) -> exact-nonnegative-integer? ~
  port : port? ~
(file-position port pos) -> void?
  port : port? ~
  pos : (or/c exact-nonnegative-integer? eof-object?) ~

Returns or sets the current read/write position of port.

Calling file-position without a position on a port other than a
file-stream port or string port returns the number of bytes that have
been read from that port if the position is known (see Counting
Positions, Lines, and Columns), otherwise the exn:fail:filesystem
exception is raised.

For file-stream ports and string ports, the position-setting variant
sets the read/write position to pos relative to the beginning of the
file or (byte) string if pos is a number, or to the current end of the
file or (byte) string if pos is eof. In position-setting mode,
file-position raises the exn:fail:contract exception for port kinds
other than file-stream ports and string ports. Furthermore, not all
file-stream ports support setting the position; if file-position is
called with a position argument on such a file-stream port, the
exn:fail:filesystem exception is raised.

When file-position sets the position pos beyond the current size of an
output file or (byte) string, the file/string is enlarged to size pos
and the new region is filled with 0 bytes.  If pos is beyond the end of
an input file or (byte) string, then reading thereafter returns eof
without changing the port’s position.

When changing the file position for an output port, the port is first
flushed if its buffer is not empty. Similarly, setting the position for
an input port clears the port’s buffer (even if the new position is the
same as the old position). However, although input and output ports
produced by open-input-output-file share the file position, setting the
position via one port does not flush the other port’s buffer.

                                        *file-position**
(file-position* port) -> (or/c exact-nonnegative-integer? #f) ~
  port : port? ~

Like file-position on a single argument, but returns #f if the position
is not known.

                                        *file-truncate*
(file-truncate port size) -> void? ~
  port : (and/c output-port? file-stream-port?) ~
  size : exact-nonnegative-integer? ~

Sets the size of the file written by port to size, assuming that the
port is associated to a file whose size can be set.

The new file size can be either larger or smaller than its current size,
but “truncate” in this function’s name reflects that it is normally used
to decrease the size of a file, since writing to a file or using
file-position can extend a file’s size.

1.4. Counting Positions, Lines, and Columns

By default, Racket keeps track of the position in a port as the number
of bytes that have been read from or written to any port (independent of
the read/write position, which is accessed or changed with
file-position). Optionally, however, Racket can track the position in
terms of characters (after UTF-8 decoding), instead of bytes, and it can
track line locations and column locations; this optional tracking must
be specifically enabled for a port via port-count-lines! or the
port-count-lines-enabled parameter. Position, line, and column locations
for a port are used by read-syntax. Position and line locations are
numbered from 1; column locations are numbered from 0.

When counting lines, Racket treats linefeed, return, and return-linefeed
combinations as a line terminator and as a single position (on all
platforms). Each tab advances the column count to one before the next
multiple of 8. When a sequence of bytes in the range 128 to 253 forms a
UTF-8 encoding of a character, the position/column is incremented once
for each byte, and then decremented appropriately when a complete
encoding sequence is discovered. See also Ports for more information on
UTF-8 decoding for ports.

A position is known for any port as long as its value can be expressed
as a fixnum (which is more than enough tracking for realistic
applications in, say, syntax-error reporting).  If the position for a
port exceeds the value of the largest fixnum, then the position for the
port becomes unknown, and line and column tacking is disabled.
Return-linefeed combinations are treated as a single character position
only when line and column counting is enabled.

Custom ports can define their own counting functions, which are not
subject to the rules above, except that the counting functions are
invoked only when tracking is specifically enabled with
port-count-lines!.

                                        *port-count-lines!*
(port-count-lines! port) -> void? ~
  port : port? ~

Turns on line location and column location counting for a port. Counting
can be turned on at any time, though generally it is turned on before
any data is read from or written to a port. At the point that line
counting is turned on, port-next-location typically starts reporting as
its last result (one more than) the number of characters read since line
counting was enabled, instead of (one more than) bytes read since the
port was opened.

When a port is created, if the value of the port-count-lines-enabled
parameter is true, then line counting is automatically enabled for the
port. Line counting cannot be disabled for a port after it is enabled.

                                        *port-counts-lines?*
(port-counts-lines? port) -> boolean? ~
  port : port? ~

Returns #t if line location and column location counting has been
enabled for port, #f otherwise.

                                        *port-next-location*
(port-next-location port) ~
 -> (or/c exact-positive-integer? #f)
    (or/c exact-nonnegative-integer? #f)
    (or/c exact-positive-integer? #f)
  port : port? ~

Returns three values: an integer or #f for the line number of the next
read/written item, an integer or #f for the next item’s column, and an
integer or #f for the next item’s position. The next column and position
normally increase as bytes are read from or written to the port, but if
line/character counting is enabled for port, the column and position
results can decrease after reading or writing a byte that ends a UTF-8
encoding sequence.

If line counting is not enabled for a port, than the first two results
are #f, and the last result is one more than the number of bytes read so
far. At the point when line counting is enabled, the first two results
typically become non-#f, and last result starts reporting characters
instead of bytes, typically starting from the point when line counting
is enabled.

Even with line counting enabled, a port may return #f values if it
somehow cannot keep track of lines, columns, or positions.

                                        *set-port-next-location!*
(set-port-next-location! port           ~
                         line          
                         column        
                         position) -> void?
  port : port? ~
  line : (or/c exact-positive-integer? #f) ~
  column : (or/c exact-nonnegative-integer? #f) ~
  position : (or/c exact-positive-integer? #f) ~

Sets the next line, column, and position for port. If line counting has
not been enabled for port or if port is a custom port that defines its
own counting function, then set-port-next-location! has no effect.

                                        *port-count-lines-enabled*
(port-count-lines-enabled) -> boolean? ~
(port-count-lines-enabled on?) -> void?
  on? : any/c ~

A parameter that determines whether line counting is enabled
automatically for newly created ports. The default value is #f.

1.5. File Ports

A port created by open-input-file, open-output-file, subprocess, and
related functions is a file-stream port.  The initial input, output, and
error ports in racket are also file-stream ports. The file-stream-port?
predicate recognizes file-stream ports.

When an input or output file-stream port is created, it is placed into
the management of the current custodian (see [missing]). In the case of
an output port, a flush callback is registered with the current plumber
to flush the port.

                                        *open-input-file*
(open-input-file  path                             ~
                 [#:mode mode-flag                 ~
                  #:for-module? for-module?]) -> input-port? ~
  path : path-string? ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  for-module? : any/c = #f ~

Opens the file specified by path for input. The mode-flag argument
specifies how the file’s bytes are translated on input:

* 'binary — bytes are returned from the port exactly as they are read
  from the file.

* 'text — return and linefeed bytes (10 and 13) as read from the file
  are filtered by the port in a platform specific manner:

  * Unix and Mac OS X: no filtering occurs.

  * Windows: a return-linefeed combination from a file is returned by
    the port as a single linefeed; no filtering occurs for return bytes
    that are not followed by a linefeed, or for a linefeed that is not
    preceded by a return.

On Windows, 'text mode works only with regular files; attempting to use
'text with other kinds of files triggers an exn:fail:filesystem
exception.

Otherwise, the file specified by path need not be a regular file. It
might be a device that is connected through the filesystem, such as
"aux" on Windows or "/dev/null" on Unix. In all cases, the port is
buffered by default.

The port produced by open-input-file should be explicitly closed, either
though close-input-port or indirectly via custodian-shutdown-all, to
release the OS-level file handle. The input port will not be closed
automatically if it is otherwise available for garbage collection (see
[missing]); a will could be associated with an input port to close it
more automatically (see [missing]).

A path value that is the cleansed version of path is used as the name of
the opened port.

If opening the file fails, if for-module? is true, and
current-module-path-for-load has a non-#f value, then the raised
exception is either exn:fail:syntax:missing-module (if the value of
current-module-path-for-load is a syntax object) or
exn:fail:filesystem:missing-module (otherwise).

Changed in version 6.0.1.6: Added #:for-module?.

Examples:
  > (with-output-to-file some-file
      (lambda () (printf "hello world")))

  (define in (open-input-file some-file))


  > (read-string 11 in)
  "hello world"
  > (close-input-port in)


                                        *open-output-file*
(open-output-file  path                        ~
                  [#:mode mode-flag            ~
                   #:exists exists-flag]) -> output-port? ~
  path : path-string? ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  exists-flag : (or/c 'error 'append 'update 'can-update ~
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error

Opens the file specified by path for output. The mode-flag argument
specifies how bytes written to the port are translated when written to
the file:

* 'binary — bytes are written to the file exactly as written to the
  port.

* 'text — on Windows, a linefeed byte (10) written to the port is
  translated to a return-linefeed combination in the file; no filtering
  occurs for returns.

On Windows, 'text mode works only with regular files; attempting to use
'text with other kinds of files triggers an exn:fail:filesystem
exception.

The exists-flag argument specifies how to handle/require files that
already exist:

* 'error — raise exn:fail:filesystem if the file exists.

* 'replace — remove the old file, if it exists, and write a new one.

* 'truncate — remove all old data, if the file exists.

* 'must-truncate — remove all old data in an existing file; if the file
  does not exist, the exn:fail:filesystem exception is raised.

* 'truncate/replace — try 'truncate; if it fails (perhaps due to file
  permissions), try 'replace.

* 'update — open an existing file without truncating it; if the file
  does not exist, the exn:fail:filesystem exception is raised. Use
  file-position to change the current read/write position.

* 'can-update — open an existing file without truncating it, or create
  the file if it does not exist.

* 'append — append to the end of the file, whether it already exists or
  not; on Windows, 'append is equivalent to 'update, except that the
  file is not required to exist, and the file position is immediately
  set to the end of the file after opening it.

The file specified by path need not be a regular file. It might be a
device that is connected through the filesystem, such as "aux" on
Windows or "/dev/null" on Unix. The output port is block-buffered by
default, unless the file corresponds to a terminal, in which case it is
line-buffered by default.

The port produced by open-output-file should be explicitly closed,
either though close-output-port or indirectly via
custodian-shutdown-all, to release the OS-level file handle. The output
port will not be closed automatically if it is otherwise available for
garbage collection (see [missing]); a will could be associated with an
output port to close it more automatically (see [missing]).

A path value that is the cleansed version of path is used as the name of
the opened port.

Examples:
  (define out (open-output-file some-file))


  > (write "hello world" out)

  > (close-output-port out)


                                        *open-input-output-file*
(open-input-output-file  path                    ~
                        [#:mode mode-flag        ~
                         #:exists exists-flag])  ~
 -> input-port? output-port?
  path : path-string? ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  exists-flag : (or/c 'error 'append 'update 'can-update ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like open-output-file, but producing two values: an input port and an
output port. The two ports are connected in that they share the
underlying file descriptor. This procedure is intended for use with
special devices that can be opened by only one process, such as "COM1"
in Windows. For regular files, sharing the file descriptor can be
confusing. For example, using one port does not automatically flush the
other port’s buffer, and reading or writing in one port moves the file
position (if any) for the other port. For regular files, use separate
open-input-file and open-output-file calls to avoid confusion.

                                        *call-with-input-file*
(call-with-input-file  path                    ~
                       proc                   
                      [#:mode mode-flag]) -> any ~
  path : path-string? ~
  proc : (input-port? . -> . any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~

Calls open-input-file with the path and mode-flag arguments, and passes
the resulting port to proc. The result of proc is the result of the
call-with-input-file call, but the newly opened port is closed when proc
returns.

Examples:
  > (with-output-to-file some-file
      (lambda () (printf "text in a file")))

  > (call-with-input-file some-file
      (lambda (in) (read-string 14 in)))
  "text in a file"

                                        *call-with-output-file*
(call-with-output-file  path                        ~
                        proc                       
                       [#:mode mode-flag            ~
                        #:exists exists-flag]) -> any ~
  path : path-string? ~
  proc : (output-port? . -> . any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  exists-flag : (or/c 'error 'append 'update ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Analogous to call-with-input-file, but passing path, mode-flag and
exists-flag to open-output-file.

Examples:
  > (call-with-output-file some-file
      (lambda (out)
        (write 'hello out)))

  > (call-with-input-file some-file
      (lambda (in)
        (read-string 5 in)))
  "hello"

                                        *call-with-input-file**
(call-with-input-file*  path                    ~
                        proc                   
                       [#:mode mode-flag]) -> any ~
  path : path-string? ~
  proc : (input-port? . -> . any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~

Like call-with-input-file, but the newly opened port is closed whenever
control escapes the dynamic extent of the call-with-input-file* call,
whether through proc’s return, a continuation application, or a
prompt-based abort.

                                        *call-with-output-file**
(call-with-output-file*  path                        ~
                         proc                       
                        [#:mode mode-flag            ~
                         #:exists exists-flag]) -> any ~
  path : path-string? ~
  proc : (output-port? . -> . any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  exists-flag : (or/c 'error 'append 'update ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like call-with-output-file, but the newly opened port is closed whenever
control escapes the dynamic extent of the call-with-output-file* call,
whether through proc’s return, a continuation application, or a
prompt-based abort.

                                        *with-input-from-file*
(with-input-from-file  path                    ~
                       thunk                  
                      [#:mode mode-flag]) -> any ~
  path : path-string? ~
  thunk : (-> any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~

Like call-with-input-file*, but instead of passing the newly opened port
to the given procedure argument, the port is installed as the current
input port (see current-input-port) using parameterize around the call
to thunk.

Examples:
  > (with-output-to-file some-file
      (lambda () (printf "hello")))

  > (with-input-from-file some-file
      (lambda () (read-string 5)))
  "hello"

                                        *with-output-to-file*
(with-output-to-file  path                        ~
                      thunk                      
                     [#:mode mode-flag            ~
                      #:exists exists-flag]) -> any ~
  path : path-string? ~
  thunk : (-> any) ~
  mode-flag : (or/c 'binary 'text) = 'binary ~
  exists-flag : (or/c 'error 'append 'update ~
                      'replace 'truncate 'truncate/replace)
              = 'error

Like call-with-output-file*, but instead of passing the newly opened
port to the given procedure argument, the port is installed as the
current output port (see current-output-port) using parameterize around
the call to thunk.

Examples:
  > (with-output-to-file some-file
      (lambda () (printf "hello")))

  > (with-input-from-file some-file
      (lambda () (read-string 5)))
  "hello"

                                        *port-try-file-lock?*
(port-try-file-lock? port mode) -> boolean? ~
  port : file-stream-port? ~
  mode : (or/c 'shared 'exclusive) ~

Attempts to acquire a lock on the file using the current platform’s
facilities for file locking. Multiple processes can acquire a 'shared
lock on a file, but at most one process can hold an 'exclusive lock, and
'shared and 'exclusive locks are mutually exclusive. When mode is
'shared, then port must be an input port; when mode is 'exclusive, then
port must be an output port.

The result is #t if the requested lock is acquired, #f otherwise. When a
lock is acquired, it is held until either it is released with
port-file-unlock or the port is closed (perhaps because the process
terminates).

Depending on the platform, locks may be merely advisory (i.e., locks
affect only the ability of processes to acquire locks) or they may
correspond to mandatory locks that prevent reads and writes to the
locked file. Specifically, locks are mandatory on Windows and advisory
on other platforms. Multiple tries for a 'shared lock on a single port
can succeed; on Unix and Mac OS X, a single port-file-unlock release the
lock, while on other Windows, a port-file-unlock is needed for each
successful port-try-file-lock?. On Unix and Mac OS X, multiple tries for
a 'exclusive lock can succeed and a single port-file-unlock releases the
lock, while on Windows, a try for an 'exclusive lock fails for a given
port if the port already holds the lock.

A lock acquired for an input port from open-input-output-file can be
released through port-file-unlock on the corresponding output port, and
vice versa. If the output port from open-input-output-file holds an
'exclusive lock, the corresponding input port can still acquire a
'shared lock, even multiple times; on Windows, a port-file-unlock is
needed for each successful lock try, while a single port-file-unlock
balances the lock tries on Unix and Mac OS X. A 'shared lock on an input
port can be upgraded to an 'exclusive lock through the corresponding
output port on Unix and Mac OS X, in which case a single
port-file-unlock (on either port) releases the lock, while such upgrades
are not allowed on Windows.

Locking is normally supported only for file ports, and attempting to
acquire a lock with other kinds of file-stream ports raises an
exn:fail:filesystem exception.

                                        *port-file-unlock*
(port-file-unlock port) -> void? ~
  port : file-stream-port? ~

Releases a lock held by the current process on the file of port.

                                        *port-file-identity*
(port-file-identity port) -> exact-positive-integer? ~
  port : file-stream-port? ~

Returns a number that represents the identity of the device and file
read or written by port. For two ports whose open times overlap, the
result of port-file-identity is the same for both ports if and only if
the ports access the same device and file. For ports whose open times do
not overlap, no guarantee can be provided for the port identities (even
if the ports actually access the same file)—except as can be inferred
through relationships with other ports. If port is closed, the exn:fail
exception is raised.  On Windows 95, 98, and Me, if port is connected to
a pipe instead of a file, the exn:fail:filesystem exception is raised.

Examples:
  (define file1 (open-output-file some-file))


  (define file2 (open-output-file some-other-file))


  > (port-file-identity file1)
  4632302337
  > (port-file-identity file2)
  4632703489
  > (close-output-port file1)

  > (close-output-port file2)


1.6. String Ports

A string port reads or writes from a byte string. An input string port
can be created from either a byte string or a string; in the latter
case, the string is effectively converted to a byte string using
string->bytes/utf-8. An output string port collects output into a byte
string, but get-output-string conveniently converts the accumulated
bytes to a string.

Input and output string ports do not need to be explicitly closed. The
file-position procedure works for string ports in position-setting mode.

+[missing] also provides information on bytestrings.

                                        *string-port?*
(string-port? p) -> boolean? ~
  p : port? ~

Returns #t if p is a string port, #f otherwise.

Added in version 6.0.1.6.

                                        *open-input-bytes*
(open-input-bytes bstr [name]) -> (and/c input-port? string-port?) ~
  bstr : bytes? ~
  name : any/c = 'string ~

Creates an input string port that reads characters from bstr (see
[missing]). Modifying bstr afterward does not affect the byte stream
produced by the port. The optional name argument is used as the name for
the returned port.

Examples:
  > (define sp (open-input-bytes #"(apples 42 day)"))

  > (define sexp1 (read sp))

  > (first sexp1)
  'apples
  > (rest sexp1)
  '(42 day)
  > (read-line (open-input-bytes
                #"the cow jumped over the moon\nthe little dog\n"))
  "the cow jumped over the moon"

+[missing] also provides information on strings.

                                        *open-input-string*
(open-input-string str [name]) -> (and/c input-port? string-port?) ~
  str : string? ~
  name : any/c = 'string ~

Creates an input string port that reads bytes from the UTF-8 encoding
(see Encodings and Locales) of str. The optional name argument is used
as the name for the returned port.

Examples:
  > (define sp (open-input-string "(λ (x) x)"))

  > (read sp)
  '(λ (x) x)
  > (define names (open-input-string "Günter Harder\nFrédéric Paulin\n"))

  > (read-line names)
  "Günter Harder"
  > (read-line names)
  "Frédéric Paulin"

                                        *open-output-bytes*
(open-output-bytes [name]) -> (and/c output-port? string-port?) ~
  name : any/c = 'string ~

Creates an output string port that accumulates the output into a byte
string. The optional name argument is used as the name for the returned
port.

Examples:
  > (define op1 (open-output-bytes))

  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op1)

  > (get-output-bytes op1)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (define op2 (open-output-bytes))

  > (write "Hi " op2)

  > (write "there" op2)

  > (get-output-bytes op2)
  #"\"Hi \"\"there\""
  > (define op3 (open-output-bytes))

  > (write-bytes #"Hi " op3)
  3
  > (write-bytes #"there" op3)
  5
  > (get-output-bytes op3)
  #"Hi there"

                                        *open-output-string*
(open-output-string [name]) -> (and/c output-port? string-port?) ~
  name : any/c = 'string ~

The same as open-output-bytes.

Examples:
  > (define op1 (open-output-string))

  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op1)

  > (get-output-string op1)
  "((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (define op2 (open-output-string))

  > (write "Hi " op2)

  > (write "there" op2)

  > (get-output-string op2)
  "\"Hi \"\"there\""
  > (define op3 (open-output-string))

  > (write-string "Hi " op3)
  3
  > (write-string "there" op3)
  5
  > (get-output-string op3)
  "Hi there"

                                        *get-output-bytes*
(get-output-bytes  out            ~
                  [reset?        
                   start-pos     
                   end-pos]) -> bytes?
  out : (and/c output-port? string-port?) ~
  reset? : any/c = #f ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = #f ~

Returns the bytes accumulated in the string port out so far in a freshly
allocated byte string (including any bytes written after the port’s
current position, if any). The out port must be an output string port
produced by open-output-bytes (or open-output-string) or a structure
whose prop:output-port property refers to such an output port
(transitively).

If reset? is true, then all bytes are removed from the port, and the
port’s position is reset to 0; if reset? is #f, then all bytes remain in
the port for further accumulation (so they are returned for later calls
to get-output-bytes or get-output-string), and the port’s position is
unchanged.

The start-pos and end-pos arguments specify the range of bytes in the
port to return; supplying start-pos and end-pos is the same as using
subbytes on the result of get-output-bytes, but supplying them to
get-output-bytes can avoid an allocation. The end-pos argument can be
#f, which corresponds to not passing a second argument to subbytes.

Examples:
  > (define op (open-output-bytes))

  > (write '((1 2 3) ("Tom" "Dick") ('a 'b 'c)) op)

  > (get-output-bytes op)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (get-output-bytes op #f 3 16)
  #" 2 3) (\"Tom\" "
  > (get-output-bytes op #t)
  #"((1 2 3) (\"Tom\" \"Dick\") ((quote a) (quote b) (quote c)))"
  > (get-output-bytes op)
  #""

                                        *get-output-string*
(get-output-string out) -> string? ~
  out : (and/c output-port? string-port?) ~

Returns (bytes->string/utf-8 (get-output-bytes out) #\?).

Examples:
  > (define i (open-input-string "hello world"))

  > (define o (open-output-string))

  > (write (read i) o)

  > (get-output-string o)
  "hello"

1.7. Pipes

A Racket pipe is internal to Racket, and not related to OS-level pipes
for communicating between different processes.OS-level pipes may be
created by subprocess, opening an existing named file on a Unix
filesystem, or starting Racket with pipes for its original input,
output, or error port. Such pipes are file-stream ports, unlike the
pipes produced by make-pipe.

                                        *make-pipe*
(make-pipe [limit input-name output-name]) ~
 -> input-port? output-port?
  limit : exact-positive-integer? = #f ~
  input-name : any/c = 'pipe ~
  output-name : any/c = 'pipe ~

Returns two port values: the first port is an input port and the second
is an output port. Data written to the output port is read from the
input port, with no intermediate buffering. Unlike some other kinds of
ports, pipe ports do not need to be explicitly closed to be reclaimed by
garbage collection.

If limit is #f, the new pipe holds an unlimited number of unread bytes
(i.e., limited only by the available memory). If limit is a positive
number, then the pipe will hold at most limit unread/unpeeked bytes;
writing to the pipe’s output port thereafter will block until a read or
peek from the input port makes more space available. (Peeks effectively
extend the port’s capacity until the peeked bytes are read.)

The optional input-name and output-name are used as the names for the
returned input and output ports, respectively.

                                        *pipe-content-length*
(pipe-content-length pipe-port) -> exact-nonnegative-integer? ~
  pipe-port : port? ~

Returns the number of bytes contained in a pipe, where pipe-port is
either of the pipe’s ports produced by make-pipe. The pipe’s content
length counts all bytes that have been written to the pipe and not yet
read (though possibly peeked).

1.8. Structures as Ports

prop:input-port : struct-type-property? ~

prop:output-port : struct-type-property? ~

The prop:input-port and prop:output-port structure type properties
identify structure types whose instances can serve as input and output
ports, respectively.

Each property value can be either of the following:

* An input port (for prop:input-port) or output port (for
  prop:output-port): In this case, using the structure as port is
  equivalent to using the given input or output port.

* An exact, non-negative integer between 0 (inclusive) and the number of
  non-automatic fields in the structure type (exclusive, not counting
  supertype fields): The integer identifies a field in the structure,
  and the field must be designated as immutable. If the field contains
  an input port (for prop:input-port) or output port (for
  prop:output-port), the port is used. Otherwise, an empty string input
  port is used for prop:input-port, and a port that discards all data is
  used for prop:output-port.

Some procedures, such as file-position, work on both input and output
ports. When given an instance of a structure type with both the
prop:input-port and prop:output-port properties, the instance is used as
an input port.

1.9. Custom Ports

The make-input-port and make-output-port procedures create custom ports
with arbitrary control procedures (much like implementing a device
driver). Custom ports are mainly useful to obtain fine control over the
action of committing bytes as read or written.

                                        *make-input-port*
(make-input-port  name                  ~
                  read-in              
                  peek                 
                  close                
                 [get-progress-evt     
                  commit               
                  get-location         
                  count-lines!         
                  init-position        
                  buffer-mode])    -> input-port?
  name : any/c ~
  read-in : (or/c ~
             (bytes?
              . -> . (or/c exact-nonnegative-integer?
                           eof-object?
                           procedure?
                           evt?))
             input-port?)
  peek : (or/c ~
          (bytes? exact-nonnegative-integer? (or/c evt? #f)
                  . -> . (or/c exact-nonnegative-integer?
                               eof-object?
                               procedure?
                               evt?
                               #f))
          input-port?)
  close : (-> any) ~
  get-progress-evt : (or/c (-> evt?) #f) = #f ~
  commit : (or/c (exact-positive-integer? evt? evt? . -> . any) ~
                 #f)
         = #f
  get-location : (or/c ~
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void ~
  init-position : (or/c exact-positive-integer? ~
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any) ~
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f

Creates an input port, which is immediately open for reading. If close
procedure has no side effects, then the port need not be explicitly
closed. See also make-input-port/read-to-peek.

The arguments implement the port as follows:

* name — the name for the input port.

* read-in — either an input port, in which case reads     are redirected
  to the given port, or a procedure that takes a single     argument:
  a mutable byte string to receive read bytes. The procedure’s
  result is one of the following:

  * the number of bytes read, as an exact, non-negative integer;

  * eof;

  * a procedure of arity four (representing a “special” result, as
    discussed further below) and optionally of arity zero, but a
    procedure result is allowed only when peek is not #f;

  * a pipe input port that supplies bytes to be used as long as the pipe
    has content (see pipe-content-length) or until read-in or peek is
    called again; or

  * a synchronizable event (see [missing]) other than a pipe input port
    or procedure of arity four; the event becomes ready when the read is
    complete (roughly): the event’s value can be one of the above three
    results or another event like itself; in the last case, a reading
    process loops with sync until it gets a non-event result.

  The read-in procedure must not block indefinitely. If no     bytes are
  immediately available for reading, the read-in     must return 0 or an
  event, and preferably an event (to     avoid busy waits). The read-in
  should not return     0 (or an event whose value is 0) when data is
  available in the port, otherwise polling the port will behave
  incorrectly. An event result from an event can also break polling.

  If the result of a read-in call is not one of the above     values,
  the exn:fail:contract exception is raised. If a returned integer is
  larger than the supplied byte string’s length, the
  exn:fail:contract exception is raised. If peek is #f and     a
  procedure for a special result is returned,     the exn:fail:contract
  exception is raised.

  The read-in procedure can report an error by raising an     exception,
  but only if no bytes are read. Similarly, no bytes     should be read
  if eof, an event, or a procedure is     returned. In other words, no
  bytes should be lost due to spurious     exceptions or non-byte data.

  A port’s reading procedure may be called in multiple threads
  simultaneously (if the port is accessible in multiple threads),
  and the port is responsible for its own internal     synchronization.
  Note that improper implementation of such     synchronization
  mechanisms might cause a non-blocking read     procedure to block
  indefinitely.

  If the result is a pipe input port, then previous     get-progress-evt
  calls whose event is not yet ready must     have been the pipe input
  port itself. Furthermore,     get-progress-evt must continue to return
  the pipe as long     as it contains data, or until the read-in or
  peek-in procedure is called again (instead of using the     pipe, for
  whatever reason). If read-in or     peek-in is called, any previously
  associated pipe (as     returned by a previous call) is disassociated
  from the     port and is not in use by any other thread as a result of
  the     previous association.

  If peek, get-progress-evt, and     commit are all provided and
  non-#f, then the following is an acceptable implementation     of
  read-in:

    (lambda (bstr)
      (let* ([progress-evt (get-progress-evt)]
             [v (peek bstr 0 progress-evt)])
        (cond
         [(sync/timeout 0 progress-evt) 0] ; try again
         [(evt? v) (wrap-evt v (lambda (x) 0))] ; sync, try again
         [(and (number? v) (zero? v)) 0] ; try again
         [else
          (if (commit (if (number? v) v 1)
                          progress-evt
                          always-evt)
              v      ; got a result
              0)]))) ; try again

  An implementor may choose not to implement the peek,
  get-progress-evt, and commit     procedures, however, and even an
  implementor who does supply     them may provide a different read-in
  that uses a fast path for non-blocking reads.

  In an input port is provided for read-in, then an input port     must
  also be provided for peek.

* peek — either #f, an input port (in which case peeks are redirected to
  the given port), or a procedure that takes three arguments:

  * a mutable byte string to receive peeked bytes;

  * a non-negative number of bytes (or specials) to skip before peeking;
    and

  * either #f or a progress event produced by get-progress-evt.

  The results and conventions for peek are mostly the same  as for
  read-in. The main difference is in the handling of  the progress
  event, if it is not #f.  If the given  progress event becomes ready,
  the peek must abort any  skip attempts and not peek any values. In
  particular,  peek must not peek any values if the progress event is
  initially ready. If the port has been closed, the progress event
  should be ready, in which case peek should complete  (instead of
  failing because the port is closed).

  Unlike read-in, peek should produce  #f (or an event whose value is
  #f) if no bytes  were peeked because the progress event became ready.
  Like  read-in, a 0 result indicates that another  attempt is likely to
  succeed, so 0 is inappropriate when  the progress event is ready. Also
  like read-in,  peek must not block indefinitely.

  The skip count provided to peek is a number of bytes (or  specials)
  that must remain present in the  port—in addition to the peek
  results—when the peek results are  reported. If a progress event is
  supplied, then the peek is  effectively canceled when another process
  reads data before the  given number can be skipped. If a progress
  event is not supplied  and data is read, then the peek must
  effectively restart with the  original skip count.

  The system does not check that multiple peeks return consistent
  results, or that peeking and reading produce consistent results.

  If peek is #f, then peeking for the port is  implemented automatically
  in terms of reads, but with several  limitations. First, the automatic
  implementation is not  thread-safe. Second, the automatic
  implementation cannot handle  special results (non-byte and non-eof),
  so  read-in cannot return a procedure for a  special when peek is  #f.
  Finally, the automatic peek implementation is  incompatible with
  progress events, so if peek is  #f, then get-progress-evt and commit
  must  be #f. See also make-input-port/read-to-peek,  which implements
  peeking in terms of read-in without  these constraints.

  In an input port is provided for peek, then an input port  must also
  be provided for read-in.

* close — a procedure of zero arguments that is called to close the
  port. The port is not considered closed until the closing procedure
  returns. The port’s procedures will never be used again via the port
  after it is closed. However, the closing procedure can be called
  simultaneously in multiple threads (if the port is accessible in
  multiple threads), and it may be called during a call to the other
  procedures in another thread; in the latter case, any outstanding
  reads and peeks should be terminated with an error.

* get-progress-evt — either #f (the default), or a procedure that takes
  no arguments and returns an event. The event must become ready only
  after data is next read from the port or the port is closed. If the
  port is already closed, the event must be ready. After the event
  becomes ready, it must remain so. See the description of read-in for
  information about the allowed results of this function when read-in
  returns a pipe input port. See also semaphore-peek-evt, which is
  sometimes useful for implementing get-progress-evt.

  If get-progress-evt is #f, then port-provides-progress-evts? applied
  to the port will produce #f, and the port will not be a valid argument
  to port-progress-evt.

  The result event will not be exposed directly by port-progress-evt.
  Instead, it will be wrapped in an event for which progress-evt?
  returns true.

* commit — either #f (the default), or a procedure that takes three
  arguments:

  * an exact, positive integer kr;

  * a progress event produced by get-progress-evt;

  * an event, done, that is either a channel-put event, channel,
    semaphore, semaphore-peek event, always event, or never event.

  A commit corresponds to removing data from the stream  that was
  previously peeked, but only if no other process removed  data first.
  (The removed data does not need to be reported,  because it has been
  peeked already.) More precisely, assuming  that kp bytes, specials,
  and  mid-stream eofs have been previously peeked or skipped  at the
  start of the port’s stream, commit must satisfy  the following
  constraints:

  * It must return only when the commit is complete or when the given
    progress event becomes ready.

  * It must commit only if kp is positive.

  * If it commits, then it must do so with either kr items or kp items,
    whichever is smaller, and only if kp is positive.

  * It must never choose done in a synchronization after the given
    progress event is ready, or after done has been synchronized once.

  * It must not treat any data as read from the port unless done is
    chosen in a synchronization.

  * It must not block indefinitely if done is ready; it must return soon
    after the read completes or soon after the given progress event is
    ready, whichever is first.

  * It can report an error by raising an exception, but only if no data
    has been committed. In other words, no data should be lost due to an
    exception, including a break exception.

  * It must return a true value if data has been committed, #f
    otherwise. When it returns a value, the given progress event must be
    ready (perhaps because data has just been committed).

  * It should return a byte string as a true result when line counting
    is enabled and get-location is #f (so that line counting is
    implemented the default way); the result byte string represents the
    data that was committed for the purposes of character and line
    counting. If any other true result is returned when a byte string is
    expected, it is treated like a byte string where each byte
    corresponds to a non-newline character.

  * It must raise an exception if no data (including eof) has been
    peeked from the beginning of the port’s stream, or if it would have
    to block indefinitely to wait for the given progress event to become
    ready.

  A call to commit is parameterize-breaked to disable breaks.

* get-location — either #f (the default), or a procedure that takes no
  arguments and returns three values: the line number for the next item
  in the port’s stream (a positive number or #f), the column number for
  the next item in the port’s stream (a non-negative number or #f), and
  the position for the next item in the port’s stream (a positive number
  or #f). See also Counting Positions, Lines, and Columns.

  This procedure is called to implement port-next-location, but only if
  line counting is enabled for the port via port-count-lines! (in which
  case count-lines! is called). The read and read-syntax procedures
  assume that reading a non-whitespace character increments the column
  and position by one.

* count-lines! — a procedure of no arguments that is called if and when
  line counting is enabled for the port. The default procedure is void.

* init-position — normally an exact, positive integer that determines
  the position of the port’s first item, which is used by file-position
  or when line counting is not enabled for the port. The default is 1.
  If init-position is #f, the port is treated as having an unknown
  position. If init-position is a port, then the given port’s position
  is always used for the new port’s position. If init-position is a
  procedure, it is called as needed to obtain the port’s position.

* buffer-mode — either #f (the default) or a procedure that accepts zero
  or one arguments. If buffer-mode is #f, then the resulting port does
  not support a buffer-mode setting. Otherwise, the procedure is called
  with one symbol argument ('block or 'none) to set the buffer mode, and
  it is called with zero arguments to get the current buffer mode. In
  the latter case, the result must be 'block, 'none, or #f (unknown).
  See Port Buffers and Positions for more information on buffer modes.

“Special” results: When  read-in or peek (or an event produced by one of
these) returns a procedure, the procedure is used to obtain a  non-byte
result. (This non-byte result is not intended to  return a character or
eof; in particular, read-char  raises an exception if it encounters a
special-result procedure, even  if the procedure produces a byte.) A
special-result procedure must  accept four arguments, and it can
optionally accept zero arguments:

* When the special read is triggered by read-syntax or
  read-syntax/recursive, the procedure is passed four arguments that
  represent a source location.

* When the special read is triggered by read, read-byte-or-special,
  read-char-or-special, peek-byte-or-special, or peek-char-or-special,
  the procedure is passed no arguments if it accepts zero arguments,
  otherwise it is passed four arguments that are all #f.

The special-value procedure can return an arbitrary value, and it  will
be called zero or one times (not necessarily before further  reads or
peeks from the port). See Reader-Extension Procedures for  more details
on the procedure’s result.

If read-in or peek returns a special  procedure when called by any
reading procedure other than  read, read-syntax, read-char-or-special,
peek-char-or-special, read-byte-or-special, or  peek-byte-or-special,
then the exn:fail:contract exception is raised.

Examples:
  ; A port with no input...
  ; Easy: (open-input-bytes #"") ~
  ; Hard: ~
  > (define /dev/null-in
      (make-input-port 'null
                       (lambda (s) eof)
                       (lambda (skip s progress-evt) eof)
                       void
                       (lambda () never-evt)
                       (lambda (k progress-evt done-evt)
                         (error "no successful peeks!"))))

  > (read-char /dev/null-in)
  #<eof>
  > (peek-char /dev/null-in)
  #<eof>
  > (read-byte-or-special /dev/null-in)
  #<eof>
  > (peek-byte-or-special /dev/null-in 100)
  #<eof>
  ; A port that produces a stream of 1s: ~
  > (define infinite-ones
      (make-input-port
       'ones
       (lambda (s)
         (bytes-set! s 0 (char->integer #\1)) 1)
       #f
       void))

  > (read-string 5 infinite-ones)
  "11111"
  ; But we can't peek ahead arbitrarily far, because the
  ; automatic peek must record the skipped bytes, so
  ; we'd run out of memory.
  ; An infinite stream of 1s with a specific peek procedure: ~
  > (define infinite-ones
      (let ([one! (lambda (s)
                    (bytes-set! s 0 (char->integer #\1)) 1)])
        (make-input-port
         'ones
         one!
         (lambda (s skip progress-evt) (one! s))
         void)))

  > (read-string 5 infinite-ones)
  "11111"
  ; Now we can peek ahead arbitrarily far: ~
  > (peek-string 5 (expt 2 5000) infinite-ones)
  "11111"
  ; The port doesn't supply procedures to implement progress events: ~
  > (port-provides-progress-evts? infinite-ones)
  #f
  > (port-progress-evt infinite-ones)
  port-progress-evt: port does not provide progress evts
    port: #<input-port:ones> ~
  ; Non-byte port results: ~
  > (define infinite-voids
      (make-input-port
       'voids
       (lambda (s) (lambda args 'void))
       (lambda (skip s evt) (lambda args 'void))
       void))

  > (read-char infinite-voids)
  read-char: non-character in an unsupported context
    port: #<input-port:voids> ~
  > (read-char-or-special infinite-voids)
  'void
  ; This port produces 0, 1, 2, 0, 1, 2, etc., but it is not
  ; thread-safe, because multiple threads might read and change n.
  > (define mod3-cycle/one-thread
      (let* ([n 2]
             [mod! (lambda (s delta)
                     (bytes-set! s 0 (+ 48 (modulo (+ n delta) 3)))
                     1)])
        (make-input-port
         'mod3-cycle/not-thread-safe
         (lambda (s)
           (set! n (modulo (add1 n) 3))
           (mod! s 0))
         (lambda (s skip evt)
           (mod! s skip))
         void)))

  > (read-string 5 mod3-cycle/one-thread)
  "01201"
  > (peek-string 5 (expt 2 5000) mod3-cycle/one-thread)
  "20120"
  ; Same thing, but thread-safe and kill-safe, and with progress
  ; events. Only the server thread touches the stateful part
  ; directly. (See the output port examples for a simpler thread-safe
  ; example, but this one is more general.)
  > (define (make-mod3-cycle)
      (define read-req-ch (make-channel))
      (define peek-req-ch (make-channel))
      (define progress-req-ch (make-channel))
      (define commit-req-ch (make-channel))
      (define close-req-ch (make-channel))
      (define closed? #f)
      (define n 0)
      (define progress-sema #f)
      (define (mod! s delta)
        (bytes-set! s 0 (+ 48 (modulo (+ n delta) 3)))
        1)
      ; —————————————-
      ; The server has a list of outstanding commit requests,
      ;  and it also must service each port operation (read,
      ;  progress-evt, etc.)
      (define (serve commit-reqs response-evts)
        (apply
         sync
         (handle-evt read-req-ch
                     (handle-read commit-reqs response-evts))
         (handle-evt progress-req-ch
                     (handle-progress commit-reqs response-evts))
         (handle-evt commit-req-ch
                     (add-commit commit-reqs response-evts))
         (handle-evt close-req-ch
                     (handle-close commit-reqs response-evts))
         (append
          (map (make-handle-response commit-reqs response-evts)
               response-evts)
          (map (make-handle-commit commit-reqs response-evts)
               commit-reqs))))
      ; Read/peek request: fill in the string and commit ~
      (define ((handle-read commit-reqs response-evts) r)
        (let ([s (car r)]
              [skip (cadr r)]
              [ch (caddr r)]
              [nack (cadddr r)]
              [evt (car (cddddr r))]
              [peek? (cdr (cddddr r))])
          (let ([fail? (and evt
                            (sync/timeout 0 evt))])
            (unless (or closed? fail?)
              (mod! s skip)
              (unless peek?
                (commit! 1)))
            ; Add an event to respond: ~
            (serve commit-reqs
                   (cons (choice-evt
                          nack
                          (channel-put-evt ch (if closed?
                                                  0
                                                  (if fail? #f 1))))
                         response-evts)))))
      ; Progress request: send a peek evt for the current ~
      ;  progress-sema
      (define ((handle-progress commit-reqs response-evts) r)
        (let ([ch (car r)]
              [nack (cdr r)])
          (unless progress-sema
            (set! progress-sema (make-semaphore (if closed? 1 0))))
          ; Add an event to respond: ~
          (serve commit-reqs
                 (cons (choice-evt
                        nack
                        (channel-put-evt
                         ch
                         (semaphore-peek-evt progress-sema)))
                       response-evts))))
      ; Commit request: add the request to the list ~
      (define ((add-commit commit-reqs response-evts) r)
        (serve (cons r commit-reqs) response-evts))
      ; Commit handling: watch out for progress, in which case ~
      ;  the response is a commit failure; otherwise, try
      ;  to sync for a commit. In either event, remove the
      ;  request from the list
      (define ((make-handle-commit commit-reqs response-evts) r)
        (let ([k (car r)]
              [progress-evt (cadr r)]
              [done-evt (caddr r)]
              [ch (cadddr r)]
              [nack (cddddr r)])
          ; Note: we don't check that k is <= the sum of ~
          ;  previous peeks, because the entire stream is actually
          ;  known, but we could send an exception in that case.
          (choice-evt
           (handle-evt progress-evt
                       (lambda (x)
                         (sync nack (channel-put-evt ch #f))
                         (serve (remq r commit-reqs) response-evts)))
           ; Only create an event to satisfy done-evt if progress-evt
           ;  isn't already ready.
           ; Afterward, if progress-evt becomes ready, then this
           ;  event-making function will be called again, because
           ;  the server controls all posts to progress-evt.
           (if (sync/timeout 0 progress-evt)
               never-evt
               (handle-evt done-evt
                           (lambda (v)
                             (commit! k)
                             (sync nack (channel-put-evt ch #t))
                             (serve (remq r commit-reqs)
                                    response-evts)))))))
      ; Response handling: as soon as the respondee listens, ~
      ;  remove the response
      (define ((make-handle-response commit-reqs response-evts) evt)
        (handle-evt evt
                    (lambda (x)
                      (serve commit-reqs
                             (remq evt response-evts)))))
      ; Close handling: post the progress sema, if any, and set ~
      ;   the closed? flag
      (define ((handle-close commit-reqs response-evts) r)
        (let ([ch (car r)]
              [nack (cdr r)])
          (set! closed? #t)
          (when progress-sema
            (semaphore-post progress-sema))
          (serve commit-reqs
                 (cons (choice-evt nack
                                   (channel-put-evt ch (void)))
                       response-evts))))
      ; Helper for reads and post-peek commits: ~
      (define (commit! k)
        (when progress-sema
          (semaphore-post progress-sema)
          (set! progress-sema #f))
        (set! n (+ n k)))
      ; Start the server thread: ~
      (define server-thread (thread (lambda () (serve null null))))
      ; —————————————-
      ; Client-side helpers: ~
      (define (req-evt f)
        (nack-guard-evt
         (lambda (nack)
           ; Be sure that the server thread is running: ~
           (thread-resume server-thread (current-thread))
           ; Create a channel to hold the reply: ~
           (let ([ch (make-channel)])
             (f ch nack)
             ch))))
      (define (read-or-peek-evt s skip evt peek?)
        (req-evt (lambda (ch nack)
                   (channel-put read-req-ch
                                (list* s skip ch nack evt peek?)))))
      ; Make the port: ~
      (make-input-port 'mod3-cycle
                       ; Each handler for the port just sends
                       ;  a request to the server
                       (lambda (s) (read-or-peek-evt s 0 #f #f))
                       (lambda (s skip evt)
                         (read-or-peek-evt s skip evt #t))
                       (lambda () ; close
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put progress-req-ch
                                               (list* ch nack))))))
                       (lambda () ; progress-evt
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put progress-req-ch
                                               (list* ch nack))))))
                       (lambda (k progress-evt done-evt)  ; commit
                         (sync (req-evt
                                (lambda (ch nack)
                                  (channel-put
                                   commit-req-ch
                                   (list* k progress-evt done-evt ch
                                          nack))))))))

  > (define mod3-cycle (make-mod3-cycle))

  > (let ([result1 #f]
          [result2 #f])
      (let ([t1 (thread
                 (lambda ()
                   (set! result1 (read-string 5 mod3-cycle))))]
            [t2 (thread
                 (lambda ()
                   (set! result2 (read-string 5 mod3-cycle))))])
        (thread-wait t1)
        (thread-wait t2)
        (string-append result1 "," result2)))
  "12020,01201"
  > (define s (make-bytes 1))

  > (define progress-evt (port-progress-evt mod3-cycle))

  > (peek-bytes-avail! s 0 progress-evt mod3-cycle)
  1
  > s
  #"1"
  > (port-commit-peeked 1 progress-evt (make-semaphore 1)
                        mod3-cycle)
  #t
  > (sync/timeout 0 progress-evt)
  #<progress-evt>
  > (peek-bytes-avail! s 0 progress-evt mod3-cycle)
  0
  > (port-commit-peeked 1 progress-evt (make-semaphore 1)
                        mod3-cycle)
  #f
  > (close-input-port mod3-cycle)


                                        *make-output-port*
(make-output-port  name                       ~
                   evt                       
                   write-out                 
                   close                     
                  [write-out-special         
                   get-write-evt             
                   get-write-special-evt     
                   get-location              
                   count-lines!              
                   init-position             
                   buffer-mode])         -> output-port?
  name : any/c ~
  evt : evt? ~
  write-out : (or/c ~
               (bytes? exact-nonnegative-integer?
                       exact-nonnegative-integer?
                       boolean?
                       boolean?
                       . -> .
                       (or/c exact-nonnegative-integer?
                             #f
                             evt?))
               output-port?)
  close : (-> any) ~
  write-out-special : (or/c (any/c boolean? boolean? = #f ~
                                   . -> .
                                   (or/c any/c
                                         #f
                                         evt?))
                            output-port?
                            #f)
  get-write-evt : (or/c                               = #f ~
                   (bytes? exact-nonnegative-integer?
                           exact-nonnegative-integer?
                           . -> .
                           evt?)
                   #f)
  get-write-special-evt : (or/c                = #f ~
                           (any/c . -> . evt?)
                           #f)
  get-location : (or/c ~
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void ~
  init-position : (or/c exact-positive-integer? ~
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case-> ~
                       ((or/c 'block 'line 'none) . -> . any)
                       (-> (or/c 'block 'line 'none #f)))
                      #f)
              = #f

Creates an output port, which is immediately open for writing. If close
procedure has no side effects, then the port need not be explicitly
closed. The port can buffer data within its write-out and
write-out-special procedures.

* name — the name for the output port.

* evt — a synchronization event (see [missing]; e.g., a semaphore or
  another port). The event is used in place of the output port when the
  port is supplied to synchronization procedures like sync.  Thus, the
  event should be unblocked when the port is ready for writing at least
  one byte without blocking, or ready to make progress in flushing an
  internal buffer without blocking. The event must not unblock unless
  the port is ready for writing; otherwise, the guarantees of sync will
  be broken for the output port. Use always-evt if writes to the port
  always succeed without blocking.

* write-out — either an output port, which indicates that      writes
  should be redirected to the given port, or a procedure      of five
  arguments:

  * an immutable byte string containing bytes to write;

  * a non-negative exact integer for a starting offset (inclusive) into
    the byte string;

  * a non-negative exact integer for an ending offset (exclusive) into
    the byte string;

  * a boolean; #f indicates that the port is allowed to keep the written
    bytes in a buffer, and that it is allowed to block indefinitely; #t
    indicates that the write should not block, and that the port should
    attempt to flush its buffer and completely write new bytes instead
    of buffering them;

  * a boolean; #t indicates that if the port blocks for a write, then it
    should enable breaks while blocking (e.g., using sync/enable-break);
    this argument is always #f if the fourth argument is #t.

  The procedure returns one of the following:

  * a non-negative exact integer representing the number of bytes
    written or buffered;

  * #f if no bytes could be written, perhaps because the internal buffer
    could not be completely flushed;

  * a pipe output port (when buffering is allowed and not when flushing)
    for buffering bytes as long as the pipe is not full and until
    write-out or write-out-special is called; or

  * a synchronizable event (see [missing]) other than a pipe output port
    that acts like the result of write-bytes-avail-evt to complete the
    write.

  Since write-out can produce an event, an acceptable implementation of
  write-out is to pass its first three arguments to the port’s
  get-write-evt. Some port implementors, however, may choose not to
  provide get-write-evt (perhaps because writes cannot be made atomic),
  or may implement write-proc to enable a fast path for non-blocking
  writes or to enable buffering.

  From a user’s perspective, the difference between buffered and
  completely written data is (1) buffered data can be lost in the future
  due to a failed write, and (2) flush-output forces all buffered data
  to be completely written. Under no circumstances is buffering
  required.

  If the start and end indices are the same, then the fourth argument to
  write-out will be #f, and the write request is actually a flush
  request for the port’s buffer (if any), and the result should be 0 for
  a successful flush (or if there is no buffer).

  The result should never be 0 if the start and end indices are
  different, otherwise the exn:fail:contract exception is raised.
  Similarly, the exn:fail:contract exception is raised if write-out
  returns a pipe output port when buffering is disallowed or when it is
  called for flushing.  If a returned integer is larger than the
  supplied byte-string range, the exn:fail:contract exception is raised.

  The #f result should be avoided, unless the next write attempt is
  likely to work. Otherwise, if data cannot be written, return an event
  instead.

  An event returned by write-out can return #f or another event like
  itself, in contrast to events produced by write-bytes-avail-evt or
  get-write-evt. A writing process loops with sync until it obtains a
  non-event result.

  The write-out procedure is always called with breaks disabled,
  independent of whether breaks were enabled when the write was
  requested by a client of the port. If breaks were enabled for a
  blocking operation, then the fifth argument to write-out will be #t,
  which indicates that write-out should re-enable breaks while blocking.

  If the writing procedure raises an exception, due to write or commit
  operations, it must not have committed any bytes (though it may have
  committed previously buffered bytes).

  A port’s writing procedure may be called in multiple threads
  simultaneously (if the port is accessible in multiple threads). The
  port is responsible for its own internal synchronization. Note that
  improper implementation of such synchronization mechanisms might cause
  a non-blocking write procedure to block.

* close — a procedure of zero arguments that is called to close the
  port. The port is not considered closed until the closing procedure
  returns. The port’s procedures will never be used again via the port
  after it is closed. However, the closing procedure can be called
  simultaneously in multiple threads (if the port is accessible in
  multiple threads), and it may be called during a call to the other
  procedures in another thread; in the latter case, any outstanding
  writes or flushes should be terminated immediately with an error.

* write-out-special — either #f (the default), an output port (which
  indicates that special writes should be redirected to the given port),
  or a procedure to handle write-special calls for the port. If #f, then
  the port does not support special output, and port-writes-special?
  will return #f when applied to the port.

  If a procedure is supplied, it takes three arguments: the special
  value to write, a boolean that is #f if the procedure can buffer the
  special value and block indefinitely, and a boolean that is #t if the
  procedure should enable breaks while blocking. The result is one of
  the following:

  * a non-event true value, which indicates that the special is written;

  * #f if the special could not be written, perhaps because an internal
    buffer could not be completely flushed;

  * a synchronizable event (see [missing]) that acts like the result of
    get-write-special-evt to complete the write.

  Since write-out-special can return an event, passing the first
  argument to an implementation of get-write-special-evt is acceptable
  as a write-out-special.

  As for write-out, the #f result is discouraged, since it can lead to
  busy waiting. Also as for write-out, an event produced by
  write-out-special is allowed to produce #f or another event like
  itself.  The write-out-special procedure is always called with breaks
  disabled, independent of whether breaks were enabled when the write
  was requested by a client of the port.

* get-write-evt — either #f (the default) or a procedure of three
  arguments:

  * an immutable byte string containing bytes to write;

  * a non-negative exact integer for a starting offset (inclusive) into
    the byte string; and

  * a non-negative exact integer for an ending offset (exclusive) into
    the byte string.

  The result is a synchronizable event (see [missing]) to act as  the
  result of write-bytes-avail-evt for the port (i.e.,  to complete a
  write or flush), which becomes available only as  data is committed to
  the port’s underlying device, and whose  result is the number of bytes
  written.

  If get-write-evt is #f, then  port-writes-atomic? will produce #f when
  applied  to the port, and the port will not be a valid argument to
  procedures such as write-bytes-avail-evt.  Otherwise, an event
  returned by get-write-evt must  not cause data to be written to the
  port unless the event is  chosen in a synchronization, and it must
  write to the port if the  event is chosen (i.e., the write must appear
  atomic with respect  to the synchronization).

  If the event’s result integer is larger than the supplied  byte-string
  range, the exn:fail:contract exception is raised by a wrapper  on the
  event. If the start and end indices are the same (i.e., no  bytes are
  to be written), then the event should produce 0  when the buffer is
  completely flushed. (If the port has no buffer,  then it is
  effectively always flushed.)

  If the event raises an exception, due to write or commit  operations,
  it must not have committed any new bytes (though it  may have
  committed previously buffered bytes).

  Naturally, a port’s events may be used in multiple threads
  simultaneously (if the port is accessible in multiple  threads). The
  port is responsible for its own internal  synchronization.

* get-write-special-evt — either #f (the default), or a procedure to
  handle write-special-evt calls for the port. This argument must be #f
  if either write-out-special or get-write-evt is #f, and it must be a
  procedure if both of those arguments are procedures.

  If it is a procedure, it takes one argument: the special value to
  write. The resulting event (with its constraints) is analogous to the
  result of get-write-evt.

  If the event raises an exception, due to write or commit operations,
  it must not have committed the special value (though it may have
  committed previously buffered bytes and values).

* get-location — either #f (the default), or a procedure that takes no
  arguments and returns three values: the line number for the next item
  written to the port’s stream (a positive number or #f), the column
  number for the next item written to port’s stream (a non-negative
  number or #f), and the position for the next item written to port’s
  stream (a positive number or #f). See also Counting Positions, Lines,
  and Columns.

  This procedure is called to implement port-next-location for the port,
  but only if line counting is enabled for the port via
  port-count-lines! (in which case count-lines! is called).

* count-lines! — a procedure of no arguments that is called if and when
  line counting is enabled for the port. The default procedure is void.

* init-position — normally an exact, positive integer that determines
  the position of the port’s first item, which is used by file-position
  or when line counting is not enabled for the port. The default is 1.
  If init-position is #f, the port is treated as having an unknown
  position. If init-position is a port, then the given port’s position
  is always used for the new port’s position. If init-position is a
  procedure, it is called as needed to obtain the port’s position.

* buffer-mode — either #f (the default) or a procedure that accepts zero
  or one arguments. If buffer-mode is #f, then the resulting port does
  not support a buffer-mode setting. Otherwise, the procedure is called
  with one symbol argument ('block, 'line, or 'none) to set the buffer
  mode, and it is called with zero arguments to get the current buffer
  mode. In the latter case, the result must be 'block, 'line, 'none, or
  #f (unknown). See Port Buffers and Positions for more information on
  buffer modes.

Examples:
  ; A port that writes anything to nowhere: ~
  > (define /dev/null-out
      (make-output-port
       'null
       always-evt
       (lambda (s start end non-block? breakable?) (- end start))
       void
       (lambda (special non-block? breakable?) #t)
       (lambda (s start end) (wrap-evt
                              always-evt
                              (lambda (x)
                                (- end start))))
       (lambda (special) always-evt)))

  > (display "hello" /dev/null-out)

  > (write-bytes-avail #"hello" /dev/null-out)
  5
  > (write-special 'hello /dev/null-out)
  #t
  > (sync (write-bytes-avail-evt #"hello" /dev/null-out))
  5
  ; A port that accumulates bytes as characters in a list,
  ;  but not in a thread-safe way: ~
  > (define accum-list null)

  > (define accumulator/not-thread-safe
      (make-output-port
       'accum/not-thread-safe
       always-evt
       (lambda (s start end non-block? breakable?)
         (set! accum-list
               (append accum-list
                       (map integer->char
                            (bytes->list (subbytes s start end)))))
         (- end start))
       void))

  > (display "hello" accumulator/not-thread-safe)

  > accum-list
  '(#\h #\e #\l #\l #\o)
  ; Same as before, but with simple thread-safety: ~
  > (define accum-list null)

  > (define accumulator
      (let* ([lock (make-semaphore 1)]
             [lock-peek-evt (semaphore-peek-evt lock)])
        (make-output-port
         'accum
         lock-peek-evt
         (lambda (s start end non-block? breakable?)
           (if (semaphore-try-wait? lock)
               (begin
                 (set! accum-list
                       (append accum-list
                               (map integer->char
                                    (bytes->list
                                     (subbytes s start end)))))
                 (semaphore-post lock)
                 (- end start))
               ; Cheap strategy: block until the list is unlocked, ~
               ;   then return 0, so we get called again
               (wrap-evt
                lock-peek
                (lambda (x) 0))))
         void)))

  > (display "hello" accumulator)

  > accum-list
  '(#\h #\e #\l #\l #\o)
  ; A port that transforms data before sending it on
  ;  to another port. Atomic writes exploit the
  ;  underlying port's ability for atomic writes.
  > (define (make-latin-1-capitalize port)
      (define (byte-upcase s start end)
        (list->bytes
         (map (lambda (b) (char->integer
                           (char-upcase
                            (integer->char b))))
              (bytes->list (subbytes s start end)))))
      (make-output-port
       'byte-upcase
       ; This port is ready when the original is ready: ~
       port
       ; Writing procedure: ~
       (lambda (s start end non-block? breakable?)
         (let ([s (byte-upcase s start end)])
           (if non-block?
               (write-bytes-avail* s port)
               (begin
                 (display s port)
                 (bytes-length s)))))
       ; Close procedure — close original port: ~
       (lambda () (close-output-port port))
       #f
       ; Write event: ~
       (and (port-writes-atomic? port)
            (lambda (s start end)
              (write-bytes-avail-evt
               (byte-upcase s start end)
               port)))))

  > (define orig-port (open-output-string))

  > (define cap-port (make-latin-1-capitalize orig-port))

  > (display "Hello" cap-port)

  > (get-output-string orig-port)
  "HELLO"
  > (sync (write-bytes-avail-evt #"Bye" cap-port))
  3
  > (get-output-string orig-port)
  "HELLOBYE"

1.10. More Port Constructors, Procedures, and Events

 (require racket/port) package: base ~

The bindings documented in this section are provided by the racket/port
and racket libraries, but not racket/base.

1.10.1. Port String and List Conversions

                                        *port->list*
(port->list [r in]) -> (listof any/c) ~
  r : (input-port? . -> . any/c) = read ~
  in : input-port? = (current-input-port) ~

Returns a list whose elements are produced by calling r on in until it
produces eof.

Examples:
  > (define (read-number input-port)
      (define char (read-char input-port))
      (if (eof-object? char)
       char
       (string->number (string char))))

  > (port->list read-number (open-input-string "12345"))
  '(1 2 3 4 5)

                                        *port->string*
(port->string [in]) -> string? ~
  in : input-port? = (current-input-port) ~

Reads all characters from in and returns them as a string.

Example:
  > (port->string (open-input-string "hello world"))
  "hello world"

                                        *port->bytes*
(port->bytes [in]) -> bytes? ~
  in : input-port? = (current-input-port) ~

Reads all bytes from in and returns them as a byte string.

Example:
  > (port->bytes (open-input-string "hello world"))
  #"hello world"

                                        *port->lines*
(port->lines [in #:line-mode line-mode]) -> (listof string?) ~ ~
  in : input-port? = (current-input-port) ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
            = 'any

Read all characters from in, breaking them into lines. The line-mode
argument is the same as the second argument to read-line, but the
default is 'any instead of 'linefeed.

Example:
  > (port->lines
     (open-input-string "line 1\nline 2\n  line 3\nline 4"))
  '("line 1" "line 2" "  line 3" "line 4")

                                        *port->bytes-lines*
(port->bytes-lines [in                           ~
                    #:line-mode line-mode]) -> (listof bytes?) ~
  in : input-port? = (current-input-port) ~
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
            = 'any

Like port->lines, but reading bytes and collecting them into lines like
read-bytes-line.

Example:
  > (port->bytes-lines
     (open-input-string "line 1\nline 2\n  line 3\nline 4"))
  '(#"line 1" #"line 2" #"  line 3" #"line 4")

                                        *display-lines*
(display-lines  lst                          ~
               [out                         
                #:separator separator]) -> void? ~
  lst : list? ~
  out : output-port? = (current-output-port) ~
  separator : any/c = #"\n" ~

Uses display on each element of lst to out, adding separator after each
element.

                                        *call-with-output-string*
(call-with-output-string proc) -> string? ~
  proc : (output-port? . -> . any) ~

Calls proc with an output port that accumulates all output into a
string, and returns the string.

The port passed to proc is like the one created by open-output-string,
except that it is wrapped via dup-output-port, so that proc cannot
access the port’s content using get-output-string. If control jumps back
into proc, the port continues to accumulate new data, and
call-with-output-string returns both the old data and newly accumulated
data.

                                        *call-with-output-bytes*
(call-with-output-bytes proc) -> bytes? ~
  proc : (output-port? . -> . any) ~

Like call-with-output-string, but returns the accumulated result in a
byte string instead of a string. Furthermore, the port’s content is
emptied when call-with-output-bytes returns, so that if control jumps
back into proc and returns a second time, only the newly accumulated
bytes are returned.

                                        *with-output-to-string*
(with-output-to-string proc) -> string? ~
  proc : (-> any) ~

Equivalent to

  (call-with-output-string
   (lambda (p) (parameterize ([current-output-port p])
                 (proc))))

                                        *with-output-to-bytes*
(with-output-to-bytes proc) -> bytes? ~
  proc : (-> any) ~

Equivalent to

  (call-with-output-bytes
   (lambda (p) (parameterize ([current-output-port p])
                 (proc))))

                                        *call-with-input-string*
(call-with-input-string str proc) -> any ~
  str : string? ~
  proc : (input-port? . -> . any) ~

Equivalent to (proc (open-input-string str)).

                                        *call-with-input-bytes*
(call-with-input-bytes bstr proc) -> any ~
  bstr : bytes? ~
  proc : (input-port? . -> . any) ~

Equivalent to (proc (open-input-bytes bstr)).

                                        *with-input-from-string*
(with-input-from-string str proc) -> any ~
  str : string? ~
  proc : (-> any) ~

Equivalent to

  (parameterize ([current-input-port (open-input-string str)])
    (proc))

                                        *with-input-from-bytes*
(with-input-from-bytes bstr proc) -> any ~
  bstr : bytes? ~
  proc : (-> any) ~

Equivalent to

  (parameterize ([current-input-port (open-input-bytes str)])
    (proc))

1.10.2. Creating Ports

                                        *input-port-append*
(input-port-append close-at-eof? in ...) -> input-port? ~
  close-at-eof? : any/c ~
  in : input-port? ~

Takes any number of input ports and returns an input port. Reading from
the input port draws bytes (and special non-byte values) from the given
input ports in order. If close-at-eof? is true, then each port is closed
when an end-of-file is encountered from the port, or when the result
input port is closed. Otherwise, data not read from the returned input
port remains available for reading in its original input port.

See also merge-input, which interleaves data from multiple input ports
as it becomes available.

                                        *make-input-port/read-to-peek*
(make-input-port/read-to-peek  name               ~
                               read-in           
                               fast-peek         
                               close             
                              [get-location      
                               count-lines!      
                               init-position     
                               buffer-mode       
                               buffering?        
                               on-consumed]) -> input-port?
  name : any/c ~
  read-in : (bytes? ~
             . -> . (or/c exact-nonnegative-integer?
                          eof-object?
                          procedure?
                          evt?))
  fast-peek : (or/c #f ~
                    (bytes? exact-nonnegative-integer?
                     (bytes? exact-nonnegative-integer?
                      . -> . (or/c exact-nonnegative-integer?
                                   eof-object?
                                   procedure?
                                   evt?
                                   #f))
                     . -> . (or/c exact-nonnegative-integer?
                                  eof-object?
                                  procedure?
                                  evt?
                                  #f)))
  close : (-> any) ~
  get-location : (or/c                                   = #f ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  count-lines! : (-> any) = void ~
  init-position : exact-positive-integer? = 1 ~
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any) ~
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f
  buffering? : any/c = #f ~
  on-consumed : (or/c ((or/c exact-nonnegative-integer? eof-object? ~
                             procedure? evt?)
                       . -> . any)
                      #f)
              = #f

Similar to make-input-port, but if the given read-in returns an event,
the event’s value must be 0.  The resulting port’s peek operation is
implemented automatically (in terms of read-in) in a way that can handle
special non-byte values. The progress-event and commit operations are
also implemented automatically. The resulting port is thread-safe, but
not kill-safe (i.e., if a thread is terminated or suspended while using
the port, the port may become damaged).

The read-in, close, get-location, count-lines!, init-position, and
buffer-mode procedures are the same as for make-input-port.

The fast-peek argument can be either #f or a procedure of three
arguments: a byte string to receive a peek, a skip count, and a
procedure of two arguments. The fast-peek procedure can either implement
the requested peek, or it can dispatch to its third argument to
implement the peek. The fast-peek is not used when a peek request has an
associated progress event.

The buffering? argument determines whether read-in can be called to read
more characters than are immediately demanded by the user of the new
port. If buffer-mode is not #f, then buffering? determines the initial
buffer mode, and buffering? is enabled after a buffering change only if
the new mode is 'block.

If on-consumed is not #f, it is called when data is read (or committed)
from the port, as opposed to merely peeked. The argument to on-consumed
is the result value of the port’s reading procedure, so it can be an
integer or any result from read-in.

                                        *make-limited-input-port*
(make-limited-input-port  in                 ~
                          limit             
                         [close-orig?]) -> input-port?
  in : input-port? ~
  limit : exact-nonnegative-integer? ~
  close-orig? : any/c = #t ~

Returns a port whose content is drawn from in, but where an end-of-file
is reported after limit bytes (and non-byte special values) have been
read.  If close-orig? is true, then the original port is closed if the
returned port is closed.

Bytes are consumed from in only when they are consumed from the returned
port. In particular, peeking into the returned port peeks into the
original port.

If in is used directly while the resulting port is also used, then the
limit bytes provided by the port need not be contiguous parts of the
original port’s stream.

                                        *make-pipe-with-specials*
(make-pipe-with-specials [limit           ~
                          in-name        
                          out-name]) -> input-port? output-port?
  limit : exact-nonnegative-integer? = #f ~
  in-name : any/c = 'pipe ~
  out-name : any/c = 'pipe ~

Returns two ports: an input port and an output port. The ports behave
like those returned by make-pipe, except that the ports support non-byte
values written with procedures such as write-special and read with
procedures such as get-byte-or-special.

The limit argument determines the maximum capacity of the pipe in bytes,
but this limit is disabled if special values are written to the pipe
before limit is reached. The limit is re-enabled after the special value
is read from the pipe.

The optional in-name and out-name arguments determine the names of the
result ports.

                                        *merge-input*
(merge-input a-in b-in [buffer-limit]) -> input-port? ~
  a-in : input-port? ~
  b-in : input-port? ~
  buffer-limit : (or/c exact-nonnegative-integer? #f) = 4096 ~

Accepts two input ports and returns a new input port. The new port
merges the data from two original ports, so data can be read from the
new port whenever it is available from either of the two original ports.
The data from the original ports are interleaved. When an end-of-file
has been read from an original port, it no longer contributes characters
to the new port. After an end-of-file has been read from both original
ports, the new port returns end-of-file. Closing the merged port does
not close the original ports.

The optional buffer-limit argument limits the number of bytes to be
buffered from a-in and b-in, so that the merge process does not advance
arbitrarily beyond the rate of consumption of the merged data. A #f
value disables the limit. As for make-pipe-with-specials, buffer-limit
does not apply when a special value is produced by one of the input
ports before the limit is reached.

See also input-port-append, which concatenates input streams instead of
interleaving them.

                                        *open-output-nowhere*
(open-output-nowhere [name special-ok?]) -> output-port? ~
  name : any/c = 'nowhere ~
  special-ok? : any/c = #t ~

Creates and returns an output port that discards all output sent to it
(without blocking). The name argument is used as the port’s name. If the
special-ok?  argument is true, then the resulting port supports
write-special, otherwise it does not.

                                        *peeking-input-port*
(peeking-input-port  in                                   ~
                    [name                                
                     skip                                
                     #:init-position init-position]) -> input-port ~
  in : input-port? ~
  name : any/c = (object-name in) ~
  skip : exact-nonnegative-integer? = 0 ~
  init-position : exact-positive-integer? = 1 ~

Returns an input port whose content is determined by peeking into in. In
other words, the resulting port contains an internal skip count, and
each read of the port peeks into in with the internal skip count, and
then increments the skip count according to the amount of data
successfully peeked.

The optional name argument is the name of the resulting port. The skip
argument is the port initial skip count, and it defaults to 0.

The resulting port’s initial position (as reported by file-position) is
(- init-position 1), no matter the position of in.

The resulting port supports buffering, and a 'block buffer mode allows
the port to peek further into in than requested. The resulting port’s
initial buffer mode is 'block, unless in supports buffer mode and its
mode is initially 'none (i.e., the initial buffer mode is taken from in
when it supports buffering). If in supports buffering, adjusting the
resulting port’s buffer mode via file-stream-buffer-mode adjusts in’s
buffer mode.

For example, when you read from a peeking port, you see the same answers
as when you read from the original port:

Examples:
  > (define an-original-port (open-input-string "123456789"))

  > (define a-peeking-port (peeking-input-port an-original-port))

  > (file-stream-buffer-mode a-peeking-port 'none)

  > (read-string 3 a-peeking-port)
  "123"
  > (read-string 3 an-original-port)
  "123"

Beware that the read from the original port is invisible to the peeking
port, which keeps its own separate internal counter, and thus
interleaving reads on the two ports can produce confusing results.
Continuing the example before, if we read three more characters from the
peeking port, we end up skipping over the 456 in the port (but only
because we disabled buffering above):

Example:
  > (read-string 3 a-peeking-port)
  "789"

If we had left the buffer mode of a-peeking-port alone, that last
read-string would have likely produced "456" as a result of buffering
bytes from an-original-port earlier.

Changed in version 6.1.0.3 of package base: Enabled buffering and
buffer-mode adjustments via file-stream-buffer-mode, and set the port’s
initial buffer mode to that of in.

                                        *reencode-input-port*
(reencode-input-port  in                     ~
                      encoding              
                     [error-bytes           
                      close?                
                      name                  
                      convert-newlines?     
                      enc-error])       -> input-port?
  in : input-port? ~
  encoding : string? ~
  error-bytes : (or/c #f bytes?) = #f ~
  close? : any/c = #f ~
  name : any/c = (object-name in) ~
  convert-newlines? : any/c = #f ~
  enc-error : (string? input-port? . -> . any) ~
            = (lambda (msg port) (error ...))

Produces an input port that draws bytes from in, but converts the byte
stream using (bytes-open-converter encoding-str "UTF-8"). In addition,
if convert-newlines? is true, then decoded sequences that correspond to
UTF-8 encodings of "\r\n", "\r\u0085", "\r", "\u0085", and "\u2028" are
all converted to the UTF-8 encoding of "\n".

If error-bytes is provided and not #f, then the given byte sequence is
used in place of bytes from in that trigger conversion errors.
Otherwise, if a conversion is encountered, enc-error is called, which
must raise an exception.

If close? is true, then closing the result input port also closes in.
The name argument is used as the name of the result input port.

In non-buffered mode, the resulting input port attempts to draw bytes
from in only as needed to satisfy requests. Toward that end, the input
port assumes that at least n bytes must be read to satisfy a request for
n bytes. (This is true even if the port has already drawn some bytes, as
long as those bytes form an incomplete encoding sequence.)

                                        *reencode-output-port*
(reencode-output-port  out                ~
                       encoding          
                      [error-bytes       
                       close?            
                       name              
                       newline-bytes     
                       enc-error])   -> output-port?
  out : output-port? ~
  encoding : string? ~
  error-bytes : (or/c #f bytes?) = #f ~
  close? : any/c = #f ~
  name : any/c = (object-name out) ~
  newline-bytes : (or/c #f bytes?) = #f ~
  enc-error : (string? output-port? . -> . any) ~
            = (lambda (msg port) (error ...))

Produces an output port that directs bytes to out, but converts its byte
stream using (bytes-open-converter "UTF-8" encoding-str). In addition,
if newline-bytes is not #f, then bytes written to the port that are the
UTF-8 encoding of "\n" are first converted to newline-bytes (before
applying the convert from UTF-8 to encoding-str).

If error-bytes is provided and not #f, then the given byte sequence is
used in place of bytes that have been sent to the output port and that
trigger conversion errors. Otherwise, enc-error is called, which must
raise an exception.

If close? is true, then closing the result output port also closes out.
The name argument is used as the name of the result output port.

The resulting port supports buffering, and the initial buffer mode is
(or (file-stream-buffer-mode out) 'block). In 'block mode, the port’s
buffer is flushed only when it is full or a flush is requested
explicitly. In 'line mode, the buffer is flushed whenever a newline or
carriage-return byte is written to the port. In 'none mode, the port’s
buffer is flushed after every write. Implicit flushes for 'line or 'none
leave bytes in the buffer when they are part of an incomplete encoding
sequence.

The resulting output port does not support atomic writes. An explicit
flush or special-write to the output port can hang if the most recently
written bytes form an incomplete encoding sequence.

When the port is buffered, a flush callback is registered with the
current plumber to flush the buffer.

                                        *dup-input-port*
(dup-input-port in [close?]) -> input-port? ~
  in : input-port? ~
  close? : any/c = #f ~

Returns an input port that draws directly from in. Closing the resulting
port closes in only if close? is #t.

The new port is initialized with the port read handler of in, but
setting the handler on the result port does not affect reading directly
from in.

                                        *dup-output-port*
(dup-output-port out [close?]) -> output-port? ~
  out : output-port? ~
  close? : any/c = #f ~

Returns an output port that propagates data directly to out. Closing the
resulting port closes out only if close? is #t.

The new port is initialized with the port display handler and port write
handler of out, but setting the handlers on the result port does not
affect writing directly to out.

                                        *relocate-input-port*
(relocate-input-port  in                ~
                      line             
                      column           
                      position         
                     [close?]          
                      #:name name) -> input-port? ~
  in : input-port? ~
  line : (or/c exact-positive-integer? #f) ~
  column : (or/c exact-nonnegative-integer? #f) ~
  position : exact-positive-integer? ~
  close? : any/c = #t ~
  name : (object-name out) ~

Produces an input port that is equivalent to in except in how it reports
location information (and possibly its name). The resulting port’s
content starts with the remaining content of in, and it starts at the
given line, column, and position. A #f for the line or column means that
the line and column will always be reported as #f.

The line and column values are used only if line counting is enabled for
in and for the resulting port, typically through port-count-lines!. The
column value determines the column for the first line (i.e., the one
numbered line), and later lines start at column 0. The given position is
used even if line counting is not enabled.

When line counting is on for the resulting port, reading from in instead
of the resulting port increments location reports from the resulting
port. Otherwise, the resulting port’s position does not increment when
data is read from in.

If close? is true, then closing the resulting port also closes in. If
close? is #f, then closing the resulting port does not close in.

The name argument is used as the name for the resulting port; the
default value keeps the same name as in.

                                        *relocate-output-port*
(relocate-output-port  out               ~
                       line             
                       column           
                       position         
                      [close?]          
                       #:name name) -> output-port? ~
  out : output-port? ~
  line : (or/c exact-positive-integer? #f) ~
  column : (or/c exact-nonnegative-integer? #f) ~
  position : exact-positive-integer? ~
  close? : any/c = #t ~
  name : (object-name out) ~

Like relocate-input-port, but for output ports.

                                        *transplant-input-port*
(transplant-input-port  in                 ~
                        get-location      
                        init-pos          
                       [close?            
                        count-lines!]     
                        #:name name)  -> input-port? ~
  in : input-port? ~
  get-location : (or/c ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer? ~
  close? : any/c = #t ~
  count-lines! : (-> any) = void ~
  name : (object-name out) ~

Like relocate-input-port, except that arbitrary position information can
be produced (when line counting is enabled) via get-location, which is
used as for make-input-port. If get-location is #f, then the port counts
lines in the usual way starting from init-pos, independent of locations
reported by in.

If count-lines! is supplied, it is called when line counting is enabled
for the resulting port. The default is void.

                                        *transplant-output-port*
(transplant-output-port  out                ~
                         get-location      
                         init-pos          
                        [close?            
                         count-lines!]     
                         #:name name)  -> output-port? ~
  out : output-port? ~
  get-location : (or/c ~
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer? ~
  close? : any/c = #t ~
  count-lines! : (-> any) = void ~
  name : (object-name out) ~

Like transplant-input-port, but for output ports.

                                        *filter-read-input-port*
(filter-read-input-port  in             ~
                         read-wrap     
                         peek-wrap     
                        [close?])  -> input-port?
  in : input-port? ~
  read-wrap : (bytes? (or/c exact-nonnegative-integer? ~
                            eof-object?
                            procedure?
                            evt?)
                      . -> .
                      (or/c exact-nonnegative-integer?
                            eof-object?
                            procedure?
                            evt?))
  peek-wrap : (bytes? exact-nonnegative-integer? (or/c evt? #f) ~
                      (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f)
               . -> . (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f))
  close? : any/c = #t ~

Creates a port that draws from in, but each result from the port’s read
and peek procedures (in the sense of make-input-port) is filtered by
read-wrap and peek-wrap. The filtering procedures each receive both the
arguments and results of the read and peek procedures on in for each
call.

If close? is true, then closing the resulting port also closes in.

                                        *special-filter-input-port*
(special-filter-input-port in proc [close?]) -> input-port? ~
  in : input-port? ~
  proc : (procedure? bytes? . -> . (or/c exact-nonnegative-integer? ~
                                         eof-object?
                                         procedure?
                                         evt?))
  close? : any/c = #t ~

Produces an input port that is equivalent to in, except that when in
produces a procedure to access a special value, proc is applied to the
procedure to allow the special value to be replaced with an alternative.
The proc is called with the special-value procedure and the byte string
that was given to the port’s read or peek function (see
make-input-port), and the result is used as the read or peek function’s
result.  The proc can modify the byte string to substitute a byte for
the special value, but the byte string is guaranteed only to hold at
least one byte.

If close? is true, then closing the resulting input port also closes in.

1.10.3. Port Events

                                        *eof-evt*
(eof-evt in) -> evt? ~
  in : input-port? ~

Returns a synchronizable event that is ready when in produces an eof. If
in produces a mid-stream eof, the eof is consumed by the event only if
the event is chosen in a synchronization.

                                        *read-bytes-evt*
(read-bytes-evt k in) -> evt? ~
  k : exact-nonnegative-integer? ~
  in : input-port? ~

Returns a synchronizable event that is ready when k bytes can be read
from in, or when an end-of-file is encountered in in. If k is 0, then
the event is ready immediately with "". For non-zero k, if no bytes are
available before an end-of-file, the event’s result is eof. Otherwise,
the event’s result is a byte string of up to k bytes, which contains as
many bytes as are available (up to k) before an available end-of-file.
(The result is a byte string on less than k bytes only when an
end-of-file is encountered.)

Bytes are read from the port if and only if the event is chosen in a
synchronization, and the returned bytes always represent contiguous
bytes in the port’s stream.

The event can be synchronized multiple times—event concurrently—and each
synchronization corresponds to a distinct read request.

The in must support progress events, and it must not produce a special
non-byte value during the read attempt.

                                        *read-bytes!-evt*
(read-bytes!-evt bstr in progress-evt) -> evt? ~
  bstr : (and/c bytes? (not/c immutable?)) ~
  in : input-port? ~
  progress-evt : (or/c progress-evt? #f) ~

Like read-bytes-evt, except that the read bytes are placed into bstr,
and the number of bytes to read corresponds to (bytes-length bstr). The
event’s result is either eof or the number of read bytes.

The bstr may be mutated any time after the first synchronization attempt
on the event and until either the event is selected, a non-#f
progress-evt is ready, or the current custodian (at the time of
synchronization) is shut down. Note that there is no time bound
otherwise on when bstr might be mutated if the event is not selected by
a synchronzation; nevertheless, multiple synchronization attempts can
use the same result from read-bytes!-evt as long as there is no
intervening read on in until one of the synchronization attempts selects
the event.

                                        *read-bytes-avail!-evt*
(read-bytes-avail!-evt bstr in) -> evt? ~
  bstr : (and/c bytes? (not/c immutable?)) ~
  in : input-port? ~

Like read-bytes!-evt, except that the event reads only as many bytes as
are immediately available, after at least one byte or one eof becomes
available.

                                        *read-string-evt*
(read-string-evt k in) -> evt? ~
  k : exact-nonnegative-integer? ~
  in : input-port? ~

Like read-bytes-evt, but for character strings instead of byte strings.

                                        *read-string!-evt*
(read-string!-evt str in) -> evt? ~
  str : (and/c string? (not/c immutable?)) ~
  in : input-port? ~

Like read-bytes!-evt, but for a character string instead of a byte
string.

                                        *read-line-evt*
(read-line-evt in mode) -> evt? ~
  in : input-port? ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~

Returns a synchronizable event that is ready when a line of characters
or end-of-file can be read from in. The meaning of mode is the same as
for read-line. The event result is the read line of characters (not
including the line separator).

A line is read from the port if and only if the event is chosen in a
synchronization, and the returned line always represents contiguous
bytes in the port’s stream.

                                        *read-bytes-line-evt*
(read-bytes-line-evt in mode) -> evt? ~
  in : input-port? ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~

Like read-line-evt, but returns a byte string instead of a string.

                                        *peek-bytes-evt*
(peek-bytes-evt k skip progress-evt in) -> evt? ~
  k : exact-nonnegative-integer? ~
  skip : exact-nonnegative-integer? ~
  progress-evt : (or/c progress-evt? #f) ~
  in : input-port? ~
(peek-bytes!-evt bstr skip progress-evt in) -> evt?
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip : exact-nonnegative-integer? ~
  progress-evt : (or/c progress-evt? #f) ~
  in : input-port? ~
(peek-bytes-avail!-evt bstr             
                       skip             
                       progress-evt     
                       in)          -> evt?
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip : exact-nonnegative-integer? ~
  progress-evt : (or/c progress-evt? #f) ~
  in : input-port? ~
(peek-string-evt k skip progress-evt in) -> evt?
  k : exact-nonnegative-integer? ~
  skip : exact-nonnegative-integer? ~
  progress-evt : (or/c progress-evt? #f) ~
  in : input-port? ~
(peek-string!-evt str skip progress-evt in) -> evt?
  str : (and/c string? (not/c immutable?)) ~
  skip : exact-nonnegative-integer? ~
  progress-evt : (or/c progress-evt? #f) ~
  in : input-port? ~

Like the read-...-evt functions, but for peeking. The skip argument
indicates the number of bytes to skip, and progress-evt indicates an
event that effectively cancels the peek (so that the event never becomes
ready). The progress-evt argument can be #f, in which case the event is
never canceled.

                                        *regexp-match-evt*
(regexp-match-evt pattern in) -> any ~
  pattern : (or/c string? bytes? regexp? byte-regexp?) ~
  in : input-port? ~

Returns a synchronizable event that is ready when pattern matches the
stream of bytes/characters from in; see also regexp-match. The event’s
value is the result of the match, in the same form as the result of
regexp-match.

If pattern does not require a start-of-stream match, then bytes skipped
to complete the match are read and discarded when the event is chosen in
a synchronization.

Bytes are read from the port if and only if the event is chosen in a
synchronization, and the returned match always represents contiguous
bytes in the port’s stream. If not-yet-available bytes from the port
might contribute to the match, the event is not ready.  Similarly, if
pattern begins with a start-of-stream ^ and the pattern does not
initially match, then the event cannot become ready until bytes have
been read from the port.

The event can be synchronized multiple times—even concurrently—and each
synchronization corresponds to a distinct match request.

The in port must support progress events. If in returns a special
non-byte value during the match attempt, it is treated like eof.

1.10.4. Copying Streams

                                        *convert-stream*
(convert-stream from-encoding      ~
                in                
                to-encoding       
                out)          -> void?
  from-encoding : string? ~
  in : input-port? ~
  to-encoding : string? ~
  out : output-port? ~

Reads data from in, converts it using (bytes-open-converter
from-encoding to-encoding) and writes the converted bytes to out. The
convert-stream procedure returns after reaching eof in in.

If opening the converter fails, the exn:fail exception is raised.
Similarly, if a conversion error occurs at any point while reading from
in, then exn:fail exception is raised.

                                        *copy-port*
(copy-port in out ...+) -> void? ~
  in : input-port? ~
  out : output-port? ~

Reads data from in and writes it back out to out, returning when in
produces eof.  The copy is efficient, and it is without significant
buffer delays (i.e., a byte that becomes available on in is immediately
transferred to out, even if future reads on in must block). If in
produces a special non-byte value, it is transferred to out using
write-special.

This function is often called from a “background” thread to continuously
pump data from one stream to another.

If multiple outs are provided, case data from in is written to every
out. The different outs block output to each other, because each block
of data read from in is written completely to one out before moving to
the next out. The outs are written in the provided order, so
non-blocking ports (e.g., file output ports) should be placed first in
the argument list.

2. Byte and String Input

                                        *read-char*
(read-char [in]) -> (or/c char? eof-object?) ~
  in : input-port? = (current-input-port) ~

Reads a single character from in—which may involve reading several bytes
to UTF-8-decode them into a character (see Ports); a minimal number of
bytes are read/peeked to perform the decoding. If no bytes are available
before an end-of-file, then eof is returned.

Examples:
  > (let ([ip (open-input-string "S2")])
      (print (read-char ip))
      (newline)
      (print (read-char ip))
      (newline)
      (print (read-char ip)))
  #\S
  #\2
  #<eof>

  > (let ([ip (open-input-bytes #"\316\273")])
      ; The byte string contains UTF-8-encoded content: ~
      (print (read-char ip)))
  #\λ


                                        *read-byte*
(read-byte [in]) -> (or/c byte? eof-object?) ~
  in : input-port? = (current-input-port) ~

Reads a single byte from in. If no bytes are available before an
end-of-file, then eof is returned.

Examples:
  > (let ([ip (open-input-string "a")])
      ; The two values in the following list should be the same.
      (list (read-byte ip) (char->integer #\a)))
  '(97 97)
  > (let ([ip (open-input-string (string #\λ))])
      ; This string has a two byte-encoding.
      (list (read-byte ip) (read-byte ip) (read-byte ip)))
  '(206 187 #<eof>)

                                        *read-line*
(read-line [in mode]) -> (or/c string? eof-object?) ~
  in : input-port? = (current-input-port) ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
       = 'linefeed

Returns a string containing the next line of bytes from in.

Characters are read from in until a line separator or an end-of-file is
read. The line separator is not included in the result string (but it is
removed from the port’s stream). If no characters are read before an
end-of-file is encountered, eof is returned.

The mode argument determines the line separator(s). It must be one of
the following symbols:

* 'linefeed breaks lines on linefeed characters.

* 'return breaks lines on return characters.

* 'return-linefeed breaks lines on return-linefeed combinations. If a
  return character is not followed by a linefeed character, it is
  included in the result string; similarly, a linefeed that is not
  preceded by a return is included in the result string.

* 'any breaks lines on any of a return character, linefeed character, or
  return-linefeed combination. If a return character is followed by a
  linefeed character, the two are treated as a combination.

* 'any-one breaks lines on either a return or linefeed character,
  without recognizing return-linefeed combinations.

Return and linefeed characters are detected after the conversions that
are automatically performed when reading a file in text mode. For
example, reading a file in text mode on Windows automatically changes
return-linefeed combinations to a linefeed. Thus, when a file is opened
in text mode, 'linefeed is usually the appropriate read-line mode.

Examples:
  > (let ([ip (open-input-string "x\ny\n")])
      (read-line ip))
  "x"
  > (let ([ip (open-input-string "x\ny\n")])
      (read-line ip 'return))
  "x\ny\n"
  > (let ([ip (open-input-string "x\ry\r")])
      (read-line ip 'return))
  "x"
  > (let ([ip (open-input-string "x\r\ny\r\n")])
      (read-line ip 'return-linefeed))
  "x"
  > (let ([ip (open-input-string "x\r\ny\nz")])
      (list (read-line ip 'any) (read-line ip 'any)))
  '("x" "y")
  > (let ([ip (open-input-string "x\r\ny\nz")])
      (list (read-line ip 'any-one) (read-line ip 'any-one)))
  '("x" "")

                                        *read-bytes-line*
(read-bytes-line [in mode]) -> (or/c bytes? eof-object?) ~
  in : input-port? = (current-input-port) ~
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one) ~
       = 'linefeed

Like read-line, but reads bytes and produces a byte string.

                                        *read-string*
(read-string amt [in]) -> (or/c string? eof-object?) ~
  amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~

To read an entire port as a string, use port->string.

Returns a string containing the next amt characters from in.

If amt is 0, then the empty string is returned. Otherwise, if fewer than
amt characters are available before an end-of-file is encountered, then
the returned string will contain only those characters before the
end-of-file; that is, the returned string’s length will be less than
amt. (A temporary string of size amt is allocated while reading the
input, even if the size of the result is less than amt characters.) If
no characters are available before an end-of-file, then eof is returned.

If an error occurs during reading, some characters may be lost; that is,
if read-string successfully reads some characters before encountering an
error, the characters are dropped.

Example:
  > (let ([ip (open-input-string "supercalifragilisticexpialidocious")])
      (read-string 5 ip))
  "super"

                                        *read-bytes*
(read-bytes amt [in]) -> (or/c bytes? eof-object?) ~
  amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~

To read an entire port as bytes, use port->bytes.

Like read-string, but reads bytes and produces a byte string.

Example:
  > (let ([ip (open-input-bytes
                      (bytes 6
                             115 101 99 114 101
                             116))])
      (define length (read-byte ip))
      (bytes->string/utf-8 (read-bytes length ip)))
  "secret"

                                        *read-string!*
(read-string! str [in start-pos end-pos]) ~
 -> (or/c exact-positive-integer? eof-object?)
  str : (and/c string? (not/c immutable?)) ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (string-length str) ~

Reads characters from in like read-string, but puts them into str
starting from index start-pos (inclusive) up to end-pos (exclusive).
Like substring, the exn:fail:contract exception is raised if start-pos
or end-pos is out-of-range for str.

If the difference between start-pos and end-pos is 0, then 0 is returned
and str is not modified. If no bytes are available before an
end-of-file, then eof is returned. Otherwise, the return value is the
number of characters read. If m characters are read and
m<end-pos-start-pos, then str is not modified at indices start-pos+m
through end-pos.

Example:
  > (let ([buffer (make-string 10 #\_)]
          [ip (open-input-string "cketRa")])
      (printf "~s\n" buffer)
      (read-string! buffer ip 2 6)
      (printf "~s\n" buffer)
      (read-string! buffer ip 0 2)
      (printf "~s\n" buffer))
  "__________"
  "__cket____"
  "Racket____"


                                        *read-bytes!*
(read-bytes! bstr [in start-pos end-pos]) ~
 -> (or/c exact-positive-integer? eof-object?)
  bstr : bytes? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-string!, but reads bytes, puts them into a byte string, and
returns the number of bytes read.

Example:
  > (let ([buffer (make-bytes 10 (char->integer #\_))]
          [ip (open-input-string "cketRa")])
      (printf "~s\n" buffer)
      (read-bytes! buffer ip 2 6)
      (printf "~s\n" buffer)
      (read-bytes! buffer ip 0 2)
      (printf "~s\n" buffer))
  #"__________"
  #"__cket____"
  #"Racket____"


                                        *read-bytes-avail!*
(read-bytes-avail! bstr [in start-pos end-pos]) ~
 -> (or/c exact-positive-integer? eof-object? procedure?)
  bstr : bytes? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes!, but returns without blocking after having read the
immediately available bytes, and it may return a procedure for a
“special” result. The read-bytes-avail! procedure blocks only if no
bytes (or specials) are yet available. Also unlike read-bytes!,
read-bytes-avail! never drops bytes; if read-bytes-avail! successfully
reads some bytes and then encounters an error, it suppresses the error
(treating it roughly like an end-of-file) and returns the read bytes.
(The error will be triggered by future reads.) If an error is
encountered before any bytes have been read, an exception is raised.

When in produces a special value, as described in Custom Ports, the
result is a procedure of four arguments. The four arguments correspond
to the location of the special value within the port, as described in
Custom Ports. If the procedure is called more than once with valid
arguments, the exn:fail:contract exception is raised. If
read-bytes-avail returns a special-producing procedure, then it does not
place characters in bstr. Similarly, read-bytes-avail places only as
many bytes into bstr as are available before a special value in the
port’s stream.

                                        *read-bytes-avail!**
(read-bytes-avail!*  bstr       ~
                    [in        
                     start-pos 
                     end-pos]) 
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : bytes? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes-avail!, but returns 0 immediately if no bytes (or
specials) are available for reading and the end-of-file is not reached.

                                        *read-bytes-avail!/enable-break*
(read-bytes-avail!/enable-break  bstr       ~
                                [in        
                                 start-pos 
                                 end-pos]) 
 -> (or/c exact-positive-integer? eof-object? procedure?)
  bstr : bytes? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes-avail!, but breaks are enabled during the read (see also
[missing]). If breaking is disabled when read-bytes-avail!/enable-break
is called, and if the exn:break exception is raised as a result of the
call, then no bytes will have been read from in.

                                        *peek-string*
(peek-string amt skip-bytes-amt [in]) -> (or/c string? eof-object?) ~
  amt : exact-nonnegative-integer? ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~

Similar to read-string, except that the returned characters are peeked:
preserved in the port for future reads and peeks. (More precisely,
undecoded bytes are left for future reads and peeks.) The skip-bytes-amt
argument indicates a number of bytes (not characters) in the input
stream to skip before collecting characters to return; thus, in total,
the next skip-bytes-amt bytes plus amt characters are inspected.

For most kinds of ports, inspecting skip-bytes-amt bytes and amt
characters requires at least skip-bytes-amt+amt bytes of memory overhead
associated with the port, at least until the bytes/characters are read.
No such overhead is required when peeking into a string port (see String
Ports), a pipe port (see Pipes), or a custom port with a specific peek
procedure (depending on how the peek procedure is implemented; see
Custom Ports).

If a port produces eof mid-stream, attempts to skip beyond the eof for a
peek always produce eof until the eof is read.

                                        *peek-bytes*
(peek-bytes amt skip-bytes-amt [in]) -> (or/c bytes? eof-object?) ~
  amt : exact-nonnegative-integer? ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~

Like peek-string, but peeks bytes and produces a byte string.

                                        *peek-string!*
(peek-string!  str             ~
               skip-bytes-amt 
              [in             
               start-pos      
               end-pos])      
 -> (or/c exact-positive-integer? eof-object?)
  str : (and/c string? (not/c immutable?)) ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (string-length str) ~

Like read-string!, but for peeking, and with a skip-bytes-amt argument
like peek-string.

                                        *peek-bytes!*
(peek-bytes!  bstr            ~
              skip-bytes-amt 
             [in             
              start-pos      
              end-pos])      
 -> (or/c exact-positive-integer? eof-object?)
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like peek-string!, but peeks bytes, puts them into a byte string, and
returns the number of bytes read.

                                        *peek-bytes-avail!*
(peek-bytes-avail!  bstr            ~
                    skip-bytes-amt 
                   [progress       
                    in             
                    start-pos      
                    end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  progress : (or/c progress-evt? #f) = #f ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes-avail!, but for peeking, and with two extra arguments.
The skip-bytes-amt argument is as in peek-bytes.  The progress argument
must be either #f or an event produced by port-progress-evt for in.

To peek, peek-bytes-avail! blocks until finding an end-of-file, at least
one byte (or special) past the skipped bytes, or until a non-#f progress
becomes ready. Furthermore, if progress is ready before bytes are
peeked, no bytes are peeked or skipped, and progress may cut short the
skipping process if it becomes available during the peek attempt.
Furthermore, progress is checked even before determining whether the
port is still open.

The result of peek-bytes-avail! is 0 only in the case that progress
becomes ready before bytes are peeked.

                                        *peek-bytes-avail!**
(peek-bytes-avail!*  bstr            ~
                     skip-bytes-amt 
                    [progress       
                     in             
                     start-pos      
                     end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  progress : (or/c progress-evt? #f) = #f ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes-avail!*, but for peeking, and with skip-bytes-amt and
progress arguments like peek-bytes-avail!. Since this procedure never
blocks, it may return before even skip-amt bytes are available from the
port.

                                        *peek-bytes-avail!/enable-break*
(peek-bytes-avail!/enable-break  bstr            ~
                                 skip-bytes-amt 
                                [progress       
                                 in             
                                 start-pos      
                                 end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?)) ~
  skip-bytes-amt : exact-nonnegative-integer? ~
  progress : (or/c progress-evt? #f) = #f ~
  in : input-port? = (current-input-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like read-bytes-avail!/enable-break, but for peeking, and with
skip-bytes-amt and progress arguments like peek-bytes-avail!.

                                        *read-char-or-special*
(read-char-or-special [in]) -> (or/c char? eof-object? any/c) ~
  in : input-port? = (current-input-port) ~

Like read-char, but if the input port returns a special value (through a
value-generating procedure in a custom port; see Custom Ports and
Special Comments for details), then the special value is returned.

                                        *read-byte-or-special*
(read-byte-or-special [in]) -> (or/c byte? eof-object? any/c) ~
  in : input-port? = (current-input-port) ~

Like read-char-or-special, but reads and returns a byte instead of a
character.

                                        *peek-char*
(peek-char [in skip-bytes-amt]) -> (or/c char? eof-object?) ~
  in : input-port? = (current-input-port) ~
  skip-bytes-amt : exact-nonnegative-integer? = 0 ~

Like read-char, but peeks instead of reading, and skips skip-bytes-amt
bytes (not characters) at the start of the port.

                                        *peek-byte*
(peek-byte [in skip-bytes-amt]) -> (or/c byte? eof-object?) ~
  in : input-port? = (current-input-port) ~
  skip-bytes-amt : exact-nonnegative-integer? = 0 ~

Like peek-char, but peeks and returns a byte instead of a character.

                                        *peek-char-or-special*
(peek-char-or-special [in skip-bytes-amt]) ~
 -> (or/c char? eof-object? any/c)
  in : input-port? = (current-input-port) ~
  skip-bytes-amt : exact-nonnegative-integer? = 0 ~

Like peek-char, but if the input port returns a non-byte value after
skip-bytes-amt byte positions, then it is returned.

                                        *peek-byte-or-special*
(peek-byte-or-special [in              ~
                       skip-bytes-amt 
                       progress])     
 -> (or/c byte? eof-object? any/c)
  in : input-port? = (current-input-port) ~
  skip-bytes-amt : exact-nonnegative-integer? = 0 ~
  progress : (or/c progress-evt? #f) = #f ~

Like peek-char-or-special, but peeks and returns a byte instead of a
character, and it supports a progress argument like peek-bytes-avail!.

                                        *port-progress-evt*
(port-progress-evt [in]) -> progress-evt? ~
  in : (and/c input-port? port-provides-progress-evts?) ~
     = (current-input-port)

Returns a synchronizable event (see [missing]) that becomes ready for
synchronization after any subsequent read from in or after in is closed.
After the event becomes ready, it remains ready. The synchronization
result of a progress event is the progress event itself.

                                        *port-provides-progress-evts?*
(port-provides-progress-evts? in) -> boolean ~
  in : input-port? ~

Returns #t if port-progress-evt can return an event for in. All built-in
kinds of ports support progress events, but ports created with
make-input-port (see Custom Ports) may not.

                                        *port-commit-peeked*
(port-commit-peeked amt progress evt [in]) -> boolean? ~
  amt : exact-nonnegative-integer? ~
  progress : progress-evt? ~
  evt : evt? ~
  in : input-port? = (current-input-port) ~

Attempts to commit as read the first amt previously peeked bytes,
non-byte specials, and eofs from in, or the first eof or special value
peeked from in. Mid-stream eofs can be committed, but an eof when the
port is exhausted does not necessarily commit, since it does not
correspond to data in the stream.

The read commits only if progress does not become ready first (i.e., if
no other process reads from in first), and only if evt is chosen by a
sync within port-commit-peeked (in which case the event result is
ignored); the evt must be either a channel-put event, channel,
semaphore, semaphore-peek event, always event, or never event.
Suspending the thread that calls port-commit-peeked may or may not
prevent the commit from proceeding.

The result from port-commit-peeked is #t if data has been committed, and
#f otherwise.

If no data has been peeked from in and progress is not ready, then
exn:fail:contract exception is raised.  If fewer than amt items have
been peeked at the current start of in’s stream, then only the peeked
items are committed as read.  If in’s stream currently starts at an eof
or a non-byte special value, then only the eof or special value is
committed as read.

If progress is not a result of port-progress-evt applied to in, then
exn:fail:contract exception is raised.

                                        *byte-ready?*
(byte-ready? [in]) -> boolean? ~
  in : input-port? = (current-input-port) ~

Returns #t if (read-byte in) would not block (at the time that
byte-ready? was called, at least).  Equivalent to (and (sync/timeout 0
in) #t).

                                        *char-ready?*
(char-ready? [in]) -> boolean? ~
  in : input-port? = (current-input-port) ~

Returns #t if (read-char in) would not block (at the time that
char-ready? was called, at least). Depending on the initial bytes of the
stream, multiple bytes may be needed to form a UTF-8 encoding.

                                        *progress-evt?*
(progress-evt? v) -> boolean? ~
  v : any/c ~
(progress-evt? evt in) -> boolean?
  evt : progress-evt? ~
  in : input-port? ~

With one argument, returns #t is v is a progress evt for some input
port, #f otherwise.

With two arguments, returns #t if evt is a progress event for in, #f
otherwise.

3. Byte and String Output

                                        *write-char*
(write-char char [out]) -> void? ~
  char : char? ~
  out : output-port? = (current-output-port) ~

Writes a single character to out; more precisely, the bytes that are the
UTF-8 encoding of char are written to out.

                                        *write-byte*
(write-byte byte [out]) -> void? ~
  byte : byte? ~
  out : output-port? = (current-output-port) ~

Writes a single byte to out.

                                        *newline*
(newline [out]) -> void? ~
  out : output-port? = (current-output-port) ~

The same as (write-char #\newline out).

                                        *write-string*
(write-string str [out start-pos end-pos]) ~
 -> exact-nonnegative-integer?
  str : string? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (string-length str) ~

Writes characters to out from str starting from index start-pos
(inclusive) up to end-pos (exclusive). Like substring, the
exn:fail:contract exception is raised if start-pos or end-pos is
out-of-range for str.

The result is the number of characters written to out, which is always
(- end-pos start-pos).

If str is mutable, mutations after write-string returns do not affect
the characters written to out. (This independence from mutation is not a
special property of write-string, but instead generally true of output
functions.)

                                        *write-bytes*
(write-bytes bstr [out start-pos end-pos]) ~
 -> exact-nonnegative-integer?
  bstr : bytes? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like write-string, but writes bytes instead of characters.

                                        *write-bytes-avail*
(write-bytes-avail  bstr           ~
                   [out           
                    start-pos     
                    end-pos]) -> exact-nonnegative-integer?
  bstr : bytes? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like write-bytes, but returns without blocking after writing as many
bytes as it can immediately flush. It blocks only if no bytes can be
flushed immediately. The result is the number of bytes written and
flushed to out; if start-pos is the same as end-pos, then the result can
be 0 (indicating a successful flush of any buffered data), otherwise the
result is between 1 and (- end-pos start-pos), inclusive.

The write-bytes-avail procedure never drops bytes; if write-bytes-avail
successfully writes some bytes and then encounters an error, it
suppresses the error and returns the number of written bytes.  (The
error will be triggered by future writes.) If an error is encountered
before any bytes have been written, an exception is raised.

                                        *write-bytes-avail**
(write-bytes-avail*  bstr       ~
                    [out       
                     start-pos 
                     end-pos]) 
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like write-bytes-avail, but never blocks, returns #f if the port
contains buffered data that cannot be written immediately, and returns 0
if the port’s internal buffer (if any) is flushed but no additional
bytes can be written immediately.

                                        *write-bytes-avail/enable-break*
(write-bytes-avail/enable-break  bstr       ~
                                [out       
                                 start-pos 
                                 end-pos]) 
 -> exact-nonnegative-integer?
  bstr : bytes? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Like write-bytes-avail, except that breaks are enabled during the write.
The procedure provides a guarantee about the interaction of writing and
breaks: if breaking is disabled when write-bytes-avail/enable-break is
called, and if the exn:break exception is raised as a result of the
call, then no bytes will have been written to out.  See also [missing].

                                        *write-special*
(write-special v [out]) -> boolean? ~
  v : any/c ~
  out : output-port? = (current-output-port) ~

Writes v directly to out if the port supports special writes, or raises
exn:fail:contract if the port does not support special write. The result
is always #t, indicating that the write succeeded.

                                        *write-special-avail**
(write-special-avail* v [out]) -> boolean? ~
  v : any/c ~
  out : output-port? = (current-output-port) ~

Like write-special, but without blocking. If v cannot be written
immediately, the result is #f without writing v, otherwise the result is
#t and v is written.

                                        *write-bytes-avail-evt*
(write-bytes-avail-evt  bstr           ~
                       [out           
                        start-pos     
                        end-pos]) -> evt?
  bstr : bytes? ~
  out : output-port? = (current-output-port) ~
  start-pos : exact-nonnegative-integer? = 0 ~
  end-pos : exact-nonnegative-integer? = (bytes-length bstr) ~

Similar to write-bytes-avail, but instead of writing bytes immediately,
it returns a synchronizable event (see [missing]).  The out must support
atomic writes, as indicated by port-writes-atomic?.

Synchronizing on the object starts a write from bstr, and the event
becomes ready when bytes are written (unbuffered) to the port. If
start-pos and end-pos are the same, then the synchronization result is 0
when the port’s internal buffer (if any) is flushed, otherwise the
result is a positive exact integer. If the event is not selected in a
synchronization, then no bytes will have been written to out.

                                        *write-special-evt*
(write-special-evt v [out]) -> evt? ~
  v : any/c ~
  out : output-port? = (current-output-port) ~

Similar to write-special, but instead of writing the special value
immediately, it returns a synchronizable event (see [missing]).  The out
must support atomic writes, as indicated by port-writes-atomic?.

Synchronizing on the object starts a write of the special value, and the
event becomes ready when the value is written (unbuffered) to the port.
If the event is not selected in a synchronization, then no value will
have been written to out.

                                        *port-writes-atomic?*
(port-writes-atomic? out) -> boolean? ~
  out : output-port? ~

Returns #t if write-bytes-avail/enable-break can provide an exclusive-or
guarantee (break or write, but not both) for out, and if the port can be
used with procedures like write-bytes-avail-evt. Racket’s file-stream
ports, pipes, string ports, and TCP ports all support atomic writes;
ports created with make-output-port (see Custom Ports) may support
atomic writes.

                                        *port-writes-special?*
(port-writes-special? out) -> boolean? ~
  out : output-port? ~

Returns #t if procedures like write-special can write arbitrary values
to the port. Racket’s file-stream ports, pipes, string ports, and TCP
ports all reject special values, but ports created with make-output-port
(see Custom Ports) may support them.

4. Reading

                                        *read*
(read [in]) -> any ~
  in : input-port? = (current-input-port) ~

Reads and returns a single datum from in. If in has a handler associated
to it via port-read-handler, then the handler is called. Otherwise, the
default reader is used, as parameterized by the current-readtable
parameter, as well as many other parameters.

See [missing] for information on the default reader.

                                        *read-syntax*
(read-syntax [source-name in]) -> (or/c syntax? eof-object?) ~
  source-name : any/c = (object-name in) ~
  in : input-port? = (current-input-port) ~

Like read, but produces a syntax object with source-location
information. The source-name is used as the source field of the syntax
object; it can be an arbitrary value, but it should generally be a path
for the source file.

See [missing] for information on the default reader in read-syntax mode.

                                        *read/recursive*
(read/recursive [in start readtable graph?]) -> any ~
  in : input-port? = (current-input-port) ~
  start : (or/c char? #f) = #f ~
  readtable : (or/c readtable? #f) = (current-readtable) ~
  graph? : any/c = #t ~

Similar to calling read, but normally used during the dynamic extent of
read within a reader-extension procedure (see Reader-Extension
Procedures). The main effect of using read/recursive instead of read is
that graph-structure annotations (see [missing]) in the nested read are
considered part of the overall read, at least when the graph? argument
is true; since the result is wrapped in a placeholder, however, it is
not directly inspectable.

If start is provided and not #f, it is effectively prefixed to the
beginning of in’s stream for the read. (To prefix multiple characters,
use input-port-append.)

The readtable argument is used for top-level parsing to satisfy the read
request, including various delimiters of a built-in top-level form (such
as parentheses and . for reading a hash table); recursive parsing within
the read (e.g., to read the elements of a list) instead uses the current
readtable as determined by the current-readtable parameter.  A reader
macro might call read/recursive with a character and readtable to
effectively invoke the readtable’s behavior for the character.  If
readtable is #f, the default readtable is used for top-level parsing.

When graph? is #f, graph structure annotations in the read datum are
local to the datum.

When called within the dynamic extent of read, the read/recursive
procedure produces either an opaque placeholder value, a special-comment
value, or an end-of-file.  The result is a special-comment value (see
Special Comments) when the input stream’s first non-whitespace content
parses as a comment. The result is end-of-file when read/recursive
encounters an end-of-file. Otherwise, the result is a placeholder that
protects graph references that are not yet resolved. When this
placeholder is returned within an S-expression that is produced by any
reader-extension procedure (see Reader-Extension Procedures) for the
same outermost read, it will be replaced with the actual read value
before the outermost read returns.

See Readtables for an extended example that uses read/recursive.

Changed in version 6.2: Adjusted use of readtable to more consistently
apply to the delimiters of a built-in form.

                                        *read-syntax/recursive*
(read-syntax/recursive [source-name      ~
                        in              
                        start           
                        readtable       
                        graph?])    -> any
  source-name : any/c = (object-name in) ~
  in : input-port? = (current-input-port) ~
  start : (or/c char? #f) = #f ~
  readtable : (or/c readtable? #f) = (current-readtable) ~
  graph? : any/c = #t ~

Analogous to calling read/recursive, but the resulting value
encapsulates S-expression structure with source-location information. As
with read/recursive, when read-syntax/recursive is used within the
dynamic extent of read-syntax, the result from read-syntax/recursive is
either a special-comment value, end-of-file, or opaque graph-structure
placeholder (not a syntax object). The placeholder can be embedded in an
S-expression or syntax object returned by a reader macro, etc., and it
will be replaced with the actual syntax object before the outermost
read-syntax returns.

Using read/recursive within the dynamic extent of read-syntax does not
allow graph structure for reading to be included in the outer
read-syntax parsing, and neither does using read-syntax/recursive within
the dynamic extent of read. In those cases, read/recursive and
read-syntax/recursive produce results like read and read-syntax, except
that a special-comment value is returned when the input stream starts
with a comment (after whitespace).

See Readtables for an extended example that uses read-syntax/recursive.

Changed in version 6.2: Adjusted use of readtable in the same way as for
read/recursive.

                                        *read-language*
(read-language [in fail-thunk]) ~
 -> (or/c (any/c any/c . -> . any) #f)
  in : input-port? = (current-input-port) ~
  fail-thunk : (-> any) = (lambda () (error ...)) ~

Reads from in in the same way as read, but stopping as soon as a reader
language (or its absence) is determined.

A reader language is specified by #lang or #! (see [missing]) at the
beginning of the input, though possibly after comment forms. The default
readtable is used by read-language (instead of the value of
current-readtable), and #reader forms (which might produce comments) are
not allowed before #lang or #!.

+See also [missing] in [missing].

When it finds a #lang or #! specification, instead of dispatching to a
read or read-syntax function as read and read-syntax do, read-language
dispatches to the get-info function (if any) exported by the same
module. The result of the get-info function is the result of
read-language if it is a function of two arguments; if get-info produces
any other kind of result, the exn:fail:contract exception is raised. If
no get-info function is exported, read-language returns #f.

The function produced by get-info reflects information about the
expected syntax of the input stream. The first argument to the function
serves as a key on such information; acceptable keys and the
interpretation of results is up to external tools, such as DrRacket (see
the DrRacket documentation). If no information is available for a given
key, the result should be the second argument.

Examples:
  > ((read-language (open-input-string "#lang algol60")) 'color-lexer #f)
  standard-module-name-resolver: collection not found
    for module path: (submod algol60 reader) ~
    collection: "algol60" ~
    in collection directories: ~
     /usr/share/racket/collects
     ... [96 additional linked and package directories]
  > ((read-language (open-input-string "#lang
  algol60")) 'something-else #f)
  standard-module-name-resolver: collection not found
    for module path: (submod algol60 reader) ~
    collection: "algol60" ~
    in collection directories: ~
     /usr/share/racket/collects
     ... [96 additional linked and package directories]

The get-info function itself is applied to five arguments: the input
port being read, the module path from which the get-info function was
extracted, and the source line (positive exact integer or #f), column
(non-negative exact integer or #f), and position (positive exact integer
or #f) of the start of the #lang or #! form. The get-info function may
further read from the given input port to determine its result, but it
should read no further than necessary. The get-info function should not
read from the port after returning a function.

If in starts with a reader language specification but the relevant
module does not export get-info (but perhaps does export read and
read-syntax), then the result of read-language is #f.

If in has a #lang or #! specification, but parsing and resolving the
specification raises an exception, the exception is propagated by
read-language. Having at least #l or #! (after comments and whitespace)
counts as starting a #lang or #! specification.

If in does not specify a reader language with #lang or #!, then
fail-thunk is called. The default fail-thunk raises exn:fail:read or
exn:fail:read:eof.

                                        *read-case-sensitive*
(read-case-sensitive) -> boolean? ~
(read-case-sensitive on?) -> void?
  on? : any/c ~

A parameter that controls parsing and printing of symbols. When this
parameter’s value is #f, the reader case-folds symbols (e.g., producing
'hi when the input is any one of hi, Hi, HI, or hI). The parameter also
affects the way that write prints symbols containing uppercase
characters; if the parameter’s value is #f, then symbols are printed
with uppercase characters quoted by a \ or |. The parameter’s value is
overridden by quoting \ or | vertical-bar quotes and the #cs and #ci
prefixes; see [missing] for more information. While a module is loaded,
the parameter is set to #t (see current-load).

                                        *read-square-bracket-as-paren*
(read-square-bracket-as-paren) -> boolean? ~
(read-square-bracket-as-paren on?) -> void?
  on? : any/c ~

A parameter that controls whether [ and ] are treated as parentheses.
See [missing] for more information.

                                        *read-curly-brace-as-paren*
(read-curly-brace-as-paren) -> boolean? ~
(read-curly-brace-as-paren on?) -> void?
  on? : any/c ~

A parameter that controls whether { and } are treated as parentheses.
See [missing] for more information.

                                        *read-accept-box*
(read-accept-box) -> boolean? ~
(read-accept-box on?) -> void?
  on? : any/c ~

A parameter that controls parsing #& input. See [missing] for more
information.

                                        *read-accept-compiled*
(read-accept-compiled) -> boolean? ~
(read-accept-compiled on?) -> void?
  on? : any/c ~

A parameter that controls parsing #~ compiled input. See [missing] and
current-compile for more information.

                                        *read-accept-bar-quote*
(read-accept-bar-quote) -> boolean? ~
(read-accept-bar-quote on?) -> void?
  on? : any/c ~

A parameter that controls parsing and printing of | in symbols. See
[missing] and [missing] for more information.

                                        *read-accept-graph*
(read-accept-graph) -> boolean? ~
(read-accept-graph on?) -> void?
  on? : any/c ~

A parameter value that controls parsing input with sharing. See
[missing] for more information.

                                        *read-decimal-as-inexact*
(read-decimal-as-inexact) -> boolean? ~
(read-decimal-as-inexact on?) -> void?
  on? : any/c ~

A parameter that controls parsing input numbers with a decimal point or
exponent (but no explicit exactness tag). See [missing] for more
information.

                                        *read-accept-dot*
(read-accept-dot) -> boolean? ~
(read-accept-dot on?) -> void?
  on? : any/c ~

A parameter that controls parsing input with a dot, which is normally
used for literal cons cells. See [missing] for more information.

                                        *read-accept-infix-dot*
(read-accept-infix-dot) -> boolean? ~
(read-accept-infix-dot on?) -> void?
  on? : any/c ~

A parameter that controls parsing input with two dots to trigger infix
conversion. See [missing] for more information.

                                        *read-accept-quasiquote*
(read-accept-quasiquote) -> boolean? ~
(read-accept-quasiquote on?) -> void?
  on? : any/c ~

A parameter that controls parsing input with ` or , which is normally
used for quasiquote, unquote, and unquote-splicing abbreviations. See
[missing] for more information.

                                        *read-accept-reader*
(read-accept-reader) -> boolean? ~
(read-accept-reader on?) -> void?
  on? : any/c ~

A parameter that controls whether #reader, #lang, or #! are allowed for
selecting a parser. See [missing] for more information.

                                        *read-accept-lang*
(read-accept-lang) -> boolean? ~
(read-accept-lang on?) -> void?
  on? : any/c ~

A parameter that (along with read-accept-reader controls whether #lang
and #! are allowed for selecting a parser. See [missing] for more
information.

                                        *current-readtable*
(current-readtable) -> (or/c readtable? #f) ~
(current-readtable readtable) -> void?
  readtable : (or/c readtable? #f) ~

A parameter whose value determines a readtable that adjusts the parsing
of S-expression input, where #f implies the default behavior. See
Readtables for more information.

                                        *call-with-default-reading-parameterization*
(call-with-default-reading-parameterization thunk) -> any ~
  thunk : (-> any) ~

Calls thunk in tail position of a parameterize to set all reader
parameters above to their default values.

Using the default parameter values ensures consistency, and it also
provides safety when reading from untrusted sources, since the default
values disable evaluation of arbitrary code via #lang or #reader.

                                        *current-reader-guard*
(current-reader-guard) -> (any/c . -> . any) ~
(current-reader-guard proc) -> void?
  proc : (any/c . -> . any) ~

A parameter whose value converts or rejects (by raising an exception) a
module-path datum following #reader. See [missing] for more information.

                                        *read-on-demand-source*
(read-on-demand-source) ~
 -> (or/c #f #t (and/c path? complete-path?))
(read-on-demand-source mode) -> void?
  mode : (or/c #f #t (and/c path? complete-path?)) ~

A parameter that enables lazy parsing of compiled code, so that closure
bodies and syntax objects are extracted (and validated) from marshaled
compiled code on demand. Normally, this parameter is set by the default
load handler when load-on-demand-enabled is #t.

A #f value for read-on-demand-source disables lazy parsing of compiled
code. A #t value enables lazy parsing.  A path value furthers enable
lazy retrieval from disk—instead of keeping unparsed compiled code in
memory—when the PLT_DELAY_FROM_ZO environment variable is set (to any
value) on start-up.

If the file at mode as a path changes before the delayed code is parsed
when lazy retrieval from disk is enabled, then the on-demand parse most
likely will encounter garbage, leading to an exception.

                                        *port-read-handler*
(port-read-handler in) -> (case-> ~
                           (input-port? . -> . any)
                           (input-port?  any/c . -> . any))
  in : input-port? ~
(port-read-handler in proc) -> void?
  in : input-port? ~
  proc : (case-> ~
          (input-port? . -> . any)
          (input-port? any/c . -> . any))

Gets or sets the port read handler for in. The handler called to read
from the port when the built-in read or read-syntax procedure is applied
to the port. (The port read handler is not used for read/recursive or
read-syntax/recursive.)

A port read handler is applied to either one argument or two arguments:

* A single argument is supplied when the port is used with read; the
  argument is the port being read. The return value is the value that
  was read from the port (or end-of-file).

* Two arguments are supplied when the port is used with read-syntax; the
  first argument is the port being read, and the second argument is a
  value indicating the source. The return value is a syntax object that
  was read from the port (or end-of-file).

The default port read handler reads standard Racket expressions with
Racket’s built-in parser (see [missing]). It handles a special result
from a custom input port (see make-custom-input-port) by treating it as
a single expression, except that special-comment values (see Special
Comments) are treated as whitespace.

The default port read handler itself can be customized through a
readtable; see Readtables for more information.

5. Writing

                                        *write*
(write datum [out]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~

Writes datum to out, normally in such a way that instances of core
datatypes can be read back in. If out has a handler associated to it via
port-write-handler, then the handler is called. Otherwise, the default
printer is used (in write mode), as configured by various parameters.

See [missing] for more information about the default printer. In
particular, note that write may require memory proportional to the depth
of the value being printed, due to the initial cycle check.

Examples:
  > (write 'hi)
  hi

  > (write (lambda (n) n))
  #<procedure>

  > (define o (open-output-string))

  > (write "hello" o)

  > (get-output-string o)
  "\"hello\""

                                        *display*
(display datum [out]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~

Displays datum to out, similar to write, but usually in such a way that
byte- and character-based datatypes are written as raw bytes or
characters. If out has a handler associated to it via
port-display-handler, then the handler is called. Otherwise, the default
printer is used (in display mode), as configured by various parameters.

See [missing] for more information about the default printer. In
particular, note that display may require memory proportional to the
depth of the value being printed, due to the initial cycle check.

                                        *print*
(print datum [out quote-depth]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~
  quote-depth : (or/c 0 1) = 0 ~

Prints datum to out. If out has a handler associated to it via
port-print-handler, then the handler is called. Otherwise, the handler
specified by global-port-print-handler is called; the default handler
uses the default printer in print mode.

The optional quote-depth argument adjusts printing when the
print-as-expression parameter is set to #t. In that case, quote-depth
specifies the starting quote depth for printing datum.

The rationale for providing print is that display and write both have
specific output conventions, and those conventions restrict the ways
that an environment can change the behavior of display and write
procedures. No output conventions should be assumed for print, so that
environments are free to modify the actual output generated by print in
any way.

                                        *writeln*
(writeln datum [out]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~

The same as (write datum out) followed by (newline out).

Added in version 6.1.1.8.

                                        *displayln*
(displayln datum [out]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~

The same as (display datum out) followed by (newline out), which is
similar to println in Pascal or Java.

                                        *println*
(println datum [out quote-depth]) -> void? ~
  datum : any/c ~
  out : output-port? = (current-output-port) ~
  quote-depth : (or/c 0 1) = 0 ~

The same as (print datum out quote-depth) followed by (newline out).

The println function is not equivalent to println in other languages,
because println uses printing conventions that are closer to write than
to display. For a closer analog to println in other languages, use
displayln.

Added in version 6.1.1.8.

                                        *fprintf*
(fprintf out form v ...) -> void? ~
  out : output-port? ~
  form : string? ~
  v : any/c ~

Prints formatted output to out, where form is a string that is printed
directly, except for special formatting escapes:

* ~n or ~% prints a newline character (which is equivalent to \n in a
  literal format string)

* ~a or ~A displays the next argument among the vs

* ~s or ~S writes the next argument among the vs

* ~v or ~V prints the next argument among the vs

* ~.>c< where >c< is a, A, s, S, v, or V: truncates display, write, or
  print output to (error-print-width) characters, using ... as the last
  three characters if the untruncated output would be longer

* ~e or ~E outputs the next argument among the vs using the current
  error value conversion handler (see error-value->string-handler) and
  current error printing width

* ~c or ~C write-chars the next argument in vs; if the next argument is
  not a character, the exn:fail:contract exception is raised

* ~b or ~B prints the next argument among the vs in binary; if the next
  argument is not an exact number, the exn:fail:contract exception is
  raised

* ~o or ~O prints the next argument among the vs in octal; if the next
  argument is not an exact number, the exn:fail:contract exception is
  raised

* ~x or ~X prints the next argument among the vs in hexadecimal; if the
  next argument is not an exact number, the exn:fail:contract exception
  is raised

* ~~ prints a tilde.

* ~>w<, where >w< is a whitespace character (see char-whitespace?),
  skips characters in form until a non-whitespace character is
  encountered or until a second end-of-line is encountered (whichever
  happens first). On all platforms, an end-of-line can be #\return,
  #\newline, or #\return followed immediately by #\newline.

The form string must not contain any ~ that is not one of the above
escapes, otherwise the exn:fail:contract exception is raised. When the
format string requires more vs than are supplied, the exn:fail:contract
exception is raised. Similarly, when more vs are supplied than are used
by the format string, the exn:fail:contract exception is raised.

Example:
  > (fprintf (current-output-port)
             "~a as a string is ~s.\n"
             '(3 4)
             "(3 4)")
  (3 4) as a string is "(3 4)".


                                        *printf*
(printf form v ...) -> void? ~
  form : string? ~
  v : any/c ~

The same as (fprintf (current-output-port) form v ...).

                                        *eprintf*
(eprintf form v ...) -> void? ~
  form : string? ~
  v : any/c ~

The same as (fprintf (current-error-port) form v ...).

                                        *format*
(format form v ...) -> string? ~
  form : string? ~
  v : any/c ~

Formats to a string. The result is the same as

  (let ([o (open-output-string)])
    (fprintf o form v ...)
    (get-output-string o))

Example:
  > (format "~a as a string is ~s.\n" '(3 4) "(3 4)")
  "(3 4) as a string is \"(3 4)\".\n"

                                        *print-pair-curly-braces*
(print-pair-curly-braces) -> boolean? ~
(print-pair-curly-braces on?) -> void?
  on? : any/c ~

A parameter that controls pair printing. If the value is true, then
pairs print using { and } instead of ( and ). The default is #f.

                                        *print-mpair-curly-braces*
(print-mpair-curly-braces) -> boolean? ~
(print-mpair-curly-braces on?) -> void?
  on? : any/c ~

A parameter that controls pair printing. If the value is true, then
mutable pairs print using { and } instead of ( and ). The default is #t.

                                        *print-unreadable*
(print-unreadable) -> boolean? ~
(print-unreadable on?) -> void?
  on? : any/c ~

A parameter that enables or disables printing of values that have no
readable form (using the default reader), including structures that have
a custom-write procedure (see prop:custom-write), but not including
uninterned symbols and unreadable symbols (which print the same as
interned symbols). If the parameter value is #f, an attempt to print an
unreadable value raises exn:fail. The parameter value defaults to #t.
See [missing] for more information.

                                        *print-graph*
(print-graph) -> boolean? ~
(print-graph on?) -> void?
  on? : any/c ~

A parameter that controls printing data with sharing; defaults to #f.
See [missing] for more information.

                                        *print-struct*
(print-struct) -> boolean? ~
(print-struct on?) -> void?
  on? : any/c ~

A parameter that controls printing structure values in vector or prefab
form; defaults to #t. See [missing] for more information. This parameter
has no effect on the printing of structures that have a custom-write
procedure (see prop:custom-write).

                                        *print-box*
(print-box) -> boolean? ~
(print-box on?) -> void?
  on? : any/c ~

A parameter that controls printing box values; defaults to #t. See
[missing] for more information.

                                        *print-vector-length*
(print-vector-length) -> boolean? ~
(print-vector-length on?) -> void?
  on? : any/c ~

A parameter that controls printing vectors; defaults to #f. See
[missing] for more information.

                                        *print-hash-table*
(print-hash-table) -> boolean? ~
(print-hash-table on?) -> void?
  on? : any/c ~

A parameter that controls printing hash tables; defaults to #f. See
[missing] for more information.

                                        *print-boolean-long-form*
(print-boolean-long-form) -> boolean? ~
(print-boolean-long-form on?) -> void?
  on? : any/c ~

A parameter that controls printing of booleans. When the parameter’s
value is true, #t and #f print as #true and #false, otherwise they print
as #t and #f. The default is #f.

                                        *print-reader-abbreviations*
(print-reader-abbreviations) -> boolean? ~
(print-reader-abbreviations on?) -> void?
  on? : any/c ~

A parameter that controls printing of two-element lists that start with
quote, 'quasiquote, 'unquote, 'unquote-splicing, 'syntax, 'quasisyntax,
'unsyntax, or 'unsyntax-splicing; defaults to #f. See [missing] for more
information.

                                        *print-as-expression*
(print-as-expression) -> boolean? ~
(print-as-expression on?) -> void?
  on? : any/c ~

A parameter that controls printing in print mode (as opposed to write or
display); defaults to #t. See [missing] for more information.

                                        *print-syntax-width*
(print-syntax-width) ~
 -> (or/c +inf.0 0 (and/c exact-integer? (>/c 3)))
(print-syntax-width width) -> void?
  width : (or/c +inf.0 0 (and/c exact-integer? (>/c 3))) ~

A parameter that controls printing of syntax objects. Up to width
characters are used to show the datum form of a syntax object within
#<syntax...> (after the syntax object’s source location, if any).

                                        *current-write-relative-directory*
(current-write-relative-directory) ~
 -> (or/c (and/c path? complete-path?)
          (cons/c (and/c path? complete-path?)
                  (and/c path? complete-path?))
          #f)
(current-write-relative-directory path) -> void?
  path : (or/c (and/c path-string? complete-path?) ~
               (cons/c (and/c path-string? complete-path?)
                       (and/c path-string? complete-path?))
               #f)

A parameter that is used when writing compiled code (see [missing]) that
contains pathname literals, including source-location pathnames for
procedure names. When the parameter’s value is a path, paths that
syntactically extend path are converted to relative paths; when the
resulting compiled code is read, relative paths are converted back to
complete paths using the current-load-relative-directory parameter (if
it is not #f; otherwise, the path is left relative). When the
parameter’s value is (cons rel-to-path base-path), then paths that
syntactically extend base-path are converted as relative to rel-to-path;
the rel-to-path must extend base-path, in which case 'up path elements
(in the sense of build-path) may be used to make a path relative to
rel-to-path.

                                        *port-write-handler*
(port-write-handler out) -> (any/c output-port? . -> . any) ~
  out : output-port? ~
(port-write-handler out proc) -> void?
  out : output-port? ~
  proc : (any/c output-port? . -> . any) ~
(port-display-handler out) -> (any/c output-port? . -> . any)
  out : output-port? ~
(port-display-handler out proc) -> void?
  out : output-port? ~
  proc : (any/c output-port? . -> . any) ~
(port-print-handler out)
 -> ((any/c output-port?) ((or/c 0 1)) . ->* . any)
  out : output-port? ~
(port-print-handler out proc) -> void?
  out : output-port? ~
  proc : (any/c output-port? . -> . any) ~

Gets or sets the port write handler, port display handler, or port print
handler for out. This handler is called to output to the port when
write, display, or print (respectively) is applied to the port.  Each
handler must accept two arguments: the value to be printed and the
destination port. The handler’s return value is ignored.

A port print handler optionally accepts a third argument, which
corresponds to the optional third argument to print; if a procedure
given to port-print-handler does not accept a third argument, it is
wrapped with a procedure that discards the optional third argument.

The default port display and write handlers print Racket expressions
with Racket’s built-in printer (see [missing]). The default print
handler calls the global port print handler (the value of the
global-port-print-handler parameter); the default global port print
handler is the same as the default write handler.

                                        *global-port-print-handler*
(global-port-print-handler) ~
 -> (->* (any/c output-port?) ((or/c 0 1)) any)
(global-port-print-handler proc) -> void?
  proc : (or/c (->* (any/c output-port?) ((or/c 0 1)) any) ~
               (any/c output-port? . -> . any))

A parameter that determines global port print handler, which is called
by the default port print handler (see port-print-handler) to print
values into a port. The default value uses the built-in printer (see
[missing]) in print mode.

A global port print handler optionally accepts a third argument, which
corresponds to the optional third argument to print. If a procedure
given to global-port-print-handler does not accept a third argument, it
is wrapped with a procedure that discards the optional third argument.

6. Pretty Printing

 (require racket/pretty) package: base ~

The bindings documented in this section are provided by the
racket/pretty and racket libraries, but not racket/base.

                                        *pretty-print*
(pretty-print v [port quote-depth]) -> void? ~
  v : any/c ~
  port : output-port? = (current-output-port) ~
  quote-depth : (or/c 0 1) = 0 ~

Pretty-prints the value v using the same printed form as the default
print mode, but with newlines and whitespace inserted to avoid lines
longer than (pretty-print-columns), as controlled by
(pretty-print-current-style-table). The printed form ends in a newline,
unless the pretty-print-columns parameter is set to 'infinity. When port
has line counting enabled (see Counting Positions, Lines, and Columns),
then printing is sensitive to the column when printing starts—both for
determining an initial line break and indenting subsequent lines.

In addition to the parameters defined in this section, pretty-print
conforms to the print-graph, print-struct, print-hash-table,
print-vector-length, print-box, and print-as-expression parameters.

The pretty printer detects structures that have the prop:custom-write
property and calls the corresponding custom-write procedure. The
custom-write procedure can check the parameter pretty-printing to
cooperate with the pretty-printer. Recursive printing to the port
automatically uses pretty printing, but if the structure has multiple
recursively printed sub-expressions, a custom-write procedure may need
to cooperate more to insert explicit newlines. Use port-next-location to
determine the current output column, use pretty-print-columns to
determine the target printing width, and use pretty-print-newline to
insert a newline (so that the function in the pretty-print-print-line
parameter can be called appropriately). Use
make-tentative-pretty-print-output-port to obtain a port for tentative
recursive prints (e.g., to check the length of the output).

                                        *pretty-write*
(pretty-write v [port]) -> void? ~
  v : any/c ~
  port : output-port? = (current-output-port) ~

Same as pretty-print, but v is printed like write instead of like print.

                                        *pretty-display*
(pretty-display v [port]) -> void? ~
  v : any/c ~
  port : output-port? = (current-output-port) ~

Same as pretty-print, but v is printed like display instead of like
print.

                                        *pretty-format*
(pretty-format v [columns]) -> string? ~
  v : any/c ~
  columns : exact-nonnegative-integer? = (pretty-print-columns) ~

Like pretty-print, except that it returns a string containing the
pretty-printed value, rather than sending the output to a port.

The optional argument columns argument is used to parameterize
pretty-print-columns.

                                        *pretty-print-handler*
(pretty-print-handler v) -> void? ~
  v : any/c ~

Pretty-prints v if v is not #<void>, or prints nothing if v is #<void>.
Pass this procedure to current-print to install the pretty printer into
the REPL run by read-eval-print-loop.

6.1. Basic Pretty-Print Options

                                        *pretty-print-columns*
(pretty-print-columns) ~
 -> (or/c exact-positive-integer? 'infinity)
(pretty-print-columns width) -> void?
  width : (or/c exact-positive-integer? 'infinity) ~

A parameter that determines the default width for pretty printing.

If the display width is 'infinity, then pretty-printed output is never
broken into lines, and a newline is not added to the end of the output.

                                        *pretty-print-depth*
(pretty-print-depth) -> (or/c exact-nonnegative-integer? #f) ~
(pretty-print-depth depth) -> void?
  depth : (or/c exact-nonnegative-integer? #f) ~

Parameter that controls the default depth for recursive pretty printing.
Printing to depth means that elements nested more deeply than depth are
replaced with “...”; in particular, a depth of 0 indicates that only
simple values are printed. A depth of #f (the default) allows printing
to arbitrary depths.

                                        *pretty-print-exact-as-decimal*
(pretty-print-exact-as-decimal) -> boolean? ~
(pretty-print-exact-as-decimal as-decimal?) -> void?
  as-decimal? : any/c ~

A parameter that determines how exact non-integers are printed.  If the
parameter’s value is #t, then an exact non-integer with a decimal
representation is printed as a decimal number instead of a fraction. The
initial value is #f.

                                        *pretty-print-.-symbol-without-bars*
(pretty-print-.-symbol-without-bars) -> boolean? ~
(pretty-print-.-symbol-without-bars on?) -> void?
  on? : any/c ~

A parameter that controls the printing of the symbol whose print name is
just a period. If set to a true value, then such a symbol is printed as
only the period.  If set to a false value, it is printed as a period
with vertical bars surrounding it.

                                        *pretty-print-show-inexactness*
(pretty-print-show-inexactness) -> boolean? ~
(pretty-print-show-inexactness show?) -> void?
  show? : any/c ~

A parameter that determines how inexact numbers are printed.  If the
parameter’s value is #t, then inexact numbers are always printed with a
leading #i. The initial value is #f.

6.2. Per-Symbol Special Printing

                                        *pretty-print-abbreviate-read-macros*
(pretty-print-abbreviate-read-macros) -> boolean? ~
(pretty-print-abbreviate-read-macros abbrev?) -> void?
  abbrev? : any/c ~

A parameter that controls whether or not quote, unquote,
unquote-splicing, etc., are abbreviated with ', ,, ,@, etc. By default,
the abbreviations are enabled.

See also pretty-print-remap-stylable.

                                        *pretty-print-style-table?*
(pretty-print-style-table? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a style table for use with
pretty-print-current-style-table, #f otherwise.

                                        *pretty-print-current-style-table*
(pretty-print-current-style-table) -> pretty-print-style-table? ~
(pretty-print-current-style-table style-table) -> void?
  style-table : pretty-print-style-table? ~

A parameter that holds a table of style mappings. See
pretty-print-extend-style-table.

                                        *pretty-print-extend-style-table*
(pretty-print-extend-style-table style-table        ~
                                 symbol-list       
                                 like-symbol-list) 
 -> pretty-print-style-table?
  style-table : pretty-print-style-table? ~
  symbol-list : (listof symbol?) ~
  like-symbol-list : (listof symbol?) ~

Creates a new style table by extending an existing style-table, so that
the style mapping for each symbol of like-symbol-list in the original
table is used for the corresponding symbol of symbol-list in the new
table. The symbol-list and like-symbol-list lists must have the same
length. The style-table argument can be #f, in which case the default
mappings are used from the original table (see below).

The style mapping for a symbol controls the way that whitespace is
inserted when printing a list that starts with the symbol. In the
absence of any mapping, when a list is broken across multiple lines,
each element of the list is printed on its own line, each with the same
indentation.

The default style mapping includes mappings for the following symbols,
so that the output follows popular code-formatting rules:

  'lambda 'case-lambda
  'define 'define-macro 'define-syntax
  'let 'letrec 'let*
  'let-syntax 'letrec-syntax
  'let-values 'letrec-values 'let*-values
  'let-syntaxes 'letrec-syntaxes
  'begin 'begin0 'do
  'if 'set! 'set!-values
  'unless 'when
  'cond 'case 'and 'or
  'module
  'syntax-rules 'syntax-case 'letrec-syntaxes+values
  'import 'export 'link
  'require 'require-for-syntax 'require-for-template 'provide
  'public 'private 'override 'rename 'inherit 'field 'init
  'shared 'send 'class 'instantiate 'make-object

                                        *pretty-print-remap-stylable*
(pretty-print-remap-stylable) ~
 -> (any/c . -> . (or/c symbol? #f))
(pretty-print-remap-stylable proc) -> void?
  proc : (any/c . -> . (or/c symbol? #f)) ~

A parameter that controls remapping for styles and for the determination
of the reader shorthands.

This procedure is called with each sub-expression that appears as the
first element in a sequence. If it returns a symbol, the style table is
used, as if that symbol were at the head of the sequence. If it returns
#f, the style table is treated normally. Similarly, when determining
whether to abbreviate reader macros, this parameter is consulted.

6.3. Line-Output Hook

                                        *pretty-print-newline*
(pretty-print-newline port width) -> void? ~
  port : output-port? ~
  width : exact-nonnegative-integer? ~

Calls the procedure associated with the pretty-print-print-line
parameter to print a newline to port, if port is the output port that is
redirected to the original output port for printing, otherwise a plain
newline is printed to port. The width argument should be the target
column width, typically obtained from pretty-print-columns.

                                        *pretty-print-print-line*
(pretty-print-print-line) ~
 -> ((or/c exact-nonnegative-integer? #f)
     output-port?
     exact-nonnegative-integer?
     (or/c exact-nonnegative-integer? 'infinity)
     . -> .
     exact-nonnegative-integer?)
(pretty-print-print-line proc) -> void?
  proc : ((or/c exact-nonnegative-integer? #f) ~
          output-port?
          exact-nonnegative-integer?
          (or/c exact-nonnegative-integer? 'infinity)
          . -> .
          exact-nonnegative-integer?)

A parameter that determines a procedure for printing the newline
separator between lines of a pretty-printed value. The procedure is
called with four arguments: a new line number, an output port, the old
line’s length, and the number of destination columns. The return value
from proc is the number of extra characters it printed at the beginning
of the new line.

The proc procedure is called before any characters are printed with 0 as
the line number and 0 as the old line length; proc is called after the
last character of a value has been printed with #f as the line number
and with the length of the last line. Whenever the pretty-printer starts
a new line, proc is called with the new line’s number (where the first
new line is numbered 1) and the just-finished line’s length. The
destination-columns argument to proc is always the total width of the
destination printing area, or 'infinity if pretty-printed values are not
broken into lines.

The default proc procedure prints a newline whenever the line number is
not 0 and the column count is not 'infinity, always returning 0. A
custom proc procedure can be used to print extra text before each line
of pretty-printed output; the number of characters printed before each
line should be returned by proc so that the next line break can be
chosen correctly.

The destination port supplied to proc is generally not the port supplied
to pretty-print or pretty-display (or the current output port), but
output to this port is ultimately redirected to the port supplied to
pretty-print or pretty-display.

6.4. Value Output Hook

                                        *pretty-print-size-hook*
(pretty-print-size-hook) ~
 -> (any/c boolean? output-port?
     . -> .
     (or/c #f exact-nonnegative-integer?))
(pretty-print-size-hook proc) -> void?
  proc : (any/c boolean? output-port? ~
          . -> .
          (or/c #f exact-nonnegative-integer?))

A parameter that determines a sizing hook for pretty-printing.

The sizing hook is applied to each value to be printed. If the hook
returns #f, then printing is handled internally by the pretty-printer.
Otherwise, the value should be an integer specifying the length of the
printed value in characters; the print hook will be called to actually
print the value (see pretty-print-print-hook).

The sizing hook receives three arguments. The first argument is the
value to print.  The second argument is a boolean: #t for printing like
display and #f for printing like write. The third argument is the
destination port; the port is the one supplied to pretty-print or
pretty-display (or the current output port).  The sizing hook may be
applied to a single value multiple times during pretty-printing.

                                        *pretty-print-print-hook*
(pretty-print-print-hook) ~
 -> (any/c boolean? output-port? . -> . void?)
(pretty-print-print-hook proc) -> void?
  proc : (any/c boolean? output-port? . -> . void?) ~

A parameter that determines a print hook for pretty-printing.  The
print-hook procedure is applied to a value for printing when the sizing
hook (see pretty-print-size-hook) returns an integer size for the value.

The print hook receives three arguments. The first argument is the value
to print.  The second argument is a boolean: #t for printing like
display and #f for printing like write. The third argument is the
destination port; this port is generally not the port supplied to
pretty-print or pretty-display (or the current output port), but output
to this port is ultimately redirected to the port supplied to
pretty-print or pretty-display.

                                        *pretty-print-pre-print-hook*
(pretty-print-pre-print-hook) ~
 -> (any/c output-port? . -> . void)
(pretty-print-pre-print-hook proc) -> void?
  proc : (any/c output-port? . -> . void) ~

A parameter that determines a hook procedure to be called just before an
object is printed. The hook receives two arguments: the object and the
output port. The port is the one supplied to pretty-print or
pretty-display (or the current output port).

                                        *pretty-print-post-print-hook*
(pretty-print-post-print-hook) ~
 -> (any/c output-port? . -> . void)
(pretty-print-post-print-hook proc) -> void?
  proc : (any/c output-port? . -> . void) ~

A parameter that determines a hook procedure to be called just after an
object is printed. The hook receives two arguments: the object and the
output port. The port is the one supplied to pretty-print or
pretty-display (or the current output port).

6.5. Additional Custom-Output Support

                                        *pretty-printing*
(pretty-printing) -> boolean? ~
(pretty-printing on?) -> void?
  on? : any/c ~

A parameter that is set to #t when the pretty printer calls a
custom-write procedure (see prop:custom-write) for output in a mode that
supports line breaks.  When pretty printer calls a custom-write
procedure merely to detect cycles or to try to print on a single line,
it sets this parameter to #f.

                                        *make-tentative-pretty-print-output-port*
(make-tentative-pretty-print-output-port out              ~
                                         width           
                                         overflow-thunk) 
 -> output-port?
  out : output-port? ~
  width : exact-nonnegative-integer? ~
  overflow-thunk : (-> any) ~

Produces an output port that is suitable for recursive pretty printing
without actually producing output. Use such a port to tentatively print
when proper output depends on the size of recursive prints. After
printing, determine the size of the tentative output using
file-position.

The out argument should be a pretty-printing port, such as the one
supplied to a custom-write procedure when pretty-printing is set to
true, or another tentative output port. The width argument should be a
target column width, usually obtained from pretty-print-columns,
possibly decremented to leave room for a terminator. The overflow-thunk
procedure is called if more than width items are printed to the port or
if a newline is printed to the port via pretty-print-newline; it can
escape from the recursive print through a continuation as a shortcut,
but overflow-thunk can also return, in which case it is called every
time afterward that additional output is written to the port.

After tentative printing, either accept the result with
tentative-pretty-print-port-transfer or reject it with
tentative-pretty-print-port-cancel. Failure to accept or cancel properly
interferes with graph-structure printing, calls to hook procedures, etc.
Explicitly cancel the tentative print even when overflow-thunk escapes
from a recursive print.

                                        *tentative-pretty-print-port-transfer*
(tentative-pretty-print-port-transfer tentative-out      ~
                                      orig-out)     -> void?
  tentative-out : output-port? ~
  orig-out : output-port? ~

Causes the data written to tentative-out to be transferred as if written
to orig-out. The tentative-out argument should be a port produced by
make-tentative-pretty-print-output-port, and orig-out should be either a
pretty-printing port (provided to a custom-write procedure) or another
tentative output port.

                                        *tentative-pretty-print-port-cancel*
(tentative-pretty-print-port-cancel tentative-out) -> void? ~
  tentative-out : output-port? ~

Cancels the content of tentative-out, which was produced by
make-tentative-pretty-print-output-port. The main effect of canceling is
that graph-reference definitions are undone, so that a future print of a
graph-referenced object includes the defining #>n<=.

7. Reader Extension

Racket’s reader can be extended in three ways: through a reader-macro
procedure in a readtable (see Readtables), through a #reader form (see
[missing]), or through a custom-port byte reader that returns a
“special” result procedure (see Custom Ports). All three kinds of reader
extension procedures accept similar arguments, and their results are
treated in the same way by read and read-syntax (or, more precisely, by
the default read handler; see port-read-handler).

    7.1 Readtables
    7.2 Reader-Extension Procedures
    7.3 Special Comments

7.1. Readtables

The dispatch table in [missing] corresponds to the default readtable. By
creating a new readtable and installing it via the current-readtable
parameter, the reader’s behavior can be extended.

A readtable is consulted at specific times by the reader:

* when looking for the start of a datum;

* when determining how to parse a datum that starts with #;

* when looking for a delimiter to terminate a symbol or number;

* when looking for an opener (such as (), closer (such as )), or . after
  the first character parsed as a sequence for a pair, list, vector, or
  hash table; or

* when looking for an opener after #>n< in a vector of specified length
  >n<.

The readtable is ignored at other times.  In particular, after parsing a
character that is mapped to the default behavior of ;, the readtable is
ignored until the comment’s terminating newline is discovered.
Similarly, the readtable does not affect string parsing until a closing
double-quote is found.  Meanwhile, if a character is mapped to the
default behavior of (, then it starts sequence that is closed by any
character that is mapped to a closing parenthesis ). An apparent
exception is that the default parsing of | quotes a symbol until a
matching character is found, but the parser is simply using the
character that started the quote; it does not consult the readtable.

For many contexts, #f identifies the default readtable. In particular,
#f is the initial value for the current-readtable parameter, which
causes the reader to behave as described in [missing].

                                        *readtable?*
(readtable? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a readtable, #f otherwise.

                                        *make-readtable*
(make-readtable readtable         ~
                key              
                mode             
                action ...+) -> readtable?
  readtable : readtable? ~
  key : (or/c char? #f) ~
  mode : (or/c (or/c 'terminating-macro ~
                     'non-terminating-macro
                     'dispatch-macro)
               char?)
  action : (or/c procedure? ~
                 readtable?)

Creates a new readtable that is like readtable (which can be #f), except
that the reader’s behavior is modified for each key according to the
given mode and action. The ...+ for make-readtable applies to all three
of key, mode, and action; in other words, the total number of arguments
to make-readtable must be 1 modulo 3.

The possible combinations for key, mode, and action are as follows:

* char 'terminating-macro proc — causes char to be parsed as a
  delimiter, and an unquoted/uncommented char in the input string
  triggers a call to the reader macro proc; the activity of proc is
  described further below.  Conceptually, characters like ;, (, and )
  are mapped to terminating reader macros in the default readtable.

* char 'non-terminating-macro proc — like the 'terminating-macro
  variant, but char is not treated as a delimiter, so it can be used in
  the middle of an identifier or number. Conceptually, # is mapped to a
  non-terminating macro in the default readtable.

* char 'dispatch-macro proc — like the 'non-terminating-macro variant,
  but for char only when it follows a # (or, more precisely, when the
  character follows one that has been mapped to the behavior of # in the
  default readtable).

* char like-char readtable — causes char to be parsed in the same way
  that like-char is parsed in readtable, where readtable can be #f to
  indicate the default readtable. Mapping a character to the same
  actions as | in the default reader means that the character starts
  quoting for symbols, and the same character terminates the quote; in
  contrast, mapping a character to the same action as a " means that the
  character starts a string, but the string is still terminated with a
  closing ". Finally, mapping a character to an action in the default
  readtable means that the character’s behavior is sensitive to
  parameters that affect the original character; for example, mapping a
  character to the same action as a curly brace { in the default
  readtable means that the character is disallowed when the
  read-curly-brace-as-paren parameter is set to #f.

* #f 'non-terminating-macro proc — replaces the macro used to parse
  characters with no specific mapping: i.e., the characters (other than
  # or |) that can start a symbol or number with the default readtable.

If multiple 'dispatch-macro mappings are provided for a single char, all
but the last one are ignored. Similarly, if multiple non-'dispatch-macro
mappings are provided for a single char, all but the last one are
ignored.

A reader macro proc must accept six arguments, and it can optionally
accept two arguments. The first two arguments are always the character
that triggered the reader macro and the input port for reading. When the
reader macro is triggered by read-syntax (or read-syntax/recursive), the
procedure is passed four additional arguments that represent a source
location for already-consumed character(s): the source name, a line
number or #f, a column number or #f, and a position or #f. When the
reader macro is triggered by read (or read/recursive), the procedure is
passed only two arguments if it accepts two arguments, otherwise it is
passed six arguments where the last four are all #f. See
Reader-Extension Procedures for information on the procedure’s results.

A reader macro normally reads characters from the given input port to
produce a value to be used as the “reader macro-expansion” of the
consumed characters. The reader macro might produce a special-comment
value (see Special Comments) to cause the consumed character to be
treated as whitespace, and it might use read/recursive or
read-syntax/recursive.

                                        *readtable-mapping*
(readtable-mapping readtable char) ~
 -> (or/c char?
          (or/c 'terminating-macro
                'non-terminating-macro))
    (or/c #f procedure?)
    (or/c #f procedure?)
  readtable : readtable? ~
  char : char? ~

Produces information about the mappings in readtable for char. The
result is three values:

* either a character (mapping to the same behavior as the character in
  the default readtable), 'terminating-macro, or 'non-terminating-macro;
  this result reports the main (i.e., non-'dispatch-macro) mapping for
  key. When the result is a character, then key is mapped to the same
  behavior as the returned character in the default readtable.

* either #f or a reader-macro procedure; the result is a procedure when
  the first result is 'terminating-macro or 'non-terminating-macro.

* either #f or a reader-macro procedure; the result is a procedure when
  the character has a 'dispatch-macro mapping in readtable to override
  the default dispatch behavior.

Note that reader-macro procedures for the default readtable are not
directly accessible. To invoke default behaviors, use read/recursive or
read-syntax/recursive with a character and the #f readtable.

Examples:
  ; Provides raise-read-error and raise-read-eof-error
  > (require syntax/readerr)

  > (define (skip-whitespace port)
      ; Skips whitespace characters, sensitive to the current
      ; readtable's definition of whitespace
      (let ([ch (peek-char port)])
        (unless (eof-object? ch)
          ; Consult current readtable: ~
          (let-values ([(like-ch/sym proc dispatch-proc)
                        (readtable-mapping (current-readtable) ch)])
            ; If like-ch/sym is whitespace, then ch is whitespace
            (when (and (char? like-ch/sym)
                       (char-whitespace? like-ch/sym))
              (read-char port)
              (skip-whitespace port))))))

  > (define (skip-comments read-one port src)
      ; Recursive read, but skip comments and detect EOF
      (let loop ()
        (let ([v (read-one)])
          (cond
           [(special-comment? v) (loop)]
           [(eof-object? v)
            (let-values ([(l c p) (port-next-location port)])
              (raise-read-eof-error
               "unexpected EOF in tuple" src l c p 1))]
           [else v]))))

  > (define (parse port read-one src)
      ; First, check for empty tuple
      (skip-whitespace port)
      (if (eq? #\> (peek-char port))
          null
          (let ([elem (read-one)])
            (if (special-comment? elem)
                ; Found a comment, so look for > again
                (parse port read-one src)
                ; Non-empty tuple: ~
                (cons elem
                      (parse-nonempty port read-one src))))))

  > (define (parse-nonempty port read-one src)
      ; Need a comma or closer
      (skip-whitespace port)
      (case (peek-char port)
        [(#\>) (read-char port)
         ; Done
         null]
        [(#\,) (read-char port)
         ; Read next element and recur
         (cons (skip-comments read-one port src)
               (parse-nonempty port read-one src))]
        [else
         ; Either a comment or an error; grab location (in case
         ; of error) and read recursively to detect comments
         (let-values ([(l c p) (port-next-location port)]
                      [(v) (read-one)])
           (cond
            [(special-comment? v)
             ; It was a comment, so try again
             (parse-nonempty port read-one src)]
            [else
             ; Wasn't a comment, comma, or closer; error
             ((if (eof-object? v)
                  raise-read-eof-error
                  raise-read-error)
              "expected `,' or `>'" src l c p 1)]))]))

  > (define (make-delims-table)
      ; Table to use for recursive reads to disallow delimiters
      ;  (except those in sub-expressions)
      (letrec ([misplaced-delimiter
                (case-lambda
                 [(ch port) (misplaced-delimiter ch port #f #f #f #f)]
                 [(ch port src line col pos)
                  (raise-read-error
                   (format "misplaced `~a' in tuple" ch)
                   src line col pos 1)])])
        (make-readtable (current-readtable)
                        #\, 'terminating-macro misplaced-delimiter
                        #\> 'terminating-macro misplaced-delimiter)))

  > (define (wrap l)
      `(make-tuple (list ,@l)))

  > (define parse-open-tuple
      (case-lambda
       [(ch port)
        ; ‘read' mode
        (wrap (parse port
                     (lambda ()
                       (read/recursive port #f
                                       (make-delims-table)))
                     (object-name port)))]
       [(ch port src line col pos)
        ; ‘read-syntax' mode
        (datum->syntax
         #f
         (wrap (parse port
                      (lambda ()
                        (read-syntax/recursive src port #f
                                               (make-delims-table)))
                      src))
         (let-values ([(l c p) (port-next-location port)])
           (list src line col pos (and pos (- p pos)))))]))

  > (define tuple-readtable
      (make-readtable #f #\< 'terminating-macro parse-open-tuple))

  > (parameterize ([current-readtable tuple-readtable])
      (read (open-input-string "<1 , 2 , \"a\">")))
  '(make-tuple (list 1 2 "a"))
  > (parameterize ([current-readtable tuple-readtable])
      (read (open-input-string
             "< #||# 1 #||# , #||# 2 #||# , #||# \"a\" #||# >")))
  '(make-tuple (list 1 2 "a"))
  > (define tuple-readtable+
      (make-readtable tuple-readtable
                      #\* 'terminating-macro (lambda a
                                               (make-special-comment #f))
                      #\_ #\space #f))

  > (parameterize ([current-readtable tuple-readtable+])
      (read (open-input-string "< * 1 __,__  2 __,__ * \"a\" * >")))
  '(make-tuple (list 1 2 "a"))

7.2. Reader-Extension Procedures

Calls to reader extension procedures can be triggered through read,
read/recursive, or read-syntax. In addition, a special-read procedure
can be triggered by calls to read-char-or-special, or by the context of
read-bytes-avail!, peek-bytes-avail!*, read-bytes-avail!, and
peek-bytes-avail!*.

Optional arities for reader-macro and special-result procedures allow
them to distinguish reads via read, etc., from reads via read-syntax,
etc. (where the source value is #f and no other location information is
available).

When a reader-extension procedure is called in syntax-reading mode (via
read-syntax, etc.), it should generally return a syntax object that has
no lexical context (e.g., a syntax object created using datum->syntax
with #f as the first argument and with the given location information as
the third argument). Another possible result is a special-comment value
(see Special Comments). If the procedure’s result is not a syntax object
and not a special-comment value, it is converted to one using
datum->syntax.

When a reader-extension procedure is called in non-syntax-reading modes,
it should generally not return a syntax object. If a syntax object is
returned, it is converted to a plain value using syntax->datum.

In either context, when the result from a reader-extension procedure is
a special-comment value (see Special Comments), then read, read-syntax,
etc. treat the value as a delimiting comment and otherwise ignore it.

Also, in either context, the result may be copied to prevent mutation to
vectors or boxes before the read result is completed, and to support the
construction of graphs with cycles. Mutable boxes, vectors, and prefab
structures are copied, along with any pairs, boxes, vectors, prefab
structures that lead to such mutable values, to placeholders produced by
a recursive read (see read/recursive), or to references of a shared
value. Graph structure (including cycles) is preserved in the copy.

7.3. Special Comments

                                        *make-special-comment*
(make-special-comment v) -> special-comment? ~
  v : any/c ~

Creates a special-comment value that encapsulates v. The read,
read-syntax, etc., procedures treat values constructed with
make-special-comment as delimiting whitespace when returned by a
reader-extension procedure (see Reader-Extension Procedures).

                                        *special-comment?*
(special-comment? v) -> boolean? ~
  v : any/c ~

Returns #t if v is the result of make-special-comment, #f otherwise.

                                        *special-comment-value*
(special-comment-value sc) -> any ~
  sc : special-comment? ~

Returns the value encapsulated by the special-comment value sc. This
value is never used directly by a reader, but it might be used by the
context of a read-char-or-special, etc., call that detects a special
comment.

8. Printer Extension

gen:custom-write : any/c ~

A generic interface (see [missing]) that supplies a method, write-proc
used by the default printer to display, write, or print instances of the
structure type.

A write-proc method takes three arguments: the structure to be printed,
the target port, and an argument that is #t for write mode, #f for
display mode, or 0 or 1 indicating the current quoting depth for print
mode.  The procedure should print the value to the given port using
write, display, print, fprintf, write-special, etc.

The port write handler, port display handler, and print handler are
specially configured for a port given to a custom-write procedure.
Printing to the port through display, write, or print prints a value
recursively with sharing annotations. To avoid a recursive print (i.e.,
to print without regard to sharing with a value currently being
printed), print instead to a string or pipe and transfer the result to
the target port using write-string or write-special. To print
recursively to a port other than the one given to the custom-write
procedure, copy the given port’s write handler, display handler, and
print handler to the other port.

The port given to a custom-write handler is not necessarily the actual
target port. In particular, to detect cycles and sharing, the printer
invokes a custom-write procedure with a port that records recursive
prints, and does not retain any other output.

Recursive print operations may trigger an escape from the call to the
custom-write procedure (e.g., for pretty-printing where a tentative
print attempt overflows the line, or for printing error output of a
limited width).

The following example definition of a tuple type includes custom-write
procedures that print the tuple’s list content using angle brackets in
write and print mode and no brackets in display mode. Elements of the
tuple are printed recursively, so that graph and cycle structure can be
represented.

Examples:
  (define (tuple-print tuple port mode)
    (when mode (write-string "<" port))
    (let ([l (tuple-ref tuple)]
          [recur (case mode
                   [(#t) write]
                   [(#f) display]
                   [else (lambda (p port) (print p port mode))])])
      (unless (zero? (vector-length l))
        (recur (vector-ref l 0) port)
        (for-each (lambda (e)
                    (write-string ", " port)
                    (recur e port))
                  (cdr (vector->list l)))))
    (when mode (write-string ">" port)))


  > (struct tuple (ref)
            #:methods gen:custom-write ~
            [(define write-proc tuple-print)])

  > (display (tuple #(1 2 "a")))
  1, 2, a

  > (print (tuple #(1 2 "a")))
  <1, 2, "a">

  > (let ([t (tuple (vector 1 2 "a"))])
      (vector-set! (tuple-ref t) 0 t)
      (write t))
  #0=<#0#, 2, "a">


prop:custom-write : struct-type-property? ~

A deprecated structure type property (see [missing]) that supplies a
procedure that corresponds to gen:custom-write’s write-proc. Use
gen:custom-write, instead.

                                        *custom-write?*
(custom-write? v) -> boolean? ~
  v : any/c ~

Returns #t if v has the prop:custom-write property, #f otherwise.

                                        *custom-write-accessor*
(custom-write-accessor v) ~
 -> (custom-write? output-port? boolean? . -> . any)
  v : custom-write? ~

Returns the custom-write procedure associated with v.

prop:custom-print-quotable : struct-type-property? ~
custom-print-quotable? : struct-type-property? ~
custom-print-quotable-accessor : struct-type-property? ~

A property and associated predicate and accessor. The property value is
one of 'self, 'never, 'maybe, or 'always. When a structure has this
property in addition to a prop:custom-write property value, then the
property value affects printing in print mode; see [missing]. When a
value does not have the prop:custom-print-quotable, it is equivalent to
having the 'self property value, which is suitable both for self-quoting
forms and printed forms that are unreadable.

9. Serialization

 (require racket/serialize) package: base ~

The bindings documented in this section are provided by the
racket/serialize library, not racket/base or racket.

                                        *serializable?*
(serializable? v) -> boolean? ~
  v : any/c ~

Returns #t if v appears to be serializable, without checking the content
of compound values, and #f otherwise. See serialize for an enumeration
of serializable values.

                                        *serialize*
(serialize v) -> any ~
  v : serializable? ~

Returns a value that encapsulates the value v. This value includes only
readable values, so it can be written to a stream with write or
s-exp->fasl, later read from a stream using read or fasl->s-exp, and
then converted to a value like the original using deserialize.
Serialization followed by deserialization produces a value with the same
graph structure and mutability as the original value, but the serialized
value is a plain tree (i.e., no sharing).

The following kinds of values are serializable:

* structures created through serializable-struct or
  serializable-struct/versions, or more generally structures with the
  prop:serializable property (see prop:serializable for more
  information);

* prefab structures;

* instances of classes defined with define-serializable-class or
  define-serializable-class*;

* booleans, numbers, characters, interned symbols, unreadable symbols,
  strings, byte strings, paths (for a specific convention), #<void>, and
  the empty list;

* pairs, mutable pairs, vectors, flvectors, fxvectors, boxes, hash
  tables, and sets;

* date, date*, arity-at-least and srcloc structures; and

* module path index values.

Serialization succeeds for a compound value, such as a pair, only if all
content of the value is serializable.  If a value given to serialize is
not completely serializable, the exn:fail:contract exception is raised.

If v contains a cycle (i.e., a collection of objects that are all
reachable from each other), then v can be serialized only if the cycle
includes a mutable value, where a prefab structure counts as mutable
only if all of its fields are mutable.

The serialize and deserialize functions currently do not handle certain
cyclic values that read and write can handle, such as '#0=(#0#).

See deserialize for information on the format of serialized data.

                                        *deserialize*
(deserialize v) -> any ~
  v : any/c ~

Given a value v that was produced by serialize, produces a value like
the one given to serialize, including the same graph structure and
mutability.

A serialized representation v is a list of six or seven elements:

* An optional list '(1), '(2), or '(3) that represents the version of
  the serialization format. If the first element of a representation is
  not a list, then the version is 0. Version 1 adds support for mutable
  pairs, version 2 adds support for unreadable symbols, and version 3
  adds support for date* structures.

* A non-negative exact integer s-count that represents the number of
  distinct structure types represented in the serialized data.

* A list s-types of length s-count, where each element represents a
  structure type. Each structure type is encoded as a pair. The car of
  the pair is #f for a structure whose deserialization information is
  defined at the top level, otherwise it is a quoted module path or a
  byte string (to be converted into a platform-specific path using
  bytes->path) for a module that exports the structure’s deserialization
  information.  The cdr of the pair is the name of a binding (at the top
  level or exported from a module) for deserialization information,
  either a symbol or a string representing an unreadable symbol. These
  two are used with either namespace-variable-binding or dynamic-require
  to obtain deserialization information. See make-deserialize-info for
  more information on the binding’s value. See also
  deserialize-module-guard.

* A non-negative exact integer, g-count that represents the number of
  graph points contained in the following list.

* A list graph of length g-count, where each element  represents a
  serialized value to be referenced during the  construction of other
  serialized values. Each list element is  either a box or not:

  * A box represents a value that is part of a cycle, and for
    deserialization, it must be allocated with #f for each of its
    fields. The content of the box indicates the shape of the value:

    * a non-negative exact integer i for an instance of a structure type
      that is represented by the ith element of the s-types list;

    * 'c for a pair, which fails on deserialization (since pairs are
      immutable; this case does not appear in output generated by
      serialize);

    * 'm for a mutable pair;

    * 'b for a box;

    * a pair whose car is 'v and whose cdr is a non-negative exact
      integer s for a vector of length s;

    * a list whose first element is 'h and whose remaining elements are
      symbols that determine the hash-table type:

      * 'equal — (make-hash)

      * 'equal 'weak — (make-weak-hash)

      * 'weak — (make-weak-hasheq)

      * no symbols — (make-hasheq)

    * 'date* for a date* structure, which fails on deserialization
      (since dates are immutable; this case does not appear in output
      generated by serialize);

    * 'date for a date structure, which fails on deserialization (since
      dates are immutable; this case does not appear in output generated
      by serialize);

    * 'arity-at-least for an arity-at-least structure, which fails on
      deserialization (since arity-at-least are immutable; this case
      does not appear in output generated by serialize); or

    * 'mpi for a module path index, which fails on deserialization
      (since a module path index is immutable; this case does not appear
      in output generated by serialize).

    * 'srcloc for a srcloc structure, which fails on deserialization
      (since srclocs are immutable; this case does not appear in output
      generated by serialize).

    The #f-filled value will be updated with content specified by the
    fifth element of the serialization list v.

  * A non-box represents a serial value to be  constructed immediately,
    and it is one of the following:

    * a boolean, number, character, interned symbol, or empty list,
      representing itself.

    * a string, representing an immutable string.

    * a byte string, representing an immutable byte string.

    * a pair whose car is '? and whose cdr is a non-negative exact
      integer i; it represents the value constructed for the ith element
      of graph, where i is less than the position of this element within
      graph.

    * a pair whose car is a number i; it represents an instance of a
      structure type that is described by the ith element of the s-types
      list. The cdr of the pair is a list of serials representing
      arguments to be provided to the structure type’s deserializer.

    * a pair whose car is 'q and whose cdr is an immutable value; it
      represents the quoted value.

    * a pair whose car is 'f; it represents an instance of a prefab
      structure type. The cadr of the pair is a prefab structure type
      key, and the cddr is a list of serials representing the field
      values.

    * a pair whose car is 'void, representing #<void>.

    * a pair whose car is 'su and whose cdr is a character string; it
      represents an unreadable symbol.

    * a pair whose car is 'u and whose cdr is either a byte string or
      character string; it represents a mutable byte or character
      string.

    * a pair whose car is 'p and whose cdr is a byte string; it
      represents a path using the serializer’s path convention
      (deprecated in favor of 'p+).

    * a pair whose car is 'p+, whose cadr is a byte string, and whose
      cddr is one of the possible symbol results of
      system-path-convention-type; it represents a path using the
      specified convention.

    * a pair whose car is 'c and whose cdr is a pair of serials; it
      represents an immutable pair.

    * a pair whose car is 'c! and whose cdr is a pair of serials; it
      represents a pair (but formerly represented a mutable pair), and
      does not appear in output generated by serialize.

    * a pair whose car is 'm and whose cdr is a pair of serials; it
      represents a mutable pair.

    * a pair whose car is 'v and whose cdr is a list of serials; it
      represents an immutable vector.

    * a pair whose car is 'v! and whose cdr is a list of serials; it
      represents a mutable vector.

    * a pair whose car is 'vl and whose cdr is a list of serials; it
      represents a flvector.

    * a pair whose car is 'vx and whose cdr is a list of serials; it
      represents a fxvector.

    * a pair whose car is 'b and whose cdr is a serial; it represents an
      immutable box.

    * a pair whose car is 'b! and whose cdr is a serial; it represents a
      mutable box.

    * a pair whose car is 'h, whose cadr is either '! or '- (mutable or
      immutable, respectively), whose caddr is a list of symbols
      (containing 'equal, 'weak, both, or neither) that determines the
      hash table type, and whose cdddr is a list of pairs, where the car
      of each pair is a serial for a hash-table key and the cdr is a
      serial for the corresponding value.

    * a pair whose car is 'date* and whose cdr is a list of serials; it
      represents a date* structure.

    * a pair whose car is 'date and whose cdr is a list of serials; it
      represents a date structure.

    * a pair whose car is 'arity-at-least and whose cdr is a serial; it
      represents an arity-at-least structure.

    * a pair whose car is 'mpi and whose cdr is a pair; it represents a
      module path index that joins the paired values.

    * a pair whose car is 'srcloc and whose cdr is a list of serials; it
      represents a srcloc structure.

* A list of pairs, where the car of each pair is a non-negative exact
  integer i and the cdr is a serial (as defined in the previous bullet).
  Each element represents an update to an ith element of graph that was
  specified as a box, and the serial describes how to construct a new
  value with the same shape as specified by the box. The content of this
  new value must be transferred into the value created for the box in
  graph.

* A final serial (as defined in the two bullets back) representing the
  result of deserialize.

The result of deserialize shares no mutable values with the argument to
deserialize.

If a value provided to serialize is a simple tree (i.e., no sharing),
then the fourth and fifth elements in the serialized representation will
be empty.

                                        *serialized*
(serialized=? v1 v2) -> boolean? ~
  v1 : any/c ~
  v2 : any/c ~

Returns #t if v1 and v2 represent the same serialization information.

More precisely, it returns the same value that (equal? (deserialize v1)
(deserialize v2)) would return if

* all structure types whose deserializers are accessed with distinct
  module paths are actually distinct types;

* all structure types are transparent; and

* all structure instances contain only the constituent values recorded
  in each of v1 and v2.

                                        *deserialize-module-guard*
(deserialize-module-guard) ~
 -> (module-path? symbol? . -> . void?)
(deserialize-module-guard guard) -> void?
  guard : (module-path? symbol? . -> . void?) ~

A parameter whose value is called by deserialize before dynamically
loading a module via dynamic-require. The two arguments provided to the
procedure are the same as the arguments to be passed to dynamic-require.
The procedure can raise an exception to disallow the dynamic-require.

                                        *serializable-struct*
(serializable-struct id maybe-super (field ...) ~
                     struct-option ...)

Like struct, but instances of the structure type are serializable with
serialize.  This form is allowed only at the top level or in a module’s
top level (so that deserialization information can be found later).

Serialization only supports cycles involving the created structure type
when all fields are mutable (or when the cycle can be broken through
some other mutable value).

In addition to the bindings generated by struct, serializable-struct
binds deserialize-info:id-v0 to deserialization information.
Furthermore, in a module context, it automatically provides this binding
in a deserialize-info submodule using module+.

The serializable-struct form enables the construction of structure
instances from places where id is not accessible, since deserialization
must construct instances. Furthermore, serializable-struct provides
limited access to field mutation, but only for instances generated
through the deserialization information bound to deserialize-info:id-v0.
See make-deserialize-info for more information.

The -v0 suffix on the deserialization enables future versioning on the
structure type through serializable-struct/version.

When a supertype is supplied as maybe-super, compile-time information
bound to the supertype identifier must include all of the supertype’s
field accessors. If any field mutator is missing, the structure type
will be treated as immutable for the purposes of marshaling (so cycles
involving only instances of the structure type cannot be handled by the
deserializer).

Examples:
  > (serializable-struct point (x y))

  > (point-x (deserialize (serialize (point 1 2))))
  1

                                        *define-serializable-struct*
(define-serializable-struct id-maybe-super (field ...) ~
                             struct-option ...)

Like serializable-struct, but with the supertype syntax and default
constructor name of define-struct.

                                        *serializable-struct/versions*
(serializable-struct/versions id maybe-super vers (field ...) ~
                              (other-version-clause ...)
                              struct-option ...)
 
other-version-clause = (other-vers make-proc-expr
                                   cycle-make-proc-expr)

Like serializable-struct, but the generated deserializer binding is
deserialize-info:id-vvers. In addition, deserialize-info:id-vother-vers
is bound for each other-vers. The vers and each other-vers must be a
literal, exact, nonnegative integer.

Each make-proc-expr should produce a procedure, and the procedure should
accept as many argument as fields in the corresponding version of the
structure type, and it produce an instance of id. Each
cycle-make-proc-expr should produce a procedure of no arguments; this
procedure should return two values: an instance x of id (typically with
#f for all fields) and a procedure that accepts another instance of id
and copies its field values into x.

Examples:
  > (serializable-struct point (x y) #:mutable #:transparent) ~

  > (define ps (serialize (point 1 2)))

  > (deserialize ps)
  (point 1 2)
  > (define x (point 1 10))

  > (set-point-x! x x)

  > (define xs (serialize x))

  > (deserialize xs)
  #0=(point #0# 10)
  > (serializable-struct/versions point 1 (x y z)
       ([0
         ; Constructor for simple v0 instances: ~
         (lambda (x y) (point x y 0))
         ; Constructor for v0 instance in a cycle: ~
         (lambda ()
           (let ([p0 (point #f #f 0)])
             (values
               p0
               (lambda (p)
                 (set-point-x! p0 (point-x p))
                 (set-point-y! p0 (point-y p))))))])
       #:mutable #:transparent) ~

  > (deserialize (serialize (point 4 5 6)))
  (point 4 5 6)
  > (deserialize ps)
  (point 1 2 0)
  > (deserialize xs)
  #0=(point #0# 10 0)

                                        *define-serializable-struct/versions*
(define-serializable-struct/versions id-maybe-super vers (field ...) ~
                                     (other-version-clause ...)
                                     struct-option ...)

Like serializable-struct/versions, but with the supertype syntax and
default constructor name of define-struct.

                                        *make-deserialize-info*
(make-deserialize-info make cycle-make) -> any ~
  make : procedure? ~
  cycle-make : (-> (values any/c procedure?)) ~

Produces a deserialization information record to be used by deserialize.
This information is normally tied to a particular structure because the
structure has a prop:serializable property value that points to a
top-level variable or module-exported variable that is bound to
deserialization information.

The make procedure should accept as many arguments as the structure’s
serializer put into a vector; normally, this is the number of fields in
the structure. It should return an instance of the structure.

The cycle-make procedure should accept no arguments, and it should
return two values: a structure instance x (with dummy field values) and
an update procedure. The update procedure takes another structure
instance generated by the make, and it transfers the field values of
this instance into x.

prop:serializable : property? ~

This property identifies structures and structure types that are
serializable. The property value should be constructed with
make-serialize-info.

                                        *make-serialize-info*
(make-serialize-info to-vector           ~
                     deserialize-id     
                     can-cycle?         
                     dir)           -> any
  to-vector : (any/c . -> . vector?) ~
  deserialize-id : (or identifier? ~
                       symbol?
                       (cons/c symbol?
                               module-path-index?))
  can-cycle? : any/c ~
  dir : path-string? ~

Produces a value to be associated with a structure type through the
prop:serializable property. This value is used by serialize.

The to-vector procedure should accept a structure instance and produce a
vector for the instance’s content.

The deserialize-id value indicates a binding for deserialize
information, to either a module export or a top-level definition. It
must be one of the following:

* If deserialize-id is an identifier, and if (identifier-binding
  deserialize-id) produces a list, then the third element is used for
  the exporting module, otherwise the top-level is assumed. Before
  trying an exporting module directly, its deserialize-info submodule is
  tried; the module itself is tried if no deserialize-info submodule is
  available or if the export is not found. In either case, syntax-e is
  used to obtain the name of an exported identifier or top-level
  definition.

* If deserialize-id is a symbol, it indicates a top-level variable that
  is named by the symbol.

* If deserialize-id is a pair, the car must be a symbol to name an
  exported identifier, and the cdr must be a module path index to
  specify the exporting module.

See make-deserialize-info and deserialize for more information.

The can-cycle? argument should be false if instances should not be
serialized in such a way that deserialization requires creating a
structure instance with dummy field values and then updating the
instance later.

The dir argument should be a directory path that is used to resolve a
module reference for the binding of deserialize-id. This directory path
is used as a last resort when deserialize-id indicates a module that was
loaded through a relative path with respect to the top level. Usually,
it should be (or (current-load-relative-directory) (current-directory)).

10. Fast-Load Serialization

 (require racket/fasl) package: base ~

The bindings documented in this section are provided by the racket/fasl
library, not racket/base or racket.

                                        *s-exp->fasl*
(s-exp->fasl v [out]) -> (or/c (void) bytes?) ~
  v : any/c ~
  out : (or/c output-port? #f) = #f ~
(fasl->s-exp in) -> any/c
  in : (or/c input-port? bytes?) ~

The s-exp->fasl function serializes v to a byte string, printing it
directly to out if out is an output port or return the byte string
otherwise. The fasl->s-exp function decodes a value from a byte string
(supplied either directly or as an input port) that was encoded with
s-exp->fasl.

The v argument must be a value that could be quoted as a literal,
because s-exp->fasl essentially uses (compile `',v) to encode the value
using Racket’s built-in fast-load format for bytecode.

The byte-string encoding produced by s-exp->fasl is specific to a
version of Racket. That is, the resulting byte string can be decoded
back to v only using the same version with which it was encoded.

Examples:
  > (define fasl (s-exp->fasl (list #("speed") 'racer #\!)))

  > fasl
  #"#~\0056.1.1T\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\0\36\0\0\0\220$\24r\220$\20\0\20\0\25_\20\1\6\5\5speedAracer\a!"
  > (fasl->s-exp fasl)
  '(#("speed") racer #\!)
