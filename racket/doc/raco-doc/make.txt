raco make: Compiling Source to Bytecode

The raco make command accept filenames for Racket modules to be compiled
to bytecode format. Modules are re-compiled only if the source Racket
file is newer than the bytecode file and has a different SHA-1 hash, or
if any imported module is recompiled or has a different SHA-1 hash for
its compiled form plus dependencies.

    1 Running raco make

    2 Bytecode Files

    3 Dependency Files

    4 API for Making Bytecode

    5 API for Parallel Builds

    6 Compilation Manager Hook for Syntax Transformers

    7 API for Simple Bytecode Creation

    8 API for Bytecode Paths

    9 Compiling to Raw Bytecode

    10 API for Raw Compilation
      10.1 Bytecode Compilation
      10.2 Recognizing Module Suffixes
      10.3 Loading Compiler Support
      10.4 Options for the Compiler
      10.5 The Compiler as a Unit
        10.5.1 Signatures
        10.5.2 Main Compiler Unit
        10.5.3 Options Unit

    11 API for Reading Compilation Dependencies

1. Running raco make

The raco make command accepts a few flags:

* -j >n< — Compiles argument modules in parallel, using up to >n<
  parallel tasks.

* --disable-inline — Disables function inlining while compiling (but
  does not re-compile files that are already up-to-date). This flag is
  often useful to simplify generated code before decompiling, and it
  corresponds to setting compile-context-preservation-enabled to #t.

* --disable-constant — Disables inference of definitions within a module
  as constant (but does not re-compile files that are already
  up-to-date). The value associated with a non-constant definition is
  never inlined or constant-propagated, either within its own module or
  an importing module. This flag corresponds to setting
  compile-enforce-module-constants to #f.

* --no-deps — Compiles a non-module file (i.e., one that is run via load
  instead of require). See Compiling to Raw Bytecode for more
  information.

* -p >file< or --prefix >file< — For use with --no-deps; see Compiling
  to Raw Bytecode.

* -no-prim — For use with --no-deps; see Compiling to Raw Bytecode.

* -v — Verbose mode, which shows which files are compiled.

* --vv — Very verbose mode, which implies -v and also shows every
  dependency that is checked.

2. Bytecode Files

A file ">name<.>ext<" is compiled to bytecode that is saved as
"compiled/>name<_>ext<.zo" relative to the file. As a result, the
bytecode file is normally used automatically when ">name<.>ext<" is
required as a module, since the underlying load/use-compiled operation
detects such a bytecode file.

For example, in a directory that contains the following files:

* "a.rkt":

    #lang racket
    (require "b.rkt" "c.rkt")
    (+ b c)

* "b.rkt":

    #lang racket
    (provide b)
    (define b 1)

* "c.rkt":

    #lang racket
    (provide c)
    (define c 1)

then

  raco make a.rkt

triggers the creation of "compiled/a_rkt.zo", "compiled/b_rkt.zo", and
"compiled/c_rkt.zo". A subsequent

  racket a.rkt

loads bytecode from the generated ".zo" files, paying attention to the
".rkt" sources only to confirm that each ".zo" file has a later
timestamp (unless the PLT_COMPILED_FILE_CHECK environment variable is
set to exists, in which case the compiled file is used without a
timestamp check).

In contrast,

  raco make b.rkt c.rkt

would create only "compiled/b_rkt.zo" and "compiled/c_rkt.zo", since
neither "b.rkt" nor "c.rkt" imports "a.rkt".

3. Dependency Files

In addition to a bytecode file, raco make creates a file
"compiled/>name<_>ext<.dep" that records dependencies of the compiled
module on other module files and the source file’s SHA-1 hash.  Using
this dependency information, a re-compilation request via raco make can
consult both the source file’s timestamp/hash and the timestamps/hashes
for the bytecode of imported modules.  Furthermore, imported modules are
themselves compiled as necessary, including updating the bytecode and
dependency files for the imported modules, transitively.

Continuing the raco make a.rkt example from the previous section, the
raco make command creates "compiled/a_rkt.dep", "compiled/b_rkt.dep",
and "compiled/c_rkt.dep" at the same time as the ".zo" files. The
"compiled/a_rkt.dep" file records the dependency of "a.rkt" on "b.rkt",
"c.rkt" and the racket library. If the "b.rkt" file is modified (so that
its SHA-1 hash changes), then running

  raco make a.rkt

again rebuilds "compiled/a_rkt.zo" and "compiled/b_rkt.zo".

For module files that are within library collections, raco setup uses
the same ".zo" and ".dep" conventions and files as raco make, so the two
tools can be used together.

As long as the PLT_COMPILED_FILE_CHECK environment variable is not set
or is set to modify, then raco make updates the timestamp on a compiled
bytecode file if it is older than the source, even if the file does not
need to be recompiled.

4. API for Making Bytecode

 (require compiler/cm) package: base ~

The compiler/cm module implements the compilation and dependency
management used by raco make and raco setup.

                                        *make-compilation-manager-load/use-compiled-handler*
(make-compilation-manager-load/use-compiled-handler                                            ~
                                                    [delete-zos-when-rkt-file-does-not-exist? 
                                                     #:security-guard security-guard])         ~
 -> (path? (or/c symbol? false/c) . -> . any)
  delete-zos-when-rkt-file-does-not-exist? : any/c = #f ~
  security-guard : (or/c security-guard? #f) = #f ~

Returns a procedure suitable as a value for the
current-load/use-compiled parameter. The returned procedure passes its
arguments on to the current-load/use-compiled procedure that is
installed when make-compilation-manager-load/use-compiled-handler is
called, but first it automatically compiles a source file to a ".zo"
file if

* the file is expected to contain a module (i.e., the second argument to
  the handler is a symbol);

* the value of each of (current-eval), (current-load), and
  (namespace-module-registry (current-namespace)) is the same as when
  make-compilation-manager-load/use-compiled-handler was called;

* the value of use-compiled-file-paths contains the first path that was
  present when make-compilation-manager-load/use-compiled-handler was
  called;

* the value of current-load/use-compiled is the result of this
  procedure; and

* one of the following holds:

  * the source file is newer than the ".zo" file in the first
    sub-directory listed in use-compiled-file-paths (at the time that
    make-compilation-manager-load/use-compiled-handler was called), and
    either no ".dep" file exists or it records a source-file SHA-1 hash
    that differs from the current version and source-file SHA-1 hash;

  * no ".dep" file exists next to the ".zo" file;

  * the version recorded in the ".dep" file does not match the result of
    (version);

  * the target machine recorded in the ".dep" file does not match the
    result of (current-compile-target-machine);

  * the source hash recorded in the ".dep" file does not match the
    current source hash;

  * one of the files listed in the ".dep" file has a ".zo" timestamp
    newer than the target ".zo" and use-compiled-file-check is set to
    'modify-seconds;

  * the combined hashes of the dependencies recorded in the ".dep" file
    does not match the combined hash recorded in the ".dep" file.

If SHA-1 hashes override a timestamp-based decision to recompile the
file, then the target ".zo" file’s timestamp is updated to the current
time, unless the use-compiled-file-check parameter is not set to
'modify-seconds.

After the handler procedure compiles a ".zo" file, it creates a
corresponding ".dep" file that lists the current version and the
identification of every file that is directly required by the module in
the compiled file. Additional dependencies can be installed during
compilation via compiler/cm-accomplice. The ".dep" file also records the
SHA-1 hash of the module’s source, and it records a combined SHA-1 hash
of all of the dependencies that includes their recursive dependencies.
If a bytecode file is generated by recompiling a bytecode file that was
formerly compiled as machine-independent, then the ".dep" file also
records the SHA-1 hash of the machine-independent form, since the
recompiled module’s behavior should be exactly the same.

The special combination of (cross-installation?) as #t,
(current-compile-target-machine) as #f, and
(current-compiled-file-roots) having two or more elements triggers a
special compilation mode. Bytecode specific to the running Racket is
written to the directory determined by the first element of
(current-compiled-file-roots). Bytecode specific to the
cross-compilation target is written to the directory determined by the
first element of (current-compiled-file-roots). By configuring
(current-compiled-file-roots) so that the first element is outside a
build tree and the second element is inside the build tree,
cross-compilation can create a build tree suitable for the target
machine while building and loading bytecode (for macro expansion, etc.)
that is usable on the current machine. This mode works correctly for a
build directory that starts with only source code and
machine-independent bytecode.

The handler caches timestamps when it checks ".dep" files, and the cache
is maintained across calls to the same handler. The cache is not
consulted to compare the immediate source file to its ".zo" file, which
means that the caching behavior is consistent with the caching of the
default module name resolver (see current-module-name-resolver).

If use-compiled-file-paths contains an empty list when
make-compilation-manager-load/use-compiled-handler is called, then an
exn:fail:contract exception is raised.

If the delete-zos-when-rkt-file-does-not-exist? argument is a true
value, then the returned handler will delete ".zo" files when there is
no corresponding original source file.

If the security-guard argument is supplied, it is used when creating
".zo" files, ".dep" files, and "compiled/" directories, and when it
adjusts the timestamps for existing files. If it is #f, then the
security guard in the current-security-guard when the files are created
is used (not the security guard at the point
make-compilation-manager-load/use-compiled-handler is called).

The continuation of the compilation of a module is marked with a
managed-compiled-context-key and the module’s source path.

Do not install the result of
make-compilation-manager-load/use-compiled-handler when the current
namespace contains already-loaded versions of modules that may need to
be recompiled—unless the already-loaded modules are never referenced by
not-yet-loaded modules. References to already-loaded modules may produce
compiled files with inconsistent timestamps and/or ".dep" files with
incorrect information.

The handler logs messages to the topic 'compiler/cm at the level 'info.
These messages are instances of a compile-event prefab structure:

  (struct compile-event (timestamp path type) #:prefab) ~

The timestamp field is the time at which the event occurred in
milliseconds since the epoch.  The path field is the path of a file
being compiled for which the event is about. The type field is a symbol
which describes the action the event corresponds to. The currently
logged values are 'locking, 'start-compile, 'finish-compile, and
'already-done.

Changed in version 6.1.1.8 of package base: Added identification of the
compilation  context via managed-compiled-context-key. Changed in
version 6.6.0.3: added check on a source’s SHA1 hash to complement the
timestamp check, where the latter can be disabled via
use-compile-file-check.

                                        *managed-compile-zo*
(managed-compile-zo  file                                   ~
                    [read-src-syntax                       
                     #:security-guard security-guard]) -> void? ~
  file : path-string? ~
  read-src-syntax : (any/c input-port? . -> . syntax?) ~
                  = read-syntax
  security-guard : (or/c security-guard? #f) = #f ~

Compiles the given module source file to a ".zo", installing a
compilation-manager handler while the file is compiled (so that required
modules are also compiled), and creating a ".dep" file to record the
timestamps of immediate files used to compile the source (i.e., files
required in the source).

If file is compiled from source, then read-src-syntax is used in the
same way as read-syntax to read the source module. The normal
read-syntax is used for any required files, however.

If security-guard is not #f, then the provided security guard is used
when creating the "compiled/" directories, ".dep" and ".zo" files, and
when it adjusts the timestamps of existing files. If it is #f, then the
security guard in the current-security-guard when the files are created
is used (not the security guard at the point managed-compile-zo is
called).

While compiling file, the error-display-handler parameter is set to
(make-compilation-context-error-display-handler
(error-display-handler)), so that errors from uncaught exceptions will
report the compilation context.

Changed in version 6.1.1.8 of package base: Added error-display-handler
configuration.

managed-compiled-context-key : any/c ~

A key used as a continuation mark key by
make-compilation-manager-load/use-compiled-handler for the continuation
of a module compilation. The associated value is a path to the module’s
source.

Added in version 6.1.1.8 of package base.

                                        *make-compilation-context-error-display-handler*
(make-compilation-context-error-display-handler orig-handlers) ~
 -> (string? any/c . -> . void?)
  orig-handlers : (string? any/c . -> . void?) ~

Produces a handler suitable for use as an error-display-handler value,
given an existing such value. The generated handler shows information
about the compilation context when the handler’s second argument is an
exception whose continuation marks include managed-compiled-context-key
keys.

Added in version 6.1.1.8 of package base.

                                        *trust-existing-zos*
(trust-existing-zos) -> boolean? ~
(trust-existing-zos trust?) -> void?
  trust? : any/c ~

A parameter that is intended for use by raco setup when installing with
pre-built ".zo" files. It causes a compilation-manager load/use-compiled
handler to “touch” out-of-date ".zo" files instead of re-compiling from
source.

                                        *make-caching-managed-compile-zo*
(make-caching-managed-compile-zo                                     ~
                                 [read-src-syntax                   
                                  #:security-guard security-guard])  ~
 -> (path-string? . -> . void?)
  read-src-syntax : (any/c input-port? . -> . syntax?) ~
                  = read-syntax
  security-guard : (or/c security-guard? #f) = #f ~

Returns a procedure that behaves like managed-compile-zo (providing the
same read-src-syntax each time), but a cache of timestamp information is
preserved across calls to the procedure.

                                        *manager-compile-notify-handler*
(manager-compile-notify-handler) -> (path? . -> . any) ~
(manager-compile-notify-handler notify) -> void?
  notify : (path? . -> . any) ~

A parameter for a procedure of one argument that is called whenever a
compilation starts. The argument to the procedure is the file’s path.

                                        *manager-trace-handler*
(manager-trace-handler) -> (string? . -> . any) ~
(manager-trace-handler notify) -> void?
  notify : (string? . -> . any) ~

A parameter for a procedure of one argument that is called to report
compilation-manager actions, such as checking a file. The argument to
the procedure is a string.

The default value of the parameter logs the argument, along with
current-inexact-milliseconds, to a logger named 'compiler/cm  at the
'debug level.

                                        *manager-skip-file-handler*
(manager-skip-file-handler) ~
 -> (-> path? (or/c (cons/c number? promise?) #f))
(manager-skip-file-handler proc) -> void?
  proc : (-> path? (or/c (cons/c number? promise?) #f)) ~

A parameter whose value is called for each file that is loaded and
needs recompilation. If the procedure returns a pair, then the file  is
skipped (i.e., not compiled); the number in the pair is used as  the
timestamp for the file’s bytecode, and the promise may be  forced to
obtain a string that is used as hash of the  compiled file plus its
dependencies. If the procedure returns  #f, then the file is compiled as
usual. The default is  (lambda (x) #f).

                                        *current-path->mode*
(current-path->mode) ~
 -> (or/c #f (-> path? (and/c path? relative-path?)))
(current-path->mode path->mode) -> void?
  path->mode : (or/c #f (-> path? (and/c path? relative-path?))) ~
 = #f

Used by make-compilation-manager-load/use-compiled-handler and
make-caching-managed-compile-zo to override use-compiled-file-paths for
deciding where to write compiled ".zo" files. If it is #f, then the
first element of use-compiled-file-paths is used. If it isn’t #f, then
it is called with the original source file’s location and its result is
treated the same as if it had been the first element of
use-compiled-file-paths.

Note that this parameter is not used by current-load/use-compiled. So if
the parameter causes ".zo" files to be placed in different directories,
then the correct ".zo" file must still be communicated via
use-compiled-file-paths, and one way to do that is to override
current-load/use-compiled to delete ".zo" files that would cause the
wrong one to be chosen right before they are loaded.

Added in version 6.4.0.14 of package base.

                                        *file-stamp-in-collection*
(file-stamp-in-collection p) ~
 -> (or/c (cons/c number? promise?) #f)
  p : path? ~

Calls file-stamp-in-paths with p and (current-library-collection-paths).

                                        *file-stamp-in-paths*
(file-stamp-in-paths p paths) ~
 -> (or/c (cons/c number? promise?) #f)
  p : path? ~
  paths : (listof path?) ~

Returns the file-modification date and delayed hash of  p or its
bytecode form (i.e., ".zo" file), whichever  exists and is newer, if p
is an extension of any path in  paths (i.e., exists in the directory, a
subdirectory,  etc.). Otherwise, the result is #f.

This function is intended for use with manager-skip-file-handler.

                                        *get-file-sha1*
(get-file-sha1 p) -> (or/c string? #f) ~
  p : path? ~

Computes a SHA-1 hash for the file p; the result is #f if p cannot be
opened.

                                        *get-compiled-file-sha1*
(get-compiled-file-sha1 p) -> (or/c string? #f) ~
  p : path? ~

Computes a SHA-1 hash for the bytecode file p, appending any
dependency-describing hash available from a ".dep" file when available
(i.e., the suffix on p is replaced by ".dep" to locate dependency
information). The result is #f if p cannot be opened.

                                        *with-compile-output*
(with-compile-output p proc) -> any ~
  p : path-string? ~
  proc : ([port input-port?] [tmp-path path?]  . -> . any) ~

A wrapper on call-with-atomic-output-file that passes along any security
guard put in place by
make-compilation-manager-load/use-compiled-handler, etc.

                                        *parallel-lock-client*
(parallel-lock-client) ~
 -> (or/c #f
          (->i ([command (or/c 'lock 'unlock)]
                [file bytes?])
               [res (command) (if (eq? command 'lock)
                                  boolean?
                                  void?)]))
(parallel-lock-client proc) -> void?
  proc : (or/c #f ~
               (->i ([command (or/c 'lock 'unlock)]
                     [file bytes?])
                    [res (command) (if (eq? command 'lock)
                                       boolean?
                                       void?)]))

Holds the parallel compilation lock client, which is used by the result
of make-compilation-manager-load/use-compiled-handler to prevent
compilation races between parallel builders.

When proc is #f (the default), no checking for parallel compilation is
done (and thus multiple threads or places running compilations via
make-compilation-manager-load/use-compiled-handler will potentially
corrupt each other’s ".zo" files).

When proc is a function, its first argument is a command, indicating if
it wants to lock or unlock the path specified in the second argument.

When the proc 'lock command returns #t, the current builder has obtained
the lock for zo-path. Once compilation of zo-path is complete, the
builder process must release the lock by calling proc 'unlock with the
exact same zo-path.

When the proc 'lock command returns #f, another parallel builder
obtained the lock first and has already compiled the zo.  The parallel
builder should continue without compiling zo-path. (In this case,
make-compilation-manager-load/use-compiled-handler’s result will not
call proc with 'unlock.)

Example:

  > (let* ([lc (parallel-lock-client)]
           [zo-name  #"collects/racket/compiled/draw_rkt.zo"]
           [locked? (and lc (lc 'lock zo-name))]
           [ok-to-compile? (or (not lc) locked?)])
      (dynamic-wind
        (lambda () (void))
        (lambda ()
          (when ok-to-compile?
            (printf "Do compile here ...\n")))
        (lambda ()
          (when locked?
            (lc 'unlock zo-name)))))
  Do compile here ...

                                        *compile-lock->parallel-lock-client*
(compile-lock->parallel-lock-client  pc      ~
                                    [cust]) 
 -> (-> (or/c 'lock 'unlock) bytes? boolean?)
  pc : place-channel? ~
  cust : (or/c #f custodian?) = #f ~

Returns a function that follows the parallel-lock-client by
communicating over pc. The argument must be the result of
make-compile-lock.

This communication protocol implementation is not kill safe. To make it
kill safe, it needs a sufficiently powerful custodian, i.e., one that is
not subject to termination (unless all of the participants in the
compilation are also terminated). It uses this custodian to create a
thread that monitors the threads that are doing the compilation. If one
of them is terminated, the presence of the custodian lets another one
continue. (The custodian is also used to create a thread that manages a
thread safe table.)

                                        *make-compile-lock*
(make-compile-lock) -> place-channel? ~

Creates a place-channel? that can be used with
compile-lock->parallel-lock-client to avoid concurrent
compilations of the same Racket source files in multiple places.

                                        *install-module-hashes!*
(install-module-hashes! bstr [start end]) -> void? ~
  bstr : bytes? ~
  start : exact-nonnegative-integer? = 0 ~
  end : exact-nonnegative-integer? = (bytes-length bstr) ~

Adjusts the bytecode representation in bstr (from bytes start to end) to
install a hash code, including any submodules within the region. The
existing representation should have zero bytes in place of each hash
string, which is what write produces for a compiled form.

Added in version 6.3 of package base.

5. API for Parallel Builds

 (require setup/parallel-build) package: base ~

The setup/parallel-build library provides the parallel-compilation
functionality of raco setup and raco make.

Both parallel-compile-files and parallel-compile log messages to the
topic 'setup/parallel-build at the level 'info. These messages are
instances of a parallel-compile-event prefab structure:

  (struct parallel-compile-event (worker event) #:prefab) ~

The worker field is the index of the worker that the created the event.
The event field is a compile-event as documented in
make-compilation-manager-load/use-compiled-handler.

                                        *parallel-compile-files*
(parallel-compile-files  list-of-files                ~
                        [#:worker-count worker-count  ~
                         #:use-places? use-places?    ~
                         #:handler handler])          ~
 -> (or/c void? #f)
  list-of-files : (listof path-string?) ~
  worker-count : exact-positive-integer? = (processor-count) ~
  use-places? : any/c = #t ~
  handler : (->i ([worker-id exact-integer?] = void ~
                  [handler-type symbol?]
                  [path path-string?]
                  [msg string?]
                  [out string?]
                  [err string?])
                 void?)

The parallel-compile-files utility function is used by raco make to
compile a list of paths in parallel.  The optional #:worker-count
argument specifies the number of compile workers to spawn during
parallel compilation.  The compile workers are implemented as Racket
places if use-places? is true, otherwise the compile workers are
implemented as separate Racket processes. The callback, handler, is
called with the symbol 'done as the handler-type argument for each
successfully compiled file, 'output when a successful compilation
produces stdout/stderr output, 'error when a compilation error has
occurred, or 'fatal-error when a unrecoverable error occurs. The other
arguments give more information for each status update. The return value
is (void) if it was successful, or #f if there was an error.

  (parallel-compile-files
    source-files
    #:worker-count 4 ~
    #:handler (lambda (type work msg out err) ~
      (match type
        ['done (when (verbose) (printf " Made ~a\n" work))]
        ['output (printf " Output from: ~a\n~a~a" work out err)] ~
        [else (printf " Error compiling ~a\n~a\n~a~a"
                      work
                      msg
                      out
                      err)])))

Changed in version 7.0.0.19 of package base: Added the #:use-places?
argument.

                                        *parallel-compile*
(parallel-compile  worker-count                     ~
                   setup-fprintf                   
                   append-error                    
                   collects-tree                   
                  [#:use-places? use-places?]) -> (void) ~
  worker-count : non-negative-integer? ~
  setup-fprintf : (->i ([stage string?] [format string?]) ~
                       ()
                       #:rest (listof any/c) void) ~
  append-error : (->i ([cc cc?] ~
                       [prefix string?]
                       [exn (or/c exn? (cons/c string? string?) #f)]
                       [out string?]
                       [err string?]
                       [message string?])
                      void?)
  collects-tree : (listof any/c) ~
  use-places? : any/c = #t ~

The parallel-compile function is used by raco setup to compile
collections in parallel. The worker-count argument specifies the number
of compilation workers to spawn during parallel compilation. The
use-places? argument specified whether to use places, otherwise separate
processes are used. The setup-fprintf and append-error functions
communicate intermediate compilation results and errors. The
collects-tree argument is a compound data structure containing an
in-memory tree representation of the collects directory.

When the exn argument to append-error is a pair of strings, the first
string is a long form of the error message, and the second string is a
short form (omitting evaluation context information, for example).

Changed in version 6.1.1.8 of package base: Changed append-error to
allow a pair of error strings. Changed in version 7.0.0.19: Added the
#:use-places? argument.

6. Compilation Manager Hook for Syntax Transformers

 (require compiler/cm-accomplice) package: base ~

                                        *register-external-file*
(register-external-file  file                         ~
                        [#:indirect? indirect?]) -> void? ~
  file : (and path? complete-path?) ~
  indirect? : any/c = #f ~

Logs a message (see log-message) at level 'info to a logger named
'cm-accomplice. The message data is a file-dependency prefab structure
type with two fields; the first field’s value is file and the second
field’s value is #f (to indicate a non-module dependency). If the
indirect? argument is true, the data is more specifically an instance of
a file-dependency/options prefab structure type that is a subtype of
file-dependency with one extra field: a hash table mapping 'indirect to
#t.

A compilation manager implemented by compiler/cm looks for such messages
to register an external dependency. In response, the compilation manager
records (in a ".dep" file) the path as contributing to the
implementation of the module currently being compiled. Afterward, if the
registered file is modified, the compilation manager will know to
recompile the module. An indirect dependency has no effect on
recompilation, but it can signal to other tools, such as a
package-dependency checker, that the dependency is indirect (and should
not imply a direct package dependency).

The include macro, for example, calls this procedure with the path of an
included file as it expands an include form.

                                        *register-external-module*
(register-external-module  file                         ~
                          [#:indirect? indirect?]) -> void? ~
  file : (and path? complete-path?) ~
  indirect? : any/c = #f ~

Like register-external-file, but logs a message with a file-dependency
prefab structure type whose second field is #t.

A compilation manager implemented by compiler/cm recognizes the message
to register a dependency on a module (which implies a dependency on all
of that module’s dependencies, etc.).

7. API for Simple Bytecode Creation

 (require compiler/compile-file) package: base ~

                                        *compile-file*
(compile-file src [dest filter]) -> path? ~
  src : path-string? ~
  dest : path-string? ~
       = (let-values ([(base name dir?) (split-path src)])
           (build-path base "compiled"
                       (path-add-suffix name #".zo")))
  filter : (any/c . -> . any/c) = values ~

Compiles the Racket file src and saves the compiled code to dest.  If
dest is not provided and the "compiled" subdirectory does not already
exist, the subdirectory is created. The result of compile-file is the
destination file’s path.

If the filter procedure is provided, it is applied to each source
expression, and the result is compiled.

Beware that compile-file uses the current reader parameterization to
read src. Typically, compile-file should be called from a thunk passed
to with-module-reading-parameterization so that the source program is
parsed in a consistent way and allowing #lang.

Each expression in src is compiled independently. If src does not
contain a single module expression, then earlier expressions can affect
the compilation of later expressions when src is loaded directly. An
appropriate filter can make compilation behave like evaluation, but the
problem is also solved (as much as possible) by the compile-zos
procedure.

See also managed-compile-zo.

8. API for Bytecode Paths

 (require compiler/compilation-path) package: base ~

Added in version 6.0.1.10 of package base.

                                        *get-compilation-dir+name*
(get-compilation-dir+name  path                           ~
                          [#:modes modes                  ~
                           #:roots roots                  ~
                           #:default-root default-root])  ~
 -> path? path?
  path : path-string? ~
  modes : (non-empty-listof (and/c path-string? relative-path?)) ~
        = (use-compiled-file-paths)
  roots : (non-empty-listof (or/c path-string? 'same)) ~
        = (current-compiled-file-roots)
  default-root : (or/c path-string? 'same) = (car roots) ~

Determines the directory that holds the bytecode form of path plus the
base name of path.

The directory is determined by checking roots in order, and for each
element of roots checking modes in order. The first such directory that
contains a file whose name matches path with ".zo" added (in the sense
of path-add-suffix) is reported as the return directory path. If no such
file is found, the result corresponds to the first element of modes
combined with default-root.

Changed in version 7.1.0.9 of package base: Added the #:default-root
argument.

                                        *get-compilation-dir*
(get-compilation-dir  path                               ~
                     [#:modes modes                      ~
                      #:roots roots                      ~
                      #:default-root default-root]) -> path? ~
  path : path-string? ~
  modes : (non-empty-listof (and/c path-string? relative-path?)) ~
        = (use-compiled-file-paths)
  roots : (non-empty-listof (or/c path-string? 'same)) ~
        = (current-compiled-file-roots)
  default-root : (or/c path-string? 'same) = (car roots) ~

The same as get-compilation-dir+name, but returning only the first
result.

Changed in version 7.1.0.9 of package base: Added the #:default-root
argument.

                                        *get-compilation-bytecode-file*
(get-compilation-bytecode-file  path                           ~
                               [#:modes modes                  ~
                                #:roots roots                  ~
                                #:default-root default-root])  ~
 -> path?
  path : path-string? ~
  modes : (non-empty-listof (and/c path-string? relative-path?)) ~
        = (use-compiled-file-paths)
  roots : (non-empty-listof (or/c path-string? 'same)) ~
        = (current-compiled-file-roots)
  default-root : (or/c path-string? 'same) = (car roots) ~

The same as get-compilation-dir+name, but combines the results and adds
a ".zo" suffix to arrive at a bytecode file path.

Changed in version 7.1.0.9 of package base: Added the #:default-root
argument.

9. Compiling to Raw Bytecode

The --no-deps mode for raco make is an improverished form of the
compilation, because it does not track import dependencies. It does,
however, support compilation of non-module source in a namespace that
initially imports scheme.

Outside of a module, top-level define-syntaxes, module, #%require,
define-values-for-syntax, and begin expressions are handled specially by
raco make --no-deps: the compile-time portion of the expression is
evaluated, because it might affect later expressions.

For example, when compiling the file containing

  (require racket/class)
  (define f (class object% (super-new)))

the class form from the racket/class library must be bound in the
compilation namespace at compile time. Thus, the require expression is
both compiled (to appear in the output code) and evaluated (for further
computation).

Many definition forms expand to define-syntaxes. For example,
define-signature expands to define-syntaxes. In --no-deps mode, raco
make --no-deps detects define-syntaxes and other expressions after
expansion, so top-level define-signature expressions affect the
compilation of later expressions, as a programmer would expect.

In contrast, a load or eval expression in a source file is compiled—but
not evaluated!—as the source file is compiled.  Even if the load
expression loads syntax or signature definitions, these will not be
loaded as the file is compiled. The same is true of application
expressions that affect the reader, such as (read-case-sensitive #t).
The -p or --prefix flag for raco make takes a file and loads it before
compiling the source files specified on the command line.

By default, the namespace for compilation is initialized by a require of
scheme. If the --no-prim flag is specified, the namespace is instead
initialized with namespace-require/copy, which allows mutation and
redefinition of all initial bindings (other than syntactic forms, in the
case of mutation).

In general, a better solution is to put all code to compile into a
module and use raco make in its default mode.

10. API for Raw Compilation

 (require compiler/compiler) package: base ~

The compiler/compiler library provides the functionality of raco make
for compilation to bytecode, but through a Racket API.

10.1. Bytecode Compilation

((compile-zos  expr                      
              [#:module? module?          ~
               #:verbose? verbose?])      ~
               racket-files              
               dest-dir)             -> void?
  expr : any/c ~
  module? : any/c = #f ~
  verbose? : any/c = #f ~
  racket-files : (listof path-string?) ~
  dest-dir : (or/c path-string? false/c (one-of/c 'auto)) ~

Supplying just expr returns a compiler that is initialized with the
expression expr, as described below.

The compiler takes a list of Racket files and compiles each of them to
bytecode, placing the resulting bytecode in a ".zo" file within the
directory specified by dest-dir.  If dest-dir is #f, each bytecode
result is placed in the same directory as its source file.  If dest-dir
is 'auto, each bytecode file is placed in a "compiled" subdirectory
relative to the source; the directory is created if necessary.

If expr is anything other than #f, then a namespace is created for
compiling the files that are supplied later, and expr is evaluated to
initialize the created namespace. For example, expr might load a set of
macros. In addition, the expansion-time part of each expression later
compiled is evaluated in the namespace before being compiled, so that
the effects are visible when compiling later expressions.

If expr is #f, then no compilation namespace is created (the current
namespace is used), and expressions in the files are assumed to compile
independently (so there’s no need to evaluate the expansion-time part of
an expression to compile).

Typically, expr is #f for compiling module files, and it is (void) for
compiling files with top-level definitions and expressions.

If module? is #t, then the given files are read and compiled as modules
(so there is no dependency on the current namespace’s top-level
environment).

If verbose? is #t, the output file for each given file is reported
through the current output port.

                                        *compile-collection-zos*
(compile-collection-zos                                             ~
                         collection ...+                           
                        [#:skip-path skip-path                      ~
                         #:skip-paths skip-paths                    ~
                         #:skip-doc-sources? skip-docs?             ~
                         #:managed-compile-zo managed-compile-zo])  ~
 -> void?
  collection : string? ~
  skip-path : (or/c path-string? #f) = #f ~
  skip-paths : (listof path-string?) = null ~
  skip-docs? : any/c = #f ~
  managed-compile-zo : (path-string? . -> . void?) ~
                     = (make-caching-managed-compile-zo)

Compiles the specified collection’s files to ".zo" files by using
managed-compile-zo on each source file. The ".zo" files are placed into
the collection’s "compiled" directory.

By default, all files with the extension ".rkt", ".ss", or ".scm" in a
collection are compiled, as are all such files within subdirectories;
the set of such suffixes is extensible globally as described in
get-module-suffixes, and compile-collection-zos recognizes suffixes from
the 'libs group. However, any file or directory whose path starts with
skip-path or an element of skip-paths is skipped. (“Starts with” means
that the simplified path p’s byte-string form after (simplify-path p
#f)starts with the byte-string form of (simplify-path skip-path #f).)

The collection compiler reads the collection’s "info.rkt" file (see
[missing]) to obtain further instructions for compiling the collection.
The following fields are used:

* name : The name of the collection as a string, used only for status
  and error reporting.

* compile-omit-paths : A list of immediate file and directory paths that
  should not be compiled. Alternatively, this field’s value is 'all,
  which is equivalent to specifying all files and directories in the
  collection (to effectively ignore the collection for compilation).
  Automatically omitted files and directories are "compiled", "doc", and
  those whose names start with ..

  Files that are required by other files, however, are always compiled
  in the process of compiling the requiring file—even when the required
  file is listed with this field or when the field’s value is 'all.

* compile-omit-files : A list of filenames (without directory paths)
  that are not compiled, in addition to the contents of
  compile-omit-paths.  Do not use this field; it is for backward
  compatibility.

* scribblings : A list of lists, each of which starts with a path for
  documentation source.  See [missing] for more information.  The
  sources (and the files that they require) are compiled in the same way
  as other module files, unless skip-docs? is a true value.

* compile-include-files : A list of filenames (without directory paths)
  to be compiled, in addition to files that are compiled based on the
  file’s extension, being in scribblings, or being required by other
  compiled files.

* module-suffixes and doc-module-suffixes : Used indirectly via
  get-module-suffixes.

Changed in version 6.3 of package base: Added support for
compile-include-files.

                                        *compile-directory-zos*
(compile-directory-zos                                             ~
                        path                                      
                        info                                      
                       [#:verbose verbose?                         ~
                        #:skip-path skip-path                      ~
                        #:skip-paths skip-paths                    ~
                        #:skip-doc-sources? skip-docs?             ~
                        #:managed-compile-zo managed-compile-zo])  ~
 -> void?
  path : path-string? ~
  info : procedure? ~
  verbose? : any/c = #f ~
  skip-path : (or/c path-string? #f) = #f ~
  skip-paths : (listof path-string?) = null ~
  skip-docs? : any/c = #f ~
  managed-compile-zo : (path-string? . -> . void?) ~
                     = (make-caching-managed-compile-zo)

Like compile-collection-zos, but compiles the given directory rather
than a collection. The info function behaves like the result of get-info
to supply "info.rkt" fields, instead of using an "info.rkt" file (if
any) in the directory.

10.2. Recognizing Module Suffixes

 (require compiler/module-suffix) package: base ~

The compiler/module-suffix library provides functions for recognizing
file suffixes that correspond to Racket modules for the purposes of
compiling files in a directory, running tests for files in a directory,
and so on. The set of suffixes always includes ".rkt", ".ss", and
".scm", but it can be extended globally by "info.rkt" configurations in
collections.

Added in version 6.3 of package base.

                                        *get-module-suffixes*
(get-module-suffixes [#:group group                ~ ~
                      #:mode mode                  ~
                      #:namespace namespace]) -> (listof bytes?) ~
  group : (or/c 'all 'libs 'docs) = 'all ~
  mode : (or/c 'preferred 'all-available 'no-planet 'no-user) ~
       = 'preferred
  namespace : (or/c #f namespace?) = #f ~

Inspects "info.rkt" files (see [missing]) of installed collections to
produce a list of file suffixes that should be recognized as Racket
modules. Each suffix is reported as a byte string that does not include
the . that precedes a suffix.

The mode and namespace arguments are propagated to
find-relevant-directories to determine which collection directories
might configure the set of suffixes. Consequently, suffix registrations
are found reliably only if raco setup (or package installations or
updates that trigger raco setup) is run.

The group argument determines whether the result includes all registered
suffixes, only those that are registered as general library suffixes, or
only those that are registered as documentation suffixes. The set of
general-library suffixes always includes ".rkt", ".ss", and ".scm". The
set of documentation suffixes always includes ".scrbl".

The following fields in an "info.rkt" file extend the set of suffixes:

* module-suffixes : A list of byte strings that correspond to
  general-library module suffixes (without the . that must appear before
  the suffix). Non-lists or non-byte-string elements of the list are
  ignored.

* doc-module-suffixes : A list of byte strings as for module-suffixes,
  but for documentation modules.

                                        *get-module-suffix-regexp*
(get-module-suffix-regexp [#:group group                ~ ~
                           #:mode mode                  ~
                           #:namespace namespace]) -> byte-regexp? ~
  group : (or/c 'all 'libs 'docs) = 'all ~
  mode : (or/c 'preferred 'all-available 'no-planet 'no-user) ~
       = 'preferred
  namespace : (or/c #f namespace?) = #f ~

Returns a regexp value that matches paths ending with a suffix as
reported by get-module-suffixes. The pattern includes a subpatterns for
the suffix without its leading .

10.3. Loading Compiler Support

The compiler unit loads certain tools on demand via dynamic-require and
get-info. If the namespace used during compilation is different from the
namespace used to load the compiler, or if other load-related parameters
are set, then the following parameter can be used to restore settings
for dynamic-require.

                                        *current-compiler-dynamic-require-wrapper*
(current-compiler-dynamic-require-wrapper) ~
 -> ((-> any) . -> . any)
(current-compiler-dynamic-require-wrapper proc) -> void?
  proc : ((-> any) . -> . any) ~

A parameter whose value is a procedure that takes a thunk to apply. The
default wrapper sets the current namespace (via parameterize) before
calling the thunk, using the namespace in which the compiler/compiler
library was originally instantiated.

10.4. Options for the Compiler

 (require compiler/option) package: base ~

The compiler/option module provides options (in the form of parameters)
that control the compiler’s behaviors.

More options are defined by the dynext/compile and dynext/link
libraries, which control the actual C compiler and linker that are used
for compilation via C.

                                        *somewhat-verbose*
(somewhat-verbose) -> boolean? ~
(somewhat-verbose on?) -> void?
  on? : any/c ~

A #t value for the parameter causes the compiler to print the files that
it compiles and produces. The default is #f.

                                        *verbose*
(verbose) -> boolean? ~
(verbose on?) -> void?
  on? : any/c ~

A #t value for the parameter causes the compiler to print verbose
messages about its operations. The default is #f.

                                        *compile-subcollections*
(compile-subcollections) -> (one-of/c #t #f) ~
(compile-subcollections cols) -> void?
  cols : (one-of/c #t #f) ~

A parameter that specifies whether sub-collections are compiled by
compile-collection-zos.  The default is #t.

10.5. The Compiler as a Unit

10.5.1. Signatures

 (require compiler/sig) package: compiler-lib ~

compiler^ : signature ~

Includes all of the names exported by compiler/compiler.

compiler:option^ : signature ~

Includes all of the names exported by compiler/option.

10.5.2. Main Compiler Unit

 (require compiler/compiler-unit) package: compiler-lib ~

compiler@ : unit? ~

Provides the exports of compiler/compiler in unit form, where C-compiler
operations are imports to the unit, although they are not used.

The unit imports compiler:option^, dynext:compile^, dynext:link^, and
dynext:file^. It exports compiler^.

10.5.3. Options Unit

 (require compiler/option-unit) package: compiler-lib ~

compiler:option@ : unit? ~

Provides the exports of compiler/option in unit form. It imports no
signatures, and exports compiler:option^.

11. API for Reading Compilation Dependencies

 (require compiler/depend) package: base ~

The compiler/depend module provides a function to inspect and traverse
the dependency information generated by raco make, raco setup, or
compiler/cm.

Added in version 6.90.0.13 of package base.

                                        *module-recorded-dependencies*
(module-recorded-dependencies module-file) ~
 -> (listof (and path? (complete-path? path?)))
  module-file : path? ~

Given a module-file for a file that has been compiled with raco make,
raco setup, or compiler/cm, returns a list of dependencies for
module-file by reading and traversing dependency-information files left
behind by compilation.
