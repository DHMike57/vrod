raco ctool: Working with C Code

The raco ctool command works in various modes (as determined by
command-line flags) to support various tasks involving C code.

    1 Compiling and Linking C Extensions
      1.1 API for 3m Transformation

    2 Embedding Modules via C

1. Compiling and Linking C Extensions

A dynamic extension is a shared library (a.k.a. DLL) that extends Racket
using the C API. An extension can be loaded explicitly via
load-extension, or it can be loaded implicitly through require or
load/use-compiled in place of a source file when the extension is
located at

  (build-path "compiled" "native" (system-library-subpath)
              (path-add-suffix file (system-type 'so-suffix)))

relative to file.

For information on writing extensions, see [missing].

raco ctool is provided by the "cext-lib"  package.

Three raco ctool modes help for building extensions:

* --cc : Runs the host system’s C compiler, automatically supplying
  flags to locate the Racket header files and to compile for inclusion
  in a shared library.

* --ld : Runs the host system’s C linker, automatically supplying flags
  to locate and link to the Racket libraries and to generate a shared
  library.

* --xform : Transforms C code that is written without explicit
  GC-cooperation hooks to cooperate with Racket’s 3m garbage collector;
  see [missing] in [missing].

Compilation and linking build on the dynext/compile and dynext/link
libraries. The following raco ctool flags correspond to setting or
accessing parameters for those libraries: --tool, --compiler, --ccf,
--ccf, --ccf-clear, --ccf-show, --linker, ++ldf, --ldf, --ldf-clear,
--ldf-show, ++ldl, --ldl-show, ++cppf, ++cppf ++cppf-clear, and
--cppf-show.

The --3m flag specifies that the extension is to be loaded into the 3m
variant of Racket. The --cgc flag specifies that the extension is to be
used with the CGC. The default depends on raco: --3m if raco itself is
running in 3m, --cgc if raco itself is running in CGC.

1.1. API for 3m Transformation

 (require compiler/xform) package: cext-lib ~

                                        *xform*
(xform  quiet?                           ~
        input-file                      
        output-file                     
        include-dirs                    
       [#:keep-lines? keep-lines?]) -> any/c ~
  quiet? : any/c ~
  input-file : path-string? ~
  output-file : path-string? ~
  include-dirs : (listof path-string?) ~
  keep-lines? : boolean? = #f ~

Transforms C code that is written without explicit GC-cooperation hooks
to cooperate with Racket’s 3m garbage collector; see [missing] in
[missing].

The arguments are as for compile-extension; in addition keep-lines? can
be #t to generate GCC-style annotations to connect the generated C code
with the original source locations.

The file generated by xform can be compiled via compile-extension.

2. Embedding Modules via C

raco ctool is provided by the "cext-lib"    package.

The --c-mods mode for raco ctool takes a set of Racket modules and
generates a C source file that can be used as part of program that
embeds the Racket runtime system. See [missing] in [missing] for an
explanation of embedding programs. The --mods mode is similar, but it
generates the raw bytes for the compiled module without encoding the
bytes in C declarations.

The generated source or compiled file embeds the specified modules.
Generated C source defines a declare_modules function that puts the
module declarations into a namespace. Thus, using the output of raco
ctool --c-mods, a program can embed Racket with a set of modules so that
it does not need a "collects" directory to load modules at run time.

If the embedded modules refer to runtime files, the files can be
gathered by supplying the --runtime argument to raco ctool --cmods,
specifying a directory >dir< to hold the files. Normally, >dir< is a
relative path, and files are found at run time in >dir< relative to the
executable, but a separate path (usually relative) for run time can be
specified with --runtime-access.

Typically, raco ctool --c-mods is used with ++lib to specify a
collection-based module path. For example,

  raco ctool --c-mods base.c ++lib racket/base

generates a "base.c" whose declare_modules function makes racket/base
available for use via the scheme_namespace_require or
scheme_dynamic_require functions within the embedding application.

When a module file is provided to raco ctool --c-mods, then
declare_modules declares a module with the symbolic name of the module
file. For example,

  raco ctool --c-mods base.c hello.rkt

creates a declare_modules that defines the module 'hello, which could be
required into the current namespace with (namespace-require ''hello) or
similarly at the C level:

  p = scheme_make_pair(scheme_intern_symbol("quote"),
                       scheme_make_pair(scheme_intern_symbol("hello"),
                                        scheme_make_null()));
  scheme_namespace_require(p);
