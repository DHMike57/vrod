raco setup: Installation Management

The raco setup command builds bytecode, documentation, executables, and
metadata indexes for all installed collections.

The collections that are built by raco setup can be part of the original
Racket distribution, installed via the package manager (see [missing]),
installed via PLaneT (see [missing]), linked via raco link, in a
directory that is listed in the PLTCOLLECTS environment variable, or
placed into one of the default collection directories.

The raco setup tool itself does not directly support the installation of
collections, except through the now-discouraged -A flag (see Installing
".plt" Archives). The raco setup command is used by installation tools
such as the package manager or PLaneT. Programmers who modify installed
collections may find it useful to run raco setup as an alternative to
un-installing and re-installing a set of collections.

    1 Running raco setup

    2 Installing ".plt" Archives

    3 Controlling raco setup with "info.rkt" Files

    4 "info.rkt" File Format

    5 Package Dependency Checking
      5.1 Declaring Build-Time Dependencies
      5.2 How Dependency Checking Works

    6 API for Setup
      6.1 raco setup Unit
      6.2 Options Unit
      6.3 Options Signature
      6.4 Setup Start Module

    7 API for Installing ".plt" Archives
      7.1 Non-GUI Installer

    8 API for Finding Installation Directories

    9 API for Reading "info.rkt" Files

    10 API for Relative Paths
      10.1 Representing Collection-Based Paths
      10.2 Representing Paths Relative to "collects"
      10.3 Representing Paths Relative to the Documentation
      10.4 Displaying Paths Relative to a Common Root

    11 API for Collection Names

    12 API for Collection Searches

    13 API for Platform Specifications

    14 API for Cross-Platform Configuration

    15 API for Cross-References for Installed Manuals

    16 API for Materializing User-Specific Documentation

1. Running raco setup

With no command-line arguments, raco setup finds all of the current
collections—see [missing]—and compiles libraries in each collection.
(Directories that are named ".git" or ".svn" are not treated as
collections.)

To restrict raco setup to a set of collections, provide the collection
names as arguments. For example, raco setup scribblings/raco would only
compile and render the documentation for raco, which is implemented in a
"scribblings/raco" collection.

An optional "info.rkt" within the collection can indicate specifically
how the collection’s files are to be compiled and other actions to take
in setting up a collection, such as creating executables or building
documentation. See Controlling raco setup with "info.rkt" Files for more
information.

The raco setup command accepts the following command-line flags:

* Constraining to specified collections or PLaneT packages:

  * --only — restrict setup to specified collections and PLaneT
    packages, even if none are specified. This mode is the default if
    any collection is specified as a command-line argument or through
    the -l, --pkgs, or -P flag.

  * -l >collection< ... — constrain setup actions to the specified
    >collection<s (i.e., the same as providing >collections<s without a
    flag, but with no possibility that a >collection< is interpreted as
    a flag).

  * --pkgs >pkg< ... — constrain setup actions to collections that are
    within (or partially within) the named >pkg<s.

  * -P >owner< >package-name< >maj< >min< — constrain setup actions to
    the specified PLaneT package, in addition to any other specified
    PLaneT packages or collections.

  * --doc-index — build collections that implement documentation indexes
    (when documentation building is enabled), in addition to specified
    collections.

  * --tidy — remove metadata cache information and documentation for
    non-existent collections or documentation to clean up after removal,
    even when setup actions are otherwise confined to specified
    collections. Although tidying is not confined to specified
    collections, it can be constrained with --avoid-main or --no-user.

* Constraining to specific tasks:

  * --clean or -c — delete existing ".zo" files, thus ensuring a clean
    build from the source files. The exact set of deleted files can be
    controlled by "info.rkt"; see clean for more information. Unless
    --no-info-domain or -d is also specified, the "info.rkt" cache is
    cleared. Unless --no-docs or -D is also specified, the
    documentation-index database is reset.

  * --fast-clean — like --clean, but without forcing a bootstrap of raco
    setup from source (which means that --fast-clean cannot clean
    corruption that affects raco setup itself).

  * --no-zo or -n — refrain from compiling source files to ".zo" files.

  * --trust-zos — fix timestamps on ".zo" files on the assumption that
    they are already up-to-date (unless the PLT_COMPILED_FILE_CHECK
    environment variable is set to exists, in which case timestamps are
    ignored).

  * --recompile-only — disallow recompilation of modules from source,
    imposing the constraint that each ".zo" file is up-to-date, needs
    only a timestamp adjustment, or can be recompiled from an existing
    ".zo" in machine-independent format (when compiling to a
    machine-dependent format).

  * --no-launcher or -x — refrain from creating executables or
    installing man pages (as specified in "info.rkt"; see Controlling
    raco setup with "info.rkt" Files).

  * --no-foreign-libs or -F — refrain from installing foreign libraries
    (as specified in "info.rkt"; see Controlling raco setup with
    "info.rkt" Files).

  * --only-foreign-libs — disable actions other than installing foreign
    libraries; equivalent to -nxiIdD, except that --only-foreign-libs
    doesn’t reject (redundant) specification of those individual flags.

  * --no-install or -i — refrain from running pre-install actions (as
    specified in "info.rkt" files; see Controlling raco setup with
    "info.rkt" Files).

  * --no-post-install or -I — refrain from running post-install actions
    (as specified in "info.rkt" files; see Controlling raco setup with
    "info.rkt" Files).

  * --no-info-domain or -d — refrain from building a cache of metadata
    information from "info.rkt" files. This cache is needed by other
    tools. For example, raco itself uses the cache to locate plug-in
    tools.

  * --no-docs or -D — refrain from building documentation.

  * --doc-pdf >dir< — in addition to building HTML documentation, render
    documentation to PDF and place files in >dir<.

  * --no-pkg-deps or -K — refrain from checking whether dependencies
    among libraries are properly reflected by package-level dependency
    declarations, whether modules are declared by multiple packages, and
    whether package version dependencies are satisfied. See Package
    Dependency Checking for more information.

  * --check-pkg-deps — checks package dependencies (unless explicitly
    disabled) even when specific collections are provided to raco setup,
    and even for packages that have no dependency declarations. See
    Package Dependency Checking for more information.

  * --fix-pkg-deps — attempt to correct dependency mismatches by
    adjusting package "info.rkt" files (which makes sense only for
    packages that are installed as links). See Package Dependency
    Checking for more information.

  * --unused-pkg-deps — attempt to report dependencies that are declared
    but are unused. Beware that some package dependencies may be
    intentionally unused (e.g., declared to force installation of other
    packages as a convenience), and beware that package dependencies may
    be reported as unused only because compilation of relevant modules
    has been suppressed.  See Package Dependency Checking for more
    information.

* Constraining user versus installation setup:

  * --no-user or -U — refrain from any user-specific (as opposed to
    installation-specific) setup actions.

  * --no-planet — refrain from any setup actions for PLaneT actions;
    this flag is implied by --no-user.

  * --avoid-main — refrain from any setup actions that affect the
    installation, as opposed to user-specific actions.

  * --force-user-docs — when building documentation, create a
    user-specific documentation entry point even if it has the same
    content as the main installation.

* Selecting parallelism and other build modes:

  * --jobs >n<, --workers >n<, or -j >n< — use up to >n< parallel
    processes.  By default, raco setup uses (processor-count) jobs,
    which typically uses all of the machine’s processing cores.

  * --places — use Racket places for parallel jobs; this mode is the
    default if Racket places run in parallel.

  * --processes — use separate processes for parallel jobs; this mode is
    the default if Racket places cannot run in parallel.

  * --verbose or -v — more verbose output about raco setup actions.

  * --make-verbose or -m — more verbose output about dependency checks.

  * --compiler-verbose or -r — even more verbose output about dependency
    checks and compilation.

  * --mode >mode< — use a ".zo" compiler other than the default
    compiler, and put the resulting ".zo" files in a subdirectory (of
    the usual place) named by >mode<. The compiler is obtained by using
    >mode< as a collection name, finding a "zo-compile.rkt" module in
    that collection, and extracting its zo-compile export. The
    zo-compile export should be a function like compile; see the
    "errortrace" collection for an example.

  * --fail-fast — attempt to break as soon as any error is discovered.

  * --error-out >file< — handle survivable errors by writing >file< and
    exiting as successful, which facilitates chaining multiple raco
    setup invocations in combination with --error-in. If there are no
    errors and >file< already exists, it is deleted.

  * --error-in >file< — treat the existence of >file< as a “errors were
    reported by a previous process” error. Typically, >file< is created
    by previous raco setup run using --error-out. A file for --error-in
    is detected before creating a file via --error-out, so the same file
    can be used to chain a sequence of raco setup steps.

  * --pause or -p — pause for user input if any errors are reported (so
    that a user has time to inspect output that might otherwise
    disappear when the raco setup process ends).

* Unpacking ".plt" archives:

  * -A >archive< ... — Install each >archive<; see Installing ".plt"
    Archives.

  * --force — for use with -A, treat version mismatches for archives as
    mere warnings.

  * --all-users or -a — for use with -A, install archive into the
    installation instead of a user-specific location.

* Bootstrapping:

  * --boot >module-file< >build-dir< — For use by directly running setup
    instead of through raco setup, loads >module-file< in the same way
    that raco setup normally loads itself, auto-detecting the need to
    start from sources and rebuild the compiled files—even for the
    compilation manager itself. The >build-dir< path is installed as the
    only path in current-compiled-file-roots, so all compiled files go
    there.

  * --chain >module-file< >build-dir< — Like --boot, but adds
    >build-dir< to the start of current-compiled-file-roots instead of
    replacing the current value, which means that libraries already
    built in the normal location (including the compilation manager
    itself) will be used instead of rebuilt. This mode makes sense for
    cross-compilation.

When building racket, flags can be provided to raco setup as run by make
install by setting the PLT_SETUP_OPTIONS environment variable. For
example, the following command line uses a single process to build
collections during an install:

  env PLT_SETUP_OPTIONS="-j 1" make install

Running raco setup is sensitive to the PLT_COMPILED_FILE_CHECK
environment variable in the same way as raco make. Specifically, if
PLT_COMPILED_FILE_CHECK is set to exists, then raco make does not
attempt to update a compiled file’s timestamp if the file is not
recompiled.

Changed in version 6.1: Added the --pkgs, --check-pkg-deps, and
--fail-fast flags. Changed in version 6.1.1: Added the --force-user-docs
flag. Changed in version 6.1.1.6: Added the --only-foreign-libs flag.
Changed in version 6.6.0.3: Added support for PLT_COMPILED_FILE_CHECK.
Changed in version 7.0.0.19: Added --places and  --processes. Changed in
version 7.2.0.7: Added --error-in and  --error-out. Changed in version
7.2.0.8: Added --recompile-only.

2. Installing ".plt" Archives

A ".plt" file is a platform-independent distribution archive for
software based on Racket. A typical ".plt" file can be installed as a
package using raco pkg (see [missing]), in which case raco pkg supplies
facilities for uninstalling the package and managing dependencies.

An older approach is to supply a ".plt" file to raco setup with the -A
flag; the files contained in the ".plt" archive are unpacked (according
to specifications embedded in the ".plt" file) and only collections
specified by the ".plt" file are compiled and setup. Archives processed
in this way can include arbitrary code that is executed at install time,
in addition to any actions triggered by the normal collection-setup part
of raco setup.

Finally, the raco unpack (see [missing]) command can list the content of
a ".plt" archive or unpack the archive without installing it as a
package or collection.

3. Controlling raco setup with "info.rkt" Files

To compile a collection’s files to bytecode, raco setup uses the
compile-collection-zos procedure. That procedure, in turn, consults the
collection’s "info.rkt" file, if it exists, for specific instructions on
compiling the collection. See compile-collection-zos for more
information on the fields of "info.rkt" that it uses, and see "info.rkt"
File Format for information on the format of an "info.rkt" file.

Additional fields are used by the Racket package manager and are
documented in [missing]. The raco test command also recognizes
additional fields, which are documented in [missing].

Optional "info.rkt" fields trigger additional actions by raco setup:

* scribblings : (listof (cons/c string? list?)) — A list of documents to
  build. Each document in the list is itself represented as a list,
  where each document’s list starts with a string that is a
  collection-relative path to the document’s source file. A document
  name (which is derived from the source module’s name by default) is
  intended to be globally unique in the same way as a package or module
  name.

  More precisely a scribblings entry must be a value that can be
  generated from an expression matching the following entry grammar:

       entry = (list doc ...)
                
         doc = (list src-string)
             | (list src-string flags)
             | (list src-string flags category)
             | (list src-string flags category name)
             | (list src-string flags category name out-k)
             | (list src-string flags category name out-k order-n)
                
       flags = (list mode-symbol ...)
                
    category = (list category-string-or-symbol)
             | (list category-string-or-symbol sort-number)
                
        name = string
             | #f

  A document’s list optionally continues with information on how to
  build the document. If a document’s list contains a second item,
  flags, it must be a list of mode symbols (described below). If a
  document’s list contains a third item, category, it must be a list
  that categorizes the document (described further below). If a
  document’s list contains a fourth item, name, it is a name to use for
  the generated documentation, instead of defaulting to the source
  file’s name (sans extension), where #f means to use the default; a
  non-#f value for name must fit the grammar of a collection-name
  element as checked by collection-name-element?. If a document’s list
  contains a fifth item, out-k, it is used a hint for the number of
  files to use for the document’s cross-reference information; see
  below. If a document’s list contains a fourth item, order-n, it is
  used a hint for the order of rendering; see below.

  Each mode symbol in flags can be one of the following, where only
  'multi-page is commonly used:

  * 'multi-page : Generates multi-page HTML output, instead of the
    default single-page format.

  * 'main-doc : Indicates that the generated documentation should be
    written into the main installation directory, instead of to a
    user-specific directory. This mode is the default for a collection
    that is itself located in the main installation.

  * 'user-doc : Indicates that the generated documentation should be
    written a user-specific directory. This mode is the default for a
    collection that is not itself located in the main installation.

  * 'depends-all : Indicates that the document should be rebuilt if any
    other document is rebuilt—except for documents that have the
    'no-depend-on flag.

  * 'depends-all-main : Indicates that the document should be rebuilt if
    any other document is rebuilt that is installed into the main
    installation—except for documents that have the 'no-depend-on flag.

  * 'depends-all-user : Indicates that the document should be rebuilt if
    any other document is rebuilt that is installed into the user’s
    space—except for documents that have the 'no-depend-on flag.

  * 'always-run : Build the document every time that raco setup is run,
    even if none of its dependencies change.

  * 'no-depend-on : Removes the document for consideration for other
    dependencies. Furthermore, references from the document to other
    documents are always direct, instead of potentially indirect (i.e.,
    resolved at document-viewing time and potentially redirected to a
    remote site).

  * 'main-doc-root : Designates the root document for the main
    installation. The document that currently has this mode should be
    the only one with the mode.

  * 'user-doc-root : Designates the root document for the user-specific
    documentation directory. The document that currently has this mode
    should be the only one with the mode.

  * 'keep-style : Leave the document’s style as-is, instead of imposing
    the document style for manuals.

  * 'no-search : Build the document without a search box.

  The category list specifies how to show the document in  the root
  table of contents. The list must start with a category,  which
  determines where the manual appears in the root  documentation page. A
  category is either a string or a symbol. If  it is a string, then the
  string is the category label on the root  page. If it is a symbol,
  then a default category label is  used. The available symbols and the
  order of categories on the  root documentation page is as below:

  * 'getting-started : High-level, introductory documentation, typeset
    at the same level as other category titles.

  * 'language : Documentation for a prominent programming language.

  * 'tool : Documentation for an executable.

  * 'gui-library : Documentation for GUI and graphics libraries.

  * 'net-library : Documentation for networking libraries.

  * 'parsing-library : Documentation for parsing libraries.

  * 'tool-library : Documentation for programming-tool libraries (i.e.,
    not important enough for the more prominent 'tool category).

  * 'interop : Documentation for interoperability tools and libraries.

  * All string categories as ordered by string<=?.

  * 'library : Documentation for libraries; this category is the default
    and used for unrecognized category symbols.

  * 'legacy : Documentation for deprecated libraries, languages, and
    tools.

  * 'experimental : Documentation for an experimental language or
    library.

  * 'other : Other documentation.

  * 'omit : Documentation that should not be listed on the root page or
    indexed for searching.

  * 'omit-start : Documentation that should not be listed on the root
    page but should be indexed for searching.

  If the category list has a second element, it must be a real number
  that designates the manual’s sorting position with the category;
  manuals with the same sorting position are ordered alphabetically. For
  a pair of manuals with sorting numbers n and m, the groups for the
  manuals are separated by space if (truncate (/ n 10))and (truncate (/
  m 10)) are different.

  The out-k specification is a hint on whether to break the document’s
  cross-reference information into multiple parts, which can reduce the
  time and memory use for resolving a cross-reference into the document.
  It must be a positive, exact integer, and the default is 1.

  The order-n specification is a hint for ordering document builds,
  since documentation references can be mutually recursive. The order
  hint can be any real number. A value of -10 or less disables running
  the document in parallel to other documents. The main Racket reference
  is given a value of -11, the search page is given a value of 10, and
  the default is 0.

  A directory for pre-rendered documentation is computed from the source
  file name by starting with the directory of the "info.rkt" file,
  adding "doc", and then using the document name (which is usually the
  source file’s name without a suffix); if such a directory exists and
  does not have a "synced.rktd" file, then it is treated as pre-rendered
  documentation and moved into place, in which case the documentation
  source file need not be present. Moving documentation into place may
  require no movement at all, depending on the way that the enclosing
  collection is installed, but movement includes adding a "synced.rktd"
  file to represent the installation.

  Changed in version 6.4: Allow a category to be a string instead of a
  symbol.

* release-note-files : (listof (cons/c string? (cons/c string? list?)))
  — A list of release-notes text files to link from the main
  documentation pages. Each note is itself represented as a list, and
  the list can specify auxiliary notes that are grouped with the main
  note.

  A release-note-files entry must be a value that can be generated from
  an expression matching the following entry grammar:

       entry = (list note ...)
                
         doc = (list label-string note-path)
             | (list label-string note-path order-integer)
             | (list label-string note-path order-integer
                     (list sub-note ...))
                
    sub-note = (list label-string note-path)

  The order-integer is used to order notes and defaults to 0.

* racket-launcher-names : (listof string?) —  A list of executable names
  to be generated in the installation’s executable directory to run
  Racket-based programs implemented by the collection. A parallel list
  of library names must be provided by racket-launcher-libraries or
  racket-launcher-flags.

  For each name, a launching executable is set up using
  make-racket-launcher.  The arguments are -l- and >colls</.../>file<,
  where >file< is the file named by racket-launcher-libraries and
  >colls</...  are the collections (and subcollections) of the
  "info.rkt" file.

  In addition,

    (build-aux-from-path
     (build-path (collection-path >colls< ...) >suffixless-file<))

  is provided for the optional aux argument (for icons, etc.) to
  make-racket-launcher, where >suffixless-file< is >file< without its
  suffix.

  If racket-launcher-flags is provided, it is used as a list of
  command-line arguments passed to racket instead of the above default,
  allowing arbitrary command-line arguments. If racket-launcher-flags is
  specified together with racket-launcher-libraries, then the flags will
  override the libraries, but the libraries can still be used to specify
  a name for build-aux-from-path (to find related information like icon
  files etc).

* racket-launcher-libraries : (listof path-string?) — A list of library
  names in parallel to racket-launcher-names.

* racket-launcher-flags : (listof string?) — A list of command-line flag
  lists, in parallel to racket-launcher-names.

* mzscheme-launcher-names, mzscheme-launcher-libraries, and
  mzscheme-launcher-flags — Backward-compatible variant of
  racket-launcher-names, etc.

* gracket-launcher-names : (listof string?)  —  Like
  racket-launcher-names, but for GRacket-based executables. The
  launcher-name list is treated in parallel to
  gracket-launcher-libraries and gracket-launcher-flags.

* gracket-launcher-libraries : (listof path-string?) — A list of library
  names in parallel to gracket-launcher-names.

* gracket-launcher-flags : (listof string?) — A list of command-line
  flag lists, in parallel to gracket-launcher-names.

* mred-launcher-names, mred-launcher-libraries, and mred-launcher-flags
  — Backward-compatible variant of gracket-launcher-names, etc.

* copy-foreign-libs : (listof (and/c path-string? relative-path?)) —
  Files to copy into a directory where foreign libraries are found by
  ffi-lib. If install-platform is defined, then the files are copied
  only if the current platform matches the definition.

  On Mac OS, when a Mach-O file is copied, if the copied file includes a
  library reference that starts @loader_path/, and if the referenced
  library exists in a different location among the paths listed by
  (get-lib-search-dirs), then the library reference is updated to an
  absolute path.

  On Unix, when an ELF file is copied, if the copied file includes an
  RPATH setting of $ORIGIN and the file is being installed to a
  user-specific location, then the file’s RPATH is adjusted to $ORIGIN:
  followed by the path to the main installation’s library directory as
  reported by (find-lib-dir).

  On Windows, deleting a previously installed foreign library may be
  complicated by a lock on the file, if it is in use. To compensate,
  raco setup deletes a foreign-library file by first renaming the file
  to have the prefix "raco-setup-delete-"; it then attempts to delete
  the renamed file and merely issues a warning on a failure to delete
  the renamed file. Meanwhile, in modes where raco setup removes
  uninstalled libraries, it attempts to delete any file in the
  foreign-library directory whose name starts with "raco-setup-delete-"
  (in an attempt to clean up after previous failures).

* move-foreign-libs : (listof (and/c path-string? relative-path?)) —
  Like copy-foreign-libs, but the original file is removed after it is
  copied (which makes sense for precompiled packages).

* copy-shared-files : (listof (and/c path-string? relative-path?)) —
  Files to copy into a directory where shared files are found. If
  install-platform is defined, then the files are copied only if the
  current platform matches the definition.

  On Windows, uninstalled files are deleted in the same way as for
  copy-foreign-libs, and the name prefix "raco-setup-delete-" is
  similarly special.

* move-shared-files : (listof (and/c path-string? relative-path?)) —
  Like copy-shared-files, but the original file is removed after it is
  copied (which makes sense for precompiled packages).

* copy-man-pages : (listof (and/c path-string? relative-path?
  filename-extension)) — Files to copy into a man directory. The file
  suffix determines its category; for example, .1 should be used for a
  man page describing an executable.

  On Windows, uninstalled files are deleted in the same way as for
  copy-foreign-libs, and the name prefix "raco-setup-delete-" is
  similarly special.

* move-man-pages : (listof (and/c path-string? relative-path?
  filename-extension)) — Like copy-man-pages, but the original file is
  removed after it is copied (which makes sense for precompiled
  packages).

* install-platform : platform-spec? — Determines whether files are
  copied or moved for copy-foreign-libs, move-foreign-libs,
  copy-shared-files, or move-shared-files. See matching-platform? for
  information on the way that the specification is compared to
  (system-type) and (system-library-subpath #f).

* install-collection : path-string? — A library module relative to the
  collection that provides installer. The installer procedure must
  accept one, two, three, or four arguments:

  * The first argument is a directory path to the parent of the Racket
    installation’s "collects" directory.

  * The second argument, if accepted, is a path to the collection’s own
    directory.

  * The third argument, if accepted, is a boolean indicating whether the
    collection is installed as user-specific (#t) or installation-wide
    (#f).

  * The fourth argument, if accepted, is a boolean indicating whether
    the collection is installed as installation-wide and should
    nevertheless avoid modifying the installation; an installer
    procedure that does not accept this argument is never called when
    the argument would be #t. An installer that does accept this
    argument is called with #t to that it can perform user-specific
    work, even though the collection is installed installation-wide.

* pre-install-collection : path-string? — Like install-collection,
  except that the corresponding installer procedures are called before
  the normal ".zo" build, instead of after. The provided procedure is
  pre-installer, so it can be provided by the same file that provides an
  installer procedure.

* post-install-collection : path-string?  — Like install-collection for
  a procedure that is called right after the install-collection
  procedure is executed. The --no-install flag can be provided to raco
  setup to disable install-collection and pre-install-collection, but
  not post-install-collection.  The post-install-collection function is
  therefore expected to perform operations that are always needed, even
  after an installation that contains pre-compiled files. The provided
  procedure is post-installer, so it can be provided by the same file
  that provides an installer procedure.

* assume-virtual-sources : any/c — A true value indicates that bytecode
  files without a corresponding source file should not be removed from
  "compiled" directories, and no files should not be removed when the
  --clean or -c flag is passed to raco setup.

* clean : (listof path-string?) —  A list of pathnames to be deleted
  when the --clean or -c flag is passed to raco setup. The pathnames
  must be relative to the collection. If any path names a directory,
  each of the files in the directory are deleted, but none of the
  subdirectories of the directory are checked. If the path names a file,
  the file is deleted. The default, if this flag is not specified, is to
  delete all files in the "compiled" subdirectory, and all of the files
  in the platform-specific subdirectory of the compiled directory for
  the current platform.

  Just as compiling ".zo" files will compile each module used by a
  compiled module, deleting a module’s compiled image will delete the
  ".zo" of each module that is used by the module. More specifically,
  used modules are determined when deleting a ".dep" file, which would
  have been created to accompany a ".zo" file when the ".zo" was built
  by raco setup or raco make (see [missing]). If the ".dep" file
  indicates another module, that module’s ".zo" is deleted only if it
  also has an accompanying ".dep" file. In that case, the ".dep" file is
  deleted, and additional used modules are deleted based on the used
  module’s ".dep" file, etc. Supplying a specific list of collections to
  raco setup disables this dependency-based deletion of compiled files.

* compile-omit-paths, compile-omit-files, and compile-include-files —
  Used indirectly via compile-collection-zos.

* module-suffixes and doc-module-suffixes — Used indirectly via
  get-module-suffixes.

4. "info.rkt" File Format

 #lang info          package: base ~
 #lang setup/infotab

In each collection, a special module file "info.rkt" provides general
information about a collection for use by various tools. For example, an
"info.rkt" file specifies how to build the documentation for a
collection, and it lists plug-in tools for DrRacket or commands for raco
that the collection provides.

The fields specified in an "info.rkt" file are documented in [missing]
for packages and in [missing] for collections.

Although an "info.rkt" file contains a module declaration, the
declaration has a highly constrained form. It must match the following
grammar of info-module:

     info-module = (module info info-mod-path
                     decl
                     ...)
                    
   info-mod-path = info
                 | setup/infotab
                 | (lib "info/main.rkt")
                 | (lib "setup/infotab.ss")
                 | (lib "setup/infotab.rkt")
                 | (lib "main.rkt" "info")
                 | (lib "infotab.rkt" "setup")
                 | (lib "infotab.ss" "setup")
                    
            decl = (define id info-expr)
                    
       info-expr = (quote datum)
                 | (quasiquote datum)
                 | (if info-expr info-expr info-expr)
                 | (info-primitive info-expr ...)
                 | id
                 | string
                 | number
                 | boolean
                    
  info-primitive = cons
                 | car
                 | cdr
                 | list
                 | list*
                 | reverse
                 | append
                 | equal?
                 | string-append
                 | make-immutable-hash
                 | hash
                 | hash-set
                 | hash-set*
                 | hash-remove
                 | hash-clear
                 | hash-update
                 | path->string
                 | build-path
                 | collection-path
                 | system-library-subpath
                 | getenv

For example, the following declaration could be the "info.rkt" library
of the "games" collection. It contains definitions for three info tags,
name, gracket-launcher-libraries, and gracket-launcher-names.

  #lang info
  (define name "Games")
  (define gracket-launcher-libraries '("main.rkt"))
  (define gracket-launcher-names     '("PLT Games"))

As illustrated in this example, an "info.rkt" file can use #lang
notation, but only with the info (or setup/infotab) language.

Although getenv is allowed in an info module, the get-info function
loads the module with an environment that prunes any variable not listed
in the PLT_INFO_ALLOW_VARS environment variable, which holds a list of
;-separated variable names. By default, the set of allowed environment
variables is empty.

See also get-info from setup/getinfo.

Changed in version 6.5.0.2 of package base: Added if, equal?, and
getenv.

5. Package Dependency Checking

When raco setup is run with no arguments,Unless --check-pkg-deps is
specified, dependency checking is disabled if any collection is
specified for raco setup. after building all collections and
documentation, raco setup checks package dependencies. Specifically, it
inspects compiled files and documentation to check that references
across package boundaries are reflected by dependency declarations in
each package-level "info.rkt" file (see [missing]).

Dependency checking in raco setup is intended as an aid to package
developers to help them declare dependencies correctly. The raco setup
process itself does not depend on package dependency declarations.
Similarly, a package with a missing dependency declaration may install
successfully for other users, as long as they happen to have the
dependencies installed already. A missing dependency creates trouble for
others who install a package without having the dependency installed
already.

Practically every package depends on the "base" package, which includes
the collections that are in a minimal variant of Racket. Declaring a
dependency on "base" may seem unnecessary, since its collections are
always installed. In a future version of Racket, however, the minimal
collections may change, and the new set of minimal collections will then
have a package name, such as "base2". Declaring a dependency on "base"
ensures forward compatibility, and raco setup complains if the
declaration is missing.

To accommodate the early stages of package development, missing
dependencies are not treated as an error for a package that has no
dependency declarations.

5.1. Declaring Build-Time Dependencies

A build-time dependency is one that is not present in a package if it is
converted to a binary package (see [missing]). For example, "tests" and
"scribblings" directories are stripped away in a binary package by
default, so cross-package references from directories with those names
are treated as build dependencies. Similarly, test and doc submodules
are stripped away, so references within those submodules create build
dependencies.

Build-time-only dependencies can be listed as build-deps instead of deps
in a package’s "info.rkt" file. Dependencies listed in deps, meanwhile,
are treated as both run-time and build-time dependencies. The advantage
of using build-deps, instead of listing all dependencies in deps, is
that a binary version of the package can install with fewer
dependencies.

5.2. How Dependency Checking Works

Dependency checking uses ".zo" files, associated ".dep" files (see
[missing]), and the documentation index. Dynamic references, such as
through dynamic-require, are not visible to the dependency checker; only
dependencies via require, define-runtime-module-path-index, and other
forms that cooperate with raco make are visible for dependency checking.

Dependency checking is sensitive to whether a dependency is needed only
as a build-time dependency. If raco setup detects that a missing
dependency could be added as a build-time dependency, it will suggest
the addition, but raco setup will not suggest converting a normal
dependency to a build-time dependency (since every normal dependency
counts as a build-time dependency, too).

6. API for Setup

 (require setup/setup) package: base ~

                                        *setup*
(setup [#:file file                              ~ ~
        #:collections collections                ~
        #:pkgs pkgs                              ~
        #:planet-specs planet-specs              ~
        #:make-user? make-user?                  ~
        #:avoid-main? avoid-main?                ~
        #:make-docs? make-docs?                  ~
        #:make-doc-index? make-doc-index?        ~
        #:force-user-docs? force-user-docs?      ~
        #:check-pkg-deps? check-pkg-deps?        ~
        #:fix-pkg-deps? fix-pkg-deps?            ~
        #:unused-pkg-deps? unused-pkg-deps?      ~
        #:clean? clean?                          ~
        #:tidy? tidy?                            ~
        #:recompile-only? recompile-only?        ~
        #:jobs jobs                              ~
        #:fail-fast? fail-fast?                  ~
        #:get-target-dir get-target-dir])   -> boolean? ~
  file : (or/c #f path-string?) = #f ~
  collections : (or/c #f (listof (listof path-string?))) = #f ~
  pkgs : (or/c #f (listof string?)) = #f ~
  planet-specs : (or/c #f ~
                       (listof (list/c string?
                                       string?
                                       exact-nonnegative-integer?
                                       exact-nonnegative-integer?)))
               = #f
  make-user? : any/c = #t ~
  avoid-main? : any/c = #f ~
  make-docs? : any/c = #t ~
  make-doc-index? : any/c = #f ~
  force-user-docs? : any/c = #f ~
  check-pkg-deps? : any/c = #f ~
  fix-pkg-deps? : any/c = #f ~
  unused-pkg-deps? : any/c = #f ~
  clean? : any/c = #f ~
  tidy? : any/c = #f ~
  recompile-only? : any/c = #f ~
  jobs : exact-nonnegative-integer? = #f ~
  fail-fast? : any/c = #f ~
  get-target-dir : (or/c #f (-> path-string?)) = #f ~

Runs raco setup with various options:

* file — if not #f, installs file as a ".plt" archive.

* collections — if not #f, constrains setup to the named collections
  (along with pkgs and planet-specs, if any)

* pkgs — if not #f, constrains setup to the named packages (along with
  collections and planet-specs, if any)

* planet-spec — if not #f, constrains setup to the named PLaneT packages
  (along with collections and pkgs, if any)

* make-user? — if #f, disables any user-specific setup actions

* avoid-main? — if true, avoids setup actions that affect the main
  installation, as opposed to user directories

* make-docs? — if #f, disables any documentation-specific setup actions

* make-doc-index? — if true, builds documentation index collections in
  addition to collections, assuming that documentation is built

* force-user-docs? — if true, then when building documentation, creates
  a user-specific documentation entry point even if it has the same
  content as the installation

* check-pkg-deps? — if true, enables package-dependency checking even
  when collections, pkgs, or planet-specs is non-#f.

* fix-pkg-deps? — if true, implies check-pkg-deps? and attempts to
  automatically correct discovered package-dependency problems

* unused-pkg-deps? — if true, implies check-pkg-deps? and also reports
  dependencies that appear to be unused

* clean? — if true, enables cleaning mode instead of setup mode

* tidy? — if true, enables global tidying of documentation and metadata
  indexes even when collections or planet-specs is non-#f

* recompile-only? — if true, disallows compilation from source, allowing
  only timestamp adjustments and recompilation from machine-independent
  form

* jobs — if not #f, determines the maximum number of parallel tasks used
  for setup

* fail-fast? — if true, breaks the current thread as soon as an error is
  discovered

* get-target-dir — if not #f, treated as a value for
  current-target-directory-getter

The result is #t if raco setup completes without error, #f otherwise.

Instead of using PLT_COMPILED_FILE_CHECK, setup is sensitive to the
use-compiled-file-check parameter.

Changed in version 6.1 of package base: Added the fail-fast? argument.
Changed in version 6.1.1: Added the force-user-docs? argument. Changed
in version 7.2.0.7: Added the check-pkg-deps?, fix-pkg-deps? , and
unused-pkg-deps? arguments. Changed in version 7.2.0.8: Added the
recompile-only? argument.

6.1. raco setup Unit

 (require setup/setup-unit) package: compiler-lib ~

The setup/setup-unit library provides raco setup in unit form. The
associated setup/option-sig and setup/option-unit libraries provides the
interface for setting options for the run of raco setup.

For example, to unpack a single ".plt" archive "x.plt", set the archives
parameter to (list "x.plt") and leave specific-collections as null.

Link the options and setup units so that your option-setting code is
initialized between them, e.g.:

  (compound-unit
    ...
    (link ...
      [((OPTIONS : setup-option^)) setup:option@] ~
      [() my-init-options@ OPTIONS]
      [() setup@ OPTIONS ...])
    ...)

setup@ : unit? ~

Imports

* setup-option^

* compiler^

* compiler:option^

* launcher^

* dynext:file^

and exports nothing. Invoking setup@ starts the setup process.

6.2. Options Unit

 (require setup/option-unit) package: compiler-lib ~

setup:option@ : unit? ~

Imports nothing and exports setup-option^.

6.3. Options Signature

 (require setup/option-sig) package: compiler-lib ~

setup-option^ : signature ~

Provides parameters used to control raco setup in unit form.

                                        *setup-program-name*
(setup-program-name) -> string? ~
(setup-program-name name) -> void?
  name : string? ~

The prefix used when printing status messages. The default is "raco
setup".
(setup-compiled-file-paths)
 -> (or/c #f (listof (and/c path? relative-path?)))
(setup-compiled-file-paths paths) -> void?
  paths : (or/c #f (listof (and/c path? relative-path?))) ~

If not #f, supplies a value like the one for use-compiled-file-paths to
control operations such as cleaning, where use-compiled-file-paths may
have been set to null to avoid loading bytecode.
Added in version 1.7 of package compiler-lib.
(verbose) -> boolean?
(verbose on?) -> void?
  on? : any/c ~

If on, prints messages from make to stderr. The default is #f.
(make-verbose) -> boolean?
(make-verbose on?) -> void?
  on? : any/c ~

If on, verbose make. The default is #f.
(compiler-verbose) -> boolean?
(compiler-verbose on?) -> void?
  on? : any/c ~

If on, verbose compiler. The default is #f.
(clean) -> boolean?
(clean on?) -> void?
  on? : any/c ~

If on, delete ".zo" and ".so"/".dll"/".dylib" files in the specified
collections. The default is #f.
(compile-mode) -> (or/c path? #f)
(compile-mode path) -> void?
  path : (or/c path? #f) ~

If a path is given, use a ".zo" compiler other than plain compile, and
build to (build-path "compiled" (compile-mode)). The default is #f.
(make-zo) -> boolean?
(make-zo on?) -> void?
  on? : any/c ~

If on, compile ".zo". The default is #t.
(make-info-domain) -> boolean?
(make-info-domain on?) -> void?
  on? : any/c ~

If on, update "info-domain/compiled/cache.rkt" for each collection path.
The default is #t.
(make-launchers) -> boolean?
(make-launchers on?) -> void?
  on? : any/c ~

If on, make collection "info.rkt"-specified launchers and man pages. The
default is #t.
(make-foreign-lib) -> boolean?
(make-foreign-lib on?) -> void?
  on? : any/c ~

If on, install collection "info.rkt"-specified libraries. The default is
#t.
(make-docs) -> boolean?
(make-docs on?) -> void?
  on? : any/c ~

If on, build documentation. The default is #t.
(make-user) -> boolean?
(make-user on?) -> void?
  on? : any/c ~

If on, build the user-specific collection tree. The default is #t.
(make-planet) -> boolean?
(make-planet on?) -> void?
  on? : any/c ~

If on, build the planet cache. The default is #t.
(avoid-main-installation) -> boolean?
(avoid-main-installation on?) -> void?
  on? : any/c ~

If on, avoid building bytecode in the main installation tree when
building other bytecode (e.g., in a user-specific collection). The
default is #f.
(make-tidy) -> boolean?
(make-tidy on?) -> void?
  on? : any/c ~

If on, remove metadata cache information and  documentation for
non-existent collections (to clean up after removal)  even when
specific-collections or specific-planet-dirs  is non-'() or make-only is
true. The default is #f.
(call-install) -> boolean?
(call-install on?) -> void?
  on? : any/c ~

If on, call collection "info.rkt"-specified setup code. The default is
#t.
(call-post-install) -> boolean?
(call-post-install on?) -> void?
  on? : any/c ~

If on, call collection "info.rkt"-specified post-install code. The
default is #t.
(pause-on-errors) -> boolean?
(pause-on-errors on?) -> void?
  on? : any/c ~

If on, in the event of an error, prints a summary error and waits for
stdin input before terminating. The default is #f.
(parallel-workers) -> exact-nonnegative-integer?
(parallel-workers num) -> void?
  num : exact-nonnegative-integer? ~

Determines the number of places to use for compiling bytecode and for
building the documentation. The default is (min (processor-count) 8).
(fail-fast) -> boolean?
(fail-fast on?) -> void?
  on? : any/c ~

If on, breaks the original thread as soon as an error is discovered. The
default is #f.
Added in version 1.2 of package compiler-lib.
(force-unpacks) -> boolean?
(force-unpacks on?) -> void?
  on? : any/c ~

If on, ignore version and already-installed errors when unpacking a
".plt" archive. The default is #f.
(specific-collections) -> (listof (listof path-string?))
(specific-collections colls) -> void?
  colls : (listof (listof path-string?)) ~

A list of collections to set up; the empty list means set-up all
collections if the archives list and specific-planet-dirs is also '().
The default is '().
(specific-planet-dirs)
 -> (listof (list/c string?
                    string?
                    exact-nonnegative-integer?
                    exact-nonnegative-integer?))
(specific-planet-dirs dir) -> void?
  dir : (listof (list/c string? ~
                        string?
                        exact-nonnegative-integer?
                        exact-nonnegative-integer?))

A list of planet package version specs to set up; the empty list means
to set-up all planet collections if the archives list and
specific-collections is also '(). The default is '().
(make-only) -> boolean?
(make-only on?) -> void?
  on? : any/c ~

If true, set up no collections if specific-collections and
specific-planet-dirs are both '().
(archives) -> (listof path-string?)
(archives arch) -> void?
  arch : (listof path-string?) ~

A list of ".plt" archives to unpack; any collections specified by the
archives are set-up in addition to the collections listed in
specific-collections. The default is null.
(archive-implies-reindex) -> boolean?
(archive-implies-reindex on?) -> void?
  on? : any/c ~

If on, when archives has a non-empty list of packages, if any
documentation is built, then suitable documentation start pages, search
pages, and master index pages are rebuilt. The default is #t.
(current-target-directory-getter) -> (-> path-string?)
(current-target-directory-getter thunk) -> void?
  thunk : (-> path-string?) ~

A thunk that returns the target directory for unpacking a relative
".plt" archive; when unpacking an archive, either this or the procedure
in current-target-plt-directory-getter will be called. The default is
current-directory.
(current-target-plt-directory-getter)
 -> (path-string?
     path-string?
     (listof path-string?) . -> . path-string?)
(current-target-plt-directory-getter proc) -> void?
  proc : (path-string? ~
          path-string?
          (listof path-string?) . -> . path-string?)

A procedure that takes a preferred path, a path to the parent of the
main "collects" directory, and a list of path choices; it returns a path
for a "plt-relative" install; when unpacking an archive, either this or
the procedure in current-target-directory-getter will be called, and in
the former case, this procedure may be called multiple times. The
default is (lambda (preferred main-parent-dir choices) preferred).

6.4. Setup Start Module

 (require setup) package: base ~

The setup library implements raco setup, including the part that
bootstraps raco setup if its own implementation needs to be compiled.

When running setup via racket, supply the -N raco to ensure that
command-line arguments are parsed the same way as for raco setup, as
opposed to a legacy command-line mode.

7. API for Installing ".plt" Archives

The setup/plt-single-installer module provides a function for installing
a single ".plt" file.

7.1. Non-GUI Installer

 (require setup/plt-single-installer) package: base ~

                                        *run-single-installer*
(run-single-installer                                                       ~
                       file                                                
                       get-dir-proc                                        
                      [#:show-beginning-of-file? show-beginning-of-file?])  ~
 -> void?
  file : path-string? ~
  get-dir-proc : (-> (or/c path-string? #f)) ~
  show-beginning-of-file? : any/c = #f ~

Creates a separate thread and namespace, runs the installer in that
thread with the new namespace, and returns when the thread completes or
dies. It also creates a custodian (see [missing]) to manage the created
thread, sets the exit handler for the thread to shut down the custodian,
and explicitly shuts down the custodian when the created thread
terminates or dies.

The get-dir-proc procedure is called if the installer needs a target
directory for installation, and a #f result means that the user canceled
the installation. Typically, get-dir-proc is current-directory.

If show-beginning-of-file? is a true value and the installation fails,
then run-single-installer prints the first 1,000 characters of the file
(in an attempt to help debug the cause of failures).

                                        *install-planet-package*
(install-planet-package file directory spec) -> void? ~
  file : path-string? ~
  directory : path-string? ~
  spec : (list/c string? string? ~
                 (listof string?)
                 exact-nonnegative-integer?
                 exact-nonnegative-integer?)

Similar to run-single-installer, but runs the setup process to install
the archive file into directory as the PLaneT package described by spec.
The user-specific documentation index is not rebuilt, so
reindex-user-documentation should be run after a set of PLaneT packages
are installed.

                                        *reindex-user-documentation*
(reindex-user-documentation) -> void? ~

Similar to run-single-installer, but runs only the part of the setup
process that rebuilds the user-specific documentation start page, search
page, and master index.

                                        *clean-planet-package*
(clean-planet-package directory spec) -> void? ~
  directory : path-string? ~
  spec : (list/c string? string? ~
                 (listof string?)
                 exact-nonnegative-integer?
                 exact-nonnegative-integer?)

Undoes the work of install-planet-package. The user-specific
documentation index is not rebuilt, so reindex-user-documentation should
be run after a set of PLaneT packages are removed.

8. API for Finding Installation Directories

 (require setup/dirs) package: base ~

The setup/dirs library provides several procedures for locating
installation directories. Many of these paths can be configured through
the configuration directory (see [missing]).

In cross-platform build mode (see API for Cross-Platform Configuration),
the functions provided by setup/dirs generally report target-system
paths, instead of current-system paths. The exceptions are
get-lib-search-dirs and find-dll-dir, which report current-system paths
while get-cross-lib-search-dirs and find-cross-dll-dir report
target-system paths.

                                        *find-collects-dir*
(find-collects-dir) -> (or/c path? #f) ~

Returns a path to the installation’s main "collects" directory, or #f if
none can be found. A #f result is likely only in a stand-alone
executable that is distributed without libraries.

                                        *find-user-collects-dir*
(find-user-collects-dir) -> path? ~

Returns a path to the user-specific "collects" directory; the directory
indicated by the returned path may or may not exist.

                                        *get-collects-search-dirs*
(get-collects-search-dirs) -> (listof path?) ~

Returns the same result as (current-library-collection-paths), which
means that this result is not sensitive to the value of the
use-user-specific-search-paths parameter.

                                        *get-main-collects-search-dirs*
(get-main-collects-search-dirs) -> (listof path?) ~

Returns a list of paths to installation "collects" directories,
including the result of find-collects-dir. These directories are
normally included in the result of (current-library-collection-paths),
but a PLTCOLLECTS setting or change to the parameter may cause them to
be omitted. Any other path in (current-library-collection-paths) is
treated as user-specific. The directories indicated by the returned
paths may or may not exist.

                                        *find-config-dir*
(find-config-dir) -> (or/c path? #f) ~

Returns a path to the installation’s "etc" directory, which contains
configuration and package information—including configuration of some of
the other directories (see [missing]). A #f result indicates that no
configuration directory is available.

                                        *find-links-file*
(find-links-file) -> (or/c path? #f) ~

Returns a path to the installation’s collection links file.  The file
indicated by the returned path may or may not exist. A #f result
indicates that no links file is available.

See also 'links-file in [missing].

                                        *find-user-links-file*
(find-user-links-file [vers]) -> path? ~
  vers : string? = (get-installation-name) ~

Returns a path to the user’s collection links file.  The file indicated
by the returned path may or may not exist.

                                        *get-links-search-files*
(get-links-search-files) -> (listof path?) ~

Returns a list of paths to installation collection links files to search
in order. (Normally, the result includes the result of
(find-links-file), which is where new installation-wide links are
installed by raco link or links.) The files indicated by the returned
paths may or may not exist.

See also 'links-search-files in [missing].

                                        *find-pkgs-dir*
(find-pkgs-dir) -> (or/c path? #f) ~

Returns a path to the directory containing packages with installation
scope; the directory indicated by the returned path may or may not
exist. A #f result indicates that no package-installation directory is
available.

See also 'pkgs-dir in [missing].

                                        *find-user-pkgs-dir*
(find-user-pkgs-dir [vers]) -> path? ~
  vers : string? = (get-installation-name) ~

Returns a path to the directory containing packages with user-specific
scope for installation name vers; the directory indicated by the
returned path may or may not exist.

                                        *get-pkgs-search-dirs*
(get-pkgs-search-dirs) -> (listof path?) ~

Returns a list of paths to the directories containing packages in
installation scope.  (Normally, the result includes the result of
(find-pkgs-dir), which is where new packages are installed by raco pkg
install.) The directories indicated by the returned paths may or may not
exist.

See also 'pkgs-search-dirs in [missing].

                                        *find-doc-dir*
(find-doc-dir) -> (or/c path? #f) ~

Returns a path to the installation’s "doc" directory. The result is #f
if no such directory is available.

See also 'doc-dir in [missing].

                                        *find-user-doc-dir*
(find-user-doc-dir) -> path? ~

Returns a path to a user-specific "doc" directory. The directory
indicated by the returned path may or may not exist.

                                        *get-doc-search-dirs*
(get-doc-search-dirs) -> (listof path?) ~

Returns a list of paths to search for documentation, not including
documentation stored in individual collections. Unless it is configured
otherwise, the result includes any non-#f result of (find-doc-dir) and
(find-user-doc-dir)—but the latter is included only if the value of the
use-user-specific-search-paths parameter is #t.

See also 'doc-search-dirs in [missing].

                                        *find-lib-dir*
(find-lib-dir) -> (or/c path? #f) ~

Returns a path to the installation’s "lib" directory, which contains
libraries and other build information. The result is #f if no such
directory is available.

See also 'lib-dir in [missing].

                                        *find-user-lib-dir*
(find-user-lib-dir) -> path? ~

Returns a path to a user-specific "lib" directory; the directory
indicated by the returned path may or may not exist.

                                        *get-lib-search-dirs*
(get-lib-search-dirs) -> (listof path?) ~

Returns a list of paths to search for foreign libraries.

Unless it is configured otherwise, and except in cross-platform build
mode, the result includes any non-#f result of (find-lib-dir) and
(find-user-lib-dir)—but the latter is included only if the value of the
use-user-specific-search-paths parameter is #t.

In cross-platform build mode (see API for Cross-Platform Configuration),
get-lib-search-dirs reports a result suitable for the current system,
instead of the target system. See also get-cross-lib-search-dirs.

See also 'lib-search-dirs in [missing].

Changed in version 6.1.1.4 of package base: Dropped (find-dll-dir) from
the set of paths to explicitly include in the default. Changed in
version 6.9.0.1: Changed behavior in cross-platform build mode.

                                        *get-cross-lib-search-dirs*
(get-cross-lib-search-dirs) -> (listof path?) ~

Like get-lib-search-dirs, but in cross-platform build mode, reports
directories for the target system (including any non-#f result of
(find-lib-dir), etc.) instead of the current system.

Added in version 6.9.0.1 of package base.

                                        *find-dll-dir*
(find-dll-dir) -> (or/c path? #f) ~

Returns a path to the directory that contains DLLs for use with the
current executable (e.g., "libracket.dll" on Windows). The result is #f
if no such directory is available, or if no specific directory is
available (i.e., other than the platform’s normal search path).

In cross-platform build mode (see API for Cross-Platform Configuration),
find-dll-dir reports a result suitable for the current system, instead
of the target system. See also find-cross-dll-dir.

Changed in version 6.9.0.1 of package base: Changed behavior in
cross-platform build mode.

                                        *find-cross-dll-dir*
(find-cross-dll-dir) -> (or/c path? #f) ~

Like find-dll-dir, but in cross-platform build mode, reports a directory
for the target system instead of the current system.

Added in version 6.9.0.1 of package base.

                                        *find-share-dir*
(find-share-dir) -> (or/c path? #f) ~

Returns a path to the installation’s "share" directory, which contains
installed packages and other platform-independent files. The result is
#f if no such directory is available.

See also 'share-dir in [missing].

                                        *find-user-share-dir*
(find-user-share-dir) -> path? ~

Returns a path to a user-specific "share" directory; the directory
indicated by the returned path may or may not exist.

                                        *find-include-dir*
(find-include-dir) -> (or/c path? #f) ~

Returns a path to the installation’s "include" directory, which contains
".h" files for building Racket extensions and embedding programs. The
result is #f if no such directory is available.

See also 'include-dir in [missing].

                                        *find-user-include-dir*
(find-user-include-dir) -> path? ~

Returns a path to a user-specific "include" directory; the directory
indicated by the returned path may or may not exist.

                                        *get-include-search-dirs*
(get-include-search-dirs) -> (listof path?) ~

Returns a list of paths to search for ".h" files. Unless it is
configured otherwise, the result includes any non-#f result of
(find-include-dir) and (find-user-include-dir)—but the latter is
included only if the value of the use-user-specific-search-paths
parameter is #t.

See also 'include-search-dirs in [missing].

                                        *find-console-bin-dir*
(find-console-bin-dir) -> (or/c path? #f) ~

Returns a path to the installation’s executable directory, where the
stand-alone Racket executable resides. The result is #f if no such
directory is available.

See also 'bin-dir in [missing].

                                        *find-gui-bin-dir*
(find-gui-bin-dir) -> (or/c path? #f) ~

Returns a path to the installation’s executable directory, where the
stand-alone GRacket executable resides. The result is #f if no such
directory is available.

See also 'gui-bin-dir in [missing].

                                        *find-user-console-bin-dir*
(find-user-console-bin-dir) -> path? ~

Returns a path to the user’s executable directory; the directory
indicated by the returned path may or may not exist.

                                        *find-user-gui-bin-dir*
(find-user-gui-bin-dir) -> path? ~

Returns a path to the user’s executable directory for graphical
programs; the directory indicated by the returned path may or may not
exist.

                                        *find-apps-dir*
(find-apps-dir) -> (or/c path? #f) ~

Returns a path to the installation’s directory ".desktop" files (for
Unix). The result is #f if no such directory exists.

See also 'apps-dir in [missing].

                                        *find-user-apps-dir*
(find-user-apps-dir) -> path? ~

Returns a path to the user’s directory for ".desktop" files (for Unix);
the directory indicated by the returned path may or may not exist.

                                        *find-man-dir*
(find-man-dir) -> (or/c path? #f) ~

Returns a path to the installation’s man-page directory. The result is
#f if no such directory exists. See also 'man-dir in [missing].

                                        *find-user-man-dir*
(find-user-man-dir) -> path? ~

Returns a path to the user’s man-page directory; the directory indicated
by the returned path may or may not exist.

                                        *get-doc-search-url*
(get-doc-search-url) -> string? ~

Returns a string that is used by the documentation system, augmented
with a version and search-key query, for remote documentation links.

See also 'doc-search-url in [missing].

                                        *get-doc-open-url*
(get-doc-open-url) -> (or/c string? #f) ~

Returns #f or a string for a root URL to be used as an alternative to
opening a local file for documentation. A non-#f configuration means
that DrRacket, for example, performs keyword searches for documentation
via the specified URL instead of from locally installed documentation.

See also 'doc-open-url in [missing].

Added in version 6.0.1.6 of package base.

                                        *get-installation-name*
(get-installation-name) -> string? ~

Returns the current installation’s name, which is often (version) but
can be configured via 'installation-name in "config.rktd" (see
[missing]).

                                        *get-build-stamp*
(get-build-stamp) -> (or/c #f string?) ~

Returns a string that identifies an installation build, which can be
used to augment the Racket version number to more specifically identify
the build. An empty string is normally produced for a release build. The
result is #f if no build stamp is available.

                                        *get-absolute-installation?*
(get-absolute-installation?) -> boolean? ~

Returns #t if this installation uses absolute path names for executable
and library references, #f otherwise.

                                        *find-addon-tethered-console-bin-dir*
(find-addon-tethered-console-bin-dir) -> (or/c #f path?) ~
(find-addon-tethered-gui-bin-dir) -> (or/c #f path?)

Returns a path to a user-specific directory to hold an extra copy of
each installed executable, where the extra copy is created by raco setup
and tethered to a particular result for (find-system-path 'addon-dir)
and (find-config-dir).

Unlike other directories, which are configured via "config.rktd" in the
(find-config-dir) directory (see [missing]), these paths are configured
via 'addon-tethered-console-bin-dir and 'addon-tethered-gui-bin-dir
entries in "config.rktd" in (build-path (find-system-path 'addon-dir)
"etc"). If no configuration is present, the result from the
corresponding function, find-addon-tethered-console-bin-dir or
find-addon-tethered-gui-bin-dir, is #f instead of a path.

The intent of this protocol is to support a kind of sandbox: an
installation that is more specific than user-specific, and where copies
of executables such as racket serve as entry points into the sandbox.
Assuming that the addon directory is set to a directory other than the
user’s default addon directory when raco setup creates the executable
copies, then further package build and setup operations through the
entry points will be confined to the sandbox and not affect a user’s
default environment.

Added in version 6.5.0.2 of package base.

                                        *find-config-tethered-console-bin-dir*
(find-config-tethered-console-bin-dir) -> (or/c #f path?) ~
(find-config-tethered-gui-bin-dir) -> (or/c #f path?)

Similar to find-addon-tethered-console-bin-dir and
find-addon-tethered-gui-bin-dir, but configured via "config.rktd" in the
(find-config-dir) directory (see [missing]) and triggers executables
that are tethered only to a particular value of (find-config-dir).

Added in version 6.5.0.2 of package base.

9. API for Reading "info.rkt" Files

 (require setup/getinfo) package: base ~

The setup/getinfo library provides functions for accessing fields in
"info.rkt" files. The file format for "info.rkt" files is documented in
[missing].

                                        *get-info*
(get-info  collection-names           ~
          [#:namespace namespace      ~
           #:bootstrap? bootstrap?])  ~
 -> (or/c
     (symbol? [(-> any)] . -> . any)
     #f)
  collection-names : (listof string?) ~
  namespace : (or/c namespace? #f) = #f ~
  bootstrap? : any/c = #f ~

Accepts a list of strings naming a collection or sub-collection, and
calls get-info/full with the full path corresponding to the named
collection and the namespace argument.

                                        *get-info/full*
(get-info/full  path                       ~
               [#:namespace namespace      ~
                #:bootstrap? bootstrap?])  ~
 -> (or/c (->* (symbol?) ((-> any)) any)
          #f)
  path : path-string? ~
  namespace : (or/c namespace? #f) = #f ~
  bootstrap? : any/c = #f ~

Accepts a path to a directory. If it finds either a well-formed
"info.rkt" file or an "info.ss" file (with preference for the "info.rkt"
file), it returns an info procedure that accepts either one or two
arguments. The first argument to the info procedure is always a symbolic
name, and the result is the value of the name in the "info.rkt" file, if
the name is defined. The optional second argument, thunk, is a procedure
that takes no arguments to be called when the name is not defined; the
result of the info procedure is the result of the thunk in that case. If
the name is not defined and no thunk is provided, then an exception is
raised.

The get-info/full function returns #f if there is no "info.rkt" (or
"info.ss") file in the directory. If there is a "info.rkt" (or
"info.ss") file that has the wrong shape (i.e., not a module using info
or setup/infotab), or if the "info.rkt" file fails to load, then an
exception is raised. If the "info.rkt" file loaded, get-info/full
returns the get-info file. If the "info.rkt" file does not exist, then
get-info/full does the same checks for the "info.ss" file, either
raising an exception or returning the get-info function from the
"info.ss" file.

The "info.rkt" (or "info.ss") module is loaded into namespace if it is
not #f, or a private, weakly-held namespace otherwise.

If bootstrap? is true, then use-compiled-file-paths is set to '() while
reading "info.rkt" (or "info.ss"), in case an existing compiled file is
broken. Furthermore, the info and setup/infotab modules are attached to
namespace from the namespace of get-info/full before attempting to load
"info.rkt" (or "info.ss").

As the module is loaded, the environment variable set is pruned to
contain only environment variables that are listed in the
PLT_INFO_ALLOW_VARS environment variable, which contains a ;-separated
list of names. By default, the list of allowed variable names is empty.

Changed in version 6.5.0.2 of package base: Added environment-variable
pruning and PLT_INFO_ALLOW_VARS support.

                                        *find-relevant-directories*
(find-relevant-directories syms [mode]) -> (listof path?) ~
  syms : (listof symbol?) ~
  mode : (or/c 'preferred 'all-available 'no-planet 'no-user) ~
       = 'preferred

Returns a list of paths identifying collections and installed PLaneT
packages whose "info.rkt" file defines one or more of the given symbols.
The result is based on a cache that is computed by raco setup.

Note that the cache may be out of date by the time you call
get-info/full, so do not assume that every returned directory’s
"info.rkt" file will supply one of the requested symbols.

The result is in a canonical order (sorted lexicographically by
directory name), and the paths it returns are suitable for providing to
get-info/full.

If mode is specified, it must be either 'preferred (the default),
'all-available, 'no-planet, or 'no-user. If mode is 'all-available,
find-relevant-directories returns all installed directories whose info
files contain the specified symbols—for instance, all versions of all
installed PLaneT packages will be searched if 'all-available is
specified. If mode is 'preferred, then only a subset of “preferred”
packages will be searched: only the directory containing the most recent
version of any PLaneT package will be returned. If mode is 'no-planet,
then PLaneT packages are not included in the search. If mode is
'no-user, then only installation-wide directories are searched, which
means omitting PLaneT package directories.

Collection links from the installation-wide collection links file or
packages with installation scope are cached with the installation’s main
"lib" directory, and links from the user-specific collection links file
and packages are cached with the user-specific directory (build-path
(find-system-path 'addon-dir) "collects") for all-version cases, and in
(build-path (find-system-path 'addon-dir) (version) "collects") for
version-specific cases.

                                        *find-relevant-directory-records*
(find-relevant-directory-records syms key) ~
 -> (listof directory-record?)
  syms : (listof symbol?) ~
  key : (or/c 'preferred 'all-available 'no-planet 'no-user) ~

Like find-relevant-directories, but returns directory-record structs
instead of path?s.

                                        *struct*
(struct directory-record (maj min spec path syms) ~
    #:extra-constructor-name make-directory-record) ~
  maj : integer? ~
  min : integer? ~
  spec : any/c ~
  path : path? ~
  syms : (listof symbol?) ~

A struct that records information about a collection or a PLaneT package
that has been installed. Collections will have the major version being 1
and the minor version being 0. The spec field is a quoted module spec;
the path field is where the info.rkt file for this collection or PLaneT
package exists on the filesystem; the syms field holds the identifiers
defined in that file.

                                        *reset-relevant-directories-state!*
(reset-relevant-directories-state!) -> void? ~

Resets the cache used by find-relevant-directories.

10. API for Relative Paths

The Racket installation tree can usually be moved around the filesystem.
To support this, care must be taken to avoid absolute paths.  The
following two APIs cover two aspects of this: a way to convert a path to
a value that is relative to the "collects" tree, and a way to display
such paths (e.g., in error messages).

10.1. Representing Collection-Based Paths

 (require setup/collects) package: base ~

                                        *path->collects-relative*
(path->collects-relative path            ~
                         #:cache cache)  ~
 -> (or/c path-string?
          (cons/c 'collects
                  (cons/c bytes? (non-empty-listof bytes?))))
  path : path-string? ~
  cache : (or/c #f (and/c hash? (not/c immutable?))) ~

Checks whether path (normalized by path->complete-path and simplify-path
with #f as its second argument) matches the result of
collection-file-path. If so, the result is a list starting with
'collects and containing the relevant path elements as byte strings. If
not, the path is returned as-is.

The cache argument is used with path->pkg, if needed.

                                        *collects-relative->path*
(collects-relative->path rel) -> path-string? ~
  rel : (or/c path-string? ~
              (cons/c 'collects
                      (cons/c bytes? (non-empty-listof bytes?))))

The inverse of path->collects-relative: if rel is a pair that starts
with 'collects, then it is converted back to a path using
collection-file-path.

                                        *path->module-path*
(path->module-path path #:cache cache) ~ ~
 -> (or/c path-string? module-path?)
  path : path-string? ~
  cache : (or/c #f (and/c hash? (not/c immutable?))) ~

Like path->collects-relative, but the result is either path or a
normalized (in the sense of collapse-module-path) module path.

10.2. Representing Paths Relative to "collects"

 (require setup/main-collects) package: base ~

                                        *path->main-collects-relative*
(path->main-collects-relative path) ~
 -> (or/c path? (cons/c 'collects (non-empty-listof bytes?)))
  path : (or/c bytes? path-string?) ~

Checks whether path has a prefix that matches the prefix to the main
"collects" directory as determined by (find-collects-dir). If so, the
result is a list starting with 'collects and containing the remaining
path elements as byte strings. If not, the path is returned as-is.

The path argument should be a complete path. Applying simplify-path
before path->main-collects-relative is usually a good idea.

For historical reasons, path can be a byte string, which is converted to
a path using bytes->path.

See also collects-relative->path.

                                        *main-collects-relative->path*
(main-collects-relative->path rel) -> path> ~
  rel : (or/c bytes? ~
              path-string?
              (cons/c 'collects (non-empty-listof bytes?)))

The inverse of path->main-collects-relative: if rel is a pair that
starts with 'collects, then it is converted back to a path relative to
(find-collects-dir).

10.3. Representing Paths Relative to the Documentation

 (require setup/main-doc) package: base ~

                                        *path->main-doc-relative*
(path->main-doc-relative path) ~
 -> (or/c path? (cons/c 'doc (non-empty-listof bytes?)))
  path : (or/c bytes? path-string?) ~

Like path->main-collects-relative, except that it checks for a prefix
relative to (find-doc-dir) and returns a list starting with 'doc if so.

                                        *main-doc-relative->path*
(main-doc-relative->path rel) -> path> ~
  rel : (or/c bytes? ~
              path-string?
              (cons/c 'doc (non-empty-listof bytes?)))

Like path->main-collects-relative, except it is the inverse of
path->main-doc-relative.

10.4. Displaying Paths Relative to a Common Root

 (require setup/path-to-relative) package: base ~

                                        *path->relative-string/library*
(path->relative-string/library  path                 ~
                               [default             
                                #:cache cache]) -> any/c ~
  path : path-string? ~
  default : (or/c (-> path-string? any/c) any/c) ~
          = (lambda (x) (if (path? x) (path->string x) x))
  cache : (or/c #f (and/c hash? (not/c immutable?))) = #f ~

Produces a string suitable for display in error messages.  If the path
is an absolute one that is inside a package, the result is a string that
begins with "<pkgs>/". If the path is an absolute one that is inside the
"collects" tree, the result is a string that begins with "<collects>/".
Similarly, a path in the user-specific collects results in a prefix of
"<user-collects>/", a PLaneT path results in "<planet>/", and a path
into documentation results in "<doc>/" or "<user-doc>/".

If cache is not #f, it is used as a cache argument for pkg->path to
speed up detection and conversion of package paths.

If the path is not absolute, or if it is not in any of these, it is
returned as-is (converted to a string if needed).  If default is given,
it specifies the return value instead: it can be a procedure that is
applied onto the path to get the result, or the result itself.

Note that this function can return a non-string only if default is given
and it does not return a string.

                                        *path->relative-string/setup*
(path->relative-string/setup  path                 ~
                             [default             
                              #:cache cache]) -> any/c ~
  path : path-string? ~
  default : (or/c (-> path-string? any/c) any/c) ~
          = (lambda (x) (if (path? x) (path->string x) x))
  cache : (or/c #f (and/c hash? (not/c immutable?))) = #f ~

The same as path->relative-string/library, for backward compatibility.

                                        *make-path->relative-string*
(make-path->relative-string dirs [default]) ~
 -> (path-string? any/c . -> . any)
  dirs : (listof (cons (-> path?) string?)) ~
  default : (or/c (-> path-string? any/c) any/c) ~
          = (lambda (x) (if (path? x) (path->string x) x))

This function produces functions like path->relative-string/library and
path->relative-string/setup.

The dirs argument determines the prefix substitutions.  It must be an
association list mapping a path-producing thunk to a prefix string for
paths in the specified path.

default determines the default for the resulting function (which can
always be overridden by an additional argument to this function).

11. API for Collection Names

 (require setup/collection-name) package: base ~

                                        *collection-name?*
(collection-name? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a string that is syntactically valid as a collection
name, which means that it is one or more /-separated strings for which
collection-name-element? returns true.

                                        *collection-name-element?*
(collection-name-element? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a string that is syntactically valid as a top-level
collection name or as a part of a collection name, which means that it
is non-empty and contains only ASCII letters, ASCII digits, -, +, _, and
%, where a % is allowed only when followed by two lowercase hexadecimal
digits, and the digits must form a number that is not the ASCII value of
a letter, digit, -, +, or _.

12. API for Collection Searches

 (require setup/collection-search) package: base ~

Added in version 6.3 of package base.

                                        *collection-search*
(collection-search  mod-path                                     ~
                   [#:init result                                ~
                    #:combine combine                            ~
                    #:break? break?                              ~
                    #:all-possible-roots? all-possible-roots?])  ~
 -> any/c
  mod-path : normalized-lib-module-path? ~
  result : any/c = #f ~
  combine : (any/c (and/c path? complete-path?) . -> . any/c) ~
          = (lambda (r v) v)
  break? : (any/c . -> . any/c) = (lambda (r) #f) ~
  all-possible-roots? : any/c = #f ~

Generalizes collection-file-path to support folding over all possible
locations of a collection-based file in the current configuration.
Unlike collection-file-path, collection-search takes the file to
location in module-path form, but always as a 'lib path.

Each possible path for the file (not counting a ".ss" to/from ".rkt"
conversion) is provided as a second argument to the combine function,
where the first argument is the current result, and the value produced
by combine becomes the new result. The #:init argument provides the
initial result.

The break? function short-circuits a search based on the current value.
For example, it could be used to short-circuit a search after a suitable
path is found.

If all-possible-roots? is #f, then combine is called only on paths
within "collects"-like directories (for the current configuration) where
at least a matching collection directory exists.

                                        *normalized-lib-module-path?*
(normalized-lib-module-path? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a module path (in the sense of module-path?) of the
form '(lib str) where str contains at least one slash. The
collapse-module-path function produces such module paths for
collection-based module references.

13. API for Platform Specifications

 (require setup/matching-platform) package: base ~

Added in version 6.0.1.13 of package base.

                                        *platform-spec?*
(platform-spec? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a symbol, string, or regexp value (in the sense of
regexp?), #f otherwise.

                                        *matching-platform?*
(matching-platform?  spec                                        ~
                    [#:cross? cross?                             ~
                     #:system-type sys-type                      ~
                     #:system-library-subpath sys-lib-subpath])  ~
 -> boolean?
  spec : platform-spec? ~
  cross? : any/c = #f ~
  sys-type : (or/c #f symbol?) = (if cross? ~
                                     (cross-system-type)
                                     (system-type))
  sys-lib-subpath : (or/c #f path-for-some-system?) ~
                  = (if cross?
                        (cross-system-library-subpath #f)
                        (system-library-subpath #f))

Reports whether spec matches sys-type or sys-lib-subpath, where #f
values for the latter are replaced with the default values.

If spec is a symbol, then the result is #t if sys-type is the same
symbol, #f otherwise.

If spec is a string, then the result is #t if (path->string
sys-lib-subpath) is the same string, #f otherwise.

If spec is a regexp value, then the result is #t if the regexp matches
(path->string sys-lib-subpath), #f otherwise.

Changed in version 6.3 of package base: Added #:cross? argument and
changed the contract on sys-lib-subpath        to accept
path-for-some-system?        instead of just path?.

14. API for Cross-Platform Configuration

 (require setup/cross-system) package: base ~

The setup/cross-system library provides functions for querying the
system properties of a destination platform, which can be different than
the current platform in cross-installation modes.

A Racket installation includes a "system.rktd" file in the directory
reported by (find-lib-dir). When the information in that file does not
match the running Racket’s information, then the setup/cross-system
module infers that Racket is being run in cross-installation mode.

For example, if an in-place Racket installation for a different platform
resides at >cross-dir<, then

  racket -C -G >cross-dir</etc -X >cross-dir</collects -l- raco pkg

runs raco pkg using the current platform’s racket executable, but using
the collections and other configuration information of >cross-dir<, as
well as modifying the packages of >cross-dir<. That can work as long as
no platform-specific libraries need to run to perform the requested raco
pkg action (e.g., when installing built packages), or as long as the
current platform’s installation already includes those libraries.

Added in version 6.3 of package base.

                                        *cross-system-type*
(cross-system-type [mode]) ~
 -> (or/c symbol? string? bytes? exact-positive-integer? vector?)
  mode : (or/c 'os 'word 'gc 'vm 'link 'machine = 'os ~
               'so-suffix 'so-mode 'fs-change)

Like system-type, but for the target platform instead of the current
platform in cross-installation mode. When not in cross-installation
mode, the results are the same as for system-type.

See also 'cross mode for system-type.

                                        *cross-system-library-subpath*
(cross-system-library-subpath [mode]) -> path-for-some-system? ~
  mode : (or/c 'cgc '3m 'cs #f) = (system-type 'gc) ~

Like system-library-subpath, but for the target platform instead of the
current platform in cross-installation mode. When not in
cross-installation mode, the results are the same as for
system-library-subpath.

In cross-installation mode, the target platform may have a different
path convention than the current platform, so the result is
path-for-some-system? instead of path?.

                                        *cross-installation?*
(cross-installation?) -> boolean? ~

Returns #t if cross-installation mode has been detected, #f otherwise.

15. API for Cross-References for Installed Manuals

 (require setup/xref) package: racket-index ~

                                        *load-collections-xref*
(load-collections-xref [on-load]) -> xref? ~
  on-load : (-> any/c) = (lambda () (void)) ~

Either creates and caches or returns a cached cross-reference record
created with make-collections-xref. The on-load function is called only
when a previously cached record is not returned.

                                        *make-collections-xref*
(make-collections-xref                                             ~
                       [#:no-user? no-user?                        ~
                        #:no-main? no-main?                        ~
                        #:doc-db db-path                           ~
                        #:quiet-fail? quiet-fail?                  ~
                        #:register-shutdown! register-shutdown!])  ~
 -> xref?
  no-user? : any/c = #f ~
  no-main? : any/c = #f ~
  db-path : (or/c #f path?) = #f ~
  quiet-fail? : any/c = #f ~
  register-shutdown! : ((-> any) . -> . any) = void ~

Like load-xref, but automatically finds all cross-reference files for
manuals that have been installed with raco setup. The resulting
cross-reference record takes advantage of a cross-reference database
db-path, when support is available, to delay the loading of
cross-reference details until needed.

Cross-reference information is skipped when it is installed in the main
installation or in a user-specific location, respectively, if no-main?
or no-user? is #t.

If quiet-fail? is true, then errors are suppressed while loading
cross-reference information.

The register-shutdown! callback may be called to register a function
that closes database connections when the result of
make-collections-xref is no longer needed. If register-shutdown! is not
supplied or if a function sent to register-shutdown! is never called,
database connections will be closed only though a custodian.

                                        *get-rendered-doc-directories*
(get-rendered-doc-directories no-user?       ~
                              no-main?) -> (listof path?)
  no-user? : any/c ~
  no-main? : any/c ~

Returns a list of directories for all documentation for all installed
collections, omitting documentation that is installed in the main
installation or in a user-specific location, respectively, if no-main?
or no-user? is #t.

                                        *get-current-doc-state*
(get-current-doc-state) -> doc-state? ~

Records the time stamps of files that are touched whenever the
documentation is changed.

Added in version 1.2 of package racket-index.

                                        *doc-state-changed?*
(doc-state-changed? doc-state) -> boolean? ~
  doc-state : doc-state? ~

Returns #t when the time stamps of the files in doc-state changed (or
new files appeared) and #f otherwise.

If the result is #t, then the documentation in this installation of
Racket has changed and otherwise it hasn’t.

Added in version 1.2 of package racket-index.

                                        *doc-state?*
(doc-state? v) -> boolean? ~
  v : any/c ~

A predicate to recognize the result of get-current-doc-state.

Added in version 1.2 of package racket-index.

16. API for Materializing User-Specific Documentation

 (require setup/materialize-user-docs)
                                       package: racket-index ~

Added in version 1.1 of package racket-index.

                                        *materialize-user-docs*
(materialize-user-docs                                                 ~
                       [on-setup                                      
                        #:skip-user-doc-check? skip-user-doc-check?])  ~
 -> void?
  on-setup : ((-> boolean?) -> any) = (lambda (setup) (setup)) ~
  skip-user-doc-check? : any/c = #f ~

Checks whether a user-specific documentation entry point already exists
in (find-user-doc-dir), and if not, runs raco setup in a mode that will
create the entry point (to have the same content as the installation’s
documentation entry point.) If skip-user-doc-check? is not #f, then
skips the check for the user-specific documentation entry point.

The run of raco setup is packaged in a thunk that is provided to
on-setup, which can adjust the current output and error ports as
appropriate and check the thunk’s result for success.

The on-setup argument is not called if the documentation entry point
already exists in (find-user-doc-dir).

Changed in version 1.1 of package racket-index: Added the
skip-user-doc-check? argument.
