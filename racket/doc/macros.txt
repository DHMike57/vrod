Macros

+[missing] in [missing] introduces Macros.

See [missing] for general information on how programs are parsed. In
particular, the subsection [missing] describes how parsing triggers
macros, and [missing] describes how macro transformers are called.

    1 Pattern-Based Syntax Matching

    2 Syntax Object Content

    3 Syntax Object Bindings

    4 Syntax Transformers
      4.1 require Transformers
      4.2 provide Transformers
      4.3 Keyword-Argument Conversion Introspection

    5 Syntax Parameters
      5.1 Syntax Parameter Inspection

    6 Local Binding with Splicing Body

    7 Syntax Object Properties

    8 Syntax Taints

    9 Expanding Top-Level Forms
      9.1 Information on Expanded Modules

    10 File Inclusion

    11 Syntax Utilities
      11.1 Creating formatted identifiers
      11.2 Pattern variables
      11.3 Error reporting
      11.4 Recording disappeared uses
      11.5 Miscellaneous utilities

1. Pattern-Based Syntax Matching

                                        *syntax-case*
(syntax-case stx-expr (literal-id ...) ~
  clause ...)
 
      clause = [pattern result-expr]
             | [pattern fender-expr result-expr]
                
     pattern = _
             | id
             | (pattern ...)
             | (pattern ...+ . pattern)
             | (pattern ... pattern ellipsis pattern ...)
             | (pattern ... pattern ellipsis pattern ... . pattern)
             | #(pattern ...)
             | #(pattern ... pattern ellipsis pattern ...)
             | #&pattern
             | #s(key-datum pattern ...)
             | #s(key-datum pattern ... pattern ellipsis pattern ...)
             | (ellipsis stat-pattern)
             | const
                
stat-pattern = id
             | (stat-pattern ...)
             | (stat-pattern ...+ . stat-pattern)
             | #(stat-pattern ...)
             | const
                
    ellipsis = ...

Finds the first pattern that matches the syntax object produced by
stx-expr, and for which the corresponding fender-expr (if any) produces
a true value; the result is from the corresponding result-expr, which is
in tail position for the syntax-case form. If no clause matches, then
the exn:fail:syntax exception is raised; the exception is generated by
calling raise-syntax-error with #f as the “name” argument, a string with
a generic error message, and the result of stx-expr.

A syntax object matches a pattern as follows:

_
A _ pattern (i.e., an identifier with the same binding as _) matches any
syntax object.

id
An id matches any syntax object when it is not bound to ... or _ and
does not have the same binding as any literal-id. The id is further
bound as pattern variable for the corresponding fender-expr (if any) and
result-expr. A pattern-variable binding is a transformer binding; the
pattern variable can be referenced only through forms like syntax. The
binding’s value is the syntax object that matched the pattern with a
depth marker of 0.
An id that has the same binding as a literal-id matches a syntax object
that is an identifier with the same binding in the sense of
free-identifier=?.  The match does not introduce any pattern variables.

                                        *pattern*
(pattern ...) ~
A (pattern ...) pattern matches a syntax object whose datum form (i.e.,
without lexical information) is a list with as many elements as
sub-patterns in the pattern, and where each syntax object that
corresponds to an element of the list matches the corresponding
sub-pattern.
Any pattern variables bound by the sub-patterns are bound by the
complete pattern; the bindings must all be distinct.

                                        *pattern*
(pattern ...+ . pattern) ~
The last pattern must not be a (pattern ...), (pattern ...+ . pattern),
(pattern ... pattern ellipsis pattern ...), or (pattern ... pattern
ellipsis pattern ... . pattern) form.
Like the previous kind of pattern, but matches syntax objects that are
not necessarily lists; for n sub-patterns before the last sub-pattern,
the syntax object’s datum must be a pair such that n-1 cdrs produce
pairs. The last sub-pattern is matched against the syntax object
corresponding to the nth cdr (or the datum->syntax coercion of the datum
using the nearest enclosing syntax object’s lexical context and source
location).

                                        *pattern*
(pattern ... pattern ellipsis pattern ...) ~
Like the (pattern ...) kind of pattern, but matching a syntax object
with any number (zero or more) elements that match the sub-pattern
followed by ellipsis in the corresponding position relative to other
sub-patterns.
For each pattern variable bound by the sub-pattern followed by ellipsis,
the larger pattern binds the same pattern variable to a list of values,
one for each element of the syntax object matched to the sub-pattern,
with an incremented depth marker. (The sub-pattern itself may contain
ellipsis, leading to a pattern variables bound to lists of lists of
syntax objects with a depth marker of 2, and so on.)

                                        *pattern*
(pattern ... pattern ellipsis pattern ... . pattern) ~
Like the previous kind of pattern, but with a final sub-pattern as for
(pattern ...+ . pattern).  The final pattern never matches a syntax
object whose datum is a pair.

#(pattern ...)
Like a (pattern ...) pattern, but matching a vector syntax object whose
elements match the corresponding sub-patterns.

#(pattern ... pattern ellipsis pattern ...)
Like a (pattern ... pattern ellipsis pattern ...) pattern, but matching
a vector syntax object whose elements match the corresponding
sub-patterns.

#&pattern
Matches a box syntax object whose content matches the pattern.

#s(key-datum pattern ...)
Like a (pattern ...) pattern, but matching a prefab structure syntax
object whose fields match the corresponding sub-patterns. The key-datum
must correspond to a valid first argument to make-prefab-struct.

#s(key-datum pattern ... pattern ellipsis pattern ...)
Like a (pattern ... pattern ellipsis pattern ...) pattern, but matching
a prefab structure syntax object whose elements match the corresponding
sub-patterns.

                                        *ellipsis*
(ellipsis stat-pattern) ~
Matches the same as stat-pattern, which is like a pattern, but
identifiers with the binding ... are treated the same as other ids.

const
A const is any datum that does not match one of the preceding forms; a
syntax object matches a const pattern when its datum is equal? to the
quoted const.

If stx-expr produces a non-syntax object, then its result is converted
to a syntax object using datum->syntax and the lexical context and
source location of the stx-expr.

If stx-expr produces a syntax object that is tainted or armed, then any
syntax object bound by a pattern are tainted—unless the binding
corresponds to the whole syntax object produced by stx-expr, in which
case it remains tainted or armed.

Examples:
  > (require (for-syntax racket/base))

  > (define-syntax (swap stx)
      (syntax-case stx ()
        [(_ a b) #'(let ([t a])
                     (set! a b)
                     (set! b t))]))

  > (let ([x 5] [y 10])
      (swap x y)
      (list x y))
  '(10 5)
  > (syntax-case #'(ops 1 2 3 => +) (=>)
      [(_ x ... => op) #'(op x ...)])
  #<syntax:4:0 (+ 1 2 3)>
  > (syntax-case #'(let ([x 5] [y 9] [z 12])
                     (+ x y z))
                 (let)
      [(let ([var expr] ...) body ...)
       (list #'(var ...)
             #'(expr ...))])
  '(#<syntax:5:0 (x y z)> #<syntax:5:0 (5 9 12)>)

                                        *syntax-case**
(syntax-case* stx-expr (literal-id ...) id-compare-expr ~
  clause ...)

Like syntax-case, but id-compare-expr must produce a procedure that
accepts two arguments. A literal-id in a pattern matches an identifier
for which the procedure returns true when given the identifier to match
(as the first argument) and the identifier in the pattern (as the second
argument).

In other words, syntax-case is like syntax-case* with an id-compare-expr
that produces free-identifier=?.

                                        *with-syntax*
(with-syntax ([pattern stx-expr] ...) ~
  body ...+)

Similar to syntax-case, in that it matches a pattern to a syntax object.
Unlike syntax-case, all patterns are matched, each to the result of a
corresponding stx-expr, and the pattern variables from all matches
(which must be distinct) are bound with a single body sequence. The
result of the with-syntax form is the result of the last body, which is
in tail position with respect to the with-syntax form.

If any pattern fails to match the corresponding stx-expr, the
exn:fail:syntax exception is raised.

A with-syntax form is roughly equivalent to the following syntax-case
form:

  (syntax-case (list stx-expr ...) ()
    [(pattern ...) (let () body ...+)])

However, if any individual stx-expr produces a non-syntax object, then
it is converted to one using datum->syntax and the lexical context and
source location of the individual stx-expr.

Examples:
  > (define-syntax (hello stx)
      (syntax-case stx ()
        [(_ name place)
         (with-syntax ([print-name #'(printf "~a\n" 'name)]
                       [print-place #'(printf "~a\n" 'place)])
           #'(begin
               (define (name times)
                 (printf "Hello\n")
                 (for ([i (in-range 0 times)])
                      print-name))
               (define (place times)
                 (printf "From\n")
                 (for ([i (in-range 0 times)])
                      print-place))))]))

  > (hello jon utah)

  > (jon 2)
  Hello
  jon
  jon

  > (utah 2)
  From
  utah
  utah

  > (define-syntax (math stx)
      (define (make+1 expression)
        (with-syntax ([e expression])
          #'(+ e 1)))
      (syntax-case stx ()
        [(_ numbers ...)
         (with-syntax ([(added ...)
                        (map make+1
                             (syntax->list #'(numbers ...)))])
           #'(begin
               (printf "got ~a\n" added)
               ...))]))

  > (math 3 1 4 1 5 9)
  got 4
  got 2
  got 5
  got 2
  got 6
  got 10


                                        *syntax*
(syntax template) ~
 
     template = id
              | (template-elem ...)
              | (template-elem ...+ . template)
              | #(template-elem ...)
              | #&template
              | #s(key-datum template-elem ...)
              | (ellipsis stat-template)
              | const
                 
template-elem = template ellipsis ...
                 
stat-template = id
              | (stat-template ...)
              | (stat-template ... . stat-template)
              | #(stat-template ...)
              | #&stat-template
              | #s(key-datum stat-template ...)
              | const
                 
     ellipsis = ...

Constructs a syntax object based on a template, which can include
pattern variables bound by syntax-case or with-syntax.

Template forms produce a syntax object as follows:

id
If id is bound as a pattern variable, then id as a template produces the
pattern variable’s match result. Unless the id is a sub-template that is
replicated by ellipsis in a larger template, the pattern variable’s
value must be a syntax object with a depth marker of 0 (as opposed to a
list of matches).
More generally, if the pattern variable’s value has a depth marker n,
then it can only appear within a template where it is replicated by at
least n ellipsises. In that case, the template will be replicated enough
times to use each match result at least once.
If id is not bound as a pattern variable, then id as a template produces
(quote-syntax id).

                                        *template-elem*
(template-elem ...) ~
Produces a syntax object whose datum is a list, and where the elements
of the list correspond to syntax objects produced by the template-elems.
A template-elem is a sub-template replicated by any number of
ellipsises:
* If the sub-template is replicated by no ellipsises, then it generates
  a single syntax object to incorporate into the result syntax object.

* If the sub-template is replicated by one ellipsis, then it generates a
  sequence of syntax objects that is “inlined” into the resulting syntax
  object.

  The number of generated elements depends on the values of pattern
  variables referenced within the sub-template. There must be at least
  one pattern variable whose value has a depth marker less than the
  number of ellipsises after the pattern variable within the
  sub-template.

  If a pattern variable is replicated by more ellipsises in a template
  than the depth marker of its binding, then the pattern variable’s
  result is determined normally for inner ellipsises (up to the
  binding’s depth marker), and then the result is replicated as
  necessary to satisfy outer ellipsises.

* For each ellipsis after the first one, the preceding element (with
  earlier replicating ellipsises) is conceptually wrapped with
  parentheses for generating output, and then the wrapping parentheses
  are removed in the resulting syntax object.

                                        *template-elem*
(template-elem ... . template) ~
Like the previous form, but the result is not necessarily a list;
instead, the place of the empty list in the resulting syntax object’s
datum is taken by the syntax object produced by template.

#(template-elem ...)
Like the (template-elem ...) form, but producing a syntax object whose
datum is a vector instead of a list.

#&template
Produces a syntax object whose datum is a box holding the syntax object
produced by template.

#s(key-datum template-elem ...)
Like the (template-elem ...) form, but producing a syntax object whose
datum is a prefab structure instead of a list. The key-datum must
correspond to a valid first argument of make-prefab-struct.

                                        *ellipsis*
(ellipsis stat-template) ~
Produces the same result as stat-template, which is like a template, but
... is treated like an id (with no pattern binding).

const
A const template is any form that does not match the preceding cases,
and it produces the result (quote-syntax const).

A (syntax template) form is normally abbreviated as #'template; see also
[missing]. If template contains no pattern variables, then #'template is
equivalent to (quote-syntax template).

                                        *quasisyntax*
(quasisyntax template) ~

Like syntax, but (unsyntax expr) and (unsyntax-splicing expr) escape to
an expression within the template.

The expr must produce a syntax object (or syntax list) to be substituted
in place of the unsyntax or unsyntax-splicing form within the
quasiquoting template, just like unquote and unquote-splicing within
quasiquote. (If the escaped expression does not generate a syntax
object, it is converted to one in the same way as for the right-hand
side of with-syntax.)  Nested quasisyntaxes introduce quasiquoting
layers in the same way as nested quasiquotes.

Also analogous to quasiquote, the reader converts #` to quasisyntax, #,
to unsyntax, and #,@ to unsyntax-splicing. See also [missing].

                                        *unsyntax*
(unsyntax expr) ~

Illegal as an expression form. The unsyntax form is for use only with a
quasisyntax template.

                                        *unsyntax-splicing*
(unsyntax-splicing expr) ~

Illegal as an expression form. The unsyntax-splicing form is for use
only with a quasisyntax template.

                                        *syntax/loc*
(syntax/loc stx-expr template) ~

Like syntax, except that the immediate resulting syntax object takes its
source-location information from the result of stx-expr (which must
produce a syntax object), unless the template is just a pattern
variable, or both the source and position of stx-expr are #f.

                                        *quasisyntax/loc*
(quasisyntax/loc stx-expr template) ~

Like quasisyntax, but with source-location assignment like syntax/loc.

                                        *quote-syntax/prune*
(quote-syntax/prune id) ~

Like quote-syntax, but the lexical context of id is pruned via
identifier-prune-lexical-context to including binding only for the
symbolic name of id and for '#%top. Use this form to quote an identifier
when its lexical information will not be transferred to other syntax
objects (except maybe to '#%top for a top-level binding).

                                        *syntax-rules*
(syntax-rules (literal-id ...) ~
  [(id . pattern) template] ...)

Equivalent to

  (lambda (stx)
    (syntax-case stx (literal-id ...)
      [(generated-id . pattern) (syntax-protect #'template)]  ...))

where each generated-id binds no identifier in the corresponding
template.

                                        *syntax-id-rules*
(syntax-id-rules (literal-id ...) ~
  [pattern template] ...)

Equivalent to

  (make-set!-transformer
   (lambda (stx)
     (syntax-case stx (literal-id ...)
       [pattern (syntax-protect #'template)]  ...)))

                                        *define-syntax-rule*
(define-syntax-rule (id . pattern) template) ~

Equivalent to

  (define-syntax id
    (syntax-rules ()
     [(id . pattern) template]))

but with syntax errors potentially phrased in terms of pattern.

...

The ... transformer binding prohibits ... from being used as an
expression. This binding is useful only in syntax patterns and
templates, where it indicates repetitions of a pattern or template. See
syntax-case and syntax.

_

The _ transformer binding prohibits _ from being used as an expression.
This binding is useful only in syntax patterns, where it indicates a
pattern that matches any syntax object. See syntax-case.

                                        *syntax-pattern-variable?*
(syntax-pattern-variable? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a value that, as a transformer-binding value, makes
the bound variable as pattern variable in syntax and other forms. To
check whether an identifier is a pattern variable, use
syntax-local-value to get the identifier’s transformer value, and then
test the value with syntax-pattern-variable?.

The syntax-pattern-variable? procedure is provided for-syntax by
racket/base.

2. Syntax Object Content

                                        *syntax?*
(syntax? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a syntax object, #f otherwise. See also [missing].

Examples:
  > (syntax? #'quinoa)
  #t
  > (syntax? #'(spelt triticale buckwheat))
  #t
  > (syntax? (datum->syntax #f 'millet))
  #t
  > (syntax? "barley")
  #f

                                        *identifier?*
(identifier? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a syntax object and (syntax-e stx) produces a symbol.

Examples:
  > (identifier? #'linguine)
  #t
  > (identifier? #'(if wheat? udon soba))
  #f
  > (identifier? 'ramen)
  #f
  > (identifier? 15)
  #f

                                        *syntax-source*
(syntax-source stx) -> any ~
  stx : syntax? ~

Returns the source for the syntax object stx, or #f if none is known.
The source is represented by an arbitrary value (e.g., one passed to
read-syntax), but it is typically a file path string. Source-location
information is dropped for a syntax object that is marshaled as part of
compiled code; see also current-compile.

                                        *syntax-line*
(syntax-line stx) -> (or/c exact-positive-integer? #f) ~
  stx : syntax? ~

Returns the line number (positive exact integer) for the start of the
syntax object in its source, or #f if the line number or source is
unknown. The result is #f if and only if (syntax-column stx) produces
#f. See also [missing], and see syntax-source for information about
marshaling compiled syntax objects.

                                        *syntax-column*
(syntax-column stx) -> (or/c exact-nonnegative-integer? #f) ~
  stx : syntax? ~

Returns the column number (non-negative exact integer) for the start of
the syntax object in its source, or #f if the source column is unknown.
The result is #f if and only if (syntax-line stx) produces #f. See also
[missing], and see syntax-source for information about marshaling
compiled syntax objects.

                                        *syntax-position*
(syntax-position stx) -> (or/c exact-positive-integer? #f) ~
  stx : syntax? ~

Returns the character position (positive exact integer) for the start of
the syntax object in its source, or #f if the source position is
unknown. See also [missing], and see syntax-source for information about
marshaling compiled syntax objects.

                                        *syntax-span*
(syntax-span stx) -> (or/c exact-nonnegative-integer? #f) ~
  stx : syntax? ~

Returns the span (non-negative exact integer) in characters of the
syntax object in its source, or #f if the span is unknown. See also
syntax-source for information about marshaling compiled syntax objects.

                                        *syntax-original?*
(syntax-original? stx) -> boolean? ~
  stx : syntax? ~

Returns #t if stx has the property that read-syntax attaches to the
syntax objects that they generate (see Syntax Object Properties), and if
stx’s lexical information does not indicate that the object was
introduced by a syntax transformer (see [missing]). The result is #f
otherwise. This predicate can be used to distinguish syntax objects in
an expanded expression that were directly present in the original
expression, as opposed to syntax objects inserted by macros.

                                        *syntax-source-module*
(syntax-source-module stx [source?]) ~
 -> (or/c module-path-index? symbol? path? resolved-module-path? #f)
  stx : syntax? ~
  source? : any/c = #f ~

Returns an indication of the module whose source contains stx, or #f if
stx has no source module.  If source? is #f, then result is a module
path index or symbol (see [missing]) or a resolved module path; if
source? is true, the result is a path or symbol corresponding to the
loaded module’s source in the sense of current-module-declare-source.

                                        *syntax-e*
(syntax-e stx) -> any ~
  stx : syntax? ~

Unwraps the immediate datum structure from a syntax object, leaving
nested syntax structure (if any) in place.  The result of (syntax-e stx)
is one of the following:

* a symbol

* a syntax pair (described below)

* the empty list

* an immutable vector containing syntax objects

* an immutable box containing syntax objects

* an immutable hash table containing syntax object values (but not
  necessarily syntax object keys)

* an immutable prefab structure containing syntax objects

* some other kind of datum—usually a number, boolean, or string—that is
  interned when datum-intern-literal would convert the value

Examples:
  > (syntax-e #'a)
  'a
  > (syntax-e #'(x . y))
  '(#<syntax:11:0 x> . #<syntax:11:0 y>)
  > (syntax-e #'#(1 2 (+ 3 4)))
  '#(#<syntax:12:0 1> #<syntax:12:0 2> #<syntax:12:0 (+ 3 4)>)
  > (syntax-e #'#&"hello world")
  '#&#<syntax:13:0 "hello world">
  > (syntax-e #'#hash((imperial . "yellow") (festival . "green")))
  '#hash((imperial . #<syntax:14:0 "yellow">)
         (festival . #<syntax:14:0 "green">)) ~
  > (syntax-e #'#(point 3 4))
  '#(#<syntax:15:0 point> #<syntax:15:0 3> #<syntax:15:0 4>)
  > (syntax-e #'3)
  3
  > (syntax-e #'"three")
  "three"
  > (syntax-e #'#t)
  #t

A syntax pair is a pair containing a syntax object as its first element,
and either the empty list, a syntax pair, or a syntax object as its
second element.

A syntax object that is the result of read-syntax reflects the use of
delimited . in the input by creating a syntax object for every pair of
parentheses in the source, and by creating a pair-valued syntax object
only for parentheses in the source. See [missing] for more information.

If stx is tainted or armed, then any syntax object in the result of
(syntax-e stx) is tainted, and multiple calls to syntax-e may return
values that are not eq?. For a stx that is not armed, the results from
multiple calls to syntax-e of stx are eq?.

                                        *syntax->list*
(syntax->list stx) -> (or/c list? #f) ~
  stx : syntax? ~

Returns a list of syntax objects or #f. The result is a list of syntax
objects when (syntax->datum stx) would produce a list. In other words,
syntax pairs in (syntax-e stx) are flattened.

If stx is tainted or armed, then any syntax object in the result of
(syntax->list stx) is tainted.

Examples:
  > (syntax->list #'())
  '()
  > (syntax->list #'(1 (+ 3 4) 5 6))
  '(#<syntax:20:0 1> #<syntax:20:0 (+ 3 4)> #<syntax:20:0 5> #<syntax:20:0
  6>)
  > (syntax->list #'a)
  #f

                                        *syntax->datum*
(syntax->datum stx) -> any ~
  stx : syntax? ~

Returns a datum by stripping the lexical information, source-location
information, properties, and tamper status from stx. Inside of pairs,
(immutable) vectors, (immutable) boxes, immutable hash table values (not
keys), and immutable prefab structures, syntax objects are recursively
stripped.

The stripping operation does not mutate stx; it creates new pairs,
vectors, boxes, hash tables, and prefab structures as needed to strip
lexical and source-location information recursively.

Examples:
  > (syntax->datum #'a)
  'a
  > (syntax->datum #'(x . y))
  '(x . y)
  > (syntax->datum #'#(1 2 (+ 3 4)))
  '#(1 2 (+ 3 4))
  > (syntax->datum #'#&"hello world")
  '#&"hello world"
  > (syntax->datum #'#hash((imperial . "yellow") (festival . "green")))
  '#hash((imperial . "yellow") (festival . "green"))
  > (syntax->datum #'#(point 3 4))
  '#(point 3 4)
  > (syntax->datum #'3)
  3
  > (syntax->datum #'"three")
  "three"
  > (syntax->datum #'#t)
  #t

                                        *datum->syntax*
(datum->syntax ctxt v [srcloc prop ignored]) -> syntax? ~
  ctxt : (or/c syntax? #f) ~
  v : any/c ~
  srcloc : (or/c syntax? #f ~
                 (list/c any/c
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f)
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f))
                 (vector/c any/c
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)))
         = #f
  prop : (or/c syntax? #f) = #f ~
  ignored : (or/c syntax? #f) = #f ~

Converts the datum v to a syntax object. The contents of pairs, vectors,
and boxes, the fields of prefab structures, and the values of immutable
hash tables are recursively converted. The keys of prefab structures and
the keys of immutable hash tables are not converted. Mutable vectors and
boxes are replaced by immutable vectors and boxes. For any kind of value
other than a pair, vector, box, immutable hash table, immutable prefab
structure, or syntax object, conversion means wrapping the value with
lexical information, source-location information, and properties after
the value is interned via datum-intern-literal.

Converted objects in v are given the lexical context information of ctxt
and the source-location information of srcloc. If v is not already a
syntax object, then the resulting immediate syntax object is given the
properties (see Syntax Object Properties) of prop (even the hidden ones
that would not be visible via syntax-property-symbol-keys); if v is a
pair, vector, box, immutable hash table, or immutable prefab structure,
recursively converted values are not given properties. If ctxt is
tainted or armed, then the resulting syntax object from datum->syntax is
tainted.

Any of ctxt, srcloc, or prop can be #f, in which case the resulting
syntax has no lexical context, source information, and/or new
properties.

If srcloc is not #f or a syntax object, it must be a list or vector of
five elements:

  (list source-name line column position span)
  or (vector source-name line column position span)

where source-name is an arbitrary value for the source name; line is an
integer for the source line, or #f; column is an integer for the source
column, or #f; position is an integer for the source position, or #f;
and span is an integer for the source span, or #f. The line and column
values must both be numbers or both be #f, otherwise the
exn:fail:contract exception is raised.

Graph structure is not preserved by the conversion of v to a syntax
object. Instead, v is essentially unfolded into a tree. If v has a cycle
through pairs, vectors, boxes, immutable hash tables, and immutable
prefab structures, then the exn:fail:contract exception is raised.

The ignored argument is allowed for backward compatibility and has no
effect on the returned syntax object.

                                        *datum-intern-literal*
(datum-intern-literal v) -> any/c ~
  v : any/c ~

Converts some values to be consistent with an interned result produced
by the default reader in read-syntax mode.

If v is a number, character, string, byte string, or regular expression,
then the result is a value that is equal? to v and eq? to a potential
result of the default reader. (Note that mutable strings and byte
strings are interned as immutable strings and byte strings.)

If v is an uninterned or an unreadable symbol, the result is still v,
since an interned symbol would not be equal? to v.

The conversion process does not traverse compound values. For example,
if v is a pair containing strings, then the strings within v are not
interned.

If v1 and v2 are equal? but not eq?, then it is possible that
(datum-intern-literal v1) will return v1 and—sometime after v1 becomes
unreachable as determined by the garbage collector (see
[missing])—(datum-intern-literal v2) can still return v2. In other
words, datum-intern-literal may adopt a given value as an interned
representative, but if a former representative becomes otherwise
unreachable, then datum-intern-literal may adopt a new representative.

                                        *syntax-shift-phase-level*
(syntax-shift-phase-level stx shift) -> syntax? ~
  stx : syntax? ~
  shift : (or/c exact-integer? #f) ~

Returns a syntax object that is like stx, but with all of its top-level
and module bindings shifted by shift phase levels. If shift is #f, then
only bindings at phase level 0 are shifted to the label phase level. If
shift is 0, then the result is stx.

                                        *generate-temporaries*
(generate-temporaries stx-pair) -> (listof identifier?) ~
  stx-pair : (or syntax? list?) ~

Returns a list of identifiers that are distinct from all other
identifiers. The list contains as many identifiers as stx-pair contains
elements. The stx-pair argument must be a syntax pair that can be
flattened into a list. The elements of stx-pair can be anything, but
string, symbol, keyword (possibly wrapped as syntax), and identifier
elements will be embedded in the corresponding generated name, which is
useful for debugging purposes.

The generated identifiers are built with interned symbols (not gensyms);
see also [missing].

Examples:
  > (generate-temporaries '(a b c d))
  '(#<syntax a1> #<syntax b2> #<syntax c3> #<syntax d4>)
  > (generate-temporaries #'(1 2 3 4))
  '(#<syntax temp5> #<syntax temp6> #<syntax temp7> #<syntax temp8>)
  > (define-syntax (set!-values stx)
      (syntax-case stx ()
        [(_ (id ...) expr)
         (with-syntax ([(temp ...) (generate-temporaries #'(id ...))])
           #'(let-values ([(temp ...) expr])
               (set! id temp) ... (void)))]))


                                        *identifier-prune-lexical-context*
(identifier-prune-lexical-context  id-stx      ~
                                  [syms]) -> identifier?
  id-stx : identifier? ~
  syms : (listof symbol?) = (list (syntax-e id-stx)) ~

Returns an identifier with the same binding as id-stx, but without
lexical information from id-stx that does not apply to the symbols in
syms, where even further extension of the lexical information drops
information for other symbols. In particular, transferring the lexical
context via datum->syntax from the result of this function to a symbol
other than one in syms produces an identifier with no binding.

See also quote-syntax/prune.

                                        *identifier-prune-to-source-module*
(identifier-prune-to-source-module id-stx) -> identifier? ~
  id-stx : identifier? ~

Returns an identifier with its lexical context minimized to that needed
for syntax-source-module. The minimized lexical context does not include
any bindings.

                                        *syntax-recertify*
(syntax-recertify new-stx        ~
                  old-stx       
                  inspector     
                  key)      -> syntax?
  new-stx : syntax? ~
  old-stx : syntax? ~
  inspector : inspector? ~
  key : any/c ~

For backward compatibility only; returns new-stx.

                                        *syntax-debug-info*
(syntax-debug-info stx phase [all-bindings?]) -> hash? ~
  stx : syntax? ~
  phase : (or/c exact-integer? #f) ~
  all-bindings? : any/c = #f ~

Produces a hash table that describes the lexical information of stx (not
counting components when (syntax-e stx) would return a compound value).
The result can include—but is not limited to—the following keys:

* 'name — the result of (syntax-e stx), if it is a symbol.

* 'context — a list of vectors, where each vector represents a scope
  attached to stx.

  Each vector starts with a number that is distinct for every scope. A
  symbol afterward provides a hint at the scope’s origin: 'module for a
  module scope, 'macro for a macro-introduction scope, 'use-site for a
  macro use-site scope, or 'local for a local binding form. In the case
  of a 'module scope that corresponds to the inside edge, the module’s
  name and a phase (since an inside-edge scope is generated for each
  phase) are shown.

* 'bindings — a list of bindings, each represented by a hash table. A
  binding table can include—but is not limited to—the following keys:

  * 'name — the symbolic name for the binding.

  * 'context — the scopes, as a list of vectors, for the binding.

  * 'local — a symbol representing a local binding; when this key is
    present, 'module is absent.

  * 'module — an encoding of a import from another module; when this key
    is present, 'local is absent.

  * 'free-identifier=? — a hash table of debugging information from an
    identifier for which the binding is an alias.

* 'fallbacks — a list of hash tables like the one produced by
  syntax-debug-info for cross-namespace binding fallbacks.

Added in version 6.3.

3. Syntax Object Bindings

                                        *bound-identifier*
(bound-identifier=? a-id b-id [phase-level]) -> boolean? ~
  a-id : syntax? ~
  b-id : syntax? ~
  phase-level : (or/c exact-integer? #f) ~
              = (syntax-local-phase-level)

Returns #t if the identifier a-id would bind b-id (or vice versa) if the
identifiers were substituted in a suitable expression context at the
phase level indicated by phase-level, #f otherwise. A #f value for
phase-level corresponds to the label phase level.

Examples:
  > (define-syntax (check stx)
      (syntax-case stx ()
        [(_ x y)
         (if (bound-identifier=? #'x #'y)
             #'(let ([y 'wrong]) (let ([x 'binds]) y))
             #'(let ([y 'no-binds]) (let ([x 'wrong]) y)))]))

  > (check a a)
  'binds
  > (check a b)
  'no-binds
  > (define-syntax-rule (check-a x) (check a x))

  > (check-a a)
  'no-binds

                                        *free-identifier*
(free-identifier=?  a-id                 ~
                    b-id                
                   [a-phase-level       
                    b-phase-level]) -> boolean?
  a-id : identifier? ~
  b-id : identifier? ~
  a-phase-level : (or/c exact-integer? #f) ~
                = (syntax-local-phase-level)
  b-phase-level : (or/c exact-integer? #f) = a-phase-level ~

Returns #t if a-id and b-id access the same local binding, module
binding, or top-level binding—perhaps via rename transformers—at the
phase levels indicated by a-phase-level and b-phase-level, respectively.
A #f value for a-phase-level or b-phase-level corresponds to the label
phase level.

“Same module binding” means that the identifiers refer to the same
original definition site, and not necessarily to the same require or
provide site. Due to renaming in require and provide, or due to a
transformer binding to a rename transformer, the identifiers may return
distinct results with syntax-e.

Examples:
  > (define-syntax (check stx)
      (syntax-case stx ()
        [(_ x)
         (if (free-identifier=? #'car #'x)
             #'(list 'same: x) ~
             #'(list 'different: x))])) ~

  > (check car)
  '(same: #<procedure:car>)
  > (check mcar)
  '(different: #<procedure:mcar>)
  > (let ([car list])
      (check car))
  '(different: #<procedure:list>)
  > (require (rename-in racket/base [car kar]))

  > (check kar)
  '(same: #<procedure:car>)

                                        *free-transformer-identifier*
(free-transformer-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~
  b-id : identifier? ~

Same as (free-identifier=? a-id b-id (add1 (syntax-local-phase-level))).

                                        *free-template-identifier*
(free-template-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~
  b-id : identifier? ~

Same as (free-identifier=? a-id b-id (sub1 (syntax-local-phase-level))).

                                        *free-label-identifier*
(free-label-identifier=? a-id b-id) -> boolean? ~
  a-id : identifier? ~
  b-id : identifier? ~

Same as (free-identifier=? a-id b-id #f).

                                        *check-duplicate-identifier*
(check-duplicate-identifier ids) -> (or/c identifier? #f) ~
  ids : (listof identifier?) ~

Compares each identifier in ids with every other identifier in the list
with bound-identifier=?. If any comparison returns #t, one of the
duplicate identifiers is returned (the first one in ids that is a
duplicate), otherwise the result is #f.

                                        *identifier-binding*
(identifier-binding id-stx [phase-level]) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~
  phase-level : (or/c exact-integer? #f) ~
              = (syntax-local-phase-level)

Returns one of three kinds of values, depending on the binding of id-stx
at the phase level indicated by phase-level (where a #f value for
phase-level corresponds to the label phase level):

* The result is 'lexical if id-stx has a local binding. If 'lexical is
  produced for any phase-level value, then it is produced for all
  phase-level values.

* The result is a list of seven items when id-stx has a module binding:
  (list source-mod source-id nominal-source-mod nominal-source-id
  source-phase import-phase nominal-export-phase).

  * source-mod is a module path index (see [missing]) that indicates the
    defining module.

  * source-id is a symbol for the identifier’s name at its definition
    site in the source module. This can be different from the local name
    returned by syntax->datum for several reasons: the identifier is
    renamed on import, it is renamed on export, or it is implicitly
    renamed because the identifier (or its import) was generated by a
    macro invocation.

  * nominal-source-mod is a module path index (see [missing]) that
    indicates the module required into the context of id-stx to provide
    its binding. It can be different from source-mod due to a re-export
    in nominal-source-mod of some imported identifier.  If the same
    binding is imported in multiple ways, an arbitrary representative is
    chosen.

  * nominal-source-id is a symbol for the identifier’s name as exported
    by nominal-source-mod. It can be different from source-id due to a
    renaming provide, even if source-mod and nominal-source-mod are the
    same.

  * source-phase is an exact non-negative integer representing the
    source phase. For example, it is 1 if the source definition is
    for-syntax.

  * import-phase is 0 if the binding import of nominal-source-mode is a
    plain require, 1 if it is from a for-syntax import, etc.

  * nominal-export-phase is the phase level of the export from
    nominal-source-mod.

* The result is #f if id-stx has a top-level binding (or, equivalently,
  if it is unbound).

If id-stx is bound to a rename-transformer, the result from
identifier-binding is for the identifier in the transformer, so that
identifier-binding is consistent with free-identifier=?.

                                        *identifier-transformer-binding*
(identifier-transformer-binding id-stx) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~

Same as (identifier-binding id-stx (add1 (syntax-local-phase-level))).

                                        *identifier-template-binding*
(identifier-template-binding id-stx) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~

Same as (identifier-binding id-stx (sub1 (syntax-local-phase-level))).

                                        *identifier-label-binding*
(identifier-label-binding id-stx) ~
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  (or/c exact-integer? #f)
                  (or/c exact-integer? #f)))
  id-stx : identifier? ~

Same as (identifier-binding id-stx #f).

                                        *identifier-binding-symbol*
(identifier-binding-symbol  id-stx             ~
                           [phase-level]) -> symbol?
  id-stx : identifier? ~
  phase-level : (or/c exact-integer? #f) ~
              = (syntax-local-phase-level)

Like identifier-binding, but produces a symbol that corresponds to the
binding. The symbol result is the same for any identifiers that are
free-identifier=?, but the result may also be the same for identifiers
that are not free-identifier=? (i.e., different symbols imply different
bindings, but the same symbol does not imply the same binding).

When identifier-binding would produce a list, then the second element of
that list is the result that identifier-binding-symbol produces.

4. Syntax Transformers

                                        *set!-transformer?*
(set!-transformer? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a value created by make-set!-transformer or an
instance of a structure type with the prop:set!-transformer property, #f
otherwise.

                                        *make-set!-transformer*
(make-set!-transformer proc) -> set!-transformer? ~
  proc : (syntax? . -> . syntax?) ~

Creates an assignment transformer that cooperates with set!. If the
result of make-set!-transformer is bound to id as a transformer binding,
then proc is applied as a transformer when id is used in an expression
position, or when it is used as the target of a set! assignment as (set!
id expr). When the identifier appears as a set! target, the entire set!
expression is provided to the transformer.

Example:
  > (let ([x 1]
          [y 2])
      (let-syntax ([x (make-set!-transformer
                        (lambda (stx)
                          (syntax-case stx (set!)
                            ; Redirect mutation of x to y
                            [(set! id v) #'(set! y v)]
                            ; Normal use of x really gets x
                            [id (identifier? #'id)  #'x])))])
        (begin
          (set! x 3)
          (list x y))))
  '(1 3)

                                        *set!-transformer-procedure*
(set!-transformer-procedure transformer) ~
 -> (syntax? . -> . syntax?)
  transformer : set!-transformer? ~

Returns the procedure that was passed to make-set!-transformer to create
transformer or that is identified by the prop:set!-transformer property
of transformer.

prop:set!-transformer : struct-type-property? ~

A structure type property to identify structure types that act as
assignment transformers like the ones created by make-set!-transformer.

The property value must be an exact integer or procedure of one or two
arguments. In the former case, the integer designates a field within the
structure that should contain a procedure; the integer must be between 0
(inclusive) and the number of non-automatic fields in the structure type
(exclusive, not counting supertype fields), and the designated field
must also be specified as immutable.

If the property value is a procedure of one argument, then the procedure
serves as a syntax transformer and for set! transformations. If the
property value is a procedure of two arguments, then the first argument
is the structure whose type has prop:set!-transformer property, and the
second argument is a syntax object as for a syntax transformer and for
set! transformations; set!-transformer-procedure applied to the
structure produces a new function that accepts just the syntax object
and calls the procedure associated through the property. Finally, if the
property value is an integer, the target identifier is extracted from
the structure instance; if the field value is not a procedure of one
argument, then a procedure that always calls raise-syntax-error is used,
instead.

If a value has both the prop:set!-transformer and
prop:rename-transformer properties, then the latter takes precedence. If
a structure type has the prop:set!-transformer and prop:procedure
properties, then the former takes precedence for the purposes of macro
expansion.

                                        *rename-transformer?*
(rename-transformer? v) -> boolean? ~
  v : any/c ~

Returns #t if v is a value created by make-rename-transformer or an
instance of a structure type with the prop:rename-transformer property,
#f otherwise.

Examples:
  > (rename-transformer? (make-rename-transformer #'values))
  #t
  > (rename-transformer? 'not-a-rename-transformer)
  #f

                                        *make-rename-transformer*
(make-rename-transformer id-stx) -> rename-transformer? ~
  id-stx : syntax? ~

Creates a rename transformer that, when used as a transformer binding,
acts as a transformer that inserts the identifier id-stx in place of
whatever identifier binds the transformer, including in non-application
positions, in set! expressions.

Such a transformer could be written manually, but the one created by
make-rename-transformer triggers special cooperation with the parser and
other syntactic forms when id is bound to the rename transformer:

* The parser installs a free-identifier=? and identifier-binding
  equivalence between id and id-stx, as long as id-stx does not have a
  true value for the 'not-free-identifier=? syntax property.

* A provide of id provides the binding indicated by id-stx instead of
  id, as long as id-stx does not have a true value for the
  'not-free-identifier=? syntax property and as long as id-stx has a
  binding.

* If provide exports id, it uses a symbol-valued 'nominal-id property of
  id-stx to specify the “nominal source identifier” of the binding as
  reported by identifier-binding.

* If id-stx has a true value for the 'not-provide-all-defined syntax
  property, then id (or its target) is not exported by all-defined-out.

* The syntax-local-value function recognizes rename-transformer bindings
  and consult their targets.

Examples:
  > (define-syntax my-or (make-rename-transformer #'or))

  > (my-or #f #t)
  #t
  > (free-identifier=? #'my-or #'or)
  #t

Changed in version 6.3: Removed an optional second argument.

                                        *rename-transformer-target*
(rename-transformer-target transformer) -> identifier? ~
  transformer : rename-transformer? ~

Returns the identifier passed to make-rename-transformer to create
transformer or as indicated by a prop:rename-transformer property on
transformer.

Example:
  > (rename-transformer-target (make-rename-transformer #'or))
  #<syntax:8:0 or>

prop:rename-transformer : struct-type-property? ~

A structure type property to identify structure types that act as rename
transformers like the ones created by make-rename-transformer.

The property value must be an exact integer or an identifier syntax
object. In the former case, the integer designates a field within the
structure that should contain an identifier; the integer must be between
0 (inclusive) and the number of non-automatic fields in the structure
type (exclusive, not counting supertype fields), and the designated
field must also be specified as immutable.

If the property value is an identifier, the identifier serves as the
target for renaming, just like the first argument to
make-rename-transformer. If the property value is an integer, the target
identifier is extracted from the structure instance; if the field value
is not an identifier, then an identifier ? with an empty context is
used, instead.

                                        *local-expand*
(local-expand  stx               ~
               context-v        
               stop-ids         
              [intdef-ctx]) -> syntax?
  stx : syntax? ~
  context-v : (or/c 'expression 'top-level 'module 'module-begin list?) ~
  stop-ids : (or/c (listof identifier?) #f) ~
  intdef-ctx : (or/c internal-definition-context? ~
                     (and/c pair?
                            (listof internal-definition-context?))
                     #f)
             = #f

Expands stx in the lexical context of the expression currently being
expanded. The context-v argument is used as the result of
syntax-local-context for immediate expansions; a list indicates an
internal-definition context, and more information on the form of the
list is below.

When an identifier in stop-ids is encountered by the expander in a
sub-expression, expansions stops for the sub-expression. If stop-ids is
a non-empty list and does not contain just module*, then begin, quote,
set!, lambda, case-lambda, let-values, letrec-values, if, begin0,
with-continuation-mark, letrec-syntaxes+values, #%app, #%expression,
#%top, and #%variable-reference are added to stop-ids.  If #%app or
#%datum appears in stop-ids, then application and literal data
expressions without the respective explicit form are not wrapped with
the explicit form, and #%top wrappers are never added (even with an
empty stop-ids list). If stop-ids is #f instead of a list, then stx is
expanded only as long as the outermost form of stx is a macro (i.e.,
expansion does not proceed to sub-expressions). A fully expanded form
can include the bindings listed in [missing] plus the
letrec-syntaxes+values form and #%expression in any expression position.

When #%plain-module-begin is not itself in stop-ids and module* is in
stop-ids, then the #%plain-module-begin transformer refrains from
expanding module* sub-forms. Otherwise, the #%plain-module-begin
transformer detects and expands sub-forms (such as define-values)
independent of the corresponding identifier’s presence in stop-ids.

When context-v is 'module-begin, and the result of expansion is a
#%plain-module-begin form, then a 'submodule syntax property is added to
each enclosed module form (but not module* forms) in the same way as by
module expansion.

The optional intdef-ctx argument must be either #f, the result of
syntax-local-make-definition-context, or a list of such results. In the
latter two cases, lexical information for internal definitions is added
to stx before it is expanded (in reverse order relative to the list).
The lexical information is also added to the expansion result (because
the expansion might introduce bindings or references to
internal-definition bindings).

For a particular internal-definition context, generate a unique value
and put it into a list for context-v. To allow liberal expansion of
define forms, the generated value should be an instance of a structure
with a true value for prop:liberal-define-context. If the
internal-definition context is meant to be self-contained, the list for
context-v should contain only the generated value; if the
internal-definition context is meant to splice into an immediately
enclosing context, then when syntax-local-context produces a list, cons
the generated value onto that list.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

Examples:
  > (define-syntax-rule (do-print x ...)
      (printf x ...))

  > (define-syntax-rule (hello x)
      (do-print "hello ~a" x))

  > (define-syntax (show stx)
      (syntax-case stx ()
        [(_ x)
         (let ([partly (local-expand #'(hello x)
                                     'expression
                                     (list #'do-print))]
               [fully (local-expand #'(hello x)
                                    'expression
                                    #f)])
           (printf "partly expanded: ~s\n" (syntax->datum partly)) ~
           (printf "fully expanded: ~s\n" (syntax->datum fully)) ~
           fully)]))

  > (show 1)
  partly expanded: (do-print "hello ~a" 1)
  fully expanded: (printf "hello ~a" 1)
  hello 1


Changed in version 6.0.1.3: Changed treatment of #%top so that it is
never introduced as an explicit wrapper.

                                        *syntax-local-expand-expression*
(syntax-local-expand-expression stx) -> syntax? syntax? ~
  stx : syntax? ~

Like local-expand given 'expression and an empty stop list, but with two
results: a syntax object for the fully expanded expression, and a syntax
object whose content is opaque. The latter can be used in place of the
former (perhaps in a larger expression produced by a macro transformer),
and when the macro expander encounters the opaque object, it substitutes
the fully expanded expression without re-expanding it; the
exn:fail:syntax exception is raised if the expansion context includes
scopes that were not present for the original expansion, in which case
re-expansion might produce different results. Consistent use of
syntax-local-expand-expression and the opaque object thus avoids
quadratic expansion times when local expansions are nested.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *local-transformer-expand*
(local-transformer-expand  stx               ~
                           context-v        
                           stop-ids         
                          [intdef-ctx]) -> syntax?
  stx : syntax? ~
  context-v : (or/c 'expression 'top-level list?) ~
  stop-ids : (or/c (listof identifier?) #f) ~
  intdef-ctx : (or/c internal-definition-context? #f) = #f ~

Like local-expand, but stx is expanded as a transformer expression
instead of a run-time expression. For 'expression expansion, any lifted
expressions—from calls to syntax-local-lift-expression during the
expansion of stx—are captured into a let-values form in the result.

                                        *local-expand/capture-lifts*
(local-expand/capture-lifts  stx             ~
                             context-v      
                             stop-ids       
                            [intdef-ctx     
                             lift-ctx]) -> syntax?
  stx : syntax? ~
  context-v : (or/c 'expression 'top-level 'module 'module-begin list?) ~
  stop-ids : (or/c (listof identifier?) #f) ~
  intdef-ctx : (or/c internal-definition-context? #f) = #f ~
  lift-ctx : any/c = (gensym 'lifts) ~

Like local-expand, but the result is a syntax object that represents a
begin expression. Lifted expressions—from calls to
syntax-local-lift-expression during the expansion of stx—appear with
their identifiers in define-values forms, and the expansion of stx is
the last expression in the begin. The lift-ctx value is reported by
syntax-local-lift-context during local expansion. The lifted expressions
are not expanded, but instead left as provided in the begin form.

                                        *local-transformer-expand/capture-lifts*
(local-transformer-expand/capture-lifts  stx             ~
                                         context-v      
                                         stop-ids       
                                        [intdef-ctx     
                                         lift-ctx]) -> syntax?
  stx : syntax? ~
  context-v : (or/c 'expression 'top-level list?) ~
  stop-ids : (or/c (listof identifier?) #f) ~
  intdef-ctx : (or/c internal-definition-context? #f) = #f ~
  lift-ctx : any/c = (gensym 'lifts) ~

Like local-expand/capture-lifts, but stx is expanded as a transformer
expression instead of a run-time expression. Lifted expressions are
reported as define-values forms (in the transformer environment).

                                        *internal-definition-context?*
(internal-definition-context? v) -> boolean? ~
  v : any/c ~

Returns #t if v is an internal-definition context, #f otherwise.

                                        *syntax-local-make-definition-context*
(syntax-local-make-definition-context [intdef-ctx    ~
                                       add-scope?]) 
 -> internal-definition-context?
  intdef-ctx : (or/c internal-definition-context? #f) = #f ~
  add-scope? : any/c = #f ~

Creates an opaque internal-definition context value to be used with
local-expand and other functions. A transformer should create one
context for each set of internal definitions to be expanded, and use it
when expanding any form whose lexical context should include the
definitions. After discovering an internal define-values or
define-syntaxes form, use syntax-local-bind-syntaxes to add bindings to
the context.

An internal-definition context internally creates a scope to represent
the context. Unless add-scope? is #f, the scope is added to any form
that is expanded within the context or that appears as the result of a
(partial) expansion within the context.

If intdef-ctx is not #f, then the new internal-definition context
extends the given one. An extending definition context adds all scopes
that are added by intdef-ctx, and expanding in the new
internal-definition context can use bindings previously introduced into
intdef-ctx.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

Changed in version 6.3: Added the add-scope? argument, and made calling
internal-definition-context-seal no longer necessary.

                                        *syntax-local-bind-syntaxes*
(syntax-local-bind-syntaxes id-list          ~
                            expr            
                            intdef-ctx) -> void?
  id-list : (listof identifier?) ~
  expr : (or/c syntax? #f) ~
  intdef-ctx : internal-definition-context? ~

Binds each identifier in id-list within the internal-definition context
represented by intdef-ctx, where intdef-ctx is the result of
syntax-local-make-definition-context. Supply #f for expr when the
identifiers correspond to define-values bindings, and supply a
compile-time expression when the identifiers correspond to
define-syntaxes bindings; in the latter case, the number of values
produced by the expression should match the number of identifiers,
otherwise the exn:fail:contract:arity exception is raised.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *internal-definition-context-introduce*
(internal-definition-context-introduce  intdef-ctx      ~
                                        stx            
                                       [mode])     -> syntax?
  intdef-ctx : internal-definition-context? ~
  stx : syntax? ~
  mode : (or/c 'flip 'add 'remove) = 'flip ~

Flips, adds, or removes (depending on mode) the scope for intdef-ctx for
all parts of stx.

Added in version 6.3.

                                        *internal-definition-context-seal*
(internal-definition-context-seal intdef-ctx) -> void? ~
  intdef-ctx : internal-definition-context? ~

For backward compatibility only; has no effect.

                                        *identifier-remove-from-definition-context*
(identifier-remove-from-definition-context id-stx       ~
                                           intdef-ctx) 
 -> identifier?
  id-stx : identifier? ~
  intdef-ctx : (or/c internal-definition-context? ~
                     (listof internal-definition-context?))

Removes all of the scopes of intdef-ctx (or of each element in a list
intdef-ctx) from id-stx.

The identifier-remove-from-definition-context function is provided for
backward compatibility; the more general
internal-definition-context-introduce function is preferred.

Changed in version 6.3: Simplified the operation to scope removal.

                                        *syntax-local-value*
(syntax-local-value  id-stx             ~
                    [failure-thunk     
                     intdef-ctx])  -> any
  id-stx : syntax? ~
  failure-thunk : (or/c (-> any) #f) = #f ~
  intdef-ctx : (or/c internal-definition-context? = #f ~
                     #f)

Returns the transformer binding value of id-stx in either the context
associated with intdef-ctx (if not #f) or the context of the expression
being expanded (if intdef-ctx is #f).  If intdef-ctx is provided, it
must be an extension of the context of the expression being expanded.

If id-stx is bound to a rename transformer created with
make-rename-transformer, syntax-local-value effectively calls itself
with the target of the rename and returns that result, instead of the
rename transformer.

If id-stx has no transformer binding (via define-syntax, let-syntax,
etc.) in that environment, the result is obtained by applying
failure-thunk if not #f. If failure-thunk is false, the
exn:fail:contract exception is raised.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

Examples:
  > (define-syntax swiss-cheeses? #t)

  > (define-syntax (transformer stx)
      (if (syntax-local-value #'swiss-cheeses?)
          #''(gruyère emmental raclette)
          #''(roquefort camembert boursin)))

  > (transformer)
  '(gruyère emmental raclette)

Examples:
  > (define-syntax (transformer-2 stx)
      (syntax-local-value #'something-else (λ () (error "no binding"))))

  > (transformer-2)
  no binding

Examples:
  > (define-syntax nachos #'(printf "nachos~n"))

  > (define-syntax chips (make-rename-transformer #'nachos))

  > (define-syntax (transformer-3 stx)
      (syntax-local-value #'chips))

  > (transformer-3)
  nachos


                                        *syntax-local-value/immediate*
(syntax-local-value/immediate  id-stx             ~
                              [failure-thunk     
                               intdef-ctx])  -> any
  id-stx : syntax? ~
  failure-thunk : (or/c (-> any) #f) = #f ~
  intdef-ctx : (or/c internal-definition-context? = #f ~
                     #f)

Like syntax-local-value, but the result is normally two values. If
id-stx is bound to a rename transformer, the results are the rename
transformer and the identifier in the transformer. Beware that provide
on an id bound to a rename transformer may export the target of the
rename instead of id. See make-rename-transformer for more information.
If id-stx is not bound to a rename transformer, then the results are the
value that syntax-local-value would produce and #f.

If id-stx has no transformer binding, then failure-thunk is called (and
it can return any number of values), or an exception is raised if
failure-thunk is #f.

                                        *syntax-local-lift-expression*
(syntax-local-lift-expression stx) -> identifier? ~
  stx : syntax? ~

Returns a fresh identifier, and cooperates with the module,
letrec-syntaxes+values, define-syntaxes, begin-for-syntax, and top-level
expanders to bind the generated identifier to the expression stx.

A run-time expression within a module is lifted to the module’s top
level, just before the expression whose expansion requests the lift.
Similarly, a run-time expression outside of a module is lifted to a
top-level definition. A compile-time expression in a
letrec-syntaxes+values or define-syntaxes binding is lifted to a let
wrapper around the corresponding right-hand side of the binding. A
compile-time expression within begin-for-syntax is lifted to a define
declaration just before the requesting expression within the
begin-for-syntax.

Other syntactic forms can capture lifts by using
local-expand/capture-lifts or local-transformer-expand/capture-lifts.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-lift-values-expression*
(syntax-local-lift-values-expression n stx) ~
 -> (listof identifier?)
  n : exact-nonnegative-integer? ~
  stx : syntax? ~

Like syntax-local-lift-expression, but binds the result to n
identifiers, and returns a list of the n identifiers.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-lift-context*
(syntax-local-lift-context) -> any/c ~

Returns a value that represents the target for expressions lifted via
syntax-local-lift-expression. That is, for different transformer calls
for which this procedure returns the same value (as determined by eq?),
lifted expressions for the two transformer are moved to the same place.
Thus, the result is useful for caching lift information to avoid
redundant lifts.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-lift-module-end-declaration*
(syntax-local-lift-module-end-declaration stx) -> void? ~
  stx : syntax? ~

Cooperates with the module form to insert stx as a top-level declaration
at the end of the module currently being expanded. If the current
expression being transformed is in phase level 0 and not in the module
top-level, then stx is eventually expanded in an expression context. If
the current expression being transformed is in a higher phase level
(i.e., nested within some number of begin-for-syntaxes within a module
top-level), then the lifted declaration is placed at the very end of the
module (under a suitable number of begin-for-syntaxes), instead of
merely the end of the enclosing begin-for-syntax.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

If the current expression being transformed is not within a module form
(see syntax-transforming-module-expression?), then the exn:fail:contract
exception is raised.

                                        *syntax-local-lift-require*
(syntax-local-lift-require raw-require-spec      ~
                           stx)             -> syntax?
  raw-require-spec : any/c ~
  stx : syntax? ~

Lifts a #%require form corresponding to raw-require-spec (either as a
syntax object or datum) to the top-level or to the top of the module
currently being expanded  or to an enclosing begin-for-syntax..

The resulting syntax object is the same as stx, except that a fresh
scope is added. The same scope is added to the lifted #%require form, so
that the #%require form can bind uses of imported identifiers in the
resulting syntax object (assuming that the lexical information of stx
includes the binding environment into which the #%require is lifted).

If raw-require-spec and stx are part of the input to a transformer, then
typically syntax-local-introduce should be applied to each before
passing them to syntax-local-lift-require, and then
syntax-local-introduce should be applied to the result of
syntax-local-lift-require. Otherwise, marks added by the macro expander
can prevent access to the new imports.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-lift-provide*
(syntax-local-lift-provide raw-provide-spec-stx) -> void? ~
  raw-provide-spec-stx : syntax? ~

Lifts a #%provide form corresponding to raw-provide-spec-stx to the top
of the module currently being expanded or to an enclosing
begin-for-syntax.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

If the current expression being transformed is not within a module form
(see syntax-transforming-module-expression?), then the exn:fail:contract
exception is raised.

                                        *syntax-local-name*
(syntax-local-name) -> any/c ~

Returns an inferred name for the expression position being transformed,
or #f if no such name is available. A name is normally a symbol or an
identifier. See also [missing].

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-context*
(syntax-local-context) ~
 -> (or/c 'expression 'top-level 'module 'module-begin list?)

Returns an indication of the context for expansion that triggered a
syntax transformer call. See [missing] for more information on contexts.

The symbol results indicate that the expression is being expanded for an
expression context, a top-level context, a module context, or a
module-begin context.

A list result indicates expansion in an internal-definition context. The
identity of the list’s first element (i.e., its eq?ness) reflects the
identity of the internal-definition context; in particular two
transformer expansions receive the same first value if and only if they
are invoked for the same internal-definition context. Later values in
the list similarly identify internal-definition contexts that are still
being expanded, and that required the expansion of nested
internal-definition contexts.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-phase-level*
(syntax-local-phase-level) -> exact-integer? ~

During the dynamic extent of a syntax transformer application by the
expander, the result is the phase level of the form being expanded.
Otherwise, the result is 0.

Examples:
  ; a macro bound at phase 0
  > (define-syntax (print-phase-level stx)
      (printf "phase level: ~a~n" (syntax-local-phase-level)) ~
      #'(void))

  > (require (for-meta 2 racket/base))

  > (begin-for-syntax
      ; a macro bound at phase 1
      (define-syntax (print-phase-level stx)
        (printf "phase level: ~a~n" (syntax-local-phase-level)) ~
        #'(void)))

  > (print-phase-level)
  phase level: 0

  > (begin-for-syntax (print-phase-level))
  phase level: 1


                                        *syntax-local-module-exports*
(syntax-local-module-exports mod-path) ~
 -> (listof (cons/c (or/c exact-integer? #f) (listof symbol?)))
  mod-path : (or/c module-path? ~
                   (and/c syntax?
                          (lambda (stx)
                            (module-path? (syntax->datum stx)))))

Returns an association list from phase-level numbers (or #f for the
label phase level) to lists of symbols, where the symbols are the names
of provided bindings from mod-path at the corresponding phase level.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-submodules*
(syntax-local-submodules) -> (listof symbol?) ~

Returns a list of submodule names that are declared via module (as
opposed to module*) in the current expansion context.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *syntax-local-get-shadower*
(syntax-local-get-shadower  id-stx                 ~
                           [only-generated?]) -> identifier?
  id-stx : identifier? ~
  only-generated? : any/c = #f ~

Adds scopes to id-stx so that it refers to bindings in the current
expansion context or could bind any identifier obtained via
(syntax-local-get-shadower id-stx) in more nested contexts. If
only-generated? is true, the phase-spanning scope of the enclosing
module or namespace is omitted from the added scopes, however, which
limits the bindings that can be referenced (and therefore avoids certain
ambiguous references).

This function is intended for the implementation of syntax-parameterize
and local-require.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

Changed in version 6.3: Simplified to the minimal functionality needed
for syntax-parameterize and local-require.

                                        *syntax-local-make-delta-introducer*
(syntax-local-make-delta-introducer id-stx) -> procedure? ~
  id-stx : identifier? ~

For (limited) backward compatibility only; raises exn:fail:supported.

Changed in version 6.3: changed to raise exn:fail:supported.

                                        *syntax-local-certifier*
(syntax-local-certifier [active?]) ~
 -> ((syntax?) (any/c (or/c procedure? #f))
     . ->* . syntax?)
  active? : boolean? = #f ~

For backward compatibility only; returns a procedure that returns its
first argument.

                                        *syntax-transforming?*
(syntax-transforming?) -> boolean? ~

Returns #t during the dynamic extent of a syntax transformer application
by the expander and while a module is being visited, #f otherwise.

                                        *syntax-transforming-module-expression?*
(syntax-transforming-module-expression?) -> boolean? ~

Returns #t during the dynamic extent of a syntax transformer application
by the expander for an expression within a module form, #f otherwise.

                                        *syntax-local-identifier-as-binding*
(syntax-local-identifier-as-binding id-stx) -> identifier? ~
  id-stx : identifier? ~

Returns an identifier like id-stx, but without use-site scopes that were
previously added to the identifier as part of a macro expansion in the
current definition context.

In a syntax transformer that runs in a non-expression context and forces
the expansion of subforms with local-expand, use
syntax-local-identifier-as-binding on an identifier from the expansion
before moving it into a binding position or comparing with with
bound-identifier=?. Otherwise, the results can be inconsistent with the
way that define works in the same definition context.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

Added in version 6.3.

                                        *syntax-local-introduce*
(syntax-local-introduce stx) -> syntax? ~
  stx : syntax? ~

Produces a syntax object that is like stx, except that the presence of
scopes for the current expansion—both the. See [missing] for information
on scopes.

This procedure must be called during the dynamic extent of a syntax
transformer application by the expander or while a module is visited
(see syntax-transforming?), otherwise the exn:fail:contract exception is
raised.

                                        *make-syntax-introducer*
(make-syntax-introducer) ~
 -> ((syntax?) ((or/c 'flip 'add 'remove)) . ->* . syntax?)

Produces a procedure that behaves similar to syntax-local-introduce, but
using a fresh scope, and where the action of the scope can be 'flip (the
default), 'add to add the scope regardless of whether it is present
already, or 'remove to remove the scope when it is currently present.

Multiple applications of the same make-syntax-introducer result
procedure use the same scope, and different result procedures use
distinct scopes.

Changed in version 6.3: Added the optional operation argument in the
result procedure.

                                        *make-syntax-delta-introducer*
(make-syntax-delta-introducer  ext-stx        ~
                               base-stx      
                              [phase-level]) 
 -> ((syntax?) ((or/c 'flip 'add 'remove)) . ->* . syntax?)
  ext-stx : syntax? ~
  base-stx : (or/c syntax? #f) ~
  phase-level : (or/c #f exact-integer?) ~
              = (syntax-local-phase-level)

Produces a procedure that behaves like the result of
make-syntax-introducer, but using the scopes of ext-stx that are not
shared with base-stx.

This procedure is potentially useful when m-id has a transformer binding
that records some orig-id, and a use of m-id introduces a binding of
orig-id. In that case, the scopes one the use of m-id added since the
binding of m-id should be transferred to the binding instance of
orig-id, so that it captures uses with the same lexical context as the
use of m-id.

If ext-stx is tainted or armed, then an identifier result from the
created procedure is tainted.

                                        *syntax-local-transforming-module-provides?*
(syntax-local-transforming-module-provides?) -> boolean? ~

Returns #t while a provide transformer is running (see
make-provide-transformer) or while an expand sub-form of #%provide is
expanded, #f otherwise.

                                        *syntax-local-module-defined-identifiers*
(syntax-local-module-defined-identifiers) ~
 -> (and/c hash? immutable?)

Can be called only while syntax-local-transforming-module-provides?
returns #t.

It returns a hash table mapping a phase-level number (such as 0) to a
list of all definitions at that phase level within the module being
expanded. This information is used for implementing provide sub-forms
like all-defined-out.

Beware that the phase-level keys are absolute relative to the enclosing
module, and not relative to the current transformer phase level as
reported by syntax-local-phase-level.

                                        *syntax-local-module-required-identifiers*
(syntax-local-module-required-identifiers mod-path      ~
                                          phase-level) 
 -> (listof (cons/c (or/c exact-integer? #f)
                    (listof identifier?)))
  mod-path : (or/c module-path? #f) ~
  phase-level : (or/c exact-integer? #f #t) ~

Can be called only while syntax-local-transforming-module-provides?
returns #t.

It returns an association list mapping phase levels to lists of
identifiers.  Each list of identifiers includes all bindings imported
(into the module being expanded) using the module path mod-path, or all
modules if mod-path is #f. The association list includes all identifiers
imported with a phase-level shift, of all shifts if phase-level is #t.

When an identifier is renamed on import, the result association list
includes the identifier by its internal name. Use identifier-binding to
obtain more information about the identifier.

Beware that the phase-level keys are absolute relative to the enclosing
module, and not relative to the current transformer phase level as
reported by syntax-local-phase-level.

prop:liberal-define-context : struct-type-property? ~
(liberal-define-context? v) -> boolean?
  v : any/c ~

An instance of a structure type with a true value for the
prop:liberal-define-context property can be used as an element of an
internal-definition context representation in the result of
syntax-local-context or the second argument of local-expand. Such a
value indicates that the context supports liberal expansion of define
forms into potentially multiple define-values and define-syntaxes forms.
The 'module and 'module-body contexts implicitly allow liberal
expansion.

The liberal-define-context? predicate returns #t if v is an instance of
a structure with a true value for the prop:liberal-define-context
property, #f otherwise.

4.1. require Transformers

 (require racket/require-transform) package: base ~

The bindings documented in this section are provided by the
racket/require-transform library, not racket/base or racket.

A transformer binding whose value is a structure with the
prop:require-transformer property implements a derived require-spec for
require as a require transformer.

A require transformer is called with the syntax object representing its
use as a require-spec within a require form, and the result must be two
lists: a list of imports and a list of import-sources.

If the derived form contains a sub-form that is a require-spec, then it
can call expand-import to transform the sub-require-spec to lists of
imports and import sources.

See also define-require-syntax, which supports macro-style require
transformers.

                                        *expand-import*
(expand-import stx) -> (listof import?) (listof import-source?) ~
  stx : syntax? ~

Expands the given require-spec to lists of imports and import sources.
The latter specifies modules to be instantiated or visited, so the
modules that it represents should be a superset of the modules
represented in the former list (so that a module will be instantiated or
visited even if all of imports are eventually filtered from the former
list).

                                        *make-require-transformer*
(make-require-transformer proc) -> require-transformer? ~
  proc : (syntax? . -> . (values ~
                          (listof import?)
                          (listof import-source?)))

Creates a require transformer using the given procedure as the
transformer.

prop:require-transformer : struct-type-property? ~

A property to identify require transformers. The property value must be
a procedure that takes the structure and returns a transformer
procedure; the returned transformer procedure takes a syntax object and
returns import and import-source lists.

                                        *require-transformer?*
(require-transformer? v) -> boolean? ~
  v : any/c ~

Returns #t if v has the prop:require-transformer property, #f otherwise.

                                        *struct*
(struct import (local-id ~
                src-sym
                src-mod-path
                mode
                req-mode
                orig-mode
                orig-stx)
    #:extra-constructor-name make-import) ~
  local-id : identifier? ~
  src-sym : symbol? ~
  src-mod-path : (or/c module-path? ~
                       (and/c syntax?
                              (lambda (stx)
                                (module-path? (syntax->datum stx)))))
  mode : (or/c exact-integer? #f) ~
  req-mode : (or/c exact-integer? #f) ~
  orig-mode : (or/c exact-integer? #f) ~
  orig-stx : syntax? ~

A structure representing a single imported identifier:

* local-id — the identifier to be bound within the importing module.

* src-sym — the external name of the binding as exported from its source
  module.

* src-mod-path — a module path (relative to the importing module) for
  the source of the imported binding.

* orig-stx — a syntax object for the source of the import, used for
  error reporting.

* mode — the phase level of the binding in the importing module.

* req-mode — the phase level shift of the import relative to the
  exporting module.

* orig-mode — the phase level of the binding as exported by the
  exporting module.

                                        *struct*
(struct import-source (mod-path-stx mode) ~
    #:extra-constructor-name make-import-source) ~
  mod-path-stx : (and/c syntax? ~
                        (lambda (x)
                          (module-path? (syntax->datum x))))
  mode : (or/c exact-integer? #f) ~

A structure representing an imported module, which must be instantiated
or visited even if no binding is imported into a module.

* mod-path-stx — a module path (relative to the importing module) for
  the source of the imported binding.

* mode — the phase level shift of the import.

                                        *current-require-module-path*
(current-require-module-path) -> (or/c #f module-path-index?) ~
(current-require-module-path module-path) -> void?
  module-path : (or/c #f module-path-index?) ~

A parameter that determines how relative require-level module paths are
expanded to #%require-level module paths by convert-relative-module-path
(which is used implicitly by all built-in require sub-forms).

When the value of current-require-module-path is #f, relative module
paths are left as-is, which means that the require context determines
the resolution of the module path.

The require form parameterizes current-require-module-path as #f while
invoking sub-form transformers, while relative-in parameterizes to a
given module path.

                                        *convert-relative-module-path*
(convert-relative-module-path module-path) ~
 -> (or/c module-path?
          (and/c syntax?
                 (lambda (stx)
                   (module-path? (syntax-e stx)))))
  module-path : (or/c module-path? ~
                      (and/c syntax?
                             (lambda (stx)
                               (module-path? (syntax-e stx)))))

Converts module-path according to current-require-module-path.

If module-path is not relative or if the value of
current-require-module-path is #f, then module-path is returned.
Otherwise, module-path is converted to an absolute module path that is
equivalent to module-path relative to the value of
current-require-module-path.

                                        *syntax-local-require-certifier*
(syntax-local-require-certifier) ~
 -> ((syntax?) (or/c #f (syntax? . -> . syntax?))
     . ->* . syntax?)

For backward compatibility only; returns a procedure that returns its
first argument.

4.2. provide Transformers

 (require racket/provide-transform) package: base ~

The bindings documented in this section are provided by the
racket/provide-transform library, not racket/base or racket.

A transformer binding whose value is a structure with the
prop:provide-transformer property implements a derived provide-spec for
provide as a provide transformer. A provide transformer is applied as
part of the last phase of a module’s expansion, after all other
declarations and expressions within the module are expanded.

A transformer binding whose value is a structure with the
prop:provide-pre-transformer property implements a derived provide-spec
for provide as a provide pre-transformer.  A provide pre-transformer is
applied as part of the first phase of a module’s expansion. Since it is
used in the first phase, a provide pre-transformer can use functions
such as syntax-local-lift-expression to introduce expressions and
definitions in the enclosing module.

An identifier can have a transformer binding to a value that acts both
as a provide transformer and provide pre-transformer. The result of a
provide pre-transformer is not automatically re-expanded, so a provide
pre-transformer can usefully expand to itself in that case.

A transformer is called with the syntax object representing its use as a
provide-spec within a provide form and a list of symbols representing
the export modes specified by enclosing provide-specs. The result of a
provide transformer must be a list of exports, while the result of a
provide pre-transformer is a syntax object to be used as a provide-spec
in the last phase of module expansion.

If a derived form contains a sub-form that is a provide-spec, then it
can call expand-export or pre-expand-export to transform the
sub-provide-spec sub-form.

See also define-provide-syntax, which supports macro-style provide
transformers.

                                        *expand-export*
(expand-export stx modes) -> (listof export?) ~
  stx : syntax? ~
  modes : (listof (or/c exact-integer? #f)) ~

Expands the given provide-spec to a list of exports. The modes list
controls the expansion of sub-provide-specs; for example, an identifier
refers to a binding in the phase level of the enclosing provide form,
unless the modes list specifies otherwise. Normally, modes is either
empty or contains a single element.

                                        *pre-expand-export*
(pre-expand-export stx modes) -> syntax? ~
  stx : syntax? ~
  modes : (listof (or/c exact-integer? #f)) ~

Expands the given provide-spec at the level of provide pre-transformers.
The modes argument is the same as for expand-export.

                                        *make-provide-transformer*
(make-provide-transformer proc) -> provide-transformer? ~
  proc : (syntax? (listof (or/c exact-integer? #f)) ~
          . -> . (listof export?))
(make-provide-transformer proc pre-proc)
 -> (and/c provide-transformer? provide-pre-transformer?)
  proc : (syntax? (listof (or/c exact-integer? #f)) ~
          . -> . (listof export?))
  pre-proc : (syntax? (listof (or/c exact-integer? #f)) ~
              . -> . syntax?)

Creates a provide transformer (i.e., a structure with the
prop:provide-transformer property) using the given procedure as the
transformer. If a pre-proc is provided, then the result is also a
provide pre-transformer.

                                        *make-provide-pre-transformer*
(make-provide-pre-transformer pre-proc) ~
 -> provide-pre-transformer?
  pre-proc : (syntax? (listof (or/c exact-integer? #f)) ~
              . -> . syntax?)

Like make-provide-transformer, but for a value that is a provide
pre-transformer, only.

prop:provide-transformer : struct-type-property? ~

A property to identify provide transformers. The property value must be
a procedure that takes the structure and returns a transformer
procedure; the returned transformer procedure takes a syntax object and
mode list and returns an export list.

prop:provide-pre-transformer : struct-type-property? ~

A property to identify provide pre-transformers. The property value must
be a procedure that takes the structure and returns a transformer
procedure; the returned transformer procedure takes a syntax object and
mode list and returns a syntax object.

                                        *provide-transformer?*
(provide-transformer? v) -> boolean? ~
  v : any/c ~

Returns #t if v has the prop:provide-transformer property, #f otherwise.

                                        *provide-pre-transformer?*
(provide-pre-transformer? v) -> boolean? ~
  v : any/c ~

Returns #t if v has the prop:provide-pre-transformer property, #f
otherwise.

                                        *struct*
(struct export (local-id out-sym mode protect? orig-stx) ~
    #:extra-constructor-name make-export) ~
  local-id : identifier? ~
  out-sym : symbol? ~
  mode : (or/c exact-integer? #f) ~
  protect? : any/c ~
  orig-stx : syntax? ~

A structure representing a single imported identifier:

* local-id — the identifier that is bound within the exporting module.

* out-sym — the external name of the binding.

* orig-stx — a syntax object for the source of the export, used for
  error reporting.

* protect? — indicates whether the identifier should be protected (see
  [missing]).

* mode — the phase level of the binding in the exporting module.

                                        *syntax-local-provide-certifier*
(syntax-local-provide-certifier) ~
 -> ((syntax?) (or/c #f (syntax? . -> . syntax?))
     . ->* . syntax?)

For backward compatibility only; returns a procedure that returns its
first argument.

4.3. Keyword-Argument Conversion Introspection

 (require racket/keyword-transform) package: base ~

The bindings documented in this section are provided by the
racket/keyword-transform library, not racket/base or racket.

                                        *syntax-procedure-alias-property*
(syntax-procedure-alias-property stx) ~
 -> (or/c #f
          (letrec ([val? (recursive-contract
                          (or/c (cons/c identifier? identifier?)
                                (cons/c val? val?)))])
            val?))
  stx : syntax? ~
(syntax-procedure-converted-arguments-property stx)
 -> (or/c #f
          (letrec ([val? (recursive-contract
                          (or/c (cons/c identifier? identifier?)
                                (cons/c val? val?)))])
            val?))
  stx : syntax? ~

Reports the value of a syntax property that can be attached to an
identifier by the expansion of a keyword-application form. See lambda
for more information about the property.

The property value is normally a pair consisting of the original
identifier and an identifier that appears in the expansion.
Property-value merging via syntax-track-origin can make the value a pair
of such values, and so on.

5. Syntax Parameters

 (require racket/stxparam) package: base ~

The bindings documented in this section are provided by the
racket/stxparam library, not racket/base or racket.

                                        *define-syntax-parameter*
(define-syntax-parameter id expr) ~

Binds id as syntax to a syntax parameter. The expr is an expression in
the transformer environment that serves as the default value for the
syntax parameter. The value is typically obtained by a transformer using
syntax-parameter-value.

The id can be used with syntax-parameterize or syntax-parameter-value
(in a transformer). If expr produces a procedure of one argument or a
make-set!-transformer result, then id can be used as a macro. If expr
produces a make-rename-transformer result, then id can be used as a
macro that expands to a use of the target identifier, but
syntax-local-value of id does not produce the target’s value.

Examples:
  > (define-syntax-parameter current-class #f)

  > (define-syntax-parameter yield (make-rename-transformer #'abort))

  > (define-syntax-parameter define/public
      (λ (stx)
        (raise-syntax-error #f "use of a class keyword not in a
  class" stx)))

  >
  (begin-for-syntax (displayln (syntax-parameter-value #'current-class)))
  #f

  > (yield 5)
  5

                                        *syntax-parameterize*
(syntax-parameterize ([id expr] ...) body-expr ...+) ~

+See also splicing-syntax-parameterize.

Each id must be bound to a syntax parameter using
define-syntax-parameter. Each expr is an expression in the transformer
environment. During the expansion of the body-exprs, the value of each
expr is bound to the corresponding id.

If an expr produces a procedure of one argument or a
make-set!-transformer result, then its id can be used as a macro during
the expansion of the body-exprs. If expr produces a
make-rename-transformer result, then id can be used as a macro that
expands to a use of the target identifier, but syntax-local-value of id
does not produce the target’s value.

Examples:
  > (define-syntax-parameter abort (syntax-rules ()))

  > (define-syntax forever
      (syntax-rules ()
        [(forever body ...)
         (call/cc (lambda (abort-k)
           (syntax-parameterize
               ([abort (syntax-rules () [(_) (abort-k)])])
             (let loop () body ... (loop)))))]))

  > (define-syntax-parameter it (syntax-rules ()))

  > (define-syntax aif
      (syntax-rules ()
        [(aif test then else)
         (let ([t test])
           (syntax-parameterize ([it (syntax-id-rules () [_ t])])
             (if t then else)))]))


5.1. Syntax Parameter Inspection

 (require racket/stxparam-exptime) package: base ~

                                        *syntax-parameter-value*
(syntax-parameter-value id-stx) -> any ~
  id-stx : syntax? ~

This procedure is intended for use in a transformer environment, where
id-stx is an identifier bound in the normal environment to a syntax
parameter. The result is the current value of the syntax parameter, as
adjusted by syntax-parameterize form.

This binding is provided for-syntax by racket/stxparam, since it is
normally used in a transformer. It is provided normally by
racket/stxparam-exptime.

                                        *make-parameter-rename-transformer*
(make-parameter-rename-transformer id-stx) -> any ~
  id-stx : syntax? ~

This procedure is intended for use in a transformer, where id-stx is an
identifier bound to a syntax parameter. The result is a transformer that
behaves as id-stx, but that cannot be used with syntax-parameterize or
syntax-parameter-value.

Using make-parameter-rename-transformer is analogous to defining a
procedure that calls a parameter. Such a procedure can be exported to
others to allow access to the parameter value, but not to change the
parameter value. Similarly, make-parameter-rename-transformer allows a
syntax parameter to be used as a macro, but not changed.

The result of make-parameter-rename-transformer is not treated specially
by syntax-local-value, unlike the result of make-rename-transformer.

This binding is provided for-syntax by racket/stxparam, since it is
normally used in a transformer. It is provided normally by
racket/stxparam-exptime.

6. Local Binding with Splicing Body

 (require racket/splicing) package: base ~

The bindings documented in this section are provided by the
racket/splicing library, not racket/base or racket.

splicing-let
splicing-letrec
splicing-let-values
splicing-letrec-values
splicing-let-syntax
splicing-letrec-syntax
splicing-let-syntaxes
splicing-letrec-syntaxes
splicing-letrec-syntaxes+values
splicing-local

Like let, letrec, let-values, letrec-values, let-syntax, letrec-syntax,
let-syntaxes, letrec-syntaxes, letrec-syntaxes+values, and local, except
that in a definition context, the body forms are spliced into the
enclosing definition context (in the same way as for begin).

Examples:
  > (splicing-let-syntax ([one (lambda (stx) #'1)])
      (define o one))

  > o
  1
  > one
  one: undefined;
   cannot reference undefined identifier

When a splicing binding form occurs in a top-level context or module
context, its local bindings are treated similarly to definitions. In
particular, if a reference to one of the splicing form’s bound variables
is evaluated before the variable is initialized, an unbound variable
error is raised, instead of the variable evaluating to the undefined
value.  Also, syntax bindings are evaluated every time the module is
visited, instead of only once during compilation as in let-syntax, etc.

Example:
  > (splicing-letrec ([x bad]
                      [bad 1])
      x)
  bad.3: undefined;
   cannot reference undefined identifier

splicing-syntax-parameterize

Like syntax-parameterize, except that in a definition context, the body
forms are spliced into the enclosing definition context (in the same way
as for begin). In a definition context, the body of
splicing-syntax-parameterize can be empty.

Note that require transformers and provide transformers are not affected
by syntax parameterization.  While all uses of require and provide will
be spliced into the enclosing context, derived import or export
specifications will expand as if they had not been inside of the
splicing-syntax-parameterize.

Examples:
  > (define-syntax-parameter place (lambda (stx) #'"Kansas"))

  > (define-syntax-rule (where) `(at ,(place)))

  > (where)
  '(at "Kansas")
  > (splicing-syntax-parameterize ([place (lambda (stx) #'"Oz")])
      (define here (where)))

  > here
  '(at "Oz")

7. Syntax Object Properties

Every syntax object has an associated syntax property list, which can be
queried or extended with syntax-property. Properties are not preserved
for a syntax-quoted syntax object in a compiled form that is marshaled
to a byte string.

In read-syntax, the reader attaches a 'paren-shape property to any pair
or vector syntax object generated from parsing a pair [ and ] or { and
}; the property value is #\[ in the former case, and #\{ in the latter
case. The syntax form copies any 'paren-shape property from the source
of a template to corresponding generated syntax.

Both the syntax input to a transformer and the syntax result of a
transformer may have associated properties. The two sets of properties
are merged by the syntax expander: each property in the original and not
present in the result is copied to the result, and the values of
properties present in both are combined with cons (result value first,
original value second).

Before performing the merge, however, the syntax expander automatically
adds a property to the original syntax object using the key 'origin. If
the source syntax has no 'origin property, it is set to the empty list.
Then, still before the merge, the identifier that triggered the macro
expansion (as syntax) is consed onto the 'origin property so far.  The
'origin property thus records (in reverse order) the sequence of macro
expansions that produced an expanded expression. Usually, the 'origin
value is an immutable list of identifiers. However, a transformer might
return syntax that has already been expanded, in which case an 'origin
list can contain other lists after a merge. The syntax-track-origin
procedure implements this tracking.

Besides 'origin tracking for general macro expansion, Racket adds
properties to expanded syntax (often using syntax-track-origin) to
record additional expansion details:

* When a begin form is spliced into a sequence with internal definitions
  (see [missing]), syntax-track-origin is applied to every spliced
  element from the begin body. The second argument to
  syntax-track-origin is the begin form, and the third argument is the
  begin keyword (extracted from the spliced form).

* When an internal define-values or define-syntaxes form is converted
  into a letrec-syntaxes+values form (see [missing]),
  syntax-track-origin is applied to each generated binding clause.  The
  second argument to syntax-track-origin is the converted form, and the
  third argument is the define-values or define-syntaxes keyword form
  the converted form.

* When a letrec-syntaxes+values expression is fully expanded, syntax
  bindings disappear, and the result is either a letrec-values form (if
  the unexpanded form contained non-syntax bindings), or only the body
  of the letrec-syntaxes+values form (wrapped with begin if the body
  contained multiple expressions). To record the disappeared syntax
  bindings, a property is added to the expansion result: an immutable
  list of identifiers from the disappeared bindings, as a
  'disappeared-binding property.

* When a subtyping struct form is expanded, the identifier used to
  reference the base type does not appear in the expansion. Therefore,
  the struct transformer adds the identifier to the expansion result as
  a 'disappeared-use property.

* When a reference to an unexported or protected identifier from a
  module is discovered, the 'protected property is added to the
  identifier with a #t value.

* When read-syntax generates a syntax object, it attaches a property to
  the object (using a private key) to mark the object as originating
  from a read. The syntax-original?  predicate looks for the property to
  recognize such syntax objects. (See Syntax Object Content for more
  information.)

See also Check Syntax for one client of the 'disappeared-use and
'disappeared-binding properties.

See Information on Expanded Modules for information about properties
generated by the expansion of a module declaration. See lambda and
[missing] for information about properties recognized when compiling a
procedure. See current-compile for information on properties and byte
codes.

                                        *syntax-property*
(syntax-property stx key v) -> syntax? ~
  stx : syntax? ~
  key : any/c ~
  v : any/c ~
(syntax-property stx key) -> any
  stx : syntax? ~
  key : any/c ~

The three-argument form extends stx by associating an arbitrary property
value v with the key key; the result is a new syntax object with the
association (while stx itself is unchanged).

The two-argument form returns an arbitrary property value associated to
stx with the key key, or #f if no value is associated to stx for key.

                                        *syntax-property-symbol-keys*
(syntax-property-symbol-keys stx) -> list? ~
  stx : syntax? ~

Returns a list of all symbols that as keys have associated properties in
stx. Uninterned symbols (see [missing]) are not included in the result
list.

                                        *syntax-track-origin*
(syntax-track-origin new-stx       ~
                     orig-stx     
                     id-stx)  -> any
  new-stx : syntax? ~
  orig-stx : syntax? ~
  id-stx : syntax? ~

Adds properties to new-stx in the same way that macro expansion adds
properties to a transformer result. In particular, it merges the
properties of orig-stx into new-stx, first adding id-stx as an 'origin
property, and it returns the property-extended syntax object. Use the
syntax-track-origin procedure in a macro transformer that discards
syntax (corresponding to orig-stx with a keyword id-stx) leaving some
other syntax in its place (corresponding to new-stx).

For example, the expression

  (or x y)

expands to

  (let ([or-part x]) (if or-part or-part (or y)))

which, in turn, expands to

  (let-values ([(or-part) x]) (if or-part or-part y))

The syntax object for the final expression will have an 'origin property
whose value is (list (quote-syntax let) (quote-syntax or)).

8. Syntax Taints

+[missing] in [missing] introduces syntax taints.

The tamper status of a syntax object is either tainted, armed, or clean:

* A tainted identifier is rejected by the macro expander for use as
  either a binding or expression. If a syntax object is tainted, then
  any syntax object in the result of (syntax-e stx) is tainted, and
  datum->syntax with stx as its first argument produces a tainted syntax
  object.

  Other derived operations, such as pattern matching in syntax-case,
  also taint syntax objects when extracting them from a tainted syntax
  object.

* An armed syntax object has a set of dye packs, which creates taints if
  the armed syntax object is used without first disarming the dye packs.
  In particular, if a syntax object is armed, syntax-e, datum->syntax,
  quote-syntax, and derived operations effectively treat the syntax
  object as tainted.  The macro expander, in contrast, disarms dye packs
  before pulling apart syntax objects.

  Each dye pack, which is added to a syntax object with the syntax-arm
  function, is keyed by an inspector. A dye pack can be disarmed using
  syntax-disarm with an inspector that is the same as or a superior of
  the dye pack’s inspector.

* A clean syntax object has no immediate taints or dye packs, although
  it may contain syntax objects that are tainted or armed.

Taints cannot be removed, and attempting to arm a syntax object that is
already tainted has no effect on the resulting syntax object.

The macro expander disarms any syntax object that it encounters in an
expression position or as a module body. A syntax object is therefore
disarmed when it is provided to a syntax transformer. The transformer’s
result, however, is rearmed by copying to it any dye packs that were
originally attached to the transformer’s input. The rearming process
obeys the following rules:

* If the result has a 'taint-mode property (see    Syntax Object
  Properties) that is 'opaque, then    dye packs are attached to the
  immediate syntax object.

* If the result has a 'taint-mode property that    is 'none, then no dye
  pack is attached to    the syntax object. The 'none mode is rarely
  appropriate.

* If the result has a 'taint-mode property that is    'transparent, then
  the dye packs are    propagated recursively to syntax object that
  corresponds to    elements of the syntax object’s datum as a list (or,
  more    precisely, to the cars of the datum as reached by    any
  number of cdrs), and the immediate syntax    object loses its lexical
  context; If the immediate syntax    object is already armed, then
  recursive propagation    taints the elements. Recursive propagation
  uses syntax    properties and shapes, as for the immediate
  rearming.

* If the result has a 'taint-mode property that is
  'transparent-binding, then dye packs are    attached in a way similar
  to 'transparent, but    further treating the syntax object
  corresponding to the    second list element as having a 'transparent
  value    for the 'taint-mode property if it does not already    have a
  'taint-mode property value.

* If the result has no 'taint-mode property value, but    its datum is a
  pair, and if the syntax object corresponding    to the car of the pair
  is an identifier bound to    begin, module, or
  #%plain-module-begin, then dye packs are propagated    as if the
  syntax object had the 'transparent    property value.

* If the result has no 'taint-mode property value, but    its datum is a
  pair, and if the syntax object corresponding    to the car of the pair
  is an identifier bound to    define-values or define-syntaxes, then
  dye    packs are propagated as if the syntax object had the
  'transparent-binding property value.

For backward compatibility, a 'certify-mode property is treated the same
as a 'taint-mode property if the former is not attached. To avoid
accidental transfer of a 'taint-mode or 'certify-mode property value,
the expander always removes any 'taint-mode and 'certify-mode property
on a syntax object that is passed to a syntax transformer.

                                        *syntax-tainted?*
(syntax-tainted? stx) -> boolean? ~
  stx : syntax? ~

Returns #t if stx is tainted, #f otherwise.

                                        *syntax-arm*
(syntax-arm stx [inspector use-mode?]) -> syntax? ~
  stx : syntax? ~
  inspector : (or/c inspector? #f) = #f ~
  use-mode? : any/c = #f ~

Produces a syntax object like stx, but armed with a dye pack that is
keyed by inspector.

A #f value for inspector is equivalent to an inspector that depends on
the current dynamic context:

* when applying a syntax transformer is being applied, the
  declaration-time code inspector of the module in which a syntax
  transformer was bound;

* when a module is being visited, the module’s declaration-time code
  inspector;

* (current-code-inspector), otherwise.

If use-mode? is #f, then if stx is tainted or already armed with the key
inspector, the result is stx.

If use-mode? is a true value, then a dye pack is not necessarily added
directly to stx. Instead, the dye pack is pushed to interior syntax
objects in the same way that the expander pushes armings into a syntax
transformer’s results when rearming (based on a 'taint-mode syntax
property or identifier bindings); see the expander’s rearming rules for
more information. To the degree that pushing dye packs into a syntax
object must destructure stx, existing taints or dye packs can lead to
tainted results rather than armed results.

                                        *syntax-protect*
(syntax-protect stx) -> syntax? ~
  stx : syntax? ~

Equivalent to (syntax-arm stx #f #t).

                                        *syntax-disarm*
(syntax-disarm stx inspector) -> syntax? ~
  stx : syntax? ~
  inspector : (or/c inspector? #f) ~

Produces a disarmed version of stx, removing any immediate dye packs
that match inspector. An inspector matches when it is either the same as
or a super-inspector of the dye pack’s inspector.  A #f value for
inspector is replaced by a specific inspector in the same way as for
syntax-arm.

                                        *syntax-rearm*
(syntax-rearm stx from-stx [use-mode?]) -> syntax? ~
  stx : syntax? ~
  from-stx : syntax? ~
  use-mode? : any/c = #f ~

Produces a rearmed or tainted version of stx by adding all immediate
taints and dye packs of from-stx.

If use-mode? is a true value, stx is not necessarily tainted or armed
directly. Instead, taints or dye packs are pushed to interior syntax
objects in the same way as for syntax-arm or rearming by the expander.

                                        *syntax-taint*
(syntax-taint stx) -> syntax? ~
  stx : syntax? ~

Returns tainted version of stx—equivalent to (datum->syntax (syntax-arm
stx) (syntax-e stx) stx stx)—or stx if it is already tainted.

9. Expanding Top-Level Forms

                                        *expand*
(expand top-level-form) -> syntax? ~
  top-level-form : any/c ~

Expands all non-primitive syntax in top-level-form, and returns a syntax
object for the expanded form that contains only core forms, matching the
grammar specified by [missing].

Before top-level-form is expanded, its lexical context is enriched with
namespace-syntax-introduce, just as for eval. Use syntax->datum to
convert the returned syntax object into a printable datum.

Here’s an example of using expand on a module:

  (parameterize ([current-namespace (make-base-namespace)])
   (expand
    (datum->syntax
     #f
     '(module foo scheme
        (define a 3)
        (+ a 4)))))

Here’s an example of using expand on a non-top-level form:

  (define-namespace-anchor anchor)
  (parameterize ([current-namespace
                  (namespace-anchor->namespace anchor)])
   (expand
    (datum->syntax
     #f
     '(delay (+ 1 2)))))

                                        *expand-syntax*
(expand-syntax stx) -> syntax? ~
  stx : syntax? ~

Like (expand stx), except that the argument must be a syntax object, and
its lexical context is not enriched before expansion.

                                        *expand-once*
(expand-once top-level-form) -> syntax? ~
  top-level-form : any/c ~

Partially expands top-level-form and returns a syntax object for the
partially-expanded expression. Due to limitations in the expansion
mechanism, some context information may be lost. In particular, calling
expand-once on the result may produce a result that is different from
expansion via expand.

Before top-level-form is expanded, its lexical context is enriched with
namespace-syntax-introduce, as for eval.

                                        *expand-syntax-once*
(expand-syntax-once stx) -> syntax? ~
  stx : syntax? ~

Like (expand-once stx), except that the argument must be a syntax
object, and its lexical context is not enriched before expansion.

                                        *expand-to-top-form*
(expand-to-top-form top-level-form) -> syntax? ~
  top-level-form : any/c ~

Partially expands top-level-form to reveal the outermost syntactic form.
This partial expansion is mainly useful for detecting top-level uses of
begin. Unlike the result of expand-once, expanding the result of
expand-to-top-form with expand produces the same result as using expand
on the original syntax.

Before stx-or-sexpr is expanded, its lexical context is enriched with
namespace-syntax-introduce, as for eval.

                                        *expand-syntax-to-top-form*
(expand-syntax-to-top-form stx) -> syntax? ~
  stx : syntax? ~

Like (expand-to-top-form stx), except that the argument must be a syntax
object, and its lexical context is not enriched before expansion.

9.1. Information on Expanded Modules

Information for an expanded module declaration is stored in a set of
syntax properties (see Syntax Object Properties) attached to the syntax
object:

* 'module-direct-requires — a list of module path indexes (or symbols)
  representing the modules explicitly imported into the module.

* 'module-direct-for-syntax-requires — a list of module path indexes (or
  symbols) representing the modules explicitly for-syntax imported into
  the module.

* 'module-direct-for-template-requires — a list of module path indexes
  (or symbols) representing the modules explicitly for-template imported
  into the module.

* 'module-variable-provides — a list of provided items, where each item
  is one of the following:

  * symbol — represents a locally defined variable that is provided with
    its defined name.

  * (cons provided-sym defined-sym) — represents a locally defined
    variable that is provided with renaming; the first symbol is the
    exported name, and the second symbol is the defined name.

  * (list* module-path-index provided-sym defined-sym) — represents a
    re-exported and possibly re-named variable from the specified
    module; module-path-index is either a module path index or symbol
    (see [missing]), indicating the source module for the binding. The
    provided-sym is the external name for the re-export, and defined-sym
    is the originally defined name in the module specified by
    module-path-index.

* 'module-syntax-provides — like 'module-variable-provides, but for
  syntax exports instead of variable exports.

* 'module-indirect-provides — a list of symbols for variables that are
  defined in the module but not exported; they may be exported
  indirectly through macro expansions.  Definitions of macro-generated
  identifiers create uninterned symbols in this list.

10. File Inclusion

 (require racket/include) package: base ~

The bindings documented in this section are provided by the
racket/include and racket libraries, but not racket/base.

                                        *include*
(include path-spec) ~
 
path-spec = string
          | (file string)
          | (lib string ...+)

Inlines the syntax in the file designated by path-spec in place of the
include expression.

A path-spec resembles a subset of the mod-path forms for require, but it
specifies a file whose content need not be a module. That is, string
refers to a file using a platform-independent relative path, (file
string) refers to a file using platform-specific notation, and (lib
string ...) refers to a file within a collection.

If path-spec specifies a relative path, the path is resolved relative to
the source for the include expression, if that source is a complete path
string. If the source is not a complete path string, then path-spec is
resolved relative to (current-load-relative-directory) if it is not #f,
or relative to (current-directory) otherwise.

The included syntax is given the lexical context of the include
expression, while the included syntax’s source location refers to its
actual source.

                                        *include-at/relative-to*
(include-at/relative-to context source path-spec) ~

Like include, except that the lexical context of context is used for the
included syntax, and a relative path-spec is resolved with respect to
the source of source. The context and source elements are otherwise
discarded by expansion.

                                        *include/reader*
(include/reader path-spec reader-expr) ~

Like include, except that the procedure produced by the expression
reader-expr is used to read the included file, instead of read-syntax.

The reader-expr is evaluated at expansion time in the transformer
environment. Since it serves as a replacement for read-syntax, the
expression’s value should be a procedure that consumes two inputs—a
string representing the source and an input port—and produces a syntax
object or eof. The procedure will be called repeatedly until it produces
eof.

The syntax objects returned by the procedure should have source location
information, but usually no lexical context; any lexical context in the
syntax objects will be ignored.

                                        *include-at/relative-to/reader*
(include-at/relative-to/reader context source path-spec reader-expr) ~

Combines include-at/relative-to and include/reader.

11. Syntax Utilities

 (require racket/syntax) package: base ~

The bindings documented in this section are provided by the
racket/syntax library, not racket/base or racket.

11.1. Creating formatted identifiers

                                        *format-id*
(format-id  lctx                  ~
            fmt                  
            v ...                
           [#:source src          ~
            #:props props         ~
            #:cert ignored]) -> identifier? ~
  lctx : (or/c syntax? #f) ~
  fmt : string? ~
  v : (or/c string? symbol? identifier? keyword? char? number?) ~
  src : (or/c syntax? #f) = #f ~
  props : (or/c syntax? #f) = #f ~
  ignored : (or/c syntax? #f) = #f ~

Like format, but produces an identifier using lctx for the lexical
context, src for the source location, and props for the properties. An
argument supplied with #:cert is ignored. (See datum->syntax.)

The format string must use only ~a placeholders. Identifiers in the
argument list are automatically converted to symbols.

Examples:
  > (define-syntax (make-pred stx)
      (syntax-case stx ()
        [(make-pred name)
         (format-id #'name "~a?" (syntax-e #'name))]))

  > (make-pred pair)
  #<procedure:pair?>
  > (make-pred none-such)
  none-such?: undefined;
   cannot reference undefined identifier
  > (define-syntax (better-make-pred stx)
      (syntax-case stx ()
        [(better-make-pred name)
         (format-id #'name #:source #'name ~
                    "~a?" (syntax-e #'name))]))

  > (better-make-pred none-such)
  none-such?: undefined;
   cannot reference undefined identifier

                                        *Scribble*
(Scribble doesn’t show it, but the DrRacket pinpoints the location of ~
the second error but not of the first.)

                                        *format-symbol*
(format-symbol fmt v ...) -> symbol? ~
  fmt : string? ~
  v : (or/c string? symbol? identifier? keyword? char? number?) ~

Like format, but produces a symbol. The format string must use only ~a
placeholders. Identifiers in the argument list are automatically
converted to symbols.

Example:
  > (format-symbol "make-~a" 'triple)
  'make-triple

11.2. Pattern variables

                                        *define/with-syntax*
(define/with-syntax pattern stx-expr) ~
 
  stx-expr : syntax? ~

Definition form of with-syntax. That is, it matches the syntax object
result of expr against pattern and creates pattern variable definitions
for the pattern variables of pattern.

Examples:
  > (define/with-syntax (px ...) #'(a b c))

  > (define/with-syntax (tmp ...) (generate-temporaries #'(px ...)))

  > #'([tmp px] ...)
  #<syntax:11:0 ((a9 a) (b10 b) (c11 c))>
  > (define/with-syntax name #'Alice)

  > #'(hello name)
  #<syntax:13:0 (hello Alice)>

11.3. Error reporting

                                        *current-syntax-context*
(current-syntax-context) -> (or/c syntax? false/c) ~
(current-syntax-context stx) -> void?
  stx : (or/c syntax? false/c) ~

The current contextual syntax object, defaulting to #f.  It determines
the special form name that prefixes syntax errors created by
wrong-syntax.

                                        *wrong-syntax*
(wrong-syntax stx format-string v ...) -> any ~
  stx : syntax? ~
  format-string : string? ~
  v : any/c ~

Raises a syntax error using the result of (current-syntax-context) as
the “major” syntax object and the provided stx as the specific syntax
object. (The latter, stx, is usually the one highlighted by DrRacket.)
The error message is constructed using the format string and arguments,
and it is prefixed with the special form name as described under
current-syntax-context.

Examples:
  > (wrong-syntax #'here "expected ~s" 'there)
  ?: expected there
  > (parameterize ([current-syntax-context #'(look over here)])
      (wrong-syntax #'here "expected ~s" 'there))
  eval:15:0: look: expected there
    at: here ~
    in: (look over here) ~

A macro using wrong-syntax might set the syntax context at the very
beginning of its transformation as follows:

  (define-syntax (my-macro stx)
    (parameterize ([current-syntax-context stx])
      (syntax-case stx ()
        __)))

Then any calls to wrong-syntax during the macro’s transformation will
refer to my-macro (more precisely, the name that referred to my-macro
where the macro was used, which may be different due to renaming,
prefixing, etc).

11.4. Recording disappeared uses

                                        *current-recorded-disappeared-uses*
(current-recorded-disappeared-uses) ~
 -> (or/c (listof identifier?) false/c)
(current-recorded-disappeared-uses ids) -> void?
  ids : (or/c (listof identifier?) false/c) ~

Parameter for tracking disappeared uses. Tracking is “enabled” when the
parameter has a non-false value. This is done automatically by forms
like with-disappeared-uses.

                                        *with-disappeared-uses*
(with-disappeared-uses stx-expr) ~
 
  stx-expr : syntax? ~

Evaluates the stx-expr, catching identifiers looked up using
syntax-local-value/record. Adds the caught identifiers to the
'disappeared-uses syntax property of the resulting syntax object.

                                        *syntax-local-value/record*
(syntax-local-value/record id predicate) -> any/c ~
  id : identifier? ~
  predicate : (-> any/c boolean?) ~

Looks up id in the syntactic environment (as syntax-local-value). If the
lookup succeeds and returns a value satisfying the predicate, the value
is returned and id is recorded as a disappeared use by calling
record-disappeared-uses. If the lookup fails or if the value does not
satisfy the predicate, #f is returned and the identifier is not recorded
as a disappeared use.

                                        *record-disappeared-uses*
(record-disappeared-uses ids) -> void? ~
  ids : (listof identifier?) ~

Add ids to (current-recorded-disappeared-uses) after calling
syntax-local-introduce on each of the identifiers.

If not used within the extent of a with-disappeared-uses form or
similar, has no effect.

11.5. Miscellaneous utilities

                                        *generate-temporary*
(generate-temporary [name-base]) -> identifier? ~
  name-base : any/c = 'g ~

Generates one fresh identifier. Singular form of generate-temporaries.
If name-base is supplied, it is used as the basis for the identifier’s
name.

                                        *internal-definition-context-apply*
(internal-definition-context-apply intdef-ctx      ~
                                   stx)       -> syntax?
  intdef-ctx : internal-definition-context? ~
  stx : syntax? ~

Applies the renamings of intdef-ctx to stx.

                                        *syntax-local-eval*
(syntax-local-eval stx [intdef-ctx]) -> any ~
  stx : syntax? ~
  intdef-ctx : (or/c internal-definition-context? #f) = #f ~

Evaluates stx as an expression in the current transformer environment
(that is, at phase level 1), optionally extended with intdef-ctx.

Examples:
  > (define-syntax (show-me stx)
      (syntax-case stx ()
        [(show-me expr)
         (begin
           (printf "at compile time produces ~s\n"
                   (syntax-local-eval #'expr))
           #'(printf "at run time produces ~s\n"
                     expr))]))

  > (show-me (+ 2 5))
  at compile time produces 7
  at run time produces 7

  > (define-for-syntax fruit 'apple)

  > (define fruit 'pear)

  > (show-me fruit)
  at compile time produces apple
  at run time produces pear


                                        *with-syntax**
(with-syntax* ([pattern stx-expr] ...) ~
  body ...+)
 
  stx-expr : syntax? ~

Similar to with-syntax, but the pattern variables of each pattern are
bound in the stx-exprs of subsequent clauses as well as the bodys, and
the patterns need not bind distinct pattern variables; later bindings
shadow earlier bindings.

Example:
  > (with-syntax* ([(x y) (list #'val1 #'val2)]
                   [nest #'((x) (y))])
      #'nest)
  #<syntax:21:0 ((val1) (val2))>
