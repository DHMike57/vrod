Thread-Local Storage

Thread cells provides primitive support for thread-local storage.
Parameters combine thread cells and continuation marks to support
thread-specific, continuation-specific binding.

    1 Thread Cells

    2 Parameters

1. Thread Cells

A thread cell contains a thread-specific value; that is, it contains a
specific value for each thread, but it may contain different values for
different threads. A thread cell is created with a default value that is
used for all existing threads. When the cell’s content is changed with
thread-cell-set!, the cell’s value changes only for the current thread.
Similarly, thread-cell-ref obtains the value of the cell that is
specific to the current thread.

A thread cell’s value can be preserved, which means that when a new
thread is created, the cell’s initial value for the new thread is the
same as the creating thread’s current value. If a thread cell is
non-preserved, then the cell’s initial value for a newly created thread
is the default value (which was supplied when the cell was created).

Within the current thread, the current values of all preserved threads
cells can be captured through current-preserved-thread-cell-values. The
captured set of values can be imperatively installed into the current
thread through another call to current-preserved-thread-cell-values. The
capturing and restoring threads can be different.

                                        *thread-cell?*
(thread-cell? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a thread cell, #f otherwise.

                                        *make-thread-cell*
(make-thread-cell v [preserved?]) -> thread-cell? ~
  v : any/c ~ ~
  preserved? : any/c = #f ~ ~

Creates and returns a new thread cell. Initially, v is the cell’s value
for all threads. If preserved? is true, then the cell’s initial value
for a newly created threads is the creating thread’s value for the cell,
otherwise the cell’s value is initially v in all future threads.

                                        *thread-cell-ref*
(thread-cell-ref cell) -> any ~
  cell : thread-cell? ~ ~

Returns the current value of cell for the current thread.

                                        *thread-cell-set!*
(thread-cell-set! cell v) -> any ~
  cell : thread-cell? ~ ~
  v : any/c ~ ~

Sets the value in cell to v for the current thread.

Examples:

  > (define cnp (make-thread-cell '(nerve) #f))
  > (define cp (make-thread-cell '(cancer) #t))
  > (thread-cell-ref cnp)
  '(nerve)
  > (thread-cell-ref cp)
  '(cancer)
  > (thread-cell-set! cnp '(nerve nerve))
  > (thread-cell-set! cp '(cancer cancer))
  > (thread-cell-ref cnp)
  '(nerve nerve)
  > (thread-cell-ref cp)
  '(cancer cancer)
  > (define ch (make-channel))
  > (thread (lambda ()
              (channel-put ch (thread-cell-ref cnp))
              (channel-put ch (thread-cell-ref cp))
              (channel-get ch)
              (channel-put ch (thread-cell-ref cp))))
  #<thread>
  > (channel-get ch)
  '(nerve)
  > (channel-get ch)
  '(cancer cancer)
  > (thread-cell-set! cp '(cancer cancer cancer))
  > (thread-cell-ref cp)
  '(cancer cancer cancer)
  > (channel-put ch 'ok)
  > (channel-get ch)
  '(cancer cancer)

                                        *current-preserved-thread-cell-values*
(current-preserved-thread-cell-values) -> thread-cell-values? ~
(current-preserved-thread-cell-values thread-cell-vals) -> void?
  thread-cell-vals : thread-cell-values? ~ ~

When called with no arguments, this procedure produces a
thread-cell-vals that represents the current values (in the current
thread) for all preserved thread cells.

When called with a thread-cell-vals generated by a previous call to
current-preserved-thread-cell-values, the values of all preserved thread
cells (in the current thread) are set to the values captured in
thread-cell-vals; if a preserved thread cell was created after
thread-cell-vals was generated, then the thread cell’s value for the
current thread reverts to its initial value.

                                        *thread-cell-values?*
(thread-cell-values? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a set of thread cell values produced by
current-preserved-thread-cell-values, #f otherwise.

2. Parameters

+[missing] in [missing] introduces parameters.

See [missing] for basic information on the parameter model. Parameters
correspond to preserved thread fluids in Scsh [Gasbichler02].

To parameterize code in a thread- and continuation-friendly manner, use
parameterize. The parameterize form introduces a fresh thread cell for
the dynamic extent of its body expressions.

When a new thread is created, the parameterization for the new thread’s
initial continuation is the parameterization of the creator thread.
Since each parameter’s thread cell is preserved, the new thread
“inherits” the parameter values of its creating thread. When a
continuation is moved from one thread to another, settings introduced
with parameterize effectively move with the continuation.

In contrast, direct assignment to a parameter (by calling the parameter
procedure with a value) changes the value in a thread cell, and
therefore changes the setting only for the current thread. Consequently,
as far as the memory manager is concerned, the value originally
associated with a parameter through parameterize remains reachable as
long the continuation is reachable, even if the parameter is mutated.

                                        *make-parameter*
(make-parameter v [guard name]) -> parameter? ~
  v : any/c ~ ~
  guard : (or/c (any/c . -> . any) #f) = #f ~ ~
  name : symbol? = 'parameter-procedure ~ ~

Returns a new parameter procedure. The value of the parameter is
initialized to v in all threads.

If guard is not #f, it is used as the parameter’s guard procedure.  A
guard procedure takes one argument. Whenever the parameter procedure is
applied to an argument, the argument is passed on to the guard
procedure. The result returned by the guard procedure is used as the new
parameter value.  A guard procedure can raise an exception to reject a
change to the parameter’s value. The guard is not applied to the initial
v.

The name argument is used as the parameter procedure’s name as reported
by object-name.

Changed in version 7.4.0.6: Added the name argument.

                                        *parameterize*
(parameterize ([parameter-expr value-expr] ...) ~
  body ...+)
 
  parameter-expr : parameter? ~ ~

+[missing] in [missing] introduces parameterize.

The result of a parameterize expression is the result of the last body.
The parameter-exprs determine the parameters to set, and the value-exprs
determine the corresponding values to install while evaluating the
bodys. The parameter-exprs and value-exprs are evaluated left-to-right
(interleaved), and then the parameters are bound in the continuation to
preserved thread cells that contain the values of the value-exprs; the
result of each parameter-expr is checked with parameter? just before it
is bound. The last body is in tail position with respect to the entire
parameterize form.

Outside the dynamic extent of a parameterize expression, parameters
remain bound to other thread cells. Effectively, therefore, old
parameters settings are restored as control exits the parameterize
expression.

If a continuation is captured during the evaluation of parameterize,
invoking the continuation effectively re-introduces the
parameterization, since a parameterization is associated to a
continuation via a continuation mark (see [missing]) using a private
key.

Examples:

  > (parameterize ([exit-handler (lambda (x) 'no-exit)])
      (exit))
  > (define p1 (make-parameter 1))
  > (define p2 (make-parameter 2))
  > (parameterize ([p1 3]
                   [p2 (p1)])
      (cons (p1) (p2)))
  '(3 . 1)
  > (let ([k (let/cc out
               (parameterize ([p1 2])
                 (p1 3)
                 (cons (let/cc k
                         (out k))
                       (p1))))])
      (if (procedure? k)
          (k (p1))
          k))
  '(1 . 3)
  > (define ch (make-channel))
  > (parameterize ([p1 0])
      (thread (lambda ()
                (channel-put ch (cons (p1) (p2))))))
  #<thread>
  > (channel-get ch)
  '(0 . 2)
  > (define k-ch (make-channel))
  > (define (send-k)
      (parameterize ([p1 0])
        (thread (lambda ()
                  (let/ec esc
                    (channel-put ch
                                 ((let/cc k
                                    (channel-put k-ch k)
                                    (esc)))))))))
  > (send-k)
  #<thread>
  > (thread (lambda () ((channel-get k-ch)
                        (let ([v (p1)])
                          (lambda () v)))))
  #<thread>
  > (channel-get ch)
  1
  > (send-k)
  #<thread>
  > (thread (lambda () ((channel-get k-ch) p1)))
  #<thread>
  > (channel-get ch)
  0

                                        *parameterize**
(parameterize* ((parameter-expr value-expr) ...) ~
  body ...+)

Analogous to let* compared to let, parameterize* is the same as a nested
series of single-parameter parameterize forms.

                                        *make-derived-parameter*
(make-derived-parameter parameter      ~
                        guard         
                        wrap)     -> parameter?
  parameter : parameter? ~ ~
  guard : (any/c . -> . any) ~ ~
  wrap : (any/c . -> . any) ~ ~

Returns a parameter procedure that sets or retrieves the same value as
parameter, but with:

* guard applied when setting the parameter (before any guard associated
  with parameter), and

* wrap applied when obtaining the parameter’s value.

See also chaperone-procedure, which can also be used to guard parameter
procedures.

                                        *parameter?*
(parameter? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a parameter procedure, #f otherwise.

                                        *parameter-procedure=?*
(parameter-procedure=? a b) -> boolean? ~
  a : parameter? ~ ~
  b : parameter? ~ ~

Returns #t if the parameter procedures a and b always modify the same
parameter with the same guards (although possibly with different
chaperones), #f otherwise.

                                        *current-parameterization*
(current-parameterization) -> parameterization? ~

Returns the current continuation’s parameterization.

                                        *call-with-parameterization*
(call-with-parameterization parameterization      ~
                            thunk)           -> any
  parameterization : parameterization? ~ ~
  thunk : (-> any) ~ ~

Calls thunk (via a tail call) with parameterization as the current
parameterization.

                                        *parameterization?*
(parameterization? v) -> boolean? ~
  v : any/c ~ ~

Returns #t if v is a parameterization returned by
current-parameterization, #f otherwise.
